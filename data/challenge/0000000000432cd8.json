{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1399807800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432cd8","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>Round 1C has finished, so congratulations to the 3000 contestants who advanced to Round 2. Round 1 this year was the biggest Round 1 qualification in Code Jam's history in terms of participation. There were <b>6,176</b> contestants who downloaded at least one input file in Round 1C, while in total for Round 1 there were <b>21,129</b> contestants.</p>\n\n<p>In this round there were three challenging problems: <i>Part Elf</i> was the easiest problem, most of the contestants managed to solve at least its small input, and about <b>27%</b> of the large input attempts failed. <i>Reordering Train Cars</i> was a very tricky problem to get it correct for small and large inputs, there were a lot of cases to be handled and need to write a clean code to handle all cases easily, and as a result about <i>66%</i> of contestants who got correct small input failed to solve the large input, and it was about <b>39%</b> of the large input attempts failed. <i>Enclosure</i> was the hardest problem in the contest, even its small input was not easy enough to get it <i>\"Correct!\"</i>, where <b>64%</b> of the small input attempts failed, and <b>63</b> contestants only managed to solve the large input.</p>\n\n<p>At the end of the day, <b>70%</b> of the contestants solved at least one input file, and only <b>43</b> contestants got full score.</p>\n\n<p>Congratulations to all 3000 contestants who advanced to Round 2!</p>\n<hr>\nCast:<br>\n<p>\nProblem A. <i>Part Elf</i> Written by Bartholomew Furrow. Prepared by Bartholomew Furrow, and Jonathan Pauslon.</p>\n<p>Problem B. <i>Reordering Train Cars</i> Written by Ahmed Aly. Prepared by Mohammad Kotb.</p>\n<p>Problem C. <i>Enclosure</i> Written by Zhen Wang. Prepared by Zhen Wang, and Jonathan Paulson.</p>\n\n<p>\nContest analysis presented by Felix Halim, Mohammad Kotb, Topraj Gurung, and Zong-Sian Li.\n</p>\n<p>\nSolutions and other problem preparation by Alex Fetisov, Carlos Guía, John Dethridge, Jonathan Shen, Md Mahbubul Hasan, Patrick Nguyen, and Timothy Loh.\n</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1399798800000,"tasks":[{"analysis":"<p>\nThe goal is to place as few stones as possible to enclose at least <b>K</b> intersection points in an <b>N</b> * <b>M</b> grid. Intuitively, it is wasteful to create more than one enclosure since we can always combine the stones into one larger enclosure that cover same or more intersection points. Thus, we can restrict our search to solutions with one enclosure only.\n</p>\n\n<p>\nThe figure below shows an enclosure for an <b>N</b> = 5 by <b>M</b> = 5 grid that covers <b>K</b> = 19 intersection points with the minimum number of 11 stones.\n<pre><code>-***-   # the first row\n*XXX*   # intermediate row\n*XXX*   # intermediate row\n*XX*-   # intermediate row\n-**--   # the last row</code></pre>\n</p>\n\n<p>\nWe use <code>'-'</code> to represent empty intersection, <code>'X'</code> to represent an enclosed intersection point, and <code>'*'</code> to represent a stone placed in the intersection point (which is also enclosed). Observe that:\n<ul>\n<li>The stones in the first row and the last row are filled in consecutive position in the row.</li>\n<li>Each intermediate row (i.e., the row except the first and the last row) has exactly two stones (i.e., the left stone and the right stone).</li>\n</ul>\n</p>\n\n<p>\nEach intermediate row always contains two stones. If there exists an intermediate row that contains only one stone, then it may form two enclosures that touches their boundaries at that row. Since we are not interested in searching solutions with more than one enclosure, we can restrict each intermediate row to always contains exactly two stones.\n</p>\n\n<p>\nWhat about having more than two stones in an intermediate row? This is wasteful and we can avoid that too. To see this, let’s enumerate all possible ways to move the left stone boundary for the next row and at the same time it explains why each intermediate row always contains two stone in the final configuration. The following figure shows all three possible ways to move the left boundary stone:\n<pre><code>previous row:  --*XXX     --*XXX      --*XXX\n    next row:  -*XXXX     --*XXX      ---*XX\n              (expand)  (unchanged)  (shrink)</code></pre>\n</p>\n\n<p>\nNotice that we can only expand the boundary by one otherwise it will create a gap and it will no longer form a <b>closed</b> enclosure. Could we place stones in between to close the gap? Such as (shown in bold):\n<pre><code>previous row:  --*XXX      -<b>*</b>*XXX\n    next row:  *<b>*</b>XXXX      *XXXXX\n                          (push up)</code></pre>\n</p>\n\n<p>\nYes, we can, but it is wasteful because we can always “push up” the placed stone to get one more enclosed intersection point as shown in the right figure. Moreover, we can do another push up on the previous row to the previous-previous row and so on until it is pushed up to the top row (each push up gains one more enclosed intersection point). Thus, in the end, after all the push ups, each intermediate row will contain exactly two stones.\n</p>\n\n<p>\nTo make the search simple, we do not want any push up to happen. In the search, we fix the number of stones at the top row, and generate the next row and we do not want the next row to alter the previous row (\"push up\" alters the previous row). This explains why we do not want to expand the left boundary more than one position (i.e., it is simpler just to change the number of stones in the top row and do a separate search).\n</p>\n\n<p>\nFor the shrink case, observe that we only need to shrink at most one position because shrinking more than one is wasteful since we will need more stones to fill the gaps (to maintain enclosure). See the following examples:\n<pre><code>previous row:   --*XXX     --*<b>*</b>XX\n    next row:   ---*<b>*</b>X     ----*X\n               (case 1)   (case 2)</code></pre>\n</p>\n\n\n<p>\nIn the shrinking case 1, the bolded stone <code>'<b>*</b>'</code> (the rightmost stone) is not needed since it is already enclosed. The shrinking case 2 is wasteful since the bolded stone <code>'<b>*</b>'</code> (the middle stone) can be pushed down to enclose one more intersection point (which will still be wasteful because it will then became case 1).\n</p>\n\n<p>\nLooking at all the possible ways to move the left boundary, we can conclude that it is sufficient to place exactly two stones in each intermediate row.\n</p>\n\n<p>\nFor the last row, we close the enclosure by connecting the left and right stone boundary of the previous row by placing the stones consecutively. For example:\n<pre><code>previous row:  --*XXXXX*--\n    last row:  ---*****---</code></pre>\n</p>\n\n<p>\nNote that we only close the enclosure if we are sure that the intersection points enclosed by all the previous rows and the last row is at least <b>K</b>.\n</p>\n\n<p>\nIn summary, our search algorithm goes as follows:\n<ul>\n<li>First place a number of stones consecutively from left to right on the top row</li>\n<li>Place two stones for the following (intermediate) rows by expanding / shrinking / unchanged the left and right boundary with respect to the previous row</li>\n<li>Finally if we have enclosed enough intersection points, close the enclosure by placing stones consecutively at the last row.</li>\n</ul>\n</p>\n\n<p>\nWe will discuss two common ways to solve this problem. The first is a dynamic programming (DP) solution and the second is a greedy solution.\n</p>\n\n<h2>Dynamic Programming (DP)</h2>\n<p>\nSince we brute-force the first row, we only need to perform DP for the intermediate rows and the last row. For each row, we need to know:\n<ul>\n<li>The remaining rows left.</li>\n<li>The left stone boundary position.</li>\n<li>The right stone boundary position.</li>\n<li>The remaining intersection points to enclose.</li>\n</ul>\n</p>\n\n<p>\nTo minimize the left / right stone boundary position, we transpose the grid (if necessary) so that we ended up with the grid with smaller columns than its rows, without affecting optimality. With this transformation, now the left / right boundary position is at most <i>sqrt</i>(<b>N</b> * <b>M</b>). This leads to O(<b>N</b> * <i>sqrt</i>(<b>N</b> * <b>M</b>) * <i>sqrt</i>(<b>N</b> * <b>M</b>) * <b>N</b> * <b>M</b>) solution. While the amortized cost can be less, it still seems large and has potential to run more than the time limit. Can we do better?\n</p>\n\n<p>\nIt turns out that the exact position of the left and right stone boundary does not really matter as long as the distance between them is not larger than the column size. This also applies for the stones at the top row. What matters is the number of stones placed consecutively in the top row. Where the stones are exactly placed does not matter as long as the number of stones is at most the column size.\n</p>\n\n<p>\nWith this intuition, we can make the DP state smaller. Instead of maintaining the left and right stone boundary position, we can just maintain the distance between the two stones instead. The three possibilities of moving the stone boundaries in the next row (expand, shrink, unchanged) now translate to five possibilities of adding the stone distance, by -2, -1, 0, 1, or 2 as shown in the following examples.\n\n<pre><code>prev row:  -*XXX*-  -*XXX*-  -*XXX*-  -*XXX*-  -*XXX*-\nnext row:  --*X*--  --*XX*-  -*XXX*-  -*XXXX*  *XXXXX*\n            (-2)     (-1)      (0)      (1)      (2)</code></pre>\n</p>\n\n<p>\nNote that for (-1) and (1) there is another possibility for the next row, but both have the same distance between the left and right stone boundaries.\n</p>\n\n<p>\nBy switching the left and right boundary position to the distance between the left and right stone, we can reduce the DP states to three states (the remaining rows left, stone distance of the previous row, the remaining intersection to enclose). This reduces the complexity to O(<b>N</b> * <i>sqrt</i>(<b>N</b> * <b>M</b>) * <b>N</b> * <b>M</b>). The amortized cost is less than 32 million operations per test case which is fast enough to answer 100 test cases. Below is a sample implementation in Python 3:\n<pre><code>from functools import lru_cache\nimport sys\n\n@lru_cache(maxsize = None)  # Memoization.\ndef rec(rem_rows, prev_dist, rem_points, M):\n  if rem_points &lt;= 0:  # If the remaining area is non positive,\n    return 0  # then no stone is needed.\n\n  ret = 1000000  # Infinity.\n  if rem_rows &lt;= 0:  # No more row but rem_points is still &gt; 0.\n    return ret  # Return infinity.\n\n  if M == 1:  # Special case where each row only has one stone.\n    return rem_points  #  rem_rows &gt;= rem_points is guaranteed.\n\n  min_dist = max(prev_dist - 2, 1)\n  max_dist = min(prev_dist + 2, M)\n  for next_dist in range(min_dist, max_dist + 1):\n    if next_dist &gt;= rem_points:\n      # Close the enclosure for the last row.\n      ret = min(ret, next_dist)\n    elif next_dist &gt; 1:\n      # Cover this row using 2 stones.\n      next_rem_points = rem_points - next_dist\n      ret = min(ret, \\\n        2 + rec(rem_rows - 1, next_dist, next_rem_points, M))\n\n  return ret\n\n\ndef min_stones(N, M, K):\n  if N &lt; M:  # If the row size is smaller than the column size\n    (N, M) = (M, N)  # Transpose the grid\n\n  res = 1000000\n  # Try all possible number of stones for the top row.\n  for stones in range(1, min(K, M) + 1):\n    # The stones needed to cover the top row + the next rows.\n    stones = stones + rec(N - 1, stones, K - stones, M)\n    res = min(res, stones)\n\n  return res\n\nsys.setrecursionlimit(5000)\nfor tc in range(int(input())):\n  print(\"Case #%d: %d\" % (tc+1, \\\n    min_stones(*map(int, input().split()))))</code></pre>\n</p>\n\n\n<h2>Greedy</h2>\n<p>\nIntuitively, the two stones in each intermediate row can be greedily placed as far as possible from each other to maximize the area enclosed without adding any additional stone. Consider the following example:\n<pre><code>---------      ---------      ----*----\n---------      ---------      ---*X*---\n--*****--      --*****--      --*XXX*--\n--*XXX*--      -*XXXXX*-      -*XXXXX*-\n--*XXX*--  -&gt;  *XXXXXXX*  -&gt;  *XXXXXXX*\n--*XXX*--      -*XXXXX*-      -*XXXXX*-\n--*****--      --*****--      --*XXX*--\n---------      ---------      ---*X*---\n---------      ---------      ----*----\n   (a)            (b)            (c)</code></pre>\n</p>\n\n<p>\nThe enclosure in Figure (a) can be improved by moving the two stones (in each of the three intermediate rows) as far as possible from each other as shown in Figure (b). Similar reasoning can be made for each column that contain only two stones: move the top and bottom stones as far from each other as possible in that column. The enclosure in Figure (b) can be improved in the same way, resulting the enclosure as shown in Figure (c).\n</p>\n\n<p>\nKnowing that the optimal shape resembles a diamond, the greedy approach is to try to construct a diamond-shaped enclosure with area at least <b>K</b>. However, this is not always feasible if the grid is not large enough. In such case, the diamond-shape may be “truncated” at the top / left / right / bottom sides as shown below for the best enclosure for <b>N</b> = 6, <b>M</b> = 7, <b>K</b> = 27\n<pre><code>--***--\n-*XXX*-\n*XXXXX*\n-*XXXX*\n--*XX*-\n---**--</code></pre>\n</p>\n\n<p>\nAnother useful observation is that the empty intersections at the corners always forms a right triangle. This allows us to generate all possible truncated (and perfect) diamond by placing empty triangles at the corners. Notice that the sizes (the length of its side) of the empty triangles at the corners may be different by at most one size.\n</p>\n\n<p>\nFortunately, the large input is small enough that we can brute-force for all possible truncated (and perfect) diamond shapes. First we try all possible grid size, and for each possible grid size, we try to put empty triangles at the corners and compute the enclosure size and the stones needed. We record and return the minimum stones needed to construct the shape with area at least <b>K</b>. Below is a sample implementation in Python 3:\n<pre><code>def empty_triangle(size):\n  return size * (size + 1) / 2\n\ndef min_stones(N, M, K):\n  if N &gt; M:\n    (N, M) = (M, N)\n\n  best = K\n  for R in range(2, N + 1):\n    for C in range(R, M + 1):\n      if R * C &gt;= K:\n        for i in range(2 * R):\n          cover = R * C\n          cover -= empty_triangle(i // 4)\n          cover -= empty_triangle((i + 1) // 4)\n          cover -= empty_triangle((i + 2) // 4)\n          cover -= empty_triangle((i + 3) // 4)\n          if cover &lt; K:\n            break\n          stones = 2 * (R + C) - 4 - i\n          best = min(best, stones)\n\n  return best</code></pre>\n</p>\n\n<p>\nThe complexity of the above solution is O(<b>N<sup>2</sup></b> * <b>M</b>). However, if you are well versed in Mathematics, you can further improve the search to O(<i>log</i>(<b>K</b>)) by doing a binary search on the number of stones needed to form the truncated diamond shape and compute the number of enclosed intersection points in O(1) to make the binary search decision.\n</p>\n","id":"0000000000432a91","statement":"<h3>Problem</h3>\n<p>\nYour task in this problem is to find out the minimum number of stones needed to place on an N-by-M rectangular grid (N horizontal line segments and M vertical line segments) to enclose at least K intersection points. An intersection point is enclosed if either of the following conditions is true:</p>\n<ol>\n<li>A stone is placed at the point.</li>\n<li>Starting from the point, we cannot trace a path along grid lines to reach an empty point on the grid border through empty intersection points only.</li>\n</ol>\n<p>For example, to enclose 8 points on a 4x5 grid, we need at least 6 stones. One of many valid stone layouts is shown below. Enclosed points are marked with an \"x\".\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2hJtUKe7lhvo0nwEGEzonHeTV5XUx-LvboL9Z8Tv1J_pEKpNVn4NC8CSrYuO4RYiVJAvfHPVpR/enclosure.png\">\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each test case is a line of three integers: <b>N</b> <b>M</b> <b>K</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of stones needed.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b>.<br/>\n1 &le; <b>M</b>.<br/>\n1 &le; <b>K</b> &le; <b>N</b> &times; <b>M</b>.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n<b>N</b> &times; <b>M</b> &le; 20.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n<b>N</b> &times; <b>M</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0KRMgUyL0EENpQlWwb8SPSjUNgFlSrjC1My4UyVwsryT-oxZfIabvL_AZdFuKnKni2uIr_FWrHH-JJAIFsOJYMHODgWD0rt-M/enclosure_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n4 5 8\n3 5 11\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0fLMjCmiTQhqg0UUDNf1bnfxYC29D2U_JWjtwyjCnB1pPlSaqrZ71aWit6gbX6in28O7tEAbEdNdt8_tdz3fH5OBHUApw-Qypu/enclosure_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 6\nCase #2: 8\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Enclosure","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIn the first generation (i.e., 40 generations ago) there were only either pure Elf (1/1 Elf) or Human (0/1 Elf). If we enumerate all possible children for the next 3 generations we have:\n<pre><code>1st gen:  0/1                                     1/1\n2nd gen:  0/2                 1/2                 2/2\n3rd gen:  0/4       1/4       2/4       3/4       4/4\n4th gen:  0/8  1/8  2/8  3/8  4/8  5/8  6/8  7/8  8/8</code></pre>\n</p>\n\n<p>\nIt is apparent that at any generation, the denominator is always a power of two. Thus, the answer for the <b>impossible</b> case is easy to check: first reduce the given fraction to its lowest terms and check whether the denominator is a power of two. A fraction can be reduced to its lowest terms by dividing both the numerator and denominator by their greatest common divisor.\n</p>\n\n<p>\nNow, the remaining question is for a <b>P</b>/<b>Q</b> Elf, what is the minimum number of generations ago that there could have been a 1/1 Elf?\n</p>\n\n<p>\nFor a small input, where <b>Q</b> is at most 1000, we can generate the first 10 generations (with 2<sup>10</sup> possible Elf combinations) to cover all possible small input. When we generate the child from the two parent we record their relationship. Then to answer the question, we simply do a breadth-first search (shortest path in unweighted graph) in the relationship graph from the <b>P</b>/<b>Q</b> Elf and stop whenever we encounter 1/1 Elf and report the length (shortest path length). This algorithm runs in O(<b>2<sup>N</sup></b> * <b>2<sup>2N</sup></b>) to generate the relationship graph of size 1001 x 1001 which is still feasible for a small input but not for the large input.\n</p>\n\n<p>\nFor the large input, another insight is needed. Let’s do some examples to get the intuition. Suppose Vida is an 3/8 Elf, what are the possible parents? Let’s enumerate them:\n<ul>\n<li>(0/8 + 6/8) / 2 = 3/8</li>\n<li>(1/8 + 5/8) / 2 = 3/8</li>\n<li>(2/8 + 4/8) / 2 = 3/8</li>\n<li>(3/8 + 3/8) / 2 = 3/8</li>\n</ul>\n</p>\n\n<p>\nThe possible parents of 3/8 are: 0/8, 1/8, 2/8, 3/8, 4/8, 5/8, 6/8 which form a “consecutive” (for the lack of a better word) fraction from 0/8 to 6/8.\n</p>\n\n<p>\nFormally speaking, a <b>P</b>/<b>Q</b> Elf could have a <b>Z</b>/<b>Q</b> parent where <b>Z</b> is ranged from <i>max</i>(0, <b>P</b> - (<b>Q</b>-<b>P</b>)) to <i>min</i>(<b>Q</b>, <b>P</b> * 2). Notice that the denominator <b>Q</b> does not change.\n</p>\n\n<p>\nWith this intuition, it is obvious that to get to the pure 1/1 Elf as fast as possible, we want to greedily generate a parent with numerator as large as possible. In other words, from an <b>P</b>/<b>Q</b> Elf we would like to generate <b>Z</b>/<b>Q</b> parent where <b>Z</b> is maximized. We continue the process for <b>Z</b>/<b>Q</b>, picking the parent with the greatest numerator and so on until we get to a 1/1 Elf. This greedy algorithm runs in O(log(<b>Q</b>)). Below is a sample implementation in Python 3:\n<pre><code>from fractions import gcd\n\ndef is_power_of_two(x):\n  return x &amp; (x - 1) == 0\n\ndef min_generation(P, Q):\n  g = gcd(P, Q)\n  P = P // g\n  Q = Q // g\n\n  if not(is_power_of_two(Q)):\n    return \"impossible\"\n\n  gen = 0\n  while P &lt; Q:\n    P = P * 2\n    gen += 1\n  return gen\n\n\nfor tc in range(int(input())):\n  print(\"Case #%d: %s\" % (tc+1, \\\n    min_generation(*map(int, input().split('/')))))\n</code></pre>\n</p>","id":"0000000000433163","statement":"<h3>Problem</h3>\n<p>\nVida says she's part Elf: that at least one of her ancestors was an Elf. But she doesn't know if it was a parent (1 generation ago), a grandparent (2 generations ago), or someone from even more generations ago. Help her out!\n</p>\n\n<p>\nBeing part Elf works the way you probably expect. People who are Elves, Humans and part-Elves are all created in the same way: two parents get together and have a baby.  If one parent is <code>A/B</code> Elf, and the other parent is <code>C/D</code> Elf, then their baby will be <code>(A/B&nbsp;+&nbsp;C/D)&nbsp;/&nbsp;2</code> Elf. For example, if someone who is <code>0/1</code> Elf and someone who is <code>1/2</code> Elf have a baby, that baby will be <code>1/4</code> Elf.\n</p>\n\n<p>\nVida is certain about one thing: 40 generations ago, she had <code>2<sup>40</sup></code> different ancestors, and each one of them was <code>1/1</code> Elf or <code>0/1</code> Elf. </p>\n\n<p>\nVida says she's <b>P</b>/<b>Q</b> Elf. Tell her what is the minimum number of generations ago that there could have been a <code>1/1</code> Elf in her family.  If it is not possible for her to be <b>P</b>/<b>Q</b> Elf, tell her that she must be wrong!\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each contains a fraction of the form <b>P</b>/<b>Q</b>, where <b>P</b> and <b>Q</b> are integers.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of generations ago a 1/1 Elf in her family could have been if she is <b>P</b>/<b>Q</b> Elf. If it's impossible that Vida could be <b>P</b>/<b>Q</b> Elf, y should be the string \"impossible\" (without the quotes).\n</p>\n\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>P</b> &lt; <b>Q</b> &le; 1000.<br/>\n<b>P</b> and <b>Q</b> have no common factors. That means <b>P</b>/<b>Q</b> is a fraction in <i>lowest terms</i>.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>P</b> &lt; <b>Q</b> &le; 10<sup>12</sup>.<br/>\n<b>P</b> and <b>Q</b> <i>may</i> have common factors. <b>P</b>/<b>Q</b> is <i>not</i> guaranteed to be a fraction in lowest terms.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n1/2\n3/4\n1/4\n2/23\n123/31488\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 1\nCase #3: 2\nCase #4: impossible\nCase #5: 8\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\nNote that the fifth sample case does not meet the limits for the Small input. Even if you don't solve it correctly, you might still have solved the Small input correctly.\n</p>\n\n<h4>Explanation of sample cases</h4>\n<p>\nIn the first sample case, Vida could have a <code>1/1</code> Elf parent and a <code>0/1</code> Elf parent. That means she could have had a 1/1 Elf one generation ago, so the answer is 1.\n</p>\n<p>\nIn the second sample case, Vida could have had a <code>1/1</code> Elf parent and a <code>1/2</code> Elf parent. That means she could have had a <code>1/1</code> Elf one generation ago, so the answer is 1.\n</p>\n<p>\nIn the third sample case, Vida could have had a <code>0/1</code> Elf parent and a <code>1/2</code> Elf parent. The <code>1/2</code> Elf parent could have had a <code>1/1</code> Elf parent and a <code>0/1</code> Elf parent. That means she could have had a <code>1/1</code> Elf two generations ago, so the answer is 2.\n</p>\n<p>\nIn the fourth sample case, it's impossible to be exactly <code>2/23</code> Elf if your ancestors 40 generations ago were all <code>0/1</code> Elf or <code>1/1</code> Elf.\n</p>\n\n<h3>Note</h3>\n\n<p>\nYes, Vida has a lot of ancestors. If that is the part of the problem that seems the most unrealistic to you, please re-read the part about Elves.\n</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Part Elf","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis is a straightforward problem, but the main issue to get it correct is to enumerate all invalid cases. The main idea of the solution is to join some strings to create sets of disjoint groups, such that every group contains a set of strings that must be joined together. Then calculate the number of ways to create every group, and the final result will be the factorial of number of disjoint groups multiplied by number of ways to create every group.\n</p>\n\n<p>One of the main issues (that lead to huge number of incorrect attempts) was to validate that the given set of strings is invalid. So let us start the analysis by specifying valid cases that should be handled before creating the groups.\n</p>\n\n<p>\nAnother good hint that will help a lot in validation process is to collapse all given strings by removing all duplicate consecutive letters, for example, if given a string <code>\"aabbccdddeaa\"</code>, after collapsing this string it should be <code>\"abcdea\"</code>. So from now, we will assume that all given strings are always collapsed, even after joining two strings <code>\"ab\"</code> and <code>\"bc\"</code> this will be collapsed automatically to be <code>\"abc\"</code> not <code>\"abbc\"</code>.\n</p>\n\n<h2>Validation Process</h2>\n\n<p>\nFirst, check that for every string there is no letter repeated in two different places in the string. For example, <code>[\"aba\", \"abca\", \"adeab\"]</code> are all invalid strings as <code>'a'</code> is repeated, while <code>[\"ab\", \"abc\", \"adbe\"]</code> are valid strings.\n</p>\n\n<p>\nWe start by precomputing some information that will help to enumerate the rest of invalid cases. We need to store the position of every character <b><i>c</i></b> in the alphabets, i.e. all letters from <code>'a'</code> to <code>'z'</code>. Character <b><i>c</i></b> will be either (i) the first character, (ii) the last character, or (iii) a middle character of any given non-single-character string. Also, we need to count the number of single-character strings for every character <b><i>c</i></b>.\nFor example, if the given list of collapsed strings is <code>[\"abc\", \"cdef\", \"a\", \"a\", \"gh\"]</code>, then the precomputed arrays are:\n<pre><code>begin = {'a': 0, 'c': 1, 'g': 4}   -- (1)\nend = {'c': 0, 'f': 1, 'h': 4}     -- (2)\nmiddle = {'b': 0, 'd': 1, 'e': 1}  -- (3)\nsingleChars = {'a': 2}             -- (4)</code></pre>\n\n<i>Notes</i>:\n<ol>\n<li><code>begin</code> means that for any character <code><b>c</b></code>, it is the first character of string number <code><b>begin[c]</b></code>.</li>\n<li><code>end</code> means that for any character <code><b>c</b></code>, it is the last character of string number <code><b>end[c]</b></code>.</li>\n<li><code>middle</code> means that for any character <code><b>c</b></code>, it is in the middle of string number <code><b>middle[c]</b></code>. Notice that, <code>\"cdef\"</code> (string number 1) has two middle characters, while <code>\"gh\"</code> (string number 4) does not have middle characters.</li>\n<li><code>singleChars</code> means that for any character <code><b>c</b></code>, There are <code><b>singleChars[c]</b></code> single-character strings composed of character <code><b>c</b></code>. For example, there are 2 single-character strings of character <code>'a'</code>.</li>\n</ol>\n</p>\n\n<p>\n\n</p>\n\n<p>\nWhile precomputing the previous arrays, you have identify a valid set of strings by sustaining the following conditions. A character is valid only if it satisfies one of the following conditions:\n<ol>\n<li>It appears in the middle of one string, and nowhere else.</li>\n<li>It appears at most once in the beginning of one string, at most once at the end of one string, and any number of times as a single-character string.</li>\n</ol>\n</p>\n\n<p>\nFor example, all the following cases are invalid:\n<ul>\n<li><code>[\"abc\", \"ade\"]</code>: character <code>'a'</code> conflicts with second condition.</li>\n<li><code>[\"bca\", \"dea\"]</code>: character <code>'a'</code> conflicts with second condition.</li>\n<li><code>[\"abc\", \"dbf\"]</code>: character <code>'b'</code> conflicts with second condition.</li>\n<li><code>[\"abc\", \"ead\"]</code>: character <code>'a'</code> conflicts with first condition.</li>\n<li><code>[\"abc\", \"gcf\"]</code>: character <code>'c'</code> conflicts with first condition.</li>\n<li><code>[\"a\", \"a\", \"bac\"]</code>: character <code>'a'</code> conflicts with first condition.</li>\n</ul>\n</p>\n\n<p>\nBy considering the previous conditions, we will be able to identify valid cases in any given set of strings.\n</p>\n\n<h2>Groups creation</h2>\n<p>\nLet us define first what it is a group, the group is a set of strings that should be joined to form a valid combined string. So in this section we focus on creating a set of disjoint groups to count the number of ways. For example, <code>[\"ab\", \"bc\"]</code> is a group as <code>\"ab\"</code> and <code>\"bc\"</code> should be joined together to form <code>\"abc\"</code>, which is a valid string. Also, assume given <code>[\"ab\", \"bc\", \"de\", \"xy\", \"yz\"]</code>, this set of strings can be divided into 3 disjoint groups, which are <code>[\"ab\", \"bc\"]</code>, <code>[\"de\"]</code>, and <code>[\"xy\", \"yz\"]</code>.\n</p>\n\n<p>\nFirst, we need to handle the special case of single-character strings. Every single-character string can be considered initially as a group, with the number of ways to create it being equal to the factorial of the number of such strings, for example, <code>[\"a\", \"a\", \"a\"]</code> can be grouped in 3! (which is 6 different ways). And this group will be represented by only one character which is <code>\"a\"</code> and not <code>\"aaa\"</code> (as we described in the beginning, we will collapse these strings too).\n</p>\n\n<p>\nAn important point to notice while creating groups is that the first string in the group should start with a character that is not used as the last character in any other string. For example, the following 2 strings <code>[\"abc\", \"cde\"]</code> can form a valid group that should be represented by string <code>\"abcde\"</code>, we notice that we cannot start forming the group with string <code>\"cde\"</code> as it starts with character <code>'c'</code> which is the last character of string <code>\"abc\"</code> (we can make this check in constant time by using the <code><b><i>end</i></b></code> array). Also, notice that this group can be created in only 1 way.\n</p>\n\n<p>\nWe now proceed with counting the <i>number of disjoint groups</i>. We loop over all non-single-character strings that start with a character not used as the last character of any other string and use this as the first string in the group, then join it to the string that starts with its last character (get the index of this string using <code><b><i>begin</i></b></code> array) and so on till you reach the last string in that group (where you cannot find any other string to join it to). For example:\n<code><pre>[\"cde\", \"mno\", \"abc\", \"opq\", \"xyz\"]\nFrom these strings we can form 3 disjoint groups as follows:\n  1) \"mno\" + \"opq\" = \"mnopq\"\n  2) \"abc\" + \"cde\" = \"abcde\"\n  3) \"xyz\"</ul></pre></code>\n</p>\n\n<p>\nAfter counting the number of disjoint groups there is one more step remaining which is to join any single-character string to an disjoint group, if possible. As stated previously, we assumed initially that every single-character string is considered as a disjoint group, so we may assume that total number of disjoint groups equals to number of non-single-character groups and number of single-character groups. But there are some cases that we need to join a single-character strings to a one of the non-single-character strings. We can elaborate that with the following two examples:\n<ul>\n<li><code>[\"ab\", \"b\", \"b\"]</code>: you must join the single-character string <code>\"b\"</code> to the end of string <code>\"ab\"</code> to form the group <code>\"ab\"</code> in 2 ways, i.e. 2 ways for the 2 single-character strings and only 1 way to join the single-character string to <code>\"ab\"</code>.</li>\n<li><code>[\"a\", \"a\", \"bc\"]</code>: in this case we consider <code>\"a\"</code> as an disjoint group and will not be joined to any other groups. So there are 4 ways, i.e. 2 ways for the single-character string, and 2 ways to order <code>\"a\"</code> and <code>\"bc\"</code> either <code>\"abc\"</code> or <code>\"bca\"</code>.</li></ul>\n\n</p>","id":"00000000004334c8","statement":"<h3>Problem</h3>\n<p>\nYahya is a brilliant kid, so his mind raises a lot of interesting questions when he plays with his toys. Today's problem came about when his father brought him a set of <a href=\"https://www.google.com/search?q=train+car+toys&tbm=isch\" target=\"_blank\">train cars</a>, where each car has a lowercase letter written on one side of the car.\n</p>\n<p>\nWhen he first saw the gift, he was happy and started playing with them, connecting cars together without any particular goal. But after a while he got bored (as usual) from playing without having any goal. So, he decided to define a new interesting problem.\n</p>\n<p>\nThe problem is that he currently has <b>N</b> sets of connected cars. He can represent each set of connected cars as a string of lowercase letters. He wants to count the number of ways he can connect all <b>N</b> sets of cars to form one <i>valid</i> train. A train is valid if all occurrences of the same character are adjacent to each other.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U060sA5pDxvPaOrz7ZjRgrnVteBBvrxaZDBlyBwVG3SAJfxiuo8eENI7Vg6cL4PPnxo9yVpFH_nZ395JCeI1NxZ8Vm69w/reordering_train_carts.png\"/>\n<p>\nThe previous figure is one way Yahya could connect the cars \"ab\", \"bc\" and \"cd\" to make a valid train: \"ab bc cd\". If he had connected them in the order \"cd ab bc\", that would have been invalid: the \"c\" characters would not have been adjacent to each other.\n</p>\n<p>\nYou've surely noticed that this is not an easy problem for Yahya to solve, so he needs your help (and he is sure that you will give it!). That's it; go and help Yahya!\n</p>\n<p>\n<b>Note</b>: letters are written only on one side of the cars, so you can not reverse them. For example, if a car has \"ab\" written on it, it could not be changed to read \"ba\".\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. The first line of each test case contains a single integer <b>N</b>, the number of sets of connected cars. The following line contains <b>N</b> strings separated by a single space. Every given string represents a set of connected cars and is composed of lowercase English letters only.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the number of different ways of obtaining a valid train. As this number may be very big, output the number of ways <i>modulo 1,000,000,007</i>.\n</p>\n\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; Set of connected <b>Cars'</b> lengths &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\nab bbbc cd\n4\naa aa bc c\n2\nabc bcd\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 4\nCase #3: 0\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h4>Sample Explanation</h4>\n<p>\nIn the first case, there is only one way to form a valid train by joining string <i>\"ab\"</i> to <i>\"bbbc\"</i> to <i>\"cd\"</i> in this order.\n</p>\n<p>\nWhile in the second case, there are 4 possible ways to form a valid train. Notice that there are two different sets of connected cars represented by the string <i>\"aa\"</i>, so there are two different ways to order these two strings and to group them to be one set of connected cars <i>\"aaaa\"</i>. Also there is only one way to order set of cars <i>\"bc\"</i> with <i>\"c\"</i> in only one way to be <i>\"bcc\"</i>. After that you can order <i>\"aaaa\"</i> and <i>\"bcc\"</i> in two different ways. So totally there are 2*2 = 4 ways to form a valid train.\n</p>\n<p>\nIn the third sample case, there is no possible way to form a valid train, as if joined in any of the two ways <i>\"abc\"+\"bcd\"</i> or <i>\"bcd\"+\"abc\"</i>, there will be two letters of <i>\"b\"</i> and <i>\"c\"</i> not consecutive.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Reordering Train Cars","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432cd8","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2014"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
