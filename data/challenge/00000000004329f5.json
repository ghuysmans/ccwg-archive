{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1218304800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000004329f5","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  The last online round of Google Code Jam 2008 turned out to be an exciting\n  feast of dynamic programming, plane geometry, discrete geometry, basic graph\n  search, bipartite matching, combinatorics and number theory -- all in the time\n  span of two hours. The problems got more challenging, and the contest more and\n  more exciting.\n</p><p>\n  Before the game, our own Tomek Czajka took a look at the problems and made\n  some amazing conjectures about the contest statistics. One of them was that\n  the first person would complete all the problems in 100 minutes. This\n  conjecture was proved by <b>bmerry</b> in a very nice way. All the problems\n  were finished at the 98th minute. In addition, <b>bmerry</b> add 4 minutes of\n  penalty for a wrong submission. The only other player with a perfect score was\n  <b>yuhch123</b>, a Chinese high school student, with a correct submission in\n  the last 5 minutes of the contest.\n</p><p>\n  In 3rd position was <b>halyavin</b>, seemingly only seconds away from the last\n  submission. In the last 5 minutes, many contestants (including 13 of the top\n  20) submitted something correct.\n</p>\n\n<hr>\n<p>\n  <b>Credits</b>\n</p><p>\n  Problem A. <i>How Big Are the Pockets?</i>\n  Written and prepared by Xiaomin Chen.\n</p><p>\n  Problem B. <i>Portal</i>\n  Written by Mohamed Eldawy. Prepared by Frank Chu and Mark Gordon.\n</p><p>\n  Problem C. <i>No Cheating</i>\n  Written by Yintao Yu. Prepared by Mark Gordon and Yintao Yu.\n</p><p>\n  Problem D. <i>Endless Knight</i>\n  Written by Junbin Teng. Prepared Xiaomin Chen.\n</p><p>\n  Contest analysis presented by Xiaomin Chen and Cosmin Negruseri.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1218297600000,"tasks":[{"analysis":"<h3>(i). Computing the area of the polygon</h3>\n<p>\n  As Polygonovich walks, the interior of the polygon either always stays on his\n  right side, or always on his left side. This is by no means a trivial fact.\n  The polygon can be so complicated that given a poriton of the walk in the\n  middle, one has no way to decide whether the left side is the interior, or the\n  right side is. Let us accept this fact and assume the former case -- his right\n  hand always touches the interior of the polygon.\n</p><p>\n  Fix a vertical bar of unit width, observe the interaction between P,\n  Polygonovich's walk, and B, the vertical bar.\n</p>\n<ul>\n  <li>\n    P crosses B an even number of times. Because the walk is closed, and any\n    time Polygonovich crosses from the left to the right, the next time he must\n    cross in the other direction. From top down, we label them as the 1st\n    crossing, the 2nd one, and so on.\n  </li>\n  <li>\n    Furthermore, look down at B from high above. In the beginning, it is outside\n    the polygon. Every time it encounters an edge of P, it changes from being\n    outside the polygon to being inside and vice versa. So, a unit square on B\n    is inside the polygon if and only if it is between some\n    <nobr>(2k-1)-st</nobr> crossing and <nobr>(2k)-th</nobr> crossing.\n  </li>\n  <li>\n    Note that if the polygon is always on the right-hand side, then we know that\n    the <nobr>(2k-1)-st</nobr> crossing is always from left to right, and the\n    <nobr>(2k)-th</nobr> one is from right to left.\n  </li>\n</ul>\n<p>\n  Given any unit square U, we can decide whether it is in the polygon by\n  counting the number of left-to-right crossings vertically above U, minus the\n  number of right-to-left crossings above U. We can have a little counter inside\n  U, and each time there is a left-to-right crossing above U, we increase the\n  counter by 1; and for the right-to-left crossings, decrease the counter by 1.\n</p><p>\n  After these mental exercises, we make the final jump back to the interaction\n  between P and B. We may imagine a bounding box outside the polygon so that\n  there are finitely many counters, and we now consider the area, it is nothing\n  other than the summation of all the counters. To compute the area, we do the\n  following.\n</p>\n<blockquote>\n  Set A = 0 in the beginning. Walk along P, for each horizontal edge from left\n  to right at height h, we increment A by h. This is the effect of this edge on\n  all the counters for the unit squares below. And for each edge from right to\n  left at height h, we decrement A by h.\n</blockquote>\n<p>\n  All the time we assume the interior is always on the right hand side. In the\n  opposite case, the highest edge on each bar will be a right-to-left cross, and\n  all of the reasoning above is similar with only a difference in signs. So if\n  we ever find that A is negative at the end, we can negate it and get the right\n  area.\n</p><p>\n  We note that this is just a special case of the simple algorithm for computing\n  polygon areas in general. However, isn't the pictures nice, in the special\n  form of integer grids and axis-parallel edges?\n</p>\n\n<h3>(ii). Computing the area of the polygon plus the pockets</h3>\n<p>\n  The polygon plus the pockets gives staircases in four (NE, NW, SE, SW)\n  directions. A formal proof would be tedious. A picture with a good example\n  should suffice.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3IlgMnFQ9YJA4X35JCtrgEw-zgTuUOgq-skx90IIE-qRigS45CVKqd17yXz59hv-zNH5O4jgBg/pocketsol.png\" />\n<p>\n  As in the picture, let A be any one of the topmost edges, C be the bottommost\n  edge, B the right-most, and D the left-most one. We have 4 staircases: one\n  from A to B, one from B to C, one from C to D, and one from D to A.\n  Theoretically speaking, these are formed by the maximal points with respect to\n  four directions, and each of these staircases can be computed in\n  <nobr><b>m</b>log<b>m</b></nobr> time, where <b>m</b> is the number of points\n  on the polygon. In this problem, we use the guarantee that there are at most\n  6000 vertical strips. For each vertical strip x, define\n</p>\n<blockquote>\n  t(x) := the topmost polygon edge to cross the strip.<br>\n  b(x) := the bottommost polygon edge to cross the strip.<br>\n  H(x) := the topmost polygon edge or pocket on that strip.<br>\n  L(x) := the bottommost polygon edge or pocket on that strip.\n</blockquote>\n<p>\n  For x between A and B, H(x) is the maximum t(x') for all x' between x and B.\n  We may compute H(x) as follows<br>\n</p>\n<pre>\nH(x) = t(x) for the last strip\nfor x = (the second last strip) down to A\n  H(x) = max(H(x+1), t(x))\n</pre>\n<p>\n  The values on the other staircases can be computed in the same manner.\n</p><p>\n  On strip x, the polygon plus pockets are the unit squares between L(x) and\n  H(x). So we can sum <nobr>H(x) - L(x)</nobr> over all the 6000 possible strips\n  and get the area of the polygon with pockets.\n</p>\n\n<h3>(iii). Solve our problem</h3>\n<p>\n  (ii) minus (i).\n</p>\n","id":"0000000000432b23","statement":"<h3>Problem</h3>\n<p>\n  Professor Polygonovich, an honest citizen of Flatland, likes to take random\n  walks along integer points in the plane. He starts from the origin in the\n  morning, facing north. There are three types of actions he makes:\n</p>\n<ul>\n  <li>'F': move forward one unit of length.</li>\n  <li>'L': turn left 90 degrees.</li>\n  <li>'R': turn right 90 degrees.</li>\n</ul>\n<p>\n  At the end of the day (yes, it is a long walk!), he returns to the origin. He\n  never visits the same point twice except for the origin, so his path encloses\n  a polygon. In the following picture the interior of the polygon is colored\n  blue (ignore the points x, y, z, and w for now; they will be explained soon):\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2jMbV8FiO0e7_zegUbquYUAOMjIyPQTe_7SQ5BbyZ6VvPVmelz2AEQMPf_C3daXKvHLWydol3m/pockets01.png\" />\n\n<p>\n  Notice that as long as Professor Polygonovich makes more than 4 turns, the\n  polygon is not convex. So there are pockets in it.\n</p><p>\n  <b>Warning!</b> To make your task more difficult, our definition of\n  <i>pockets</i> might be different from what you may have heard before.\n</p><p>\n  The gray area below indicates pockets of the polygon.\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U345jpgACBk6COkcXxzU233HGszWnU5ceK9QrRyrjNuhYlhgbvy-zJeZIdUwG4S9lN8-iPZd137/pockets02.png\" />\n\n<p>\n  Formally, a point <b>p</b> is said to be in a pocket if it is not inside the\n  polygon, and at least one of the following two conditions holds.\n</p>\n<ul>\n  <li>There are boundary points directly both east and west of <b>p</b>; or</li>\n  <li>There are boundary points directly both north and south of <b>p</b>.</li>\n</ul>\n<p>\n  Boundary points are the points traversed by Mr. Poligonovich on his walk\n  (these include all points, not just those with integer coordinates).\n</p><p>\n  Consider again the first picture from above. Point <b>x</b> satisfies the\n  first condition; <b>y</b> satisfies both; <b>z</b> satisfies the second one.\n  All three points are in pockets. The point <b>w</b> is not in a pocket.\n</p><p>\n  Given Polygonovich's walk, your job is to find the total area of the pockets.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>N</b>. <b>N</b> test\n  cases follow.\n</p><p>\n  Each test case has the description of one walk of Professor Polygonovich. It\n  starts with an integer <b>L</b>. Following are <b>L</b> \"<b>S</b> <b>T</b>\"\n  pairs, where <b>S</b> is a string consisting of 'L', 'R', and 'F' characters,\n  and <b>T</b> is an integer indicating how many times <b>S</b> is repeated.\n</p><p>In other words, the input for one test case looks like this:</p>\n<pre>\nS<sub>1</sub> T<sub>1</sub> S<sub>2</sub> T<sub>2</sub> ... S<sub>L</sub> T<sub>L</sub>\n</pre>\n<p>\n  The actions taken are the concatenation of T<sub>1</sub> copies of\n  S<sub>1</sub>, followed by T<sub>2</sub> copies of S<sub>2</sub>, and so on.\n</p><p>\n  The \"<b>S</b> <b>T</b>\" pairs for a single test case may not all be on the\n  same line, but the strings <b>S</b> will not be split across multiple lines.\n  The second example below demonstrates this.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>X</b>: <b>Y</b>\",\n  where <b>X</b> is the 1-based case number, and <b>Y</b> is the total area of\n  all pockets.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 60 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>N</b> &le; 100<br>\n  1 &le; <b>T</b> (bounded from above by constraints in the problem statement,\n  \"Small dataset\" and \"Large dataset\" sections)<br>\n  The path, when concatenated from the input strings, will not have two\n  consecutive direction changes (that is, there will be no 'LL', 'RR', 'LR', nor\n  'RL' in the concatenated path). There will be at least one 'F' in the path.<br>\n  The path described will not intersect itself, except at the end, and it will\n  end back at the origin.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>L</b> &le; 100<br>\n  The length of each string <b>S</b> will be between 1 and 16, inclusive.<br>\n  The professor will not visit any point with a coordinate bigger than 100 in\n  absolute value.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>L</b> &le; 1000<br>\n  The length of each string <b>S</b> will be between 1 and 32, inclusive.<br>\n  The professor will not visit any point with a coordinate bigger than 3000 in\n  absolute value.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n1\nFFFR 4\n9\nF 6 R 1 F 4 RFF 2 LFF 1\nLFFFR 1 F 2 R 1 F 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  The following picture illustrates the two sample test cases.\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2hZYf99GNJx8kgtzDJjqL1aiaAwfJLJmHpSpCWznWa0rwpGVmiYFbzXEKcTe6IIWXkPc88cPBM/pockets03.png\" />\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":15}],"title":"How Big Are the Pockets?","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  The small dataset can be solved by simple, two-dimensional dynamic\n  programming. In fact, this is obviously the easiest dataset most of the\n  contestants found in this round, with 884 correct submissions. Quite on the\n  contrary, the large dataset turns out to be the most difficulty for this\n  round, solved by only 32 contestants.\n</p><p>\n  Below we outline three tricks one may use in this problem.\n</p>\n\n<h3>Section A. A nice simplification</h3>\n<p>\n  Most people are familiar with lattice walks from (0, 0) to (m, n), where each\n  step one can either increase row by 1 or increase column by 1. The total\n  number of such walks is the binomial number (m+n) choose n. One simple reason\n  is that the set of paths is bijective to the ways you choose m steps for\n  vertical moves among the (m+n) steps.\n</p><p>\n  If there are no rocks, one can see that the situation in this problem is quite\n  similar. In fact, they are essentially the same. After a nice transformation\n  of the input, we can forget about the knight and focus on the normal lattice\n  walks.\n</p><p>\n  In our problem, the two kinds of moves the knight can make correspond to the\n  vectors <nobr>u = (1, 2)</nobr> and <nobr>v = (2, 1)</nobr>. The set of\n  reachable positions forms a lattice with u, v as the basis. To find the\n  coordinate of <nobr>(r, c)</nobr> in the new system is a matter of linear\n  transformation between two bases. In our problem, it is as simple as\n</p>\n<blockquote>\n  r' (2, 1) + c' (1, 2) = (r, c) - (1, 1).\n</blockquote>\n<p>\n  Solving, we get r+c = 2 mod 3, and\n</p>\n<blockquote>\n  r' = r - 1 - (r+c-2)/3, and c' = c - 1 - (r+c-2)/3.\n</blockquote>\n<p>\n  We illustrate using the following picture.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3Y6laGGixw1IRbQbAfkXK16gCY0uGsz1GPMLr3WKMRGsbY5MjRcNnDWPJr0sg8PJtKjGdp/knight.png\" />\n<p>\n  When reading the input, we can transform the points to the new system, and\n  throw away any points that are not reachable. Assume the destination is\n  reachable, otherwise we can simply output 0. We can also disregard any rock\n  with row number or column number that exceeds the destination. In short, we\n  are now in a rectangular lattice in the new coordinate system.\n</p>\n\n<h3>Section B. A key idea</h3>\n<p>\n  Notice that there is an important restriction in our problem: there are at\n  most 10 rocks. The key idea to our solution -- although other solutions are\n  possible as well -- is the inclusion-exclusion principle.\n</p><p>\n  Let S be any subset of rocks (including the empty set). Define f(S) to be the\n  number of ways we can walk from the origin to destination and hitting every\n  rock in S, and possibly hitting some other rocks.\n</p>\n<blockquote>\n  Number of paths that do not hit any rock = &Sigma;<sub>S</sub> f(S)\n  (-1)<sup>|S|</sup>.\n</blockquote>\n<p>\n  <i> Also note:</i> we refer to the Round 1C problem Ugly Numbers. There we\n  needed to consider the multiples of 2, 3, 5, and 7. Some solutions can be\n  viewed as an application of the inclusion-exclusion principle, although this\n  is not necessary for solving that problem.\n</p>\n\n<h3>Section C. N choose K mod 10007?</h3>\n<p>\n  Now we need to calculate f(S) for any S. Let's sort rocks in S from left to\n  right, and for rocks on the same column, pick the higher one first. It should\n  be clear that if some later rock is higher than some earlier ones, then f(S) =\n  0 -- there is no way to hit all the rocks in S.<br>\n  Otherwise, the sorted set S forms a chain from the top-left corner to the\n  lower-right corner\n</p>\n<blockquote>\n  (0, 0) =: (r<sub>0</sub>, c<sub>0</sub>) &rarr; (r<sub>1</sub>, c<sub>1</sub>)\n  &rarr; ... &rarr; (r<sub>k+1</sub>, c<sub>k+1</sub>) := destination\n</blockquote>\n<p>\n  We can view any path hitting all the k rocks as (k+1) stages. f(S) is the\n  product of the number of ways we can do each stage. (This is another important\n  counting principle. It is so important and obvious that usually people don't\n  call it by name. But it does have a name -- the multiplication rule.)\n</p><p>\n  Now, we are back to the classical problem in the beginning of this analysis.\n  Let <nobr>m = (r<sub>i</sub> - r<sub>i-1</sub>)</nobr> and\n  <nobr>n = (c<sub>i</sub> - c<sub>i-1</sub>)</nobr>, the number of ways we can\n  do the i-th stage is exactly (m+n) choose n.\n</p><p>\n  So, is this the end of the story? Not yet. Many contestants failed this\n  problem because it is tricky to compute A choose B mod 10007 quickly and\n  correctly. In this problem, both A and B can be on the order of\n  10<sup>8</sup>. To compute A choose B mod P for a prime number P, one needs\n  some tricks. There are many clever ways you can find, like pre-computing N!\n  for all N, pre-computing the inverse of each number mod P, utilizing the\n  periodicity of the numbers in factorials.<br>\n  What we want to introduce below is a nice theorem that is not as well known as\n  it should be. It removes all the worries about the multiples of P. It is not a\n  difficult theorem, but looks very cute and especially useful for this problem.\n</p><p>\n  <i>Lucas' Theorem:</i> Suppose (n<sub>t</sub>n<sub>t-1</sub>...n<sub>0</sub>)\n  and (k<sub>t</sub>k<sub>t-1</sub>...k<sub>0</sub>) are the representation of n\n  and k in base P, where P is a prime number. Then (n choose k) is the product\n  of (n<sub>i</sub> choose k<sub>i</sub>) in Z<sub>P</sub>.\n</p><p>\n  The following is the choose function from <b>Reid</b>'s beautiful Haskel code.\n</p>\n<pre>\nchoose :: Int -&gt; Int -&gt; Int10007\nchoose n k | k &gt; n = 0\nchoose n k | n &lt; 10007 = \n  product [ (fromIntegral i) :: Int10007 |  i &lt;- [n-k+1..n] ]\n  / product [ (fromIntegral i) :: Int10007 | i &lt;- [1..k] ]\nchoose n k = choose qn qk * choose rn rk\n  where (qn, rn) = n `divMod` 10007\n        (qk, rk) = k `divMod` 10007\n</pre>\n\n<h3>More information</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=inclusion+exclusion+principle\" target=\"_blank\">The inclusion-exclusion principle</a> -\n  <a href=\"http://www.google.com/search?q=lucas+theorem\" target=\"_blank\">Lucas' Theorem</a> -\n  <a href=\"http://www.google.com/search?hl=en&q=staircase+walk&btnG=Google+Search\" target=\"_blank\">Staircase walk</a><br>\n  For the study of lattice points, we refer to any standard text in Discrete\n  Geometry.\n</p>\n","id":"0000000000432bd6","statement":"<h3>Problem</h3>\n<p>\n  In the game of chess, there is a piece called the knight. A knight is special\n  -- instead of moving in a straight line like other pieces, it jumps in an \"L\"\n  shape. Specifically, a knight can jump from square (r1, c1) to (r2, c2) if and\n  only if <nobr>(r1 - r2)</nobr><sup>2</sup> + <nobr>(c1 - c2)</nobr\n  ><sup>2</sup> = 5.\n</p><p>\n  In this problem, one of our knights is going to undertake a chivalrous quest\n  of moving from the top-left corner (the (1, 1) square) to the bottom-right\n  corner (the (<b>H</b>, <b>W</b>) square) on a gigantic board. The chessboard\n  is of height <b>H</b> and width <b>W</b>.\n</p><p>\n  Here are some restrictions you need to know.\n</p>\n<ul>\n  <li>\n    The knight is so straightforward and ardent that he is only willing to move\n    towards the right <i>and</i> the bottom. In other words, in each step he\n    only moves to a square with a bigger row number and a bigger column number.\n    Note that, this might mean that there is no way to achieve his goal, for\n    example, on a 3 by 10 board.\n  </li>\n  <li>\n    There are <b>R</b> squares on the chessboard that contain rocks with evil\n    power. Your knight may not land on any of such squares, although flying over\n    them during a jump is allowed.\n  </li>\n</ul>\n<p>\n  Your task is to find the number of unique ways for the knight to move from the\n  top-left corner to the bottom-right corner, under the above restrictions. It\n  should be clear that sometimes the answer is huge. You are asked to output the\n  remainder of the answer when divided by 10007, a prime number.\n</p>\n\n<h3>Input</h3>\n<p>\n  Input begins with a line containing a single integer, <b>N</b>. <b>N</b> test\n  cases follow.\n</p><p>\n  The first line of each test case contains 3 integers, <b>H</b>, <b>W</b>, and\n  <b>R</b>. The next <b>R</b> lines each contain 2 integers each, <b>r</b> and\n  <b>c</b>, the row and column numbers of one rock. You may assume that (1, 1)\n  and (<b>H</b>, <b>W</b>) never contain rocks and that no two rocks are at the\n  same position.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output a single line of output, prefixed by \"Case\n  #<b>X</b>: \", where <b>X</b> is the 1-based case number, followed by a single\n  integer indicating the number of ways of reaching the goal, modulo 10007.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>N</b> &le; 100<br>\n  0 &le; <b>R</b> &le; 10\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>W</b> &le; 100<br>\n  1 &le; <b>H</b> &le; 100<br>\n  1 &le; <b>r</b> &le; H<br>\n  1 &le; <b>c</b> &le; W\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>W</b> &le; 10<sup>8</sup><br>\n  1 &le; <b>H</b> &le; 10<sup>8</sup><br>\n  1 &le; <b>r</b> &le; H<br>\n  1 &le; <b>c</b> &le; W\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n1 1 0\n4 4 1\n2 1\n3 3 0\n7 10 2\n1 2\n7 1\n4 4 1\n3 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 2\nCase #3: 0\nCase #4: 5\nCase #5: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Endless Knight","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  The challenge in this problem was mainly coding a bug-free solution. It was\n  pretty obvious that solving it involved using a shortest path algorithm. And\n  as you can see, even some people in the top 20 skipped this problem to go for\n  other ones, which were more difficult to figure out, but easier to code.\n</p><p>\n  Let's look at <b>bmerry</b>'s solution, because it is very readable, and he\n  was the winner of this round. Then I will continue with some other, more\n  efficient solutions.\n</p><p>\n  A state of the game corresponds to the position of the player in the maze and\n  the positions of the two portals, if they exist. This solution considers the\n  map of the maze indexed from 1 so the values (0, 0) for the coordinates of the\n  portals mean that the portals do not exist.\n</p><p>\n  At each step, the player can create a new portal, move one step North, South,\n  East or West or, if he is currently near a portal, and another portal exists,\n  travel from one portal to the other one. The first type of move can be made\n  instantaneously while the second and third types take one turn.\n</p><p>\n  One optimization step is to find, for each cell, the positions of the portals\n  that can be created from that cell, since you don't want to take O(R + C)\n  every time you need to find the possible moves from a state.\n</p><p>\n  If each move took exactly one turn, then the classic breadth-first search\n  algorithm could provide us with the answer, but in this graph with two types\n  of weights for the edges it seems like we need Dijkstra's shortest path\n  algorithm. In fact, we can still use an algorithm very similar to breadth\n  first search. The tweak is that instead of adding a new state of the same cost\n  with the current state at the end of the state queue, we add it at the\n  beginning. This way the states will be expanded in the order of their costs,\n  which is exactly what Dijkstra's algorithm does. The complexity of this\n  algorithm is <nobr>O((R*C)<sup>3</sup>)</nobr> instead of\n  <nobr>O((R*C)<sup>3</sup> log (R*C))</nobr>, which is the cost of Dijkstra's\n  shortest path algorithm.\n</p>\n\n<h3>Code</h3>\n<p>\n  Here is <b>bmerry</b>'s code, modified slightly and with some additional\n  comments.\n</p>\n<pre>\nstruct state {\n    int r;\n    int c;\n    // portal rows\n    int pr[2];\n    // portal columns\n    int pc[2];\n};\n\n#define ADDR(state) state.r][state.c] \\\n                   [state.pr[0]][state.pc[0]] \\\n                   [state.pr[1]][state.pc[1]\n\nstatic unsigned char prio[16][16][16][16][16][16];\n\nstatic const int dr[4] = {-1, 0, 1, 0};\nstatic const int dc[4] = {0, -1, 0, 1};\n\nint main() {\n    int cases;\n    cin &gt;&gt; cases;\n    for (int cas = 0; cas &lt; cases; cas++) {\n        cin &gt;&gt; R &gt;&gt; C;\n        grid.clear();\n        grid.resize(R + 2);\n\n        state start;\n        memset(&amp;start, 0, sizeof(start));\n        grid[0] = string(C + 2, '#');\n        grid[R + 1] = grid[0];\n        for (int i = 1; i &lt;= R; i++) {\n            string line;\n            cin &gt;&gt; line;\n            grid[i] = \"#\" + line + \"#\";\n            if (grid[i].find(\"O\") != string::npos) {\n                start.r = i;\n                start.c = grid[i].find(\"O\");\n                grid[i][start.c] = '.';\n            }\n        }\n\n        memset(prio, 255, sizeof(prio));\n        prio[ADDR(start)] = 0;\n        deque&lt;state&gt; q;\n        q.push_back(start);\n        int ans = -1;\n        while (!q.empty()) {\n            state cur = q.front();\n            unsigned char pri = prio[ADDR(cur)];\n            if (grid[cur.r][cur.c] == 'X') {\n                ans = pri;\n                break;\n            }\n            q.pop_front();\n\n            for (int d = 0; d &lt; 4; d++) {\n                int hr = cur.r;\n                int hc = cur.c;\n                do {\n                    hr += dr[d];\n                    hc += dc[d];\n                } while (grid[hr][hc] != '#');\n                hr -= dr[d];\n                hc -= dc[d];\n\n                // adding a new portal\n                for (int p = 0; p &lt; 2; p++) {\n                    state nxt = cur;\n                    nxt.pr[p] = hr;\n                    nxt.pc[p] = hc;\n                    if (prio[ADDR(nxt)] &gt; pri) {\n                        prio[ADDR(nxt)] = pri;\n                        // We push the state at the\n                        // front since adding a portal\n                        // is instantaneous.\n                        q.push_front(nxt);\n                    }\n                }\n            }\n\n            for (int d = 0; d &lt; 4; d++) {\n                state nxt = cur;\n                nxt.r += dr[d];\n                nxt.c += dc[d];\n                if (grid[nxt.r][nxt.c] != '#') {\n                    if (prio[ADDR(nxt)] &gt; pri + 1) {\n                        prio[ADDR(nxt)] = pri + 1;\n                        q.push_back(nxt);\n                    }\n                }\n            }\n            if (cur.pr[0] &gt; 0 &amp;&amp; cur.pr[1] &gt; 0)\n                for (int p = 0; p &lt; 2; p++)\n                    if (cur.pr[p] == cur.r &amp;&amp;\n                       cur.pc[p] == cur.c) {\n                        state nxt = cur;\n                        nxt.r = cur.pr[1 - p];\n                        nxt.c = cur.pc[1 - p];\n                        if (prio[ADDR(nxt)] &gt; pri + 1) {\n                            prio[ADDR(nxt)] = pri + 1;\n                            q.push_back(nxt);\n                        }\n                    }\n        }\n\n        printf(\"Case #%d: \", cas + 1);\n        if (ans == -1)\n            printf(\"THE CAKE IS A LIE\\n\");\n        else\n            printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n</pre>\n<p>\n  The restrictions on the inputs in the problem are small enough so that this\n  solution passes all the tests. There are other, more efficient solutions which\n  we thought of.\n</p>\n\n<h3>Other solutions</h3>\n<p>\n  It does not make sense to create the starting portal before actually being\n  able to jump through it. This way we can improve the previous solution and get\n  the complexity down to O((R*C)<sup>2</sup>).\n</p><p>\n  As we have just seen, premature portal creation is the root of complexity, so\n  let's think now of the destination portal. Once we have created a destination\n  portal, we need to move as quickly as possible to the nearest wall, create a\n  starting portal, walk through it and arrive at the destination. So what we can\n  do is just keep R*C states and move from one to another by either going North,\n  West, South or East or do a teleport move which takes a few turns. We can\n  compute in O(R*C) how much time each teleport move takes by doing a breadth\n  first search starting from all the cells in the maze where a portal can be\n  created. Now we can use Dijkstra's algorithm to find the shortest path. The\n  final algorithm can have either <nobr>O(R*C log (R*C))</nobr> complexity, or\n  if we use the fact that the teleport edges have the cost at most R * C, by\n  using a array of lists in Dijkstra's algorithm instead of a priority queue, we\n  can get the complexity of the solution down to <nobr>O(R * C)</nobr>.\n</p>\n\n<h3>More Information</h3>\n<p>\n  <a href=\"http://www.google.com/search?hl=en&q=Dijkstra%27s+algorithm&btnG=Search\" target=\"_blank\">Dijkstra's algorithm</a> -\n  <a href=\"http://www.google.com/search?hl=en&q=Breadth+First+Search&btnG=Search\" target=\"_blank\">Breadth First Search</a>\n</p>\n","id":"0000000000432cc1","statement":"<h3>Problem</h3>\n<p>\n  Portal<sup>TM</sup> is a first-person puzzle/platform game developed and\n  published by Valve Software. The idea of the game was to create two portals on\n  walls and then jump through one portal and come out the other. This problem\n  has a similar idea but it does not assume you have played Portal.\n</p><p>\n  For this problem you find yourself in a <b>R</b> by <b>C</b> grid.\n  Additionally there is a delicious cake somewhere else in the grid. You're very\n  hungry and wish to arrive at the cake with as few moves as possible. You can\n  move north, south, east or west to an empty cell. Additionally, you have the\n  ability to create portals on walls.\n</p><p>\n  To help you get to the cake you have a portal gun which can shoot two types of\n  portals, a yellow portal and a blue portal. A portal is created by shooting\n  your portal gun either north, south, east or west. This emits a ball of energy\n  that creates a portal on the first wall it hits. Note that for this problem\n  shooting the portal gun does not count as a move. If you fire your portal gun\n  at the cake, the energy ball will go right through it.\n</p><p>\n  After creating a yellow portal and a blue portal, you can move through the\n  yellow portal to arrive at the blue portal or vice versa. Using these portals\n  you may be able to reach the cake even faster! You can only use portals after\n  you create both a yellow and a blue portal.\n</p><p>\n  Consider the following grid:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0nwqK5Vyb5bTVwE7lS_WD4MGc6Ms9Co0-l0W3HHokTnpIO3_Mtwt--hGNggRRMq1rrfBqv-A/portal1.png\" />\n<p>\n  Gray cells represent walls, white cells represent empty cells, and the red\n  circle indicates your position.\n</p><p>\n  Suppose you shoot a blue portal east. The portal is created on the first wall\n  it hits, resulting in:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U11y6W1R12Vb8TTQfAw71R7VquDHmtWZ_bgb0PUU3JOwEh1GeWocUeFdysCqplBwi6949iFIw/portal2.png\" />\n<p>\n  Now suppose you shoot a yellow portal south:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2yzhBgb0ggNVX15IqOHlKFCOxLuQI1gtfzgQpOB3pGl6_fNVAHaOxN_19TGVbcDJz1qNRoYw/portal3.png\" />\n<p>\n  Next you move south once:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3q3b_Axt3KjJI3GTKzUdJnCk6hixow3i7G8Z_aQ8HaBo7W3XixlydQJelcQ7UnkG3Bhj-b5g/portal4.png\" />\n<p>\n  Now comes the interesting part. If you move south one more time you go through\n  the yellow portal to the blue portal:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0CQ49mh2VZ5IXTaseeybzjvaj7OtoC5ZERdOQl-sZGrR7ipFecidG2EC2AfLrbxUXUcm9yCw/portal5.png\" />\n<p>\n  There can only be one yellow portal and one blue portal at any time. For\n  example if you attempt to create a blue portal to the west the other blue\n  portal will disappear:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0CDqaj1otOjexcTVqKAWJTHFudszC_BL1BB-b1KRUcgt3YyyiYl_kmrMDvlV3-OIOODw5gqA/portal6.png\" />\n<p>\n  A portal disappears only when another portal of the same color is fired.\n</p><p>\n  Note that the portals are created on one side of the wall. If a wall has a\n  portal on its east side you must move into the wall from the east to go\n  through the portal. Otherwise you'll be moving into a wall, which is\n  improbable.\n</p><p>\n  Finally, you may not put two portals on top of each other. If you try to fire\n  a portal at a side of a wall that already has a portal, the second portal will\n  fail to form.\n</p><p>\n  Given the maze, your initial position, and the cake's position, you want to\n  find the minimum number of moves needed to reach the cake if it is possible.\n  Remember that shooting the portal gun does not count as a move.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>N</b>. <b>N</b> test\n  cases follow.\n</p><p>\n  The first line of each test case will contain the integers <b>R</b> and\n  <b>C</b> separated by a space. <b>R</b> lines follow containing\n  <b>C</b> characters each, representing the map:\n</p>\n<ul>\n  <li><code>.</code> indicates an empty cell;</li>\n  <li><code>#</code> indicates a wall;</li>\n  <li><code>O</code> indicates your starting position; and</li>\n  <li><code>X</code> indicates the cake's position.</li>\n</ul>\n<p>\n  There will be exactly one <code>O</code> and one <code>X</code> character per\n  case.\n</p><p>\n  Cells outside of the grid are all walls and you may use them to create\n  portals.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case you should output one line containing \"Case #<b>X</b>:\n  <b>Y</b>\" (quotes for clarity) where <b>X</b> is the number of the test case\n  and <b>Y</b> is the minimum number of moves needed to reach the cake or \"THE\n  CAKE IS A LIE\" (quotes for clarity) if the cake cannot be reached.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  <b>N</b> = 200<br>\n  1 &le; <b>R</b>, <b>C</b> &le; 8\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  <b>N</b> = 50<br>\n  1 &le; <b>R</b>, <b>C</b> &le; 15\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 7\n.O..##.\n.#.....\n.#.####\n.#...X.\n5 5\nO....\n.....\n.....\n.....\n....X\n1 3\nO#X\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 2\nCase #3: THE CAKE IS A LIE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Here is the sequence of moves for the first case (note that shooting the\n  portal gun does not count as a move):\n</p>\n<ol>\n  <li>Move one step east.</li>\n  <li>Shoot a blue portal north.</li>\n  <li>Shoot a yellow portal south.</li>\n  <li>Move one step north through the blue portal.</li>\n  <li>Shoot a blue portal east.</li>\n  <li>Move one step south through the yellow portal.</li>\n  <li>Move one step west.</li>\n  <li>Eat your delicious and moist cake.</li>\n</ol>\n\n<p>\n  Portal<sup>TM</sup> is a trademark of Valve Inc. Valve Inc. does not endorse\n  and has no involvement with Google Code Jam.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Portal","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  Programming contests have certainly changed over the years. Nowadays, dynamic\n  programming is a trivial matter to many, and bipartite matching is no longer a\n  secret idea. More than half of the contestants solved the small datasets of\n  this problem, and 77 passed the large tests.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  The small tests can be solved using dynamic programming. The main idea is to\n  do this row by row.\n</p><p>\n  The naive dynamic programming has states (R1, r), where r is the row number\n  and R1 is the possible configurations of the current row. In order to compute\n  the value of (R1, r), (the maximum number of students who can be put in the\n  first r rows, with the r-th row identical to R1), one can loop through all of\n  the possible values of R2 and use the value of (R2, r-1).\n</p><p>\n  A more sophisticated approach also goes row by row, but in each row, we do it\n  by squares. The states are (S, r, c), where (r, c) is the current position,\n  and S is the bitmap for up to n positions before (r, c). These are all the\n  squares to the left on the same row, and all the squares from the\n  <nobr>(c-1)-st</nobr> to the last on the last row. In this way, each value of\n  (S, r, c) can be computed in constant time.\n</p><p>\n  One may estimate the number of states to be <nobr>O(M N 2<sup>N</sup>)</nobr>.\n  But actually the number of states is much smaller. It is not hard to see, with\n  the restriction that no two horizontally adjacent seats can be both occupied,\n  that the number of states S is <nobr>O(F<sub>N</sub>)</nobr>, the N-th\n  Fibonacci number. This means that the dynamic programming solution can even\n  handle a classroom of size about 35 by 35.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  Well, but universities do have very large classrooms. The large dataset has\n  tests with 80 rows and 80 columns.\n</p><p>\n  The key idea is to see through the puzzle and notice that this is a standard\n  graph problem. Let each square be a node. What the problem requires is to pick\n  a set of nodes, such that some pairs of nodes cannot be picked together. Let\n  us draw an edge between each such pair of nodes. This is the well-known\n  problem of finding a maximum independent set of the graph. While the general\n  independent set problem is NP-hard, we do know that the problem is tractable\n  on bipartite graphs. A-ha! The graph is indeed bipartite, because all of the\n  edges are between a square in odd-numbered columns and squares in\n  even-numbered columns.\n</p><p>\n  We can easily find the\n  <a href=\"http://www.google.com/search?hl=en&q=maximum+matching&btnG=Google+Search\" target=\"_blank\">maximum matching</a>\n  on bipartite graphs. Let's see how a maximum matching can help us solve the\n  problem. Let's assume that the size of the matching is <i>X</i>, and the\n  number of nodes in the graph is <i>N</i>. Notice that the the maximum\n  independent set cannot contain more than\n  <nobr><i>N</i> - <i>X</i></nobr> nodes, because that would mean you will have\n  two nodes that share an edge of the maximum matching in this set.\n</p><p>\n  In general, we have the following relations between the important graph\n  parameters. For a graph <nobr>G = (V, E)</nobr>, let &alpha;(G) be the size of\n  the maximum independent set, m(G) be the size of a maximum matching, &mu;(G)\n  be the size of a minimum vertex cover,\n</p>\n<ul>\n  <li>\n    The complement of an independent set is a vertex cover, and vice versa. So\n    <nobr>&alpha;(G) + &mu;(G) = |V|.</nobr>\n  </li>\n  <li>\n    To cover all the edges, we need one vertex from any edge of a matching. So\n    <nobr>&mu;(G) &ge; m(G)</nobr>.\n  </li>\n  <li>\n    If G is bipartite, then <nobr>&mu;(G) = m(G)</nobr>. Equivalently,\n    <nobr>&alpha;(G) + m(G) = |V|</nobr>.\n  </li>\n</ul>\n<p>\n  The last fact can be proved directly, or as a consequence of Hall's theorem,\n  or as an application of the powerful max-flow-min-cut theorem. Below we\n  provide a constructive proof that suits to our problem.\n</p>\n\n<h3>Proof</h3>\n<p>\n  We will prove that <nobr><i>N</i> - <i>X</i></nobr> is smaller than or equal\n  to the size of the maximum independent set. Let's have a maximum matching\n  <i>M</i> and a set <i>S</i> which contains all the nodes that are not in\n  <i>M</i>. Now let's add to <i>S</i> all the nodes from <i>M</i> which are on\n  the left side of the bipartite graph. <i>S</i> is of size\n  <nobr><i>N</i> - <i>X</i></nobr\n  >. If <i>S</i> is not an independent set, then it has a node <i>u</i> from\n  <i>M</i> and another one <i>v</i> that doesn't belong to <i>M</i>, such that\n  <nobr>(<i>u</i>, <i>v</i>)</nobr> is an edge. To fix this problem we remove\n  <i>u</i> from <i>S</i> and add node <i>u'</i> to <i>S</i> where\n  <nobr>(<i>u</i>, <i>u'</i>)</nobr> is an edge from the matching. If this\n  operation caused a problem with another node in the matching, then we can\n  remove that node and add it's match, and so on. This repeated procedure is\n  guaranteed to finish since we only delete nodes from the left side of the\n  graph and add nodes from the right side. There will be no problem caused by\n  the nodes on the right side of the graph and nodes outside the matching\n  because that would mean that we can find an alternating path, and the maximum\n  matching is not the largest possible.\n</p><p>\n  We have proved that in any bipartite graph, the size of the maximum\n  independent set equals the size of the graph minus the size of the maximum\n  matching.\n</p>\n\n<h3>Code</h3>\n<p>\n  We believe that many contestants have the standard bipartite matching\n  algorithm prepared. You may download many nice samples from the scoreboard.\n  Below we show a sample solution which keeps the bipartite graph only in mind,\n  and actually runs the matching algorithm on the board itself. From the judges:\n</p>\n<pre>\nint C, N, M;\nstring bd[100];\n\nint nbx[100][100], nby[100][100], v[100][100];\nint T=0;\n\nbool dfs(int a, int b) {\n  if (a&lt;0) return true;\n  if(v[a][b]==T) return false;\n  v[a][b]=T;\n  for (int i=a-1;i&lt;=a+1;i++)\n    for (int j=b-1;j&lt;=b+1;j+=2)\n      if (i&gt;=0 &amp;&amp; i&lt;M &amp;&amp; j&gt;=0 &amp;&amp; j&lt;N &amp;&amp; bd[i][j]=='.') {\n        if (dfs(nbx[i][j], nby[i][j])) {\n          nbx[i][j]=a; nby[i][j]=b;\n          nbx[a][b]=i; nby[a][b]=j;\n          return true;\n        }\n      }\n  return false;\n}\n\nint play() {\n  memset(nbx,-1,sizeof(nbx));\n  memset(nby,-1,sizeof(nby));\n  memset(v, -1, sizeof(v)); T=-1;\n  int rst=0;\n  for(int i=0;i&lt;M;i++) for(int j=0;j&lt;N;j++) {\n    if (bd[i][j]=='.') {\n      rst++;\n      if (j%2) {\n        T++;\n        if (dfs(i,j)) rst--;\n      }\n    }\n  }\n  return rst;\n}\n\nint main() {\n  cin&gt;&gt;C;\n  for (int i=1; i&lt;=C; i++) {\n    cin&gt;&gt;M&gt;&gt;N;\n    for (int r=0;r&lt;M;r++) cin&gt;&gt;bd[r];\n    cout&lt;&lt;\"Case #\"&lt;&lt;i&lt;&lt;\": \"&lt;&lt;play()&lt;&lt;endl;\n  }\n  return 0;\n}\n</pre>\n\n<h3>More Information</h3>\n<p>\n  <a href=\"http://www.google.com/search?hl=en&q=maximum+independent+set&btnG=Search\" target=\"_blank\">Maximum independent set</a> -\n  <a href=\"http://www.google.com/search?hl=en&q=Bipartite+Matching&btnG=Search\" target=\"_blank\">Bipartite Matching</a>\n</p>\n","id":"000000000043314f","statement":"<h3>Problem</h3>\n<p>\n  A local high school is going to hold a final exam in a big classroom. However,\n  some students in this school are always trying to see each other's answer\n  sheet during exams!\n</p><p>\n  The classroom can be regarded as a rectangle of <b>M</b> rows by\n  <b>N</b> columns of unit squares, where each unit square represents a seat.\n</p><p>\n  The school principal decided to set the following rule to prevent cheating:<br>\n  Assume a student is able to see his left, right, upper-left, and upper-right\n  neighbors' answer sheets. The assignment of seats must guarantee that nobody's\n  answer sheet can be seen by any other student.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0QQ4222auUN4LUS9LuYfiG7Kezg_DqJyGNqKp-XK1LIcoi-8xN4MLEa0fUrop8QFwscoyMvg/nocheat.png\" />\n<p>\n  As in this picture, it will not be a good idea to seat anyone in A, C, D, or E\n  because the boy in the back row would be able to see their answer sheets.\n  However, if there is a girl sitting in B, he will not be able to see her\n  answer sheet.\n</p><p>\n  Some seats in the classroom are broken, and we cannot put a student in a\n  broken seat.\n</p><p>\n  The principal asked you to answer the following question: What is the maximum\n  number of students that can be placed in the classroom so that no one can\n  cheat?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>C</b>. <b>C</b> test\n  cases follow. Each case consists of two parts.\n</p><p>\n  The first part is a single line with two integers <b>M</b> and <b>N</b>: The\n  height and width of the rectangular classroom.\n</p><p>\n  The second part will be exactly <b>M</b> lines, with exactly\n  <b>N</b> characters in each of these lines. Each character is either a '.'\n  (the seat is not broken) or 'x' (the seat is broken, lowercase x).\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>X</b>: <b>Y</b>\",\n  where <b>X</b> is the case number, starting from 1, and <b>Y</b> is the\n  maximum possible number of students that can take the exam in the classroom.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  <b>C</b> = 20\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>M</b> &le; 10<br>\n  1 &le; <b>N</b> &le; 10\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>M</b> &le; 80<br>\n  1 &le; <b>N</b> &le; 80\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2 3\n...\n...\n2 3\nx.x\nxxx\n2 3\nx.x\nx.x\n10 10\n....x.....\n..........\n..........\n..x.......\n..........\nx...x.x...\n.........x\n...x......\n........x.\n.x...x....\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 1\nCase #3: 2\nCase #4: 46\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"No Cheating","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000004329f5","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
