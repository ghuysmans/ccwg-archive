{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1336242600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432f3e","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1B featured a tough implementation problem, a tough algorithmic problem, and a theoretically easy problem that proved the devil is sometimes in the details.  A large number of contestants managed to solve C-small and all of A; advancing required doing that within an hour, nineteen minutes and twenty-seven seconds.  Of course, contestants who weren't that quick off the mark could solve another problem to get ahead!\n</p>\n\n<p>\nThe simplest solution for Problem A needed a binary search, but a high failure rate showed that there were some tough details.  Problem B took Dijkstra's algorithm for finding shortest paths in graphs, plus some adaptation to deal with staying in one place for some time.  Problem C was a nifty problem that required some mathematical insight, with the most straightforward solution taking advantage of the birthday \"paradox\".\n</p>\n\n<p>\nBelarusian wunderkind Gennady Korotkevich, or a clever impostor making use of his name, had enough points to qualify after 11 minutes, and finished solving the whole set after only 54 minutes, 11 seconds -- a feat that only 50 people could accomplish given the full 2.5 hours.  South Africa's bmerry and Canada's hansonw1 rounded out the top 3 over the course of the next 15 minutes.\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>\nProblem A. <i>Safety in Numbers</i> Written by Bartholomew Furrow. Prepared by Onufry Wojtaszczyk and Bartholomew Furrow.\n</p>\n\n<p>\nProblem B. <i>Tide Goes In, Tide Goes Out</i> Written by Andrei Missine. Prepared by Onufry Wojtaszczyk and Andrei Missine.\n</p>\n\n<p>\nProblem C. <i>Equal Sums</i> Written by David Arthur. Prepared by Onufry Wojtaszczyk and David Arthur.\n</p>\n\n<p>\nContest analysis presented by Bartholomew Furrow, Onufry Wojtaszczyk and David Arthur.\n</p>\n\n<p>\nSolutions and other problem preparation by Igor Naverniouk, Adam Polak, Alexander Georgiev, John Dethridge, Jon Calhoun, Luka Kalinovcic, Nikolay Kurtov, Sean Henderson and Yiming Li.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1336233600000,"tasks":[{"analysis":"<p>There is a lot going on in this problem, and it is difficult to keep track of everything. Only seven hundred contestants managed to get it right, so you know it can't have been easy! Let's go over it.</p>\n\n<p>The first thing you should notice is that this is a shortest-path problem. We want to get from point A (the start) to point B (the exit) as fast as possible. There are a number of classical shortest-path algorithms available; we will try to adapt <a href=\"http://en.wikipedia.org/wiki/Dijkstra's_algorithm\" target=\"_blank\">Dijkstra's algorithm</a> here.</p>\n\n<p>Dijkstra's algorithm works on a weighted graph, so we need to identify a set of vertices and edges between them to use it. This is pretty easy if you have done graph theory before - we take the squares to be the vertices, and we put an edge between every two adjacent cells. We encounter problems when trying to assign weights to the edges: the cost (in seconds) of travelling from one square to another is not fixed - it can be one or ten seconds (and we haven't touched on the issue of moving around before the tide starts going down yet).</p>\n\n<p>A fact that might be somewhat surprising is that this is not a problem for Dijkstra's algorithm. Let us briefly recall how it works - it maintains a tentative cost for each vertex, and at each step it chooses the vertex with the smallest cost, fixes that to be the real cost of visiting that vertex, and updates the neighbors accordingly. Of course in our case the cost of reaching a vertex is simply the time it takes.</p>\n\n<p>This means that we need to consider the time of going from some square <b>A</b> to an adjacent square <b>B</b> only once, when we are recalculating the time of reaching <b>B</b> due to having fixed the time for <b>A</b>. But since we fixed the time of reaching <b>A</b>, we can easily calculate the water level at this moment - and so we will know the cost of travelling this edge. (Note that the earlier we can start moving from <b>A</b>, the faster the move will be. Therefore, we really should be moving as soon as possible instead of waiting for a better moment.)</p>\n\n<p> There are also other constraints that we have. Let's name two of them - the water level needs to be at least 50 centimeters below the ceiling of the square we want to enter, and the \"gap condition\" needs to be satisfied. For the latter, we can just check - this does not depend on the time we want to travel - and remove the edge from the graph if the condition is not satisfied (we can either do this up-front, or lazily at the moment we try to use this edge). For the former, we need to look at what Dijkstra's algorithm needs again. The cost of travelling the edge <b>AB</b> is used to determine the shortest path to <b>B</b> that goes through <b>A</B> and then directly through the edge <b>AB</b> to <b>B</b>. Well, if we really want to take this path, and the water level is too high to enter <b>B</b> when we arrive at <b>A</b>, we have only one choice - we have to wait until the water level drops to <b>C<sub>B</sub></b>-50 before moving. Remember that this may cause us to have to drag the kayak!</p>\n\n<p>All this means that we can calculate the cost of each edge at the moment in which we need it, and we would have a complete solution for the problem if not for the extra possibility of moving around before the tide starts going down. One might be tempted to solve this issue by a preprocessing phase, where we use a breadth-first search to find all the squares that are reachable from the start in time zero.</p>\n\n<p>A simpler solution to code, however, is to insert this phase into the Dijkstra's algorithm that works so well for us so far. All this extra movement means is that if we want to traverse the edge <b>AB</b>, we are at <b>A</b> in time zero, and <b>B</b> is accessible from <b>A</b> in time zero, then the cost of making this move is zero - as we can make it before the tide starts going down. This means that we insert one extra condition in our function that calculates the cost, and we are done!</p>\n\n<p>Notice that the outcome here is just a standard implementation of Dijkstra's algorithm and nothing more, with all the problem-specific logic inserted into the function that calculates the weight of a given edge at the time it is needed. To convince oneself that this works, however, an understanding of the inner workings of the algorithm is needed.</p> ","id":"00000000004329ff","statement":"<h3>Problem</h3>\n<p>\nYou are kayaking through a system of underground caves and suddenly realize that the tide is coming in and you are trapped! Luckily, you have a map of the cave system. You are stuck until the tide starts going out, so you will be here for a while. In the meantime, you want to determine the fastest way to the exit once the tide starts going out.\n</p>\n\n<p>\nThe cave system is an <b>N</b> by <b>M</b> grid.  Your map consists of two <b>N</b> by <b>M</b> grids of numbers: one that specifies the height of the ceiling in each grid square, and one that specifies the height of the floor in each grid square. The floor of the cave system is porous, which means that as the water level falls, no water will remain above the water level.\n</p>\n\n<p>\nYou are trapped at the north-west corner of the map. The current water level is <b>H</b> centimeters, and once it starts going down, it will drop at a constant rate of 10 centimeters per second, down to zero. The exit is at the south-east corner of the map. It is now covered by water, but it will become passable as soon as the water starts going down.\n</p>\n\n<p>\nAt any time, you can move north, south, east or west to an adjacent square with the following constraints:\n<ul>\n<li>The water level, the floor height of your current square, and the floor height of the adjacent square must all be at least 50 centimeters lower than the ceiling height of the adjacent square. Note: this means that you will never be able to enter a square with less than 50 centimeters between the floor and the ceiling.\n<li>The floor height of the adjacent square must be at least 50 centimeters below the ceiling height of your current square as well.\n<li>You can never move off the edge of the map.\n</ul>\nNote that you can go up or down as much as you want with your kayak. (You're very athletic from all this kayaking!) For example, you can go from a square with floor at height 10 centimeters to an adjacent square with floor at height 9000 centimeters (assuming the constraints given above are met).\n</ul>\n</p>\nThese constraints are illustrated below:\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2qoGKuvLZ6viNXuWWz2VWfpCC-MLwJUgA13s40l_KvQhpscDHqfWXK7J8SwKTjJKz3H1seWw/diagram.png\"/><br/>\n<ul>\n<li>In the first image, you can't move to the right because the water level is less than 50 centimeters below the ceiling height of the adjacent square.</li>\n<li>In the second image, you can't move to the right because the floor height of your current square is less than 50 centimeters below the ceiling height of the adjacent square.</li>\n<li>In the third image, you can't move to the right because the floor height of the adjacent square is less than 50 centimeters below the ceiling height of the adjacent square.  You'll never be able to enter that square from any direction.</li>\n<li>In the fourth image, you can't move to the right because the floor height of the adjacent square is less than 50 centimeters below the ceiling height of the current square.</li>\n</ul>\n</p>\n<p>\nWhen moving from one square to another, if there are at least 20 centimeters of water remaining on the current square when you start moving from it, it takes 1 second to complete the move (you can use your kayak).  Otherwise, it takes 10 seconds (you have to drag your kayak).  Note that the time depends only on the water level in the square you are leaving, not in the square you are entering.\n</p>\n\n<p>\nIt will be a while before the tide starts going out, and so you can spend as much time moving as you want before the water starts going down. What matters is how much time you will need from the moment the water starts going down until the moment you reach the exit. Can you calculate this time?\n</p>\n\n<h3>Input</h3>\n<p>\n<ul>\n<li> The first line will contain a single integer, <b>T</b>: the number of test cases </li>\n<li> It is followed by <b>T</b> test cases, each starting with a line containing integers <b>H</b>, <b>N</b> and <b>M</b>, representing the initial water level height, in centimeters, and the map dimensions. The following 2<b>N</b> lines contain the ceiling and floor heights as follows:\n<ul>\n<li> The next <b>N</b> lines contain <b>M</b> space-separated integers each.  The <i>j</i>th integer in the <i>i</i>th row represents <b>C<sub>ij</sub></b>, the height of the ceiling in centimeters at grid location <i>(j, i)</i>, where increasing <i>i</i> coordinates go South, and increasing <i>j</i> coordinates go East.</li>\n<li> The next <b>N</b> lines contain <b>M</b> space-separated integers representing the heights of the floor, in the same format.</li>\n</ul>\n<li> At the starting location, there will always be at least 50 cm of air between the ceiling and the starting water level, and at least 50 cm between the ceiling and the floor.\n<li> The exit location will always have at least 50 cm of air between the ceiling and the floor.\n<li> There will always be a way out (you got in, after all!).\n</ul>\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: t\", where x is the case number (starting from 1), and t is the time, in seconds, starting from when the tide begins going out, that it takes you to make your way out of the cave system. Answers within an absolute or relative error of 10<sup>-6</sup> of the correct answer will be accepted.\n</p>\n\n<h3>Notes</h3>\n<p>It is possible that you can go through the whole cave system before the tide starts dropping. In this case you will be able to wait at the exit for the tide to start dropping, so the answer in this case should be zero (this is the case in the fourth of the sample test cases).</p>\n\n<h3>Limits</h3>\nMemory limit: 1GB.<br/>\nTime limit: 40 seconds per test set.<br/>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>T</b> &le; 50. <br>\n1 &le; <b>N, M</b> &le; 10. <br>\n1 &le; <b>H</b> &le; 1000. <br>\n1 &le; <b>F<sub>xy</sub></b> &le; <b>C<sub>xy</sub></b> &le; 1000.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>T</b> &le; 50. <br>\n1 &le; <b>N, M</b> &le; 100. <br>\n1 &le; <b>H</b> &le; 10000. <br>\n1 &le; <b>F<sub>xy</sub></b> &le; <b>C<sub>xy</sub></b> &le; 10000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n200 1 2\n250 233\n180 100\n100 3 3\n500 500 500\n500 500 600\n500 140 1000\n10 10 10\n10 10 490\n10 10 10\n100 3 3\n500 100 500\n100 100 500\n500 500 500\n10 10 10\n10 10 10\n10 10 10\n100 2 2\n1000 1000\n1000 1000\n100 900\n900 100\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 11.7\nCase #2: 3.0\nCase #3: 18.0\nCase #4: 0.0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>In the first sample test case, there are initially only 33 centimeters between the water level and the ceiling of the eastern square, so after the tide starts going down, you have to wait for at 1.7 seconds to enter it. Once it is accessible, you can start going in - but the water level in the western square is now so low (only 3 centimeters above the floor) that you have to drag your kayak for the next 10 seconds to get to the exit point.</p>\n\n<p>The initial situation in the second case is better - you have a lot of headroom in adjacent squares, so you can move, for example, to (1, 1) before the tide starts dropping. Once there, you have to wait for the tide to start going down, and the water level to go down to 90cm (that takes one second). Then you can kayak south and then east and get out (in a total of three seconds). Note that you cannot go through the cave at (2, 1), even though the ceiling there is high enough, because there is too little space between the floor of this cave and the ceiling of any caves you could try to enter from ((1, 1) and (2, 0)) - only 10 centimeters in each case.</p>\n\n<p>The third case is somewhat similar to the first - you have to wait at the starting position until the tide goes down to 50cm. After that you can kayak for the exit - but after three moves (taking three seconds) the water is at 20cm, which is only 10cm above the floor, which means the fourth move will be dragging instead of kayaking.</p>\n\n<p>In the fourth case you are really lucky! You can immediately go the exit, even before the tide starts leaving, and wait there.</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":18},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Tide Goes In, Tide Goes Out","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<br/><b>The Small Input</b><br/>\n\n<p>\nIf you want to forget about the large input and go straight for the small, then Equal Sums might look like a classic dynamic programming problem. Here is a sketch of one possible solution in Python:\n</p>\n\n<pre>\ndef GetSetWithSum(x, target):\n  if target == 0: return []\n  return GetSetWithSum(x, target - x[target]) + [x[target]]\n\ndef FindEqualSumSubsets(S):\n  x = [0] + [None] * (50000 * 20)\n  for s in S:\n    for base_sum in xrange(50000 * 20, -1, -1):\n      if x[base_sum] is not None:\n        if x[base_sum + s] is None:\n          x[base_sum + s] = s\n        else:\n          subset1 = GetSetWithSum(x, base_sum + s)\n          subset2 = GetSetWithSum(x, base_sum) + [s]\n          return subset1, subset2\n  return None\n</pre>\n\n<p>\nThe idea is that, in x, we store a way of obtaining every possible subset sum. If we reach a sum in two different ways, then we can construct two subsets with the same sum.</p>\n\n<p>\nFor the small input, this approach should work fine. However, x would have to have size 500 * 10<sup>12</sup> for the large input. That is too big to work with, and you will need a different approach there.</p>\n\n<br/><b>The Large Input</b><br/>\n\n<p>\nThe first step towards solving the large input is realizing that the statement is very misleading! Let's suppose you have just 50 integers less than 10<sup>12</sup>. There are 2<sup>50</sup> ways of choosing a subset of them, and the sum of the integers in any such subset is at most 50 * 10<sup>12</sup> &lt; 2<sup>50</sup>. By the <a href=\"https://www.google.com/search?q=pigeonhole+principle\" target=\"_blank\">Pigeonhole Principle</a>, this means that there are two different subsets with the same sum.\n</p>\n\n<p>\nSo what does that mean for this problem? Well, even if you had just 50 integers to choose from instead of 500, the answer would never be \"Impossible\". You need to find some pair of subsets that have the same sum, and there is a lot of slack to work with. The trick is figuring out how to take advantage of that slack.\n</p>\n\n<br/><b>The Birthday \"Paradox\" Method</b>\n\n<p>\nThe simplest solution is based on a classic mathematical puzzle: the birthday paradox.\n</p>\n\n<p>\nThe birthday paradox says that if you have just 23 people in a room, then some two of them probably have the same birthday. This can be surprising because there are 365 possible days, and 23 is much smaller than 365. But it is true! One good way to look at is this: there are 23 choose 2 = 253 pairs of people, and each pair of people has a 1/365 chance of having the same birthday. In particular, the <i>expected</i> (aka average) number of pairs of people with the same birthday is 253 / 365 = 0.693... Once you write it that way, it is not too surprising that the probability of having at least <i>one</i> pair matching is about 0.5.\n</p>\n\n<p>\nIt turns out this exact reasoning applies to the Equals Sums problem just as well. Here is a simple algorithm:\n<ul>\n<li> Choose 6 random integers from <b>S</b>, add them up, and store the result in a hash set. (Why 6? We'll come back to that later...)\n<li> Repeat until two sets of 6 integers have the same sum, then stop.\n</ul>\nAfter choosing t sets, there will be t choose 2 pairs, and each set will have sum at most 6 * 10<sup>12</sup>. Therefore, the expected number of collisions would be approximately t<sup>2</sup> / (12 * 10<sup>12</sup>). When t is around 10<sup>6</sup>, this expectation will be near 1, and the reasoning from the birthday paradox says that we'll likely have our collision.\n</p>\n\n<p>\nThat's it! Since we can quickly generate 10<sup>6</sup> small subsets and put their sums into a hash-set, this simple algorithm will absolutely solve the problem. You may be worried about the randomness, but for this problem at least, you should not be. This algorithm is extremely reliable. By the way, this method will work on the small input as well, so you don't need to do the dynamic programming solution if you do not want to.\n</p>\n\n<p>\n<i>Note:</i> There are many similar approaches here that can work. For example, in our internal tests, one person solved the problem by only focusing on the first 50 integers, and trying random subsets from there. The proof below works for this algorithm, as well as many others.\n</p>\n\n<br/>\n<b>A Rigorous Proof</b>\n\n<p>If you have some mathematical background, we can actually prove rigorously that the randomness is nothing to worry about. It all comes down to the following version of the birthday theorem:</p>\n\n<p><b>Lemma:</b> Let X be an arbitrary collection of N integers with values in the range [1, R]. Suppose you choose t + 1 of these integers independently at random. If N &ge; 2R, then the probability that these randomly chosen integers are all different is less than <code>e<sup>-t<sup>2</sup> / 4R</sup></code>.</p>\n\n<p><b>Proof:</b> Let x<sub>i</sub> denote the number of integers in X with value equal to i. The number of ways of choosing t + 1 distinct integers from X is precisely</p>\n\n<p><code>sum<sub>(1 &le; i<sub>1</sub> &lt; i<sub>2</sub> &lt; ... &lt; i<sub>t+1</sub> &le; R)</sub> [ x<sub>i<sub>1</sub></sub> * x<sub>i<sub>2</sub></sub> * ... * x<sub>i<sub>t+1</sub></sub> ]</code>.</p>\n\n<p>For example, if t=1 and R=3, the sum would be <code>x<sub>1</sub> * x<sub>2</sub> + x<sub>1</sub> * x<sub>3</sub> + x<sub>2</sub> * x<sub>3</sub></code>. Each term here represents the number of ways of choosing integers with a specific set of values. Unfortunately, this sum is pretty hard to work with directly, but <a href=\"https://www.google.com/search?q=maclaurin's+inequality\" target=\"_blank\">Maclaurin's inequality</a> states that it is at most the following:</p>\n\n<p><code>(R choose t+1) * [ (x<sub>1</sub> + x<sub>2</sub> + ... + x<sub>R</sub>) / R ]<sup>t+1</sup><br/>\n= (R choose t+1) * (N/R)<sup>t+1</sup></code>.</p>\n\n<p>On the other hand, the number of ways of choosing <i>any</i> t + 1 integers out of X is equal to <code>N choose t+1</code>. Therefore, the probability p that we are looking for is at most:\n\n<p><code>[ (R choose t+1) / (N choose t+1) ] * (N/R)<sup>t+1</sup><br/>\n= R/N * (R-1)/(N-1) * (R-2)/(N-2) * ... * (R-t)/(N-t) * (N/R)<sup>t+1</sup></code>.</p>\n\n<p>Now, since N &ge; 2R, we know the following is true for all a &le; t:</p>\n\n<p><code>(R-a) / (N-a)<br/>\n&lt; (R - a/2)<sup>2</sup> / [ R * (N-a) ]&nbsp;&nbsp;&nbsp;&nbsp;  (this is because (R - a/2)<sup>2</sup> &ge; R(R-a))<br/>\n&le; (R - a/2)<sup>2</sup> / [ N * (R-a/2) ]<br/>\n= (R - a/2) / N.</code></p>\n\n<p>Therefore, p is less than:</p>\n\n<p><code>R * (R - 1/2) * (R - 2/2) * ... * (R - t/2) / R<sup>t+1</sup></code>.</p>\n\n<p>It is now easy to check that <code>(R-a/2) * (R-t/2+a/2) &le; (R-t/4)<sup>2</sup></code>, from which it follows that p is also less than:\n\n<p><code>(R - t/4)<sup>t+1</sup> / R<sup>t+1</sup><br/>\n= (1 - t/4R)<sup>t+1</sup><br/>\n&lt; (1 - t/4R)<sup>t</sup>.</code></p>\n\n<p>And finally, we use the very useful fact that <code>1 - x &le; e<sup>-x</sup></code> for all x. This gives us <code>p &lt; e<sup>-t<sup>2</sup> / 4R</sup></code> as required.\n</p>\n<br/>\n\n<p>In our case, X represents the sums of all 6-integer subsets. We have N = 500 choose 6 and R = 6 * 10<sup>12</sup>. You can check that N &ge; 2R, so we can apply the lemma to estimate the probability that the algorithm will still be going after t+1 steps:\n\n<ul>\n<li>If t = 10<sup>6</sup>, the still-going probability is at most 0.972604477.\n<li>If t = 5*10<sup>6</sup>, the still-going probability is at most 0.499351789.\n<li>If t = 10<sup>7</sup>, the still-going probability is at most 0.062176524.\n<li>If t = 2*10<sup>7</sup>, the still-going probability is at most 0.000014945.\n<li>If t = 3*10<sup>7</sup>, the still-going probability is at most 0.00000000001.\n</ul>\n\n<p>In other words, we have a good chance of being done after 5,000,000 steps, and we will <i>certainly</i> be done after 30,000,000 steps. Note this is a mathematical fact, regardless of what the original 500 integers were.</p>\n\n<p><b>Comment:</b> What happens if you look at 5-element subsets instead of 6-element subsets? The mathematical proof fails completely because N &lt; R. In practice though, it worked fine on all test data we could come up with.</p>\n\n<p><br/><b>A Deterministic Approach</b></p>\n\n<p>The randomized method discussed above is certainly the simplest way of solving this problem. However, it is not the only way. Here is another way, this time with no randomness:</p>\n\n<ul>\n<li> Take 7,000,000 3-integer subsets of <b>S</b>, sort them by their sum, and let the difference between the two closest sums be d<sub>1</sub>. Let X<sub>1</sub> and Y<sub>1</sub> be the corresponding subsets.\n<li> Remove X<sub>1</sub> and Y<sub>1</sub> from <b>S</b>, and repeat 25 times to get X<sub>i</sub>, Y<sub>i</sub> and d<sub>i</sub> for i from 1 to 25.\n<li> Let Z = {d<sub>1</sub>, d<sub>2</sub>, ..., d<sub>25</sub>}. Calculate all 2<sup>25</sup> subset sums of Z.\n<li> Two of these subset sums are guaranteed to be equal. Find them and trace back through X<sub>i</sub> and Y<sub>i</sub> to find two corresponding subsets of <b>S</b> with equal sum.\n</ul>\n\n<p>\nThere are two things to show here, in order to justify that this algorithm works:\n</p>\n\n<ul>\n<li><i><b>S</b> will always have at least 7,000,000 3-integer subsets.</i> This is because, even after removing X<sub>i</sub> and Y<sub>i</sub>, <b>S</b> will have at least 350 integers, and 350 choose 3 &gt; 7,000,000.\n<li><i>Z will always have two subsets with the same sum.</i> First notice that the subsets in the first step have sum at most 3 * 10<sup>12</sup>, and so two of the sums must differ by at most 3 * 10<sup>12</sup> / 7,000,000 &lt; 500,000. Therefore, each d<sub>i</sub> is at most 500,000. Now, Z has 2<sup>25</sup> subsets, and each has sum at most 25 * 500,000 &lt; 2<sup>25</sup>, and so it follows from the Pigeonhole Principle that two subsets have the same sum.\n</ul>\n\n<p>\nOther similar methods are possible too. This is a pretty open-ended problem!\n</p>","id":"0000000000432b34","statement":"<h3>Problem</h3>\n<p>\nI have a set of positive integers <b>S</b>. Can you find two non-empty, distinct subsets with the same sum? \n</p>\n\n<p>Note: A subset is a set that contains only elements from <b>S</b>, and two subsets are distinct if they do not have exactly the same elements.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, one per line. Each test case begins with <b>N</b>, the number of positive integers in <b>S</b>. It is followed by <b>N</b> distinct positive integers, all on the same line.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, first output one line containing \"Case #x:\", where x is the case number (starting from 1).\n<ul>\n<li> If there are two different subsets of <b>S</b> that have the same sum, then output these subsets, one per line. Each line should contain the numbers in one subset, separated by spaces.\n<li> If it is impossible, then you should output the string \"Impossible\" on a single line.\n</li>\n</ul>\nIf there are multiple ways of choosing two subsets with the same sum, any choice is acceptable.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nNo two numbers in <b>S</b> will be equal.<br/>\n1 &le; <b>T</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n<b>N</b> is <i>exactly</i> equal to 20.<br/>\nEach number in <b>S</b> will be a positive integer less than 10<sup>5</sup>.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n<b>N</b> is <i>exactly</i> equal to 500.<br/>\nEach number in <b>S</b> will be a positive integer less than 10<sup>12</sup>.<br/>\n</p>\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td><span class=\"io-table-header\">Input</span></td>\n</tr>\n<tr><td>\n<code>\n2<br/>\n20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20<br/>\n20 120 266 858 1243 1657 1771 2328 2490 2665 2894 3117 4210 4454 4943 5690 6170 7048 7125 9512 9600<br/>\n</code>\n</td></tr>\n<tr><td><br/><hr/><br/></td></tr>\n<tr><td>\n<span class=\"io-table-header\">Output</span>\n</td></tr>\n<tr><td>\n<code>\nCase #1:<br/>\n1 2<br/>\n3<br/>\nCase #2:<br/>\n3117 4210 4943<br/>\n2328 2894 7048<br/>\n</code>\n</td></tr>\n</table>\n</div>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":37}],"title":"Equal Sums","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Introduction</h3>\n<p>\nLike some earlier problems in Code Jam 2012, this one was inspired by the author watching significant amounts of Dancing With the Stars.  Unlike previous problems, this one needed no modification to be used in Code Jam (although we don't know what they do in case of a tie): this is exactly how their scoring system works.\n</p>\n<h3>Sample Cases</h3>\n<p>\nSometimes it's useful when solving Code Jam problems to start by working to understand the provided sample cases.  Let's start there.\n</p>\n<h4>Case #1</h4>\n<p>\nIn the first case, if the first dancer (err, contestant) gets 1/3 of the audience votes, then his score is 30.  There's only one way for the rest of the votes to be distributed, which is for 2/3 of the votes to go to the second contestant.  That contestant's score would then be 30, which is a tie, and would lead to contestant #1 being safe.  Any lower score would result in that contestant being eliminated.  We can do similar math on the second contestant.\n</p>\n<h4>Case #4</h4>\n<p>\nNow let's think about a case where there are more than two contestants.  In the fourth sample case, there are three contestants, and their judges' scores are 24, 30 and 21.  The sample output claims that the first contestant is safe if she gets 34.666667% of the vote.  Is that really true?\n</p>\n<p>\nThat proportion of the votes would give contestant #1 a total of 50 points.  For her to be eliminated, all other contestants would need more than 50 points.  We can do a little math and find out that for the second contestant to get more than 50 points, he would need more than 26.66666...% of the vote.  For the third contestant to get more than 50 points, she would need more than 38.66666...% of the vote.  Adding those numbers up gives us 100%.\n</p>\n<p>\nThat means the other contestants would need more votes than the 65.333333% that remain in order to all beat the first contestant, so the first contestant can't be eliminated.  If we lowered the first contestant's percentage at all, then the other contestants would all be able to beat her, and she'd end up being eliminated; so 34.666667% is correct.\n</p>\n\n<h3><b>N</b> Binary Searches</h3>\n\n<p>\nConsidering the sample cases has led us very naturally to an algorithm.  When we're trying to find the minimum score that will make a particular contestant safe, first we'll choose that contestant's audience vote percentage, and then we'll allocate the rest of the audience votes to other contestants in the worst possible way.\n<p>\n<p>\nThis lends itself very naturally to <b>binary search</b>.  First we pick a percentage.  Is the contestant safe at that percentage?  If so, the minimum safe percentage is lower.  If not, the minimum safe percentage is higher.  Repeat that <b>N</b> times, and you have the answer for each contestant.\n</p>\n\n<h3>Those numbers add up to 1!</h3>\n\n<p>\nIt's a bit surprising that, when you independently calculate the minimum safe percentage for each contestant, you apparently end up with percentages that add up to 1.  A little thought shows us why.\n</p>\n<p>\nIf each contestant has a minimum \"safe\" percentage, we can say that contestant has a minimum \"safe\" score (50 for contestant #1 in case #4).  Thinking about the last example, we might say the minimum safe score is the value <code>x</code> such that we use up 100% of the audience votes if all contestants have a score equal to <code>x</code>.  The percentages that contestants need to reach that score will naturally add up to 100%.\n</p>\n<p>\nThis is almost true, but there is one exception.  Consider the following case: <code>4 30 0 0 0</code>.  The safe score clearly won't be more than 30, since not all contestants can get to 30, so we have to deal specially with contestants whose score is greater than the safe score.  With that in mind, the safe score is the value <code>x</code> such that we use up 100% of the audience votes if all contestants have either a score equal to <code>x</code>, or 0% of the audience votes and a score greater than <code>x</code>.\n</p>\n<p>\n</p>\n\n<h3>A Different Binary Search</h3>\n\n<p>\nNow we know how to write a single binary search to find the \"safe\" score.  The safe score is the score for which all contestants with a higher number of judge points get 0% of the audience votes; the other contestants get a percentage that gives them that total score; and the total audience vote percentages add up to 100%.\n</p>\n<p>\nSo to find the safe score, we can try a candidate score, and see if the total audience vote percentage adds up to more than 100%.  If so, we need a lower score.  If not, we need a higher score.  As one of our preparers put it, \"Binary search for the number such that it's impossible for all contestants to have that many points, and you're done!\"\n</p>\n\n<h3>A Linear Solution</h3>\n<p>\nAfter this editorial was first published, a number of contestants wrote in to tell us that they didn't use binary search at all.  One way to avoid it is to use a single loop, plus some math, to compute the \"safe\" score we talked about before.  First, create a sorted list of judges' points.  Then, for <code>i</code> from 0 to <b>N</b>-1, repeatedly determine the following number: if we allocated all the audience votes to the first <code>i</code> people to give them the same score, what would that score be?  If it's less than the score for contestant <code>i+1</code>, or <code>i+1=<b>N</b></code>, then that's the \"safe\" score.\n</p>\n\n<h3>Precision</h3>\n\n<p>\nThe output of this problem had to be a floating-point number, and any number would be fine as long as it was within 1e-5 of the correct number, absolute or relative.  What does that mean?\n</p>\n<ul>\n<li><b>Absolute:</b> If the correct answer is <code>y</code> and you output <code>x</code>, you will be judged correct if <code>|y&minus;x|&nbsp;&lt;&nbsp;10<sup>-5</sup></code>.</li>\n<li><b>Relative:</b> If the correct answer is <code>y</code> and you output <code>x</code>, you will be judged correct if <code>|1&minus;min(y/x,x/y)|&nbsp;&lt;&nbsp;10<sup>-5</sup></code>.</li>\n</ul>\n<p>\nWe confused some of our contestants by outputting an inconsistent number of decimal places in our sample output.  The reason we did that was to illustrate that the number of decimal places you output isn't important, as long as the answer was right; unfortunately, although a number of contestants got an impromptu education on this rule, many more were confused.  We'll think about careful ways of presenting problems with floating-point output in the future.\n</p>\n\n<h3>Solving the Small</h3>\n\n<p>\nThere's actually an algorithmic approach for this problem that isn't good enough to solve the Large, but does work for the Small, if you aren't up on your binary search.  Because each answer you come up with only has to be within 1e-5 of the correct answer, and we know the right answer is between 0 and 100, there are only a couple million numbers you have to check for each user's minimum score that avoids elimination.\n</p>\n<p>\nCheck 0, 0.00001, 0.00002, 0.00003, ... 9.99999, 10.  That's 1 million numbers.  Then, because the right answer can be within 1e-5 multiplicatively, and the answers we're checking now are more than 10, you can check 10.0001, 10.0002, ..., 99.9999, 100.  That's another 900,000 numbers.  So by checking 1.9 million numbers, we avoid having to implement binary search; though to be honest, it's probably easier to implement binary search than do that -- and binary search only has to check <code>log<sub>2</sub>(10<sup>5</sup>)=17</code> numbers!\n</p>\n<p>\nAlso, note that this method will only work to replace the first binary search we talked about here, not the second one.  It isn't enough that the safe score is within 1e-5 of the correct value: the numbers we <i>output</i> have to be that close.\n</p>\n\n<h3>Why did people get it wrong?</h3>\n\n<p>\n5608 people downloaded the Small input for this problem, but only 2687 of them got it right.  That's an unusually low success rate.  So what did those people do wrong?\n</p>\n<p>\nSome of them outputted a negative percentage for users with a score above the \"safe score\".  Presumably that would have moved the safe score for them as well.  Users who did that, and were told that they'd gotten the wrong answer, could have checked their output to see that they'd printed a negative number.  In Code Jam you have access to the input and output file you're being tested on; use it!\n</p>\n<p>\nOthers made assumptions that ended up not being true about certain derived values being integers.  One contestant who did that got our sample cases right, but outputted <code>0.0 33.0 33.0 33.0</code> for the case <code>4 10 0 0 0</code>.  Still others had problems with integer division: in many programming languages an integer divided by an integer will always return an integer.  If you want to avoid that, you have to \"cast\" one of the integers to a floating-point number -- or just add 0.0 to it, which amounts to the same thing.\n</p>\n<p>\n<i>Some</i> users might have made a mistake early, then fixed it, but submitted the output for the wrong input file.  Whenever you retry a submission, it's important to run your code on the input you just downloaded, or you'll get the wrong answer!  We're working on ways to make it easier for users to catch this problem.\n</p>","id":"000000000043324f","statement":"<h3>Problem</h3>\n<p>\nThere are <b>N</b> contestants in a reality TV show.  Each contestant is assigned a point value by the judges and receives votes from the audience.  The point value given by the judges and the audience's votes are combined to form a <i>final score</i> for the contestant, in the following way:\n</p>\n<p>\nLet <code>X</code> be the sum of the judge-assigned point values of all contestants.   Now suppose a contestant got <code>J</code> points from the judges, and that she received a fraction <code>Y</code> (between 0 and 1, inclusive) of the audience's votes (<code>Y</code> might be, for example, 0.3).  Then that contestant's final score is <code>J+X*Y</code>.  Note that the sum of all contestants' audience vote fractions must be 1.\n</p>\n<p>\nThe contestant with the lowest score is eliminated.\n</p>\n<p>Given the points contestants got from judges, your job is to find out, for each contestant, the minimum percentage of audience votes he/she must receive in order for him/her to be guaranteed <b>not to be eliminated</b>, no matter how the rest of the audience's votes are distributed.\n</p>\n<p>\nIf the lowest score is shared by multiple contestants, no contestants will be eliminated.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow, one per line.  Each line starts with an integer <b>N</b>, the number of contestants, followed by a space, followed by <b>N</b> integers <b>s</b><sub>0</sub>, <b>s</b><sub>1</sub>, ..., <b>s</b><sub>N-1</sub>, separated by single spaces.  The integer <b>s</b><sub>i</sub> is the point value assigned to contestant <code>i</code> by the judges.  \n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: \" followed by <b>N</b> real numbers: <b>m</b><sub>i</sub>s.  The value x is the case number (starting from 1).  The value <b>m</b><sub>i</sub> is the smallest percentage of audience votes required for contestant <code>i</code> to definitely avoid elimination.\n</p>\n<p>\nAnswers within an absolute or relative error of 10<sup>-5</sup> of the correct answer will be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 30 seconds per test set.<br/>\n0 &le; <b>s</b><sub>i</sub> &le; 100.<br/>\n<b>s</b><sub>i</sub> &gt; 0 for some i.  This means at least one contestant will have a point value greater than 0.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>T</b> &le; 20.<br/>\n2 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>T</b> &le; 50.<br/>\n2 &le; <b>N</b> &le; 200.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2 20 10\n2 10 0\n4 25 25 25 25\n3 24 30 21\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 33.333333 66.666667\nCase #2: 0.000000 100.000000\nCase #3: 25.0 25.0 25.0 25.0\nCase #4: 34.666667 26.666667 38.666667\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":11}],"title":"Safety in Numbers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432f3e","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2012"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
