{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1460777400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201bf2","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n\nThe first of our three Round 1s got off to a quick start: sourspinach submitted\nthe last of six datasets a mere 19 minutes and 31 seconds into the round!\nsourspinach had a 4 minute penalty from an Incorrect Small submission, though,\nand was passed by nika (21:06, no penalties) for first place. The fast pace\ncontinued throughout the round.\n</p><p>\n<i>The Last Word</i> has a simple greedy approach. <i>Rank and File</i> becomes\nquite simple if you have one key observation; of course, having that            \nobservation may not be so simple! <i>BFFs</i> is a more complex graph problem\nthat requires some thought and careful implementation; nonetheless, 1,055       \ncontestants successfully solved\tall datasets correctly!\n<p></p>\nAn impressive 10,047 competitors got at least one dataset right, which explains the huge number of perfect scores. To be in the top 1000, you needed a perfect score and a little bit of speed. However, there are two more chances to qualify for round 2!\n</p><p>\nEmails with the final verdict will go out soon, at least one day before Round 1B.\n</p><p>\nThe top 1000 contestants in this round advance to Round 2. If you weren't in\nthe top 1000, you still have a chance to advance in Round 1B or Round 1C; see   \nthe schedule.\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>The Last Word</i>): Written and prepared by Karol Pokorski.\n</p><p>\nProblem B (<i>Rank and File</i>): Written by Ian Tullis. Prepared by Yiming Li\nand Ian Tullis.\n</p><p>\nProblem C (<i>BFFs</i>): Written by Pablo Heiber. Prepared by Pablo Heiber and\nKarol Pokorski.\n</p><p>\nSolutions and other problem preparation and review by Minh Doan, Jackson\nGatenby, Taman (Muhammed) Islam, Sean Lip, Igor Naverniouk, Nathan Pinsker, and\nYerzhan Utkelbayev.\n</p><p>\nAnalysis authors:\n</p>\n<ul>\n<li>The Last Word: Nathan Pinsker</li>\n<li>Rank and File: Ian Tullis</li>\n<li>BFFs: Pablo Heiber</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1460768400000,"tasks":[{"analysis":"<h2>BFFs: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nThe Small dataset has a pretty low limit of 10 kids. That allows us to try every possible\narrangement and check which ones would make valid circles (circles in which every kid is next to\ntheir BFF).\nFor every possible subset of kids and every possible circular ordering of them,\ncheck that for every kid at least one of their neighbors\nis a BFF, and if that is the case, update a running global maximum if it is greater than the size\nof the circle we just checked.\n</p><p>\nThere are a number of small but powerful optimizations to this approach. Notice that the\npermutations of a subset of kids <i>S</i> always appear as a prefix of the permutations of any\nother subset of kids that includes <i>S</i>. Moreover, the only difference in BFF checking is what\nwe do for the first and last kid. So, we can just check all the permutations of <b>N</b> kids and\nconsider whether each\nprefix forms a valid circle, and that accounts for all permutations of all subsets while reducing\nthe number of total checks substantially. Note that some subsets are checked multiple\ntimes, but that is unimportant, as long as the procedure runs in the allotted time.\n</p><p>\nThere are other possible optimizations, but this is more than enough. The following Python code\nimplements the approach outlined above:\n</p><code><pre>\nimport itertools\n# The F parameter is the list of BFF identifiers, but 0-based (subtracting 1 from the input).\ndef cc(F):\n  n = len(F)\n  r = 0\n  # Iterate over all possible orderings of the n kids.\n  for O in itertools.permutations(xrange(n)):\n    first = O[0]\n    second = O[1]\n    for i in xrange(1, n):  # Iterate over the permutation, skipping the first.\n      # Check if i can be the last one by checking it and the first.\n      prev = O[i - 1]\n      cur = O[i]\n      if ((F[cur] == first or F[cur] == prev) and\n          (F[first] == cur or F[first] == second)):\n        r = max(r, i + 1)\n      # Check if i can be in the middle, and stop if it can't.\n      if F[cur] != prev and (i == n - 1 or F[cur] != O[i + 1]):\n        break\n  return r\n</pre></code>\n<h3>Large dataset</h3>\n<p>\nOf course, a simple brute force approach, even with many additional optimizations, will not be fast\nenough for the Large dataset. Let's examine the input more closely. It is actually a function BFF\nthat maps each kid to another kid. We can represent this function with a\n<a href=\"https://en.wikipedia.org/wiki/Pseudoforest#Graphs_of_functions\">graph</a>\nwhere the nodes are kids and the edges go from each kid to that kid's BFF.\nAs you can see from the linked article, this type of graph has a\nparticular property: each connected component is made up of a directed cycle and branches of nodes\nwith the edges directed towards the cycle. To visualize it better, if we compressed the cycle into\na single node, we would obtain a tree with all the edges pointing towards the root.\nHere's an important fact that will come up a lot: <i>each connected component contains exactly one\ncycle.</i>\n</p><p>\nNow that we have examined the input a bit, let's examine the output, or, better yet, let's examine\nthe form of a valid circle. It must contain at least one kid <i>k</i><sub>1</sub>. It must also\ncontain <i>k</i><sub>1</sub>'s BFF, <i>k</i><sub>2</sub>, who must be sitting next to\n<i>k</i><sub>1</sub>.\nAnd <i>k</i><sub>2</sub>'s BFF <i>k</i><sub>3</sub> (who might or might not be\n<i>k</i><sub>1</sub>), and so on. The BFF of the BFF of the BFF ... of <i>k</i><sub>1</sub> must be\nin the circle. In terms of the graph we mentioned above, we are starting on the node representing\nthe first kid <i>k</i><sub>1</sub>, and moving through the edges. Therefore, we will eventually end\nup cycling through the cycle in <i>k</i><sub>1</sub>'s connected component.\n(That cycle may or may not include <i>k</i><sub>1</sub>.) This a second important property:\n<i>for any connected component containing at least one kid who is in the circle, all of the kids\nin that component's cycle must be in the circle.</i>.\n</p><p>\nConsider a connected component with a cycle of more than 2 kids. If we put that cycle in\nthe circle, there is no room for anyone else, as the cycle already forces the two neighbors of\neach kid. So, one possibility is that the final circle consists entirely of a single cycle from the\ngraph.\n</p><p>\nSince nobody is their own BFF, there are no cycles with just 1 kid.\nIf we consider a connected component with a cycle of exactly 2 kids <i>l</i> and <i>r</i>,\nthe situation is different. We can\nsit <i>l</i> and <i>r</i> together, and we already know they are both happy, and we have room on\n<i>l</i>'s left and <i>r</i>'s right (or vice versa, but it is equivalent)\nto seat more kids. We could choose anybody, even from another\ncomponent. However, we want the maximum number of kids, so we might as well choose an\n<i>l</i><sub>1</sub> whose BFF is <i>l</i> to sit next to <i>l</i> (if there exists such an\n<i>l</i><sub>1</sub>). <i>l</i><sub>1</sub> is already\nhappy, so can choose an <i>l</i><sub>2</sub> whose BFF is <i>l</i><sub>1</sub> and sit it next to\n<i>l</i><sub>1</sub>. And we can continue this process. We can build a chain of kids to\n<i>l</i>'s left following the edges of the graph in reverse, and similarly, we can build a chain of\nkids on <i>r</i>'s right. When we are done, having added zero or more kids to each side,\nwe have a line of kids from the same component that are all happy, so we can continue to add kids\nfrom other components right next to them!\n</p><p>\nTo summarize the previous paragraph, we can build a chain of kids from each component with a cycle\nof length 2 (we already showed that cycles longer than that do not allow chains to be added). Since\nwe want to construct the largest possible chain, we take the longest chain from each component\nwith a cycle of length 2, and put them all together. That is, we sum their lengths as a possible\nfinal result to be compared with the largest cycle from the first case.\n</p><p>\nThe following image illustrates the previous paragraph. On the left, a graph with three\nseparate connected\ncomponents is displayed. Red nodes are nodes in the cycles of each component. From the component\nwith a cycle of length 4, we can build a circle (which we've shown on the right side of the image)\nbut not add anything else. However,\nwe can build a chain from each component with a cycle of length 2. Marked in green and orange are\noptimal choices for a chain on each side, and on the right you can see the circle of kids with the\narrows indicating their BFFs at their side. You can see here how the cycles of length 2 allow us\nto add more kids, even including different connected components of the graph in the same circle,\nwhereas longer cycles don't leave room for anyone\nelse.\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3t_r9dYcYbto_VDTwfJ2BsHWQNahHQ4DB3_A8cKy68gEU5KEhwaGu6d5VBfV03GjYfu3rH_lWs_sbCbyl4d6pT/bffs_analysis_expl.png\"/>\n</p><p>\nIt is easy to find the connected components and their cycles using\n<a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">DFS</a> or a number of other ways that\nwe leave up to the reader to find and choose. There are also a number of ways to find the longest\nchains on each side of each cycle of length 2, that we also leave up to the reader. Notice that\nthe process on each side is really similar to finding the height of a tree.\n</p>\n","id":"0000000000201b6f","statement":"<h3>Problem</h3>\n<p>\nYou are a teacher at the brand new Little Coders kindergarten. You have\n<b>N</b> kids in your class, and each one has a different student ID number\nfrom 1 through <b>N</b>. Every kid in your class has a single best friend\nforever (BFF), and you know who that BFF is for each kid. BFFs are not\nnecessarily reciprocal -- that is, B being A's BFF does not\nimply that A is B's BFF.\n</p>\n<p>\nYour lesson plan for tomorrow includes an activity in which the participants\nmust sit in a circle. You want to make the activity as successful as possible\nby building the largest possible circle of kids such that each kid in the\ncircle is sitting directly next to their BFF, either to the left or to the right.\nAny kids not in the circle will watch the activity without participating.\n</p>\n<p>\nWhat is the greatest number of kids that can be in the circle?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each test case consists of two lines. The first line of a\ntest case contains a single integer <b>N</b>, the total number of kids in the\nclass. The second line of a test case contains <b>N</b> integers\n<b>F<sub>1</sub></b>, <b>F<sub>2</sub></b>, ..., <b>F<sub>N</sub></b>, where\n<b>F<sub>i</sub></b> is the student ID number of the BFF of the kid with student ID i.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the\ntest case number (starting from 1) and y is the maximum number of kids in the\ngroup that can be arranged in a circle such that each kid in the circle is\nsitting next to his or her BFF.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>F<sub>i</sub></b> &le; <b>N</b>, for all i.<br/>\n<b>F<sub>i</sub></b> &ne; i, for all i. (No kid is their own BFF.)<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n3 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n3 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n4\n2 3 4 1\n4\n3 3 4 1\n4\n3 3 4 3\n10\n7 8 10 10 9 2 9 6 3 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 3\nCase #3: 3\nCase #4: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn sample case #4, the largest possible circle seats the following kids in the\nfollowing order: <code>7 9 3 10 4 1</code>. (Any reflection or rotation of this\ncircle would also work.) Note that the kid with student ID 1 is next to the kid with student ID 7,\nas required, because the list represents a circle.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":16},{"type":2,"type__str":"HIDDEN","value":29}],"title":"BFFs","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>The Last Word: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nIn the Small dataset, there will be at most 15 letters in <b>S</b>. At each\nstep of the game, we are given a letter to add to either the front or the back\nof the current word. The number of possible words after adding the <i>i</i>-th\nletter (during step <i>i</i>) is at most twice the number of possible words\nafter step <i>i</i>-1, since we have two choices of where to add the new\nletter. This means that the number of possible last words that can be made from\nall of the letters is at most 2<sup>15</sup>. We can generate each of these\npossible last words and find which one comes last alphabetically.\n</p><p>\nHere is one way of doing this in Python:\n<pre>\ndef alphabetically_last_word(S):\n  possible_words = set([''])\n  for c in S:\n    possible_words = set([c + r for r in possible_words] + [r + c for r in possible_words])\n  return max(possible_words)\n</pre>\n</p>\n<h3>Large dataset</h3>\n<p>\nThe approach in the previous paragraph is too slow for the Large dataset, and\nso some additional observations are required. During step <i>i</i>, we are\nadding a single new letter <b>S</b><sub><i>i</i></sub> to the front or the back\nof our current word X<sub><i>i</i>-1</sub>, yielding a new word\nX<sub><i>i</i></sub> = X<sub><i>i</i>-1</sub><b>S</b><sub><i>i</i></sub> or\nX<sub><i>i</i></sub> = <b>S</b><sub><i>i</i></sub>X<sub><i>i</i>-1</sub>. To\nhave the end result be as alphabetically late as possible, it is always better\nto have X<sub><i>i</i></sub> be as alphabetically late as possible as well. We\ncan show this formally: during every step of the process that produces the\nalphabetically latest answer, after <i>i</i> letters have been chosen, our\nstring X<sub><i>i</i></sub> should be the alphabetically latest substring that\nwe can produce from the first <i>i</i> letters of <b>S</b> under the given\nrules.\n</p><p>\nAssume we are at the <i>i</i>-th step, and we can either add the new letter\n<b>S</b><sub><i>i</i></sub> at the beginning or the end of\nX<sub><i>i</i>-1</sub>. Let Y<sub><i>i</i></sub> be the alphabetically earlier\nof <b>S</b><sub><i>i</i></sub>X<sub><i>i</i>-1</sub> and\nX<sub><i>i</i>-1</sub><b>S</b><sub><i>i</i></sub>, and Z<sub><i>i</i></sub> be\nthe alphabetically later of the two. Suppose that Y<sub><i>i</i></sub> were\nthe optimal choice at this step. Then we could write our last word as\nAY<sub><i>i</i></sub>B for some A and B. We could instead choose\nZ<sub><i>i</i></sub> and insert the letters during future steps in the same way\nto yield AZ<sub><i>i</i></sub>B as the last word. No matter what the values of\nA and B are, it is always true that AZ<sub><i>i</i></sub>B comes no\nalphabetically earlier than AY<sub><i>i</i></sub>B, because\nZ<sub><i>i</i></sub> comes no alphabetically earlier than Y<sub><i>i</i></sub>.\nThis means that any word using Y<sub><i>i</i></sub> can be turned into a word\nthat is at least as late in alphabetical order by substituting\nZ<sub><i>i</i></sub> at this step instead. It follows that choosing\nZ<sub><i>i</i></sub> is always correct.\n</p><p>\nThis means that our X<sub><i>i</i></sub> must be the alphabetically latest of\nX<sub><i>i</i>-1</sub>S<sub><i>i</i></sub> and\nS<sub><i>i</i></sub>X<sub><i>i</i>-1</sub>. Therefore, when we add\n<b>S</b><sub><i>i</i></sub> to X<sub><i>i</i>-1</sub>, we only need to check\nwhether putting <b>S</b><sub><i>i</i></sub> in the front or putting\n<b>S</b><sub><i>i</i></sub> in the back would produce the alphabetically latest\nstring.\n</p><p>\nHere is some simple Python code that implements the optimized procedure:\n<pre>\ndef alphabetically_last_word(S):\n  result = ''\n  for c in S:\n    result = max(c + result, result + c)\n  return result\n</pre>\n</p><p>\nNote that the solutions for the Small and Large datasets are very similar. The\nonly difference is that the solution to the Large recognizes which one of the\npossible words that can be formed at each step will necessarily be part of the\noptimal last word. Instead of keeping an amount of information that may grow\nexponentially with the number of steps in the game, the code for the Large\nkeeps track of a single string at each step, allowing it to run much faster\nand use less memory. The presented solution for the Small dataset requires\nexponential time and memory, whereas the presented solution for the Large\ndataset requires only polynomial time and memory.\n</p><p>\nAnother way to think about this is that the <code>max</code> operation commutes\nwith the set-building step inside the code for the Small, allowing us to keep\nthe maximum at each step rather than computing the maximum at the end. This\nobservation shows a path for extending a solution that solves the Small dataset\ninto the one we explained that can also solve the Large dataset. (Check out\n\"A possible stepping stone...\" in\n<a href=\"https://plus.sandbox.google.com/+LifeatGoogle/posts/FqAEpWfvMDh\">\nthis essay</a>.)\n</p>\n","id":"0000000000201c8d","statement":"<h3>Problem</h3>\n<p>\nOn the game show <i>The Last Word</i>, the host begins a round by showing the\ncontestant a string <b>S</b> of uppercase English letters. The contestant\nhas a whiteboard which is initially blank. The host will then present the\ncontestant with the letters of <b>S</b>, one by one, in the order in which they\nappear in <b>S</b>. When the host presents the first letter, the contestant\nwrites it on the whiteboard; this counts as the first <i>word</i> in the game\n(even though it is only one letter long). After that, each time the host\npresents a letter, the contestant must write it at the beginning or the end of\nthe word on the whiteboard before the host moves on to the next letter (or to\nthe end of the game, if there are no more letters).\n</p><p>\nFor example, for <b>S</b> = <code>CAB</code>, after writing the word\n<code>C</code> on the whiteboard, the contestant could make one of the\nfollowing four sets of choices:\n</p>\n<ul>\n<li>put the <code>A</code> before <code>C</code> to form <code>AC</code>, then\nput the <code>B</code> before <code>AC</code> to form <code>BAC</code></li>\n<li>put the <code>A</code> before <code>C</code> to form <code>AC</code>, then\nput the <code>B</code> after <code>AC</code> to form <code>ACB</code></li>\n<li>put the <code>A</code> after <code>C</code> to form <code>CA</code>, then\nput the <code>B</code> before <code>CA</code> to form <code>BCA</code></li>\n<li>put the <code>A</code> after <code>C</code> to form <code>CA</code>, then\nput the <code>B</code> after <code>CA</code> to form <code>CAB</code></li>\n</ul>\n<p>\nThe word is called the <i>last word</i> when the contestant finishes writing\nall of the letters from <b>S</b>, under the given rules. The contestant wins\nthe game if their last word is the last of an alphabetically sorted list of all\nof the possible last words that could have been produced. For the example\nabove, the winning last word is <code>CAB</code> (which happens to be the\nsame as the original word). For a game with <b>S</b> = <code>JAM</code>, the\nwinning last word is <code>MJA</code>.\n</p><p>\nYou are the next contestant on this show, and the host has just showed you the\nstring <b>S</b>. What's the winning last word that you should produce?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each consists of one line with a string <b>S</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe winning last word, as described in the statement.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n1 &le; length of <b>S</b> &le; 15.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n1 &le; length of <b>S</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">7\nCAB\nJAM\nCODE\nABAAB\nCABCBBABC\nABCABCABC\nZXCASDQWE\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: CAB\nCase #2: MJA\nCase #3: OCDE\nCase #4: BBAAA\nCase #5: CCCABBBAB\nCase #6: CCCBAABAB\nCase #7: ZXCASDQWE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":11}],"title":"The Last Word","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Rank and File: Analysis<h2>\n<h3>Small dataset</h3>\n<p>\nA natural first approach is to reconstruct the grid by brute force: try all\nways of assigning the lines to the rows and columns until the lines all overlap\nperfectly, with no conflicts. But as we get into later rounds of Code Jam, pure\nbrute force becomes less likely to work for every Small dataset! In this case,\nwith <b>N</b> = 10, we can have up to 19 lines that we must turn into a 10 x 10\narray. Trying all 20! = about 2.4 * 10<sup>18</sup> ways of assigning those 19\nlines (plus the one empty line that we need to figure out) to the 20 rows and\ncolumns would just take too long, and Sergeant Argus isn't going to give us\nthat much time.\n</p><p>\nHere's one approach that takes advantage of the unusual properties of the grid.\nLet's continue with our 19-line case. We'll assume (without loss of generality)\nthat the grid has a column missing. In that case, our grid has 10 rows. We can\ntry all 19 choose 10 = 19! / (10! * 9!) = 92378 ways of choosing ten of our\nlines to call the \"rows\". But what order should they go in? Well, we know that\nthe values in the first column, like the values in any other column, must be in\nstrictly increasing order. If any two of the \"rows\" that we've chosen begin\nwith the same number, then we must not have chosen the right set, and we can\nmove on. Otherwise, we know exactly how to order them, so we already have a\ncomplete potential grid! Then we can just check the 10 columns to see if 9 of\nthem match the 9 lines we didn't use in this set. If they do, then the\nremaining line is the answer.\n</p>\n<h3>Large dataset</h3>\n<p>\nWith up to 99 lines, the approach above won't work: 99 choose 50 is roughly\n5 * 10<sup>28</sup>.\n</p><p>\nIt is possible to write a solution that reconstructs such a large grid. But it\nturns out that we don't need to frame the problem that way at all! We haven't\nfully taken advantage of the fact that we're only asked for the missing row or\ncolumn, not for the entire grid.\n</p><p>\nIn a <i>complete</i> set of lists of rows and columns of a grid, every cell\nof the grid appears twice: once in the list for the row it is in, and once in\nthe list for the column it is in. There may be multiple copies of the same\nnumber in the grid, but we can still say that every number appears an even\nnumber of times in total within that complete set of lists.\n</p><p>\nBut what about our input set of lists, which is missing the list for one row or\ncolumn? All of the numbers in that missing list are different, and each of them\nappears one time fewer in the input than it would in the complete set of lists.\nThis means that all of those numbers appear an odd number of times in our\ninput. Moreover, they are the <i>only</i> numbers that appear an odd number of\ntimes in our input!\n</p><p>\nTherefore, we don't need to build a grid at all. All we need to do is look\nthrough all the numbers in all the lists and see which <b>N</b> of them\nappear an odd number of times; those are the numbers in our missing row/column.\nWe can put them in the order they must go in (strictly increasing), and then we\nhave our answer. And we haven't even done a single push-up!\n</p>\n","id":"0000000000201d1a","statement":"<h3>Problem</h3>\n<p>\nWhen Sergeant Argus's army assembles for drilling, they stand in the shape of\nan <b>N</b> by <b>N</b> square grid, with exactly one soldier in each cell.\nEach soldier has a certain height.\n</p><p>\nArgus believes that it is important to keep an eye on all of his soldiers at\nall times. Since he likes to look at the grid from the upper left, he requires\nthat:\n</p>\n<ul>\n<li>Within every row of the grid, the soldiers' heights must be in strictly\nincreasing order, from left to right.\n<li>Within every column of the grid, the soldiers' heights must be in strictly\nincreasing order, from top to bottom.\n</ul>\n<p>\nAlthough no two soldiers in the same row or column may have the same height,\nit is possible for multiple soldiers in the grid to have the same height.\n</p>\n<p>\nSince soldiers sometimes train separately with their row or their column, Argus\nhas asked you to make a report consisting of 2*<b>N</b> lists of the soldiers'\nheights: one representing each row (in left-to-right order) and column (in\ntop-to-bottom order). As you surveyed the soldiers, you only had small pieces\nof paper to write on, so you wrote each list on a separate piece of paper.\nHowever, on your way back to your office, you were startled by a loud bugle\nblast and you dropped all of the pieces of paper, and the wind blew one away\nbefore you could recover it! The other pieces of paper are now in no particular\norder, and you can't even remember which lists represent rows and which\nrepresent columns, since you didn't write that down.\n</p>\n<p>\nYou know that Argus will make you do hundreds of push-ups if you give him an\nincomplete report. Can you figure out what the missing list is?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each consists of one line with an integer <b>N</b>, followed\nby 2*<b>N</b>-1 lines of <b>N</b> integers each, representing the lists you\nhave, as described in the statement. It is guaranteed that these lists\nrepresent all but one of the rows and columns from a valid grid, as described\nin the statement.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and y is a list of\n<b>N</b> integers in strictly increasing order, representing the missing list.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n1 &le; all heights &le; 2500.<br/>\nThe integers on each line will be in strictly increasing order.<br/>\nIt is guaranteed that a unique valid answer exists.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n3\n1 2 3\n2 3 5\n3 5 6\n2 3 4\n1 2 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3 4 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the sample case, the arrangement must be either this:\n</p>\n<code>\n1 2 3<br>\n2 3 4<br>\n3 5 6<br>\n</code>\n<p>\nor this:\n</p>\n<code>\n1 2 3<br>\n2 3 5<br>\n3 4 6<br>\n</code>\n<p>\nIn either case, the missing list is <code>3 4 6</code>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Rank and File","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201bf2","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2016"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
