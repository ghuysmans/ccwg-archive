{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1273359600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432b7e","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nCode Jam 2010 is off to a huge start! Despite the tougher-than-usual problems and a few technical glitches, more contestants than ever advanced to Round 1 this year (about 8523).  We also set records in participants who downloaded at least one input (12092), participating countries (125), and programming languages (53).\n</p>\n<p>\nThe problems were a mix of simulation, number theory and big integer arithmetic. Big integers made their first appearance in a Code Jam round as part of a problem with the foreboding name of \"Fair Warning\".\n</p>\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Snapper Chain</i> Written and prepared by Igor Naverniouk.</p>\n<p>Problem B. <i>Fair Warning</i> Written by Bartholomew Furrow. Prepared by Xiaomin Chen and Bartholomew Furrow.</p>\n<p>Problem C. <i>Theme Park</i> Written by Bartholomew Furrow and Igor Naverniouk. Prepared by Ante Derek and Bartholomew Furrow.</p>\n<p>Contest analysis presented by Bartholomew Furrow, Igor Naverniouk, and Cosmin Negruseri.</p>\n<p>Solutions and other problem preparation provided by David Arthur, John Dethridge, Petr Mitrichev, and Cosmin Negruseri.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1273273200000,"tasks":[{"analysis":"<p>\nThe difficult part was understanding how a single Snapper works. Each Snapper can be in one of two states -- On or Off. Also, each snapper can either be powered or unpowered. The first Snapper is always powered because it is plugged into the power socket in the wall. The i'th Snapper is powered if and only if the (i-1)'th Snapper is powered and On. Snapping your fingers changes the state of each powered snapper (from On to Off, or from Off to On).\n</p>\n<p>\nWith these rules in mind, let's represent the On/Off state of the Snappers by a sequence of bits, 1 meaning On. If we list the bits right-to-left, we get a binary integer. Initially, the integer has value 0. Similarly, we can write down the binary integer for the powered/unpowered state of each Snapper. Initially, this integer is 1 because only the rightmost Snapper is powered.\n</p>\n<p>\nSnapping your fingers is equivalent to doing an XOR of the On/Off integer and the powered/unpowered integer and putting the result into the On/Off integer. After that, we update the powered/unpowered bits according to the rule above,\n</p>\n<p>\nFor example, let's say that the On/Off number is now 10100011111. This means that the powered/unpowered number is 00000111111. When we XOR these two numbers, we get the new value of the On/Off number: 10100100000.\n</p>\n<p>\nThe interesting thing is that these two updates are equivalent to a simple increment of the On/Off integer! Snapping your fingers adds 1 to the On/Off integer, and we do not even need to care about the powered/unpowered integer.\n</p>\n<p>\nThe solution to the problem is then very simple. The answer is \"ON\" if and only if the rightmost <b>N</b> bits of <b>K</b> are 1.\n</p>","id":"0000000000432912","statement":"<h3>Problem</h3>\n<p>\nThe <i>Snapper</i> is a clever little device that, on one side, plugs its input plug into an output socket, and, on the other side, exposes an output socket for plugging in a light or other device.\n</p>\n\n<p>\nWhen a <i>Snapper</i> is in the ON state and is receiving power from its input plug, then the device connected to its output socket is receiving power as well. When you snap your fingers -- making a clicking sound -- any <i>Snapper</i> receiving power at the time of the snap toggles between the ON and OFF states.\n</p>\n\n<p>\nIn hopes of destroying the universe by means of a singularity, I have purchased <b>N</b> <i>Snapper</i> devices and chained them together by plugging the first one into a power socket, the second one into the first one, and so on. The light is plugged into the <b>N</b>th <i>Snapper</i>.\n</p>\n\n<p>Initially, all the <i>Snapper</i>s are in the OFF state, so only the first one is receiving power from the socket, and the light is off. I snap my fingers once, which toggles the first <i>Snapper</i> into the ON state and gives power to the second one. I snap my fingers again, which toggles both <i>Snapper</i>s and then promptly cuts power off from the second one, leaving it in the ON state, but with no power. I snap my fingers the third time, which toggles the first <i>Snapper</i> again and gives power to the second one.  Now both <i>Snapper</i>s are in the ON state, and if my light is plugged into the second <i>Snapper</i> it will be <i>on</i>.\n</p>\n\n<p>\nI keep doing this for hours. Will the light be <i>on</i> or <i>off</i> after I have snapped my fingers <b>K</b> times?  The light is <i>on</i> if and only if it's receiving power from the <i>Snapper</i> it's plugged into.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each one contains two integers, <b>N</b> and <b>K</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is either \"ON\" or \"OFF\", indicating the state of the light bulb.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 10,000.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 10;<br>\n0 &le; <b>K</b> &le; 100;\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 30;<br>\n0 &le; <b>K</b> &le; 10<sup>8</sup>;\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 0\n1 1\n4 0\n4 47\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: OFF\nCase #2: ON\nCase #3: OFF\nCase #4: ON\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Snapper Chain","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nAt first glance, this problem appears to be a straightforward simulation: keep adding groups until you run out space on the roller coaster (or run out of groups), then re-form the queue and start again.  Repeat this <b>R</b> times and you're done.\n</p>\n<p>\nFor the Small, that was enough; and we got more than a few questions during the contest from contestants thinking that they were unable to solve the Large because their computers were so slow.  The fact is that, with limits so large -- up to 10<sup>3</sup> groups queuing for 10<sup>9</sup> rides -- you need to come up with a smarter algorithm to solve the problem, since that one is O(NR).\n</p>\n\n<h3>Optimization One</h3>\n<p>\nWhen you're sending the roller coaster out for 10<sup>9</sup> rides, you've got to expect that a few of them are going to be the same.  If you store the queue of groups as an unchanging array, with a pointer to the front, then every time you send out a ride s, you could make a note of where it ended, given where it started.  Then the next time you see a ride starting with the same group in the queue, you can do a quick lookup rather than iterating through all the groups.\n</p>\n<p>\nThat speeds up the algorithm by a factor of 10<sup>3</sup> in the worst case, leaving us with O(R) operations.  There are some other ways of speeding up the calculation for any given roller coaster run: for example, you could make an array that makes it O(1) to calculate how many people are in the range [group_a, group_b] and then binary search to figure out how many groups get to go in O(log(N)) time.  That gives a total of O(R log N) operations.\n<p>\n\n<h3>Optimization Two</h3>\n<p>\nAs we observed in Optimization One, you're going to see a lot of repetition between rides.  You're also going to see a lot of repetition between groups of rides.  In the example in the problem statement, the queue was made up of groups of size [1, 4, 2, 1].  6 people get to go at once.  Let's look at how the queue changes between rides:\n<pre>\n1, 4, 2, 1  [5]\n2, 1, 1, 4  [4]\n4, 2, 1, 1  [6]\n1, 1, 4, 2  [6]\n2, 1, 1, 4  [4]\n4, 2, 1, 1  [6]\n1, 1, 4, 2  [6]\n</pre>\nAs you may have noticed, there's a <i>cycle</i> of length three: starting from the second run, every third queue looks the same.  We make 16 Euros when that happens, which means we'll be making 16 Euros every 3 runs until the roller coaster stops rolling.\n</p>\n<p>\nSo if the roller coaster is set to go 10<sup>9</sup> times: the first time it makes 5 Euros; then there are 999999999 runs left; and every three of those makes 16 Euros.  3 divides 999999999 evenly -- if it didn't, we'd have to do some extra work at the end -- so we make 5 + (999999999 / 3 * 16) = 5333333333 Euros in total.\n</p>\n<p>\nIt turns out that a cycle <i>must</i> show up within the first N+1 rides, because there are only <b>N</b> different states the queue can be in (after <b>N</b>, you have to start repeating).  So you only have to simulate <b>N</b> rides, each of which takes O(N) time in the worst case, before finding the cycle: that's an O(N<sup>2</sup>) solution.\n</p>\n\n<h3>Optimization Three</h3>\n<p>\nEither of the optimizations above should be enough.  But if you're a real speed demon, you can squeeze out a little more efficiency by combining the binary search that we mentioned briefly in Optimization One with the cycle detection from Optimization Two, bringing our running time down to O(N log N).  An alternate optimization can bring us down to O(N); we'll leave that as an exercise for the reader.  Visit our <a href=\"http://groups.google.com/group/google-code/subscribe\" target=\"_blank\">Google Group</a> to discuss it with the other contestants!\n</p>","id":"0000000000432f38","statement":"<h3>Problem</h3>\n<p>\nRoller coasters are so much fun!  It seems like everybody who visits the theme park wants to ride the roller coaster.  Some people go alone; other people go in groups, and don't want to board the roller coaster unless they can all go together.  And <i>everyone</i> who rides the roller coaster wants to ride again.  A ride costs 1 Euro per person; your job is to figure out how much money the roller coaster will make today.\n</p>\n<p>\nThe roller coaster can hold <b>k</b> people at once.  People queue for it in groups.  Groups board the roller coaster, one at a time, until there are no more groups left or there is no room for the next group; then the roller coaster goes, whether it's full or not.  Once the ride is over, all of its passengers re-queue in the same order.  The roller coaster will run <b>R</b> times in a day.\n</p>\n<p>\nFor example, suppose <b>R</b>=4, <b>k</b>=6, and there are four groups of people with sizes: 1, 4, 2, 1. The first time the roller coaster goes, the first two groups [1, 4] will ride, leaving an empty seat (the group of 2 won't fit, and the group of 1 can't go ahead of them).  Then they'll go to the back of the queue, which now looks like 2, 1, 1, 4.  The second time, the coaster will hold 4 people: [2, 1, 1].  Now the queue looks like 4, 2, 1, 1.  The third time, it will hold 6 people: [4, 2].  Now the queue looks like [1, 1, 4, 2].  Finally, it will hold 6 people: [1, 1, 4].  The roller coaster has made a total of 21 Euros!\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow, with each test case consisting of two lines.  The first line contains three space-separated integers: <b>R</b>, <b>k</b> and <b>N</b>.  The second line contains <b>N</b> space-separated integers <b>g<sub>i</sub></b>, each of which is the size of a group that wants to ride.  <b>g<sub>0</sub></b> is the size of the first group, <b>g<sub>1</sub></b> is the size of the second group, etc.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of Euros made by the roller coaster.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n<b>g<sub>i</sub></b> &le; <b>k</b>.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>R</b> &le; 1000.<br/>\n1 &le; <b>k</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\n1 &le; <b>g<sub>i</sub></b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>R</b> &le; 10<sup>8</sup>.<br/>\n1 &le; <b>k</b> &le; 10<sup>9</sup>.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>g<sub>i</sub></b> &le; 10<sup>7</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 6 4\n1 4 2 1\n100 10 1\n1\n5 5 10\n2 4 2 3 4 2 1 2 1 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 21\nCase #2: 100\nCase #3: 20\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Theme Park","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis turned out to be the hardest problem in the qualification round. One of the reasons may have been that the solution involves big arithmetic precision. Using big numbers in timed programming contests is sometimes not considered fair because some languages like python or java have internal libraries that deal with this while for other languages you may have needed to write your own or search for a external one like the GNU Multi-Precision Library. Considering that the qualification round was 24 hours long we took this chance to give you a warning and one which is fair ... that big numbers are fair game for now on, so have a library on hand!\n</p>\n<p>\nThis problem talks about divisors and multiples so it hints at using the greatest common divisor concept in some way. To solve the problem we need to find <i>T</i> and afterwards we can easily find <i>y</i>.</p>\n<p>Let's simplify the problem and just look at  two numbers <i>a</i> and <i>b</i>. In this case we need to find the largest <i>T</i> so that some positive <i>y</i> exists where <i>a + y</i> and <i>b + y</i> are multiples of <i>T</i>. So <i>(a + y) modulo T = (b + y) modulo T</i> which means that <i>(a - b) modulo T = 0</i>. Thus <i>T</i> must be a divisor of <i>|a - b|</i>.</p>\n<p>Coming back to the problem with <i>N</i> numbers, we have proved that <i>T</i> must divide every <i>|t<sub>i</sub> - t<sub>j</sub>|</i>. This means that the solution is the greatest common divisor of all <i>|t<sub>i</sub> - t<sub>j</sub>|</i> numbers.\nA simple observation can improve our algorithm from <i>O(N<sup>2</sup>)</i> to <i>O(N)</i> iterations of the Euclidean algorithm. Let's say <i>a &le; b &le; c</i>, then <i>gcd(b - a, c - a) = gcd(b - a, c - a, c - b)</i>. To prove this we look at the first iteration of the Euclidean algorithm. Since <i>a &le; b &le; c</i> it means that <i>b - a &le; c - a</i> so in the first step we subtract <i>b - a</i> from <i>c - a</i>:  <i>gcd(b - a, c - a) = gcd(c -  b, b - a)</i>, this proves our observation. Now we can just compute the greatest common divisor of all <i>|t<sub>i</sub> - t<sub>1</sub>|</i> to find <i>T</i>.\n</p>\n<p>\nHere's some python code from Xiaomin Chen that solves one test case:\n</p>\n<pre>\ndef Gcd(a, b):\n  if b == 0:\n    return a\n  return Gcd(b, a % b)\n\ndef Solve(L):\n  y = L[0]\n  L1 = [abs(x - y) for x in L]\n  g = reduce(Gcd, L1)\n  if y % g == 0:\n    return 0\n  else:\n    return g - (y % g)\n</pre>\n\n<p>Useful concepts: <a href=\"http://www.google.com/search?q=Greatest+common+divisor\" target=\"_blank\">Greatest common divisor</i></a>, <a href=\"http://www.google.com/search?q=Euclidean+algorithm\" target=\"_blank\">Euclidean algorithm</a>, <a href=\"http://www.google.com/search?q=Arbitrary+precision+arithmetic\" target=\"_blank\">Arbitrary precision arithmetic</a>.","id":"00000000004330fd","statement":"<h3>Problem</h3>\n<p>\n<i>On our planet, Jamcode IX, three Great Events occurred.  They happened 26000, 11000 and 6000 slarboseconds ago.  In 4000 slarboseconds, the amount of time since all of those events will be multiples of 5000 slarboseconds, the largest possible amount... and the apocalypse will come.</i>\n</p>\n<p>\nLuckily for you, you live on Jamcode X!  The apocalypse came on Jamcode IX less than a year ago.  But Jamcode X has a worrying prophecy: \"After the moment of reckoning, on the first <i>optimum anniversary</i> of the <b>N</b> Great Events, the apocalypse will come.  64 bits will not save you.  You have been warned.\"\n</p>\n<p>\nThe people of Jamcode X are very concerned by this prophecy.  All of the Great Events have already happened, and their times have been measured to the nearest slarbosecond; but nobody knows when their <i>optimum anniversary</i> will occur.  After studying the diary of a scientist from Jamcode IX, scientists working on the problem have come up with a theory:\n</p>\n<p>\nThe <i>moment of reckoning</i> is now, the moment you solve this problem.  At some time <b>y &ge; 0</b> slarboseconds from now, the number of slarboseconds since each of the Great Events will be divisible by some maximum number <b>T</b>.  If you can find the smallest value of <b>y</b> that gives this largest possible <b>T</b>, that will give you the <i>optimum anniversary</i> when the apocalypse will come.\n</p>\n<p>\nOn Jamcode IX, for example, there were 3 Great Events and they happened 26000, 11000 and 6000 slarboseconds before the moment of reckoning.  4000 slarboseconds later, the amount of time since each event was a multiple of T=5000 slarboseconds, and the apocalypse came.\n</p>\n<p>\nYour job is to compute the amount of time until the apocalypse comes.  But remember the prophecy: even though the people of Jamcode X have been solving problems for two years, and 64-bit integers have always been enough, they might not always be enough now or in the future.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>C</b>.  <b>C</b> lines follow.  Each starts with a single integer <b>N</b>, which is followed by a space and then <b>N</b> space-separated integers <b>t<sub>i</sub></b>, the number of slarboseconds since Great Event <b>i</b> occurred.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and <b>y</b> is the minimum number of slarboseconds until <b>t<sub>i</sub></b> + <b>y</b> is a multiple of the largest possible integer factor <b>T</b> for all <b>i</b>.\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>C</b> &le; 100.<br/>\n<b>t<sub>i</sub></b> &ne; <b>t<sub>j</sub></b> for some <b>i</b>, <b>j</b>.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 3.<br/>\n1 &le; <b>t<sub>i</sub></b> &le; 10<sup>8</sup>.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>t<sub>i</sub></b> &le; 10<sup>50</sup>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3 26000000 11000000 6000000\n3 1 10 11\n2 800000000000000000001 900000000000000000001\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: 4000000\nCase #2: 0\nCase #3: 99999999999999999999\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n\n<h3>Epilogue</h3>\n<p>\nFortunately for the peoples of the Jamcode system, \"the apocalypse\" turned out to be a mistranslation of \"the giant party.\"  Nobody from Jamcode IX bothered to pass this along, because they were having so much fun.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Fair Warning","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432b7e","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2010"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
