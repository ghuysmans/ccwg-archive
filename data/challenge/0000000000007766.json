{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1533933000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000007766","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  When a Code Jam final round has five problems instead of six, watch out!\n  However, the first two problems were somewhat safe places to start.\n  <i>Jurisdiction Restrictions</i> was not exactly a warm-up, but it could be\n  solved by piecing together some classic algorithmic techniques in the right\n  way. <i>Two-Tiling</i> looked like it had many edge cases, and approaching it\n  via casework would have eaten up far too much time, but it was solvable\n  with some relatively straightforward backtracking code plus a couple of key\n  optimizations.\n</p><p>\n  The other three problems required even more creativity and coding accuracy.\n  <i>Go, Gophers!</i>, our final interactive problem of 2018, was structured\n  in a way that shut down obvious approaches, and contestants had to find\n  another way in. <i>The Cartesian Job</i> had an outer layer of planar\n  geometry that masked a simple but hard-to-find solution. Finally, in\n  <i>Swordmaster</i>, understanding the fairly complex scenario was only the\n  first step along the way to becoming a virtuoso of dueling (and, perhaps, the\n  Code Jam champion!)\n</p><p>\n  The scoring breakdown was unusual by Code Jam standards; there were two\n  \"easier\" problems worth the same amount, and three harder ones worth the same\n  larger amount. This gave the contestants some flexibility to pick their\n  preferred problem(s) at a particular point level, but it also did not offer\n  many clues about what was hardest! Of course, the three hardest problems\n  tested very different skillsets, so it would be difficult to pick an\n  objective \"most difficult\"...\n</p><p>\n  During the round, Jurisdiction Restrictions and Go, Gopher got a lot of\n  attention from contestants; so did the Cartesian Job, which proved to be\n  dangerous! By design, it was very difficult to squeeze a floating-point\n  solution through. A couple hours in, it became clear that nobody was going\n  to solve all five problems, or even four; contestants vied for three, and\n  we saw the usual handful of heroic last-minute submissions. By the end of\n  the contest, the optimistic scoreboard showed three contestants\n  (<b>rng..58</b>, <b>SnapDragon</b>, and <b>LHiC</b>) tied at the\n  optimistic score of 124, with two more (<b>Gennady.Korotkevich</b> and\n  <b>PavelKunyavskiy</b>) following at 104.\n</p><p>\n  As usual, it isn't over until it's over, and the final reveal changed\n  everything! <b>rng..58</b> moved into third with 86 (beating out\n  <b>LHiC</b>, who had a higher penalty); <b>Errichto.rekt</b> jumped to\n  second place thanks to a truly last-minute Cartesian Job submission. But\n  in first, with all 104 of his points surviving judgment, it was our\n  now-<u>five</u>-time Code Jam World Champion, <b>Gennady.Korotkevich</b>!\n  Every problem was solved by at least one contestant; <b>overtroll</b> was\n  the only contestant to solve Swordmaster. Congratulations to all of our\n  contestants for making it through another very tough problem set! You can\n  check out individual contestants' screencasts\n  <a href=\"https://www.youtube.com/playlist?list=PLllx_3tLoo4dKCswFCctSgMj9y3GQyAlq\" target=\"_blank\">here</a>.\n</p><p>\n  2018 was an exciting year for Code Jam! Whether you solved a single\n  Qualification Round problem, sweated it out in the Finals, or just followed\n  along with the contest, we're glad you joined us and we sincerely hope you'll\n  do so again next year.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Jurisdiction Restrictions: Written by Pablo Heiber. Prepared by Jonathan\n    Irvin Gunawan.\n</p><p>\n  Two-Tiling: Written by Petr Mitrichev. Prepared by Petr Mitrichev and Ian\n    Tullis.\n</p><p>\n  Go, Gophers!: Written by Pablo Heiber. Prepared by Pablo Heiber and Ian\n    Tullis.\n</p><p>\n  The Cartesian Job: Written by David Arthur. Prepared by Pi-Hsun Shih and\n  Kevin Tran.\n</p><p>\n  Swordmaster: Written by Onufry Wojtaszczyk. Prepared by John Dethridge.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Shane Carr,\n  Jackson Gatenby, Jonathan Irvin Gunawan, Md Mahbubul Hasan, Igor Naverniouk,\n  Trung Thanh Nguyen, and Micah Stairs.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Jurisdiction Restrictions: Pablo Heiber</li>\n  <li>Two-Tiling: Ian Tullis</li>\n  <li>Go, Gophers!: Pablo Heiber</li>\n  <li>The Cartesian Job: Pablo Heiber</li>\n  <li>Swordmaster: Jonathan Irvin Gunawan and Onufry Wojtaszczyk</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1533918600000,"tasks":[{"analysis":"<p>\n  The only way we can fail to become the Swordmaster is to get stuck in a situation where for all\n  remaining duelists (duelists that we have not beaten yet) we will not defeat them without learning\n  additional skills. At any point in time, the remaining duelists can be divided into four groups:\n  <ol>\n    <li> D1: Duelists we certainly can defeat. </li>\n    <li> D2: Duelists that have an attack we cannot defend against and a defense for every one of\n         our attacks. </li>\n    <li> D3: Duelists that do not have a defense for one of our attacks, but have an attack we\n         cannot defend against. </li>\n    <li> D4: Duelists that do not have an attack we cannot defend against, but have a defense for\n         every one of our attacks. </li>\n  </ol>\n</p><p>\n  If there is any remaining duelist in D1, we should just defeat them. If there is someone in D3 and\n  there is someone in D4, then we can make some progress (i.e. reducing the number of remaining\n  duelists, or moving a remaining duelist to D1) by doing the following:\n  <ol>\n    <li> We choose any duelist in D3 (call them A) and any duelist in D4 (call them B). </li>\n    <li> We ask A for a duel. Since A is in D3, A has an attack that we don't defend against. Either\n         A will use an attack that we don't defend against (thus we will learn the attack), or we\n         can defend and win the duel (thus learning all of A's attacks). At the end of the duel, we\n         will learn an attack which we can't defend against. Let us call this attack is <i>a</i>.\n         </li>\n    <li> If B cannot defend against <i>a</i>, then B has moved to D1 and we have made some progress.\n         Otherwise, we ask B for a duel and use attack <i>a</i>. If B cannot defend, then we will\n         win the duel and make some progress. Otherwise, we will learn defense <i>a</i>. </li>\n    <li> Now that we have learned defense <i>a</i>, A might have moved to D1, or might still be in\n         D3 (by having another attack that we can't defend against). If A moved to D1, then we have\n         made progress. Otherwise, we repeat from step 2 until we make some progress. We cannot\n         loop indefinitely because we are learning additional moves each time through the loop, and\n         there are only a finite number of them.</li>\n  </ol>\n</p><p>\n  Therefore, the only possibilities in which we might fail to become the Swordmaster are when either\n  every remaining duelist is in D2 or D3, or every remaining duelist is in D2 or D4.\n</p><p>\n  If every remaining duelist is in D2 or D3, then every remaining duelist has an attack we can't\n  defend against. From this point, every remaining duelist can just attack us with an attack we\n  can't defend\n  against and choose to not defend against, which means that we will not learn any new defenses.\n  Therefore, we can't defeat any more duelists and are certain to fail to become the Swordmaster.\n  Notice that we can actually detect this situation up front &mdash; if there exists a group of\n  duelists G<sub>1</sub> (not containing us), such that every duelist in G<sub>1</sub> has at least\n  one attack against which nobody outside G<sub>1</sub> can defend, then we are doomed. The strategy\n  for the duelists is that everybody in G<sub>1</sub> can just successfully attack us and choose to\n  not defend (thus we are not learning any new defense known by duelists in G<sub>1</sub>).\n</p><p>\n  We can check the existence of a G<sub>1</sub> by starting with G<sub>1</sub>', the set of all\n  duelists except us. We can iteratively remove from G<sub>1</sub>' any duelist we can defend\n  against regardless of their attack, and get all their defenses. If this process ends with a\n  non-empty G<sub>1</sub>', then this set is a valid G<sub>1</sub>; otherwise, no G<sub>1</sub> can\n  exist. This can be done in\n  O(<b>N</b> &times; <b>P</b>) time. This complexity is also bounded by the sum of the number of\n  attacks and defenses known to all duelists, which is linear in the size of the input.\n</p>\n<h3>Test set 1</h3>\n<p>\n  For test set 1, the situation when every remaining duelist is in D2 or D4 is similar. This means\n  every remaining duelist can defend against all of our attacks. Therefore, there exists a group of\n  duelists G<sub>2</sub> (not containing us), such that every duelist in G<sub>2</sub> has a defense\n  for every attack available outside G<sub>2</sub>. Therefore, we are also doomed, since everybody\n  in G<sub>2</sub> can just defend against our attack and always use attack 1 (thus we are not\n  learning any new attack known by duelists in G<sub>2</sub>). We can check the existence of such\n  G<sub>2</sub> up front with an algorithm analogous to the one presented above to check for\n  G<sub>1</sub>.\n</p>\n<h3>Test set 2</h3>\n<p>\n  For test set 2, the situation when every remaining duelist is in D2 or D4 is complex. In test set\n  1, our opponents could choose to attack us with attack 1 and be sure they would not teach us\n  anything new. However, in test set 2, the attack an opponent uses potentially\n  causes some duelist to move from D4 to D1, or from D2 to D3. Therefore, the fact that every\n  remaining duelist is in D2 or D4 is not a sufficient condition for us to fail to become the\n  Swordmaster.\n</p><p>\n  Now imagine we are in a situation where we are actually doomed &mdash; we are in a position where,\n  finally, every remaining duelist is in D2 or D4 and we will never defeat any duelist, nor will we\n  learn a new attack or defense. Such a situation has to be reached at some point since there is\n  only a finite number of steps of learning (attack or defense) to be made. In this situation, we\n  could fight a duel with every remaining duelist and learn the attacks they use. By definition, we\n  already knew all these attacks, and so, also by definition, all our opponents can defend against\n  all these attacks. So, for us to be doomed through this path, there must exist a group\n  G<sub>2</sub> of duelists and an assignment of an attack for each of them\n  <i>a</i> : G<sub>2</sub> -> Attacks, such that every duelist d in G<sub>2</sub> knows attack\n  <i>a</i>(d) and knows how to defend against every attack known by someone outside G<sub>2</sub>\n  and every attack <i>a</i>(d') for d' in G<sub>2</sub>.\n</p><p>\n  This condition is harder to check. Let us assume there exists such G<sub>2</sub>. Consider any two\n  duelists X and Y. If X has an attack that Y cannot defend against, then Y being in G<sub>2</sub>\n  implies X must be in G<sub>2</sub> as well. This defines a directed graph on the duelists, with\n  the edge going from Y to X.\n</p><p>\n  We find the <a href=\"https://en.wikipedia.org/wiki/Strongly_connected_component\">\n  strongly connected component</a>s (SCCs) of this graph. If any duelist of a SCC is in\n  G<sub>2</sub>, then the whole SCC is in G<sub>2</sub>. Therefore, G<sub>2</sub> will be an upper\n  subset (a subset with no edges going out of the subset) of the\n  <a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\">directed acyclic graph</a> (DAG)\n  of the strongly connected components of the graph. Notice that if we can choose some upper subset\n  of duelists to be a valid set G<sub>2</sub>, then any subset of G<sub>2</sub> which is also an\n  upper subset will also be a valid G<sub>2</sub> with the same attack selections. Therefore, it is\n  enough to check only leaf SCCs in the DAG. If any valid G<sub>2</sub> exists, then a G<sub>2</sub>\n  which is a leaf in the DAG also exists.\n</p><p>\n  Therefore, for each leaf SCC in the DAG, we can check whether each duelist in the SCC can choose\n  an attack that every duelist in the SCC can defend against. To do this, we can first find the set\n  <i>D</i> which is an intersection of the defenses known by every duelist in the SCC, and see\n  whether every duelist in the SCC has an attack in <i>D</i>. We also check that every attack we\n  already know is in <i>D</i>.\n</p><p>\n  To construct the graph in O(<b>N</b> &times; <b>P</b>) time, we can introduce nodes for attacks as\n  well. We add an edge from a duelist to an attack if the duelist cannot defend against the attack,\n  and an edge from an attack to a duelist if the duelist knows that attack. The overall solution\n  runs in O(<b>N</b> &times; <b>P</b>) time.\n</p><p>\n  <b>overtroll</b> was the only contestant to solve this problem during the contest.\n</p>\n","id":"000000000004d961","statement":"<h3>Problem</h3>\n<p>\n  You are a duelist aspiring to become the next Swordmaster. You will work\n  toward this title by dueling with opponents until you win\n  against every opponent. Every opponent is always available for dueling, and\n  opponents do not duel each other.\n</p><p>\n  Each duelist (including you) knows at least one attack, and at least one\n  defense. There are at most <b>P</b> pairs of attacks and defenses in the\n  world; the i-th defense only counters the i-th attack, and the i-th attack is\n  only countered by the i-th defense. It is possible that there are attacks\n  and/or defenses that no duelist knows. You can use any attack or defense that\n  you know as many times as you like; they do not get \"used up\".\n</p><p>\n  Here are the rules for each individual duel with an opponent:\n</p>\n<ul>\n  <li>As the aspiring Swordmaster, you always get to attack first. You select an\n    attack that you know. If the opponent knows the corresponding defense, they\n    may choose to use it. If they do not know that defense, or they choose not\n    to use it, then they do not defend.</li>\n  <li>Then, the opponent selects an attack that they know. If you know the\n    corresponding defense, you may choose to use it. If you do not know that\n    defense, or you choose not to use it, then you do not defend.</li>\n  <li>If you successfully defended and the opponent did not, you win the\n    duel! Otherwise, you do not win, but your quest to become the Swordmaster\n    can continue.</li>\n</ul>\n<p>\n  You can fight as many duels as you want, including multiple duels with the\n  same opponent, regardless of the outcomes of any previous duels. You do not\n  need to determine a complete schedule of duels in advance; you can base your\n  next decision on what has already happened. Once you have won at least once\n  against every opponent, you become the Swordmaster!\n</p><p>\n  You are an especially quick learner. After each duel, regardless of the\n  outcome of the duel, you can add the attack and the defense (if any) used by\n  the opponent to your own set of known attacks/defenses. (Note that if an\n  opponent uses an unfamiliar defense against you, you do not learn it during\n  the duel itself, so you cannot use it against the opponent's attack in the\n  same duel.) Only you have this advantage; the attacks and defenses known by\n  your opponents never change.\n</p><p>\n  Moreover, after you win against an opponent, and before your next duel,\n  that opponent will teach you all of the attacks and defenses that they know\n  and that you do not already know. (Once they have lost to you, it looks\n  better for them if you eventually do become the Swordmaster!)\n</p><p>\n  You know which attacks and defenses each opponent knows. If you make optimal\n  choices, is it possible to guarantee that you will become the Swordmaster,\n  regardless of what choices your opponents make?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow.\n</p><ul>\n  <li>Each case begins with one line with two integers <b>N</b> and <b>P</b>:\n    the number of duelists (including you), and the maximum number of\n    attack/defense pairs in the world.</li>\n  <li>Then, there are <b>N</b> groups of three lines each. The i-th of\n    these groups represents one of the duelists; in particular, the first of\n    them represents you. Each group has the following structure:\n    <ol>\n      <li>One line with two integers <b>Attacks<sub>i</sub></b> and\n        <b>Defenses<sub>i</sub></b>: the numbers of different attacks and\n        defenses, respectively, known by the i-th duelist.</li>\n      <li>One line with <b>Attacks<sub>i</sub></b> different integers\n        <b>A<sub>ij</sub></b>, sorted in increasing order: the identities of\n        the attacks known by the i-th duelist.</li>\n      <li>One line with <b>Defenses<sub>i</sub></b> different integers\n        <b>D<sub>ij</sub></b>, sorted in increasing order: the identities of\n        the defenses known by the i-th duelist.</li>\n    </ol>\n  </li>\n</ul>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is <code>YES</code> if you can guarantee that you will become the Swordmaster\n  (as described in the problem statement), or <code>NO</code> otherwise.\n</p>\n\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>N</b> &le; 1000.<br/>\n  1 &le; <b>P</b> &le; 1000.<br/>\n  1 &le; <b>Attacks<sub>i</sub></b> &le; <b>P</b>, for all i.<br/>\n  1 &le; <b>Defenses<sub>i</sub></b> &le; <b>P</b>, for all i.<br/>\n  1 &le; <b>A<sub>ij</sub></b> &lt; <b>A<sub>i(j+1)</sub></b> &le; <b>P</b>,\n    for all i and j.<br/>\n  1 &le; <b>D<sub>ij</sub></b> &lt; <b>D<sub>i(j+1)</sub></b> &le; <b>P</b>,\n    for all i and j.<br/>\n  The sum of all <b>Attacks<sub>i</sub></b> + the sum of all <b>Defenses<sub>i</sub></b>,\n  over all i, does not exceed 50000.<br/>\n  Time limit: 10 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>A<sub>i1</sub></b> = 1, for all i. (Attack 1 is known by all the duelists,\n    including you.)<br/>\n  <b>D<sub>i1</sub></b> = 1, for all i. (Defense 1 is known by all the\n    duelists, including you.)<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  No extra restrictions.\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">5\n2 2\n1 2\n1\n1 2\n2 1\n1 2\n1\n2 2\n1 1\n1\n2\n1 1\n2\n1\n2 5\n1 1\n2\n3\n2 1\n2 4\n2\n3 5\n3 2\n1 2 3\n3 4\n2 4\n3 4\n2 3 4 5\n2 5\n4 5\n1 2 3 4 5\n4 4\n1 1\n1\n4\n2 3\n2 3\n2 3 4\n1 3\n4\n1 2 4\n1 3\n4\n1 3 4\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: NO\nCase #2: YES\nCase #3: NO\nCase #4: NO\nCase #5: YES\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  Note that the last four sample cases would not appear in Test set 1.\n</p>\n<p>\n  In Sample Case #1, as long as your opponent keeps choosing defense 1 and\n  attack 1, you cannot win the duel. There is no guarantee that your opponent\n  will ever choose attack 2 or choose not to use defense 1, so it is not\n  possible to guarantee that you will become the Swordmaster.\n</p>\n<p>\n  In Sample Case #2, you know attack 1 and defense 2, and your (only) opponent\n  knows attack 2 and defense 1. The following strategy is guaranteed to make\n  you the Swordmaster:\n</p>\n<ul>\n  <li>In your first duel, you must choose attack 1; the opponent may defend\n    with defense 1. Then, the opponent must choose attack 2; you should choose\n    defense 2.\n    <ul>\n      <li>If the opponent did not defend, then you won and you are now the\n        Swordmaster.</li>\n      <li>Otherwise, you do not win, but you learn attack 2 and defense 1\n        afterward. Then, start a second duel with that opponent. This time,\n        choose attack 2; the opponent cannot defend against it. Once again, the\n        opponent must choose attack 2; you should choose defense 2. You have\n        won and you are now the Swordmaster.</li>\n    </ul>\n  </li>\n</ul>\n<p>\n  In Sample Case #3, in your first duel, if your opponent always chooses attack\n  4, you will never be able to defend, since nobody knows the defense to that\n  attack. So, there is no way for you to ever become the swordmaster. Note that\n  there can be attacks and/or defenses that exist in the world, but are not\n  known by any of the duelists in this problem.\n</p><p>\n  In Sample Case #4, there is an opponent that knows every defense, so you\n  cannot guarantee that you will ever win against them (they would have to\n  be nice and not defend!)\n</p><p>\n  Here is one guaranteed winning strategy for Sample Case #5:\n</p>\n<ol>\n  <li>Duel the first opponent. You must choose attack 1, and they cannot defend.\n    We will proceed assuming that they choose attack 2. (If they choose attack\n    3, an isomorphic strategy will work.) You cannot defend, and you do not\n    win the duel, but you learn attack 2.</li>\n  <li>Duel the third opponent, and use attack 2 and defense 4 for a guaranteed\n    win. You learn attack 4 (which you will never use) and defenses 1 and\n    3.</li>\n  <li>Duel the second opponent, and use attack 2. You are guaranteed to learn\n    defense 2: either the opponent will use it against you, or they will not\n    use it and you will win (and learn all of their attacks and defenses).</li>\n  <li>Duel the first opponent again, and choose attack 1. Now, whichever attack\n    they use, you can defend, and you win. You learn attack 3.</li>\n  <li>Duel the second opponent again, using attack 3, if you did not already win\n    against them before.</li>\n</ol>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":38}],"title":"Swordmaster","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe first thing to notice about the problem is that all lasers rotate at the same speed. That\nmeans that after each second, regardless of direction, the lasers will be back at the\nconfiguration given in the input, and each subsequent second will just be a copy of the\nprevious one. Then, we only need to check what happens within a second. In what follows,\nwe assume the configuration given in the input happens at time = 0 seconds and we only care\nabout what happens for times in the range 0 to 1 seconds.\n</p>\n<h3>Test set 1</h3>\n<p>\nIn Test set 1 there are such a low number of lasers that we can try every possibly combination\nof directions and add 2<sup>-<b>N</b></sup> to the result for each one that leaves the segment\nuncovered some of the time.\n</p><p>\nFor fixed directions of rotation, we can check whether the segment is covered by first mapping\neach laser to the interval of time during which it will cover the segment and then seeing if the\nunion of all those intervals covers the full second. We refer to intervals in the\nmodulo 1-second ring; that is, an interval can start at t<sub>0</sub> and end at\nt<sub>1</sub> &lt; t<sub>0</sub>, covering the time from t<sub>0</sub> to 1 second and from 0\nseconds to t<sub>1</sub>. There are several ways to check if the union of intervals, even\nintervals in a ring, cover the full second, but a simple one is to split the intervals that\nwrap around into two non-wrapping-around ones, sort those intervals by start time, let t = 0,\nand do for each interval (t<sub>0</sub>, t<sub>1</sub>), if t<sub>0</sub> &gt; t, then there's\na hole; else, t = max(t, t<sub>1</sub>). If we reach the end,\nthere's a hole if and only if t &lt; 1.\n</p><p>\nTo obtain the covering interval for a given laser with endpoint p and second point q we check\nthe angle qp(0,0) and qp(0,1000),\nand then divide by 2&pi;. Notice that if we do this with floating point arithmetic,\nit is highly likely that we will have precision problems. We can do it with integer only\narithmetic by representing the times symbolically as the angles represented by the original\nvectors. To simplify the presentation, we assume we computed actual times, but all the\noperations needed for the rest of the solution can be implemented for an indirect\nrepresentation of those times intervals.\n</p><p>\nSince we need to check every combination of clockwise and counterclockwise rotations, and\nevaluating a particular combination requires looping over each laser, this solution takes\nO(<b>N</b> &times; 2<sup><b>N</b></sup>) time, which is sufficient for Test set 1.\n</p>\n<h3>Test set 2</h3>\n<p>\nWe start by observing that the two time intervals corresponding to each direction of rotation\nof a given laser are symmetrical; that is, they are of the form (t<sub>0</sub>, t<sub>1</sub>)\nand (1-t<sub>1</sub>, 1-t<sub>0</sub>). Notice that the symmetry is both to the 1/2 second point\nand to the extreme 0 seconds / 1 second, because we are in a ring. Adding the fact that intervals\nare less than 1/2 long, we can notice that the pair of intervals coming from a given laser can\nbe categorized into one of three types:\n</p><ul>\n<li>Two non-overlapping intervals, one within (0, 1/2) and the other within (1/2, 1). Example:\n  [0.2, 0.3] and [0.7, 0.8].</li>\n<li>Two intervals that overlap around 1/2. Example: [0.3, 0.6] and [0.4, 0.7].</li>\n<li>Two intervals that overlap around 0 a.k.a. 1. Example: [0.8, 0.1] and [0.9, 0.2].</li>\n</ul><p>\nFor the last two types, the overlapped area is an interval of time during which the segment\nis guaranteed to be guarded. Therefore, we can remove the overlapped part from further\nconsideration and assume that the two intervals are just their symmetric difference. In the\nfirst example above, we'd remove [0.4, 0.6] from consideration and keep the pair of\nintervals [0.3, 0.4] and [0.6, 0.7]. After we do this with all intervals, the part that remains\nto be considered is some subinterval of (0, 1/2) and some subinterval of (1/2, 1), and each\npair of intervals is exactly two symmetrical intervals, one on each side.\n</p><p>\nAt this point the problem we need to solve is, given two symmetrical intervals\nu<sub>1</sub> within (0, 1/2) and u<sub>2</sub> within (1/2, 1), and a set of pairs of\nintervals (a, b), (1 - b, 1 - a), what is the probability that the union of picking one from\nevery pair uniformly at random does not cover both u<sub>1</sub> and u<sub>2</sub>?\nNotice that because of symmetry, one particular split (a collection of one interval from each pair)\ncovers u<sub>1</sub> if and only if the opposite split covers u<sub>2</sub>.\nSo, an alternate way to frame the problem is: given the list of intervals from each pair that are\ninside u<sub>1</sub>, what is the probability at least one part of a random split of them doesn't\ncover u<sub>1</sub>? This problem we can solve with a dynamic programming approach over the list of\nintervals.\n</p><p>\nThe dynamic programming algorithm is, in a way, a simulation of the algorithm we presented above\nto check if the union of the intervals covers the universe, over all combinations at once.\nWe iterate the intervals in non-decreasing order of left end. We also keep a state of which\nprefix of u<sub>1</sub> each side of the split has already covered. Formally,\nif u<sub>1</sub> = (v, w) we calculate a\nfunction f(i, x, y) = probability of a split of intervals i, i+1, ..., <b>N</b> not covering\n<i>both</i> the remainder of the first side (x, w) <i>and</i> the remainder of the second\nside (y, w). Equivalently, this is the probability of the cover not being full given that intervals\n1, 2,..., i are split in a way that the union of the intervals from one side of\nthe split is (v, x) and the union of the intervals from the other side is (v, y).\nThe base case is if min(x, y) &ge; w, then f(i, x, y) = 0, or\nif i &gt; <b>N</b> or min(x, y) &gt; the left end of the i-th interval, then\nf(i, x, y) = 1. For all other cases, we can calculate\nf(i, x, y) = (f(i+1, max(x, b), y) + f(i+1, x, max(y, b))) / 2, where\n(a, b) is the i-th interval in the order. Finally, the answer to the problem is f(0, v, v).\n</p><p>\nNoticing the values x and y for which we need to calculate f are always either s or the right end\nof an interval bounds the size of the part of f's domain that we need, and thus the running time\nof the algorithm, by O(<b>N</b><sup>3</sup>). We can further notice that max(x, y) is always\nequal to the maximum between s and the maximum right end of intervals 0, 1, ..., i-1. This reduces\nthe domain size and running time to O(<b>N</b><sup>2</sup>). One further optimization needed is\nto notice that if min(x, y) is not one of the largest K right ends of intervals 0, 1, ..., i-1,\nthen the result of f(i, x, y) is multiplied by 2<sup>-K</sup> or less to calculate the final\nanswer. For values as small as 50 for K, that means the impact in the answer of\nthe value of f is negligible in those cases and we can just approximate it as 0,\nmaking the size of the domain of f we have to recursively calculate only\nO(K &times; <b>N</b>).\n</p><p>\nImplementing the dynamic programming algorithm as explained above can be tricky, especially if\nyou want to memoize using integer indices over the intervals and largest K last values,\nas opposed to floating point numbers. However, doing a forward-looking iterative algorithm can\nbe a lot easier. We maintain a dictionary of states to probability, where a state is just\nthe two values x and y, always sorted so that x &le; y. We start with just {(s, s): 1}.\nThe, we consider each interval (a, b) iterative and for each state (s<sub>1</sub>, s<sub>2</sub>)\nwith probability p in the last step's result, we add probability p / 2 to new states\nsorted(max(s<sub>1</sub>, b), s<sub>2</sub>) and sorted(s<sub>1</sub>, max(s<sub>2</sub>, b))\nif a &le; s<sub>1</sub>. If a &gt; s<sub>1</sub>, we add p to our accumulated result and don't\ngenerate any new state, since state (s<sub>1</sub>, s<sub>2</sub>) is guaranteed to\nleave some unguarded time. This is a simple implementation of the quadratic version, but\nthe real trick is when making the optimization to bring the time down to linear, which in this\ncase is simply ignoring states with too low probability (i.e., if p &lt; &epsilon;, do nothing).\n</p>\n","id":"000000000004d962","statement":"<h3>Problem</h3>\n<p>\n  You may have heard of the platinum-iridium cylinder that serves as the\n  standard for the kilogram, but did you know that there is a special line\n  segment used as the standard for the kilometer? It runs from (0, 0) to\n  (0, 1000) in a 2D plane in a confidential and very flat location.\n</p><p>\n  Naturally, this segment is extremely valuable, so it is protected by <b>N</b>\n  rotating surveillance lasers, which are rays in the 2D plane. Each laser\n  has a fixed endpoint, and it rotates around that endpoint at a constant speed\n  of 1 revolution per second. Whether each laser rotates clockwise or\n  counterclockwise is chosen uniformly and independently at random by the\n  security system.\n</p><p>\n  Lasers are not blocked by other lasers or their endpoints, or the segment\n  itself. No laser has an endpoint on the segment.\n</p><p>\n  You have been hired to audit the security system, but all you have to work\n  with is a single snapshot from an instant in time, which shows the endpoint\n  and orientation (at that instant) of each laser. Since the image is just a\n  snapshot, you have no way of inferring the rotation directions of the lasers.\n</p><p>\n  You have determined that the segment could be stolen in a heist if there is\n  ever a non-empty open interval of time during which no laser is touching the\n  segment. What is the probability of this happening?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with one line containing one\n  integer <b>N</b>: the number of lasers. Then, <b>N</b> more lines follow.\n  The i-th of these lines represents the ray that is the i-th laser, and\n  contains four integers <b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>,\n  <b>X<sub>i</sub>'</b>, and <b>Y<sub>i</sub>'</b>, representing the 2D\n  coordinates of the endpoint of the ray, followed by the 2D coordinates of\n  some other point on the ray.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the probability described above. <code>y</code> will be considered correct\n  if it is within an absolute or relative error of 10<sup>-6</sup> of the\n  correct answer. See the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a>\n  for an explanation of what that means, and what formats of real numbers we\n  accept.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 40 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  -10<sup>6</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  -10<sup>6</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  -10<sup>6</sup> &le; <b>X<sub>i</sub>'</b> &le; 10<sup>6</sup>, for all\n    i.<br/>\n  -10<sup>6</sup> &le; <b>Y<sub>i</sub>'</b> &le; 10<sup>6</sup>, for all\n    i.<br/>\n  (<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>) &ne; (<b>X<sub>i</sub>'</b>,\n  <b>Y<sub>i</sub>'</b>), for all i.<br/>\n  If <b>X<sub>i</sub></b> = 0, then either <b>Y<sub>i</sub></b> &lt; 0 or\n  <b>Y<sub>i</sub></b> &gt; 1000, for all i. (No laser's endpoint is on the\n    segment.)<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10000.<br/>\n  There are at most 8 cases with <b>N</b> &gt; 100.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n5\n0 1001 -1 1001\n0 1001 -1 1001\n0 1001 -2 1001\n0 1001 0 500\n0 1002 1234 5678\n4\n500 500 1000 1000\n500 500 0 1000\n500 500 0 0\n500 500 1000 0\n4\n500 500 1000 1001\n500 500 0 1000\n500 500 0 0\n500 500 1000 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.000000\nCase #2: 0.750000\nCase #3: 1.000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, note that multiple lasers might share the same endpoint\n  and initial orientation, but this does not necessarily imply that they\n  rotate in the same direction. (Also note that the second and third lasers\n  have the same initial orientation even though it is specified differently.)\n  Regardless of their rotation directions, though, each of these lasers only\n  touches the segment at the instant that it is pointing in the negative y\n  direction, so there is clearly some other open interval during which no laser\n  is touching the segment, and the answer is 1.\n</p><p>\n  In Sample Case #2, each of the lasers touches the segment during exactly 1/4\n  of its rotation, and the segment will be touched by a laser at all times if\n  and only if lasers 1 and 4 rotate in the same direction, and lasers 2 and 3\n  rotate in the same direction. The probability of that is 1/4, so the answer is 3/4.\n</p><p>\n  Sample Case #3 is like Sample Case #2, but with a slight difference that\n  guarantees that there will be an instant at which no laser is touching the\n  segment, even if the lasers are all rotating the same way. So the answer is 1.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":38}],"title":"The Cartesian Job","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nLet M = 25 be the maximum possible number of gophers.\n</p>\n<h3>Test set 1</h3>\n<p>\nOur approach to test set 1 will be as follows: first, we will find the minimum taste level among\nall gophers, and then we will use it to determine the total number of gophers N.\n</p><p>\nTo find the minimum taste level, we can simply\n<a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">binary search</a>\nusing the question \"is the minimum taste\nlevel strictly greater than X?\" This is equivalent to asking: \"Would a snack of quality\nX go uneaten by all gophers?\" To answer such a question, we can offer 2M-1 snacks\nof quality X consecutively, which guarantees that each gopher is exposed to at least one of them.\nIf none of those snacks are eaten, every gopher's taste level must be greater than X, but if\nat least one snack is eaten, then there is at least one gopher with taste level at or below X.\nWe can even stop offering snacks as soon as one gets eaten, if we want to save some snacks.\nThis requires ceil(log 10<sup>6</sup>) &times; 49 = 980 snacks at the most.\n</p><p>\nOnce we know that there is a gopher g with level exactly L, and that L is the minimum taste\nlevel, we can use our snacks to answer a query \"is it g's turn?\" by offering a snack of quality L,\nbecause g is the only gopher who would eat it. If we offer that many times in a row and calculate\nthe fraction of eaten snacks, that should approximate 1/number of gophers fairly well. At this\npoint, we might as well use our enormous number of leftover snacks to estimate, and then just\nanswer with the N such that the result is closest to 1/N. It turns out that M<sup>3</sup> tries of\nthis experiment guarantee that the answer is correct, even in the worst case. The proof is\nincluded below as part of the explanation of the solution for test set 2.\n</p>\n<h3>Test set 2</h3>\n<p>\nThe solution from test set 1 does not extend naturally to test set 2. In particular, it no longer\nsuffices to find out what fraction of gophers have the minimum (or maximum) taste level, because\nthere could be multiple gophers with that taste level; if we find a fraction of 1/K, the number\nof gophers could be any multiple of K. So, we need to investigate other levels. Investigating taste\nlevels other than an extreme one brings about the problem of the result being impacted by gophers\nwith taste levels other than the one we are interested in.\nWe can still use the idea of answering general queries by repeating snacks\nof the same quality, but they are significantly more complicated than a simple disjunction of the\nsnack outcomes.\n</p><p>\nThe first query Q we describe is somewhat natural: What is the exact fraction of gophers with\ntaste level &ge; X?\n</p><p>\nNotice that this query alone is enough to solve the problem: we can do a binary search of sorts:\ngiven a range [A, B] of at least two levels, and known fractions of gophers of those taste\nlevels X and Y, respectively, we can calculate the fraction of gophers Z for taste level\nC = (A + B) / 2. We recurse over the range [A,C] if X &ne; Z and over the range\n[C,B] if Y &ne; Z, because the fractions are different if and only if there is a gopher with a\ntaste level in the range producing the change.\nThis algorithm allows to identify all levels at which at least one gopher\nexists. For each of them we calculate the fraction of gophers at level L using our query and then\nsubtracting the fraction of gophers at each other level &lt; L. Finally, we can take the\n<a href=\"https://en.wikipedia.org/wiki/Least_common_multiple\">least common multiple</a> (LCM) of\nthe denominators of all those fractions to find the answer.\n</p><p>\nThis algorithm requires about N &times; ceil(log 10<sup>6</sup> - N) queries like Q to be\nmade. Unfortunately, we see below that this would be too many.\n</p><p>\nOne way W1 of solving Q is to try enough snacks and then round to the nearest feasible fraction.\nIf we use enough snacks, the rounding will give the exact answer. Note that if we give X\nconsecutive snacks, we are guaranteed to have the right answer in all but a prefix and a suffix\nof the tries, both of which have length up to M-1. This bounds the error by 2M-2. Moreover,\nsince our experiment has a binary answer, the farthest we can be from the true number of positive\n(or negative) answers is M-1, in the case when there are exactly ceil(M/2) answers of one type\nand floor(M/2) of the other, and we happen to hit both a prefix and suffix of size floor(M/2)\ngiving the same answer (this is for odd M, the worst case would be M for an even M).\n</p><p>\nAdditionally, since we only consider fractions with denominators up to M, the distance between\ntwo different results is bounded by 1 / (M &times; (M-1)). This means that if our experiment has\nan error of less than half of that, rounding is guaranteed to produce the right answer. Putting\nthe total error of M together, this implies that we need M<sup>3</sup> snacks to get a perfect\nanswer for Q. A total number of snacks of\nM &times; ceil(log 10<sup>6</sup> - M) &times; M<sup>3</sup> exceeds the allotted total by a large\nmargin.\n</p><p>\nA different way W2 to answer Q is to always use R consecutive snacks, where R is the LCM\nof all the possible results. That means the error is always zero, since we give each gopher\nexactly the same number of snacks. Unfortunately, LCM(2,3,...,25) is also much too large, so this\ndoesn't work either.\n</p><p>\nAnother strategy to reduce the number of queries is to notice that we only need an exact number for\nthe final levels, right before doing the LCM to get the result. For all intermediate values of our\n\"multi-leaf binary search\", we only need to decide whether there is some gopher in a range or not.\nOne way W3 to do it would be to, instead of using exact fractions X, Y and Z for A, B and C above,\nhave approximations X', Y' and Z' that are good enough that we can decide whether the real numbers\nare equal. Using 2M<sup>2</sup> snacks guarantees that we will encounter each gopher at least 2M\ntimes, which means that if X and Z are different, their approximations of the number of total\npositives will differ by at least 2M. Since we showed that the total error of both approximations\nis at most M-1, the error of the difference is at most 2M-1, which means comparing that difference\nwith 2M is enough to determine whether the real fractions\nare equal or not. This significantly reduces the total required number of snacks, since we only\nneed to use M &times; ceil(log 10<sup>6</sup> - M) &times; M<sup>2</sup> for the multi-leaf\nbinary search, and then M &times; M<sup>3</sup> or M &times; R to get the final precise answers.\nHowever, this is still too many.\n</p><p>\nThe final algorithm requires us to use all 3 of the variants above: we start the multi-leaf binary\nsearch using W3. Each time we find a level, we use either W1 or W2, whichever is cheapest, to\nget the real fraction of the found level. If we recurse on the larger intervals first, we'll find\nthe levels from highest to lowest, so we can do the subtraction. Once we have the real fraction,\nwe potentially restrict the number of possible results N to the multiples of the denominator. This\nreduces R. Eventually, R might be small enough that we can use W2 for the binary search instead of\nW3 as well. Notice that each time we use W2, since we started with other methods, we need an\nadditional R to \"align\" ourselves, depending on how many snacks we have used so far. However, since\nwe eventually use R for everything, the additional cost of these alignments is extremely small.\n</p><p>\nWe leave the precise analysis of total number of snacks needed to the reader, but it's possible,\nwith some careful bounding, to prove that it never exceeds <b>S</b>, and we couldn't find a case\nthat gets above ~85% of <b>S</b>. The reason is that if the denominator of a fraction is larger than\nM/2, then there's only one possible result left and we are done. If it's less than M/2 but somewhat\nlarge, the number of possibilities for the result is reduced significantly, and its LCM is reduced\neven more because the GCD of those possibilities is more than 1. If the denominator is small, it\nmeans that the found level has multiple gophers, which reduces the total cost of the multi-leaf\nbinary search.\n</p>\n","id":"000000000004da2d","statement":"<h3>Problem</h3>\n\n<p>\n  Earlier this year, the Code Jam team planted an orchard with the help of an\n  industrious gopher. It must have told other gophers, because we now have\n  somewhere between 2 and 25 gophers living in the orchard. But it is hard to\n  be sure exactly how many there are, because these gophers only emerge from\n  their underground tunnels to eat at night, and we are too tired after a hard\n  day of tree-pruning to stay up and watch for them. However, we do know how to\n  make one \"gopher snack\" per day, which we can leave out each night to see\n  whether it gets eaten. We think we can use this information to determine the\n  number of gophers.\n</p><p>\n  Here is what we know about the way that gophers eat. The N gophers meet during\n  one day in a council to determine an order in which\n  they will emerge over the following N nights, one at a time. Then, during each\n  of the i-th of the next N nights, the i-th gopher in the order emerges and\n  looks for a gopher snack. Each gopher has its own particular taste level\n  (which never changes), and it will eat a snack if and only if the snack's\n  quality level is at least as high as that gopher's taste level. During the day\n  after the N-th gopher in the order has emerged, the gophers choose a new\n  order and the process continues. Notice that even if a gopher chooses not to eat the\n  snack that it finds, it still does not emerge again until it comes up in the\n  next order chosen by the council.\n</p><p>\n  We must make exactly one new gopher snack each day; even if a snack is not\n  eaten, it spoils and cannot be reused the next night. Each morning, we learn\n  whether or not the previous night's snack was taken.\n</p><p>\n  Today, we know that the gophers are meeting in their council to determine\n  their next order, so tonight will mark the start of that order. We are willing\n  to devote some serious time to this investigation &mdash; as many as\n  10<sup>5</sup> nights. Using <b>S</b> or fewer snacks, can you help us figure\n  out how many gophers there are?\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This problem is\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\" target=\"_blank\">interactive</a>,\n  which means that the concepts of input and output are different than in\n  standard Code Jam problems. You will interact with a separate process that\n  both provides you with information and evaluates your responses. All\n  information comes into your program via standard input; anything that you\n  need to communicate should be sent via standard output. Remember that many\n  programming languages buffer the output by default, so make sure your output\n  actually goes out (for instance, by flushing the buffer) before blocking to\n  wait for a response. See the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\" target=\"_blank\">FAQ</a>\n  for an explanation of what it means to flush the buffer. Anything your\n  program sends through standard error is ignored, but it might consume some\n  memory and be counted against your memory limit, so do not overflow it. To\n  help you debug, a local testing tool script (in Python) is provided at the\n  very end of the problem statement. In addition, sample solutions to a\n  previous Code Jam interactive problem (in all of our supported languages) are\n  provided in the analysis for\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000000130/0000000000000523\" target=\"_blank\">Number Guessing</a>.\n</p><p>\n  Initially, your program should read a single line containing a single integer\n  <b>T</b> indicating the number of test cases. Then, you need to process\n  <b>T</b> test cases. For each test case, your program will first read one\n  line containing one integer <b>S</b>: the maximum number of snacks you can\n  use. Then, your program will process up to <b>S</b> + 1 exchanges with our\n  judge, in which the last exchange must be a guess at the answer.\n</p><p>\n  For the i-th exchange, your program needs to use standard output to send a\n  single line containing an integer Q<sub>i</sub>.\n</p>\n<ul>\n  <li>If Q<sub>i</sub> is in the inclusive range [1, 10<sup>6</sup>], it\n    represents that you will leave out a gopher snack with quality level\n    Q<sub>i</sub>. In response, the judge will print a single line with a\n    single integer: 1 if the gopher ate the snack, or 0 if it did not. This\n    line will be printed to your input stream, as described above, and your\n    program must read it through standard input. Then, you can start another\n    exchange.</li>\n  <li>If Q<sub>i</sub> is in the inclusive range [-25, -2], it represents\n    that your answer to the test case is that there are -Q<sub>i</sub>\n    gophers. If your answer is correct, the judge will proceed to the next test\n    case, if there is one.</li>\n</ul>\n<p>\n  The judge will print a single line with the integer -1, and then stop sending\n  output to your input stream, if any of the following happen:\n</p>\n<ol>\n  <li>Your program sends a malformed or out-of-bounds value (e.g.,\n    1000001, -1, or GO_IS_THE_BEST_LANGUAGE), or too many values (e.g.,\n    1 2).</li>\n  <li>Your program sends a value not in the inclusive range [-25, -2] after\n    having already sent <b>S</b> values for the current test case.</li>\n  <li>Your program sends a value in the inclusive range [-25, -2] that is not a\n    correct answer. Note that this means that you only get one chance to answer\n    a test case correctly.</li>\n</ol>\n<p>\n  If your program continues to wait for the judge after receiving\n  -1, your program will time out, resulting in a Time Limit Exceeded error.\n  Notice that it is your responsibility to have your program exit in time to\n  receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead\n  of a Time Limit Exceeded error. As usual, if the total time or memory is\n  exceeded, or your program gets a runtime error, you will receive the\n  appropriate verdict.\n</p><p>\n  You should not send additional information to the judge after solving all test\n  cases. In other words, if your program keeps printing to standard output after\n  sending the answer to the last test case, you will get a Wrong Answer\n  judgment.\n</p>\n<h4>Important warning</h4>\n<p>\n  Context switching between your program and the judge is expensive, and more so in our judging\n  system. As opposed to other interactive problems, we found it necessary in all our reference\n  solutions for this problem to bundle the exchanges to the server. That is, instead of\n  \"print taste level, read response, print taste level, read response\" we can do\n  \"print taste level, print taste level, read response, read response\" which requires less\n  context switching.\n</p><p>\n  <b>Benchmarks:</b>\n  To give you some idea of how a given bundling of queries will perform in our system, we are\n  providing some benchmarks. We wrote a program that performs <b>S</b> = 10<sup>5</sup>\n  exchanges bundled into groups of specific sizes B &mdash; that is, it prints B taste levels,\n  then reads B responses, then prints B more, then reads B more, and so on,\n  <b>S</b> / B times. We implemented this in both Python and C++, always\n  printing the B taste levels to a string variable and printing that string later, ensuring the\n  buffer is not flushed within a bundle. Here are the results for each bundle size B, in seconds\n  (rounded up to the next half-second, and taking the worst case over multiple runs):\n</p><table>\n  <tr><td>B</td><td>1</td><td>10</td><td>50</td><td>100</td><td>200</td><td>500</td><td>10<sup>5</sup></td></tr>\n  <tr><td>Python</td><td>167</td><td>21</td><td>6.5</td><td>5.5</td><td>5</td><td>5</td><td>&gt;250</td></tr>\n  <tr><td>C++</td><td>130</td><td>18</td><td>5.5</td><td>5.5</td><td>4.5</td><td>2.5</td><td>&gt;250</td></tr>\n</table><p>\n  Notice that with somewhat small bundle sizes, the context switching time gets below 5s per test,\n  which is under a minute per test set.\n<p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 10.<br/>\n  Time limit: 90 seconds per test set. <b>(See important warning in the input/output section).</b><br/>\n  Memory limit: 1GB.<br/>\n  The number of gophers is between 2 and 25, inclusive.\n  The taste level of each gopher is between 1 and 10<sup>6</sup>, inclusive.\n  <b>S</b> = 10<sup>5</sup>.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  No two gophers have the same taste level.<br/>\n  The order in which the gophers emerge each night is chosen uniformly at random from all\n  possible orders, and independently of all other orders.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  The GCD of the set {x : there exist exactly x &ge; 1 gophers in the input that share\n  a taste level} = 1.<br/>\n  The order in which the gophers emerge is chosen independently of the provided snacks.<br/>\n</p>\n\n<p>\n  For each test case, the multiset of taste levels and the seed for the random\n  number generation are generated by the problem setters in advance of the\n  contest, and will be the same for any contestant, for any submission. That means two\n  submissions that offer the same number s<sub>i</sub> of snacks for test case i will\n  see the gophers emerge in the same order.\n</p>\n\n<p>\n  For example, the following scenario would be possible in either of the\n  test sets:\n</p>\n<ul>\n  <li>two gophers, one with taste level 1, and one with taste level 2</li>\n</ul>\n<p>\n  The following scenario would be possible in test set 2, but not in test set\n  1:\n</p>\n<ul>\n  <li>three gophers, two with taste level 1, and one with taste level 2</li>\n</ul>\n<p>\n  The following scenarios would not be possible in either of the test sets:\n</p>\n<ul>\n  <li>six gophers, four with taste level 1, and two with taste level 2</li>\n  <li>two gophers, both with taste level 7</li>\n</ul>\n\n<h3>Sample Interactions</h3>\n\n<p>\n  The following interaction is for Test set 1.\n</p>\n<pre>\n  // In this example, the problem setters have already determined that the first\n  // test case has two gophers with taste levels 1 and 2 (we will call them A\n  // and B, respectively), and that the second test case has four gophers with\n  // taste levels 1, 999, 123, and 4567 (we will call them C, D, E, and F,\n  // respectively).\n  // The judge randomly generates the first order: A, B.\n  t = readline_int()           // Code reads 2 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout        // Code sends a snack with quality level 1.\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n                               // Judge randomly generates B, A as the next\n                               //   order.\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate the\n                               //   snack).\n  printline -2 to stdout       // Code correctly determines that the only\n  flush stdout                 //   scenario consistent with the information\n                               //   given so far is two gophers with taste\n                               //   levels 1 and 2.\n                               // Judge rules that the answer is correct, and\n                               //   prepares the next test case...\n                               // Judge randomly generates C, E, F, D as the\n                               //   first order.\n  s = readline_int()           // Code reads 100000 into s. (This also shows\n                               //   that the answer to the first test case was\n                               //   correct.)\n  printline 0 to stdout        // Code sends an invalid value.\n  flush stdout\n  resp = readline_str()        // Code reads -1 into resp.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n</pre>\n\n<p>\n  The following interaction is for Test set 2. Notice that the interactions in\n  the first test case are the same as in the previous example, but the outcome\n  is different.\n</p>\n<pre>\n  // In this example, the problem setters have already determined that the first\n  // test case has three gophers with taste levels 1, 2, and 1; we will call\n  // them A, B, and C, respectively, and they will be ordered ABCCBAABCCBA...\n  t = readline_int()           // Code reads 1 into t.\n  s = readline_int()           // Code reads 100000 into s.\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher A ate\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat\n                               //   the snack).\n  printline 1 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher C ate the\n                               //   snack).\n  printline 2 to stdout\n  flush stdout\n  resp = readline_str()        // Code reads 1 into resp (gopher B ate the\n                               //   snack).\n  printline -2 to stdout       // Code erroneously decides that there\n                               //   are two gophers A and B with taste levels\n                               //   1 and 2; this is consistent with the\n                               //   information given so far for the order\n                               //   A,B,A,B,A, but the true number of gophers\n  flush stdout                 //   is different, so judge rules it is wrong.\n  s = readline_str()           // Code tries to read s but gets -1, meaning\n                               //   that the answer to the last test case was\n                               //   wrong.\n  exit                         // Code exits to avoid an ambiguous TLE error.\n</pre>\n\n\n<h3>Local Testing Tool</h3>\n<p>\n  To better facilitate local testing, we provide you the following script.\n  Instructions are included inside. You are encouraged to add more test cases\n  for better testing. Please be advised that although the testing tool is\n  intended to simulate the judging system, it is <b>NOT</b> the real judging\n  system and might behave differently.\n</p><p>\n  If your code passes the testing tool but fails the real judge, please check\n  the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#coding\">\n  Coding section</a> of our FAQ to make sure that you are using the same\n  compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1ofw819ctF-2AZz8B4XvrcYKGAm9NbahQHNHFKIB2uO50lLAzUOBid29FRAt9GCaEh9HGhjFv6-Otjj_Py/local_testing_tool.py?dl=1\" download=\"local_testing_tool.py\">Download local testing tool</a>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":38}],"title":"Go, Gophers!","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<p>\n  The restriction on tile size limits the problem to just 35 distinct tiles,\n  and therefore \"only\" 35 * 34 / 2 = 595 possible cases. We might consider\n  whittling away at this number via individual insights &mdash; e.g., any case\n  with a 9-cell tile and an 8-cell tile must be impossible, since the least\n  common multiple of 9 and 8 is 72, which is larger than the allowed board\n  size. We may even be tempted to cut out some paper tiles and do some solving\n  by hand, but if so, we will quickly discover that this is harder than it\n  seems, and it is particularly hard to be sure that a case is impossible. We\n  need to either write a Master's thesis on properties of n-ominoes, or take an\n  exhaustive approach.\n</p><p>\n  We cannot simply find all of the ways to tile part or all of the board with\n  each tile, and then intersect those two sets; there could be too many\n  possible tilings to generate (e.g., 2<sup>64</sup> for the 1x1 tile). Even\n  if we could come up with special-case solutions to get around this issue for\n  enough of the smaller tiles, we would still waste a lot of time enumerating\n  sets that are obviously incompatible with the other tile.\n</p><p>\n  Instead, we can use a backtracking strategy that takes advantage of our\n  constraints, using the placement one type of tile to guide how we place the\n  other type. The strategy does not have to be lightning-fast; we know that\n  every case will appear in the test set, so we can enumerate and solve them\n  all offline and then submit once we have an answer for each one. However, it\n  must be fast enough to generate all 595 answers before the World Finals end!\n</p><p>\n  Let us number the cells of the 8x8 board in row-major order, which is the\n  same order in which our backtracking search will explore. We can translate\n  each tile (and all of its rotations and reflections) around the 8x8 board to\n  exhaustively find all possible placements. Then, we can assign each of those\n  placements to the lowest-numbered cell that the placement uses. For example,\n  one placement of the 2x2 square tile can cover cells 1, 2, 9, and 10 of the\n  board, and the lowest-numbered of those cells is 1, so we assign that\n  placement to cell 1. Now we have a helpful map from each board cell to the\n  tile placements that fit there. Notice that it would be redundant to list\n  our example 2x2 square tile placement under cell 10. For example, by the time\n  our search reaches cell 10, it will have already considered that same\n  placement at cell 1, so there would be no need to consider it again.\n</p><p>\n  Then, starting in the upper left cell and going in row-major order, we try to\n  build a set of cells that can be tiled by both tiles. For each cell c, we\n  decide whether to fill it. If it is already covered by a previous tile\n  placement, we must fill it; if we decide to fill it, and it is not already\n  covered by one or both types of tiles, then we have our search explore all\n  of the tile positions assigned to that cell in our map above.\n</p><p>\n  Since the board is 8x8, we can use the bits of a 64-bit data type to\n  represent each tile's coverage of the board, and we can use bitmasking to\n  quickly see whether desired cells are occupied, or generate one state from an\n  existing state. It is also very quick to check whether two states are equal;\n  if this is ever the case, we stop immediately, step back through our\n  backtracking to figure out exactly how to divide that set up into tiles of\n  each type, and output that tiling. If the backtracking process finishes\n  without finding such a set, then the case is impossible.\n</p><p>\n  This solution turns out to be fast in practice, running in seconds.\n  Intuitively, small tiles are more \"flexible\" and it is easier to find\n  solutions quickly for cases involving them, whereas large tiles fill up the\n  board's cells rapidly and do not open up as many choices. That is, the\n  recursion tree for the backtracking is wide but short in the case of small\n  tiles, and tall but narrow in the case of large tiles.\n</p><p>\n  This approach does not necessarily find minimal sets of cells, but it can\n  generate some artistically pleasing shapes and tilings, and/or puzzles that\n  really would be fun to solve! Here are a couple examples generated by one of\n  our solutions:\n</p>\n<p>\n  These angular tiles create a solution with a surprising mix of dense and\n  holey areas!\n</p>\n<code>\n  aaa.bbb. AAA.BBB.<br/>\n  a..cbcb. A..CCCB.<br/>\n  aaacbcb. ADDDECB.<br/>\n  ...ccc.. ...DEC..<br/>\n  ..dddeee ..FDEEEG<br/>\n  ..d....e ..F....G<br/>\n  ..dddeee ..FFFGGG<br/>\n  ........ ........<br/>\n</code>\n<p>\n  We hope you \"loved\" this problem! Notice that a test case is not necessarily\n  any easier when the two tiles differ in only a very small way.\n</p>\n<code>\n  aa...bb. AA...BB.<br/>\n  aaa..bbb AAA..CBB<br/>\n  acacdbdb DDACCCBB<br/>\n  .cccddd. .DDCCEE.<br/>\n  .cceedd. .DDFFEE.<br/>\n  ..eefff. ..FFEEG.<br/>\n  ..eeeff. ..FFGGG.<br/>\n  ....ff.. ....GG..<br/>\n</code>\n","id":"000000000004da97","statement":"<h3>Problem</h3>\n<p>\n  Your game company just ordered a lot of square game boards with 64 blank unit\n  cells, intending to turn them into chessboards, but your boss has suddenly\n  declared that chess is out of fashion. To make the best use of all of these\n  boards, you have designed a new puzzle that uses <i>tiles</i>.\n</p><p>\n  A tile is a contiguous set of unit cells, connected edge-to-edge, that can\n  fit inside a 3x3 square of unit cells. For example, the following are\n  examples of valid tiles (with each <code>@</code> denoting a piece of the\n  tile, and extra <code>.</code> characters for padding):\n</p>\n<p><code>\n    ... @@@ @@@ .@@<br/>\n    ... @@@ @.@ @.@<br/>\n    .@. @@@ @.. @@@<br/>\n</code></p>\n<p>\n  The following would NOT be valid tiles:\n</p>\n<p><code>\n    @@. @.@ .@@.<br/>\n    ... .@. @@@@<br/>\n    .@@ @.@ .@@.<br/>\n</code></p>\n<p>\n  When the solver of your new puzzle places a tile on the board, its unit cells\n  must exactly overlap some unit cells on the board that have not already been\n  covered by other tiles. A tile is still considered the same type of tile even\n  after being arbitrarily translated, rotated (by multiples of 90 degrees),\n  and/or reflected, and the solver is allowed to do any of those things to a\n  tile while placing it. For example, all of these are considered to be\n  the same tile (and other variants of that tile are possible):\n</p>\n<p><code>\n    .@. ..@ @.. ... @@.<br/>\n    @@. .@@ @@. .@@ .@@<br/>\n    @.. .@. .@. @@. ...<br/>\n</code></p>\n<p>\n  To make your puzzle, you will color one or more of the cells on the board\n  red. The solver will solve the puzzle by placing tiles on the board such that\n  all red cells are covered up, but no other cell is covered up. To save on\n  manufacturing costs, the solver receives only one type of tile, but they are\n  given exactly enough copies of it to be able to cover all of the red cells.\n</p><p>\n  Your job is to decide which of the board's cells to color red. Unfortunately,\n  your boss is still deciding which of two particular tiles to use for the\n  game. You are tired of waiting, so you have decided to try to color a set of\n  cells such that the puzzle can be solved regardless of which of the tiles\n  ends up being used.\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each consists of four lines. Each of the first\n  three lines has three characters, then a single space, then three more\n  characters. The fourth line is a blank line.\n</p><p>\n  When looking at an entire case, the space characters separate a 3x3 grid on\n  the left and a 3x3 grid on the right. Each grid represents a frame in which\n  one of the two tiles is displayed. In each grid, each character is either\n  <code>@</code>, representing a cell that is part of the tile, or\n  <code>.</code>, representing a cell that is not part of the tile. Note that\n  these <code>.</code> cells have nothing to do with the puzzle or the board,\n  and are just padding to make the shape of the tile clear. It is guaranteed\n  that the two tiles are not the same, as described in the statement above.\n</p><p>\n<h3>Output</h3>\n<p>\n  For each test case, output one line with <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1), and <code>y</code>\n  is <code>POSSIBLE</code> if there is a solution to the problem, and\n  <code>IMPOSSIBLE</code> if there is not. Then, if there is a solution, output\n  eight more lines of seventeen characters each, forming two 8x8 grids with one\n  column of space characters in between. Each grid must use dot\n  (<code>.</code>) characters to denote any blank cells, or characters from the\n  following set of 64:\n</p><p>\n  <code>!?0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code>\n</p><p>\n  to denote the individual tiles used in a solution to the puzzle. Within each\n  8x8 grid, each non-dot character must denote a part of the same single tile,\n  and different characters must denote different tiles. Each tile in the grid\n  on the left must be the same as the tile on the left in input, up to\n  rotations, translations and reflections. Each tile in the grid on the right\n  must be the same as the tile on the right in input, up to rotations,\n  translations and reflections. The set of cells that are not dots in both 8x8\n  grids must be the same, and must be nonempty.\n</p><p>\n  If there are multiple valid solutions, you may output any one of them.\n</p>\n\n<h3>Limits for Test set 1 (Visible; the only test set)</h3>\n<p>\n  <b>T</b> = 595. (Every possible test case, up to isomorphism, is included.)\n  <br/>\n  Time limit: <b>30</b> seconds.<br/>\n  Memory limit: 1GB.<br/>\n  The cells in each tile in the input form a single contiguous group via their\n    edge-to-edge connections.<br/>\n  The two tiles in the input are not the same, as described in the statement.\n    <br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">4\n.@@ .@.\n.@. .@.\n.@@ @@.\n\n@@@ @@@\n@.@ @@@\n@@@ @@@\n\n.@. ...\n@@. .@@\n@.. ...\n\n... ..@\n... ..@\n@.. ...\n\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: POSSIBLE\n....11.. ....11..\n...221.. ...221..\n...211.. ...321..\n...22... ...32...\n.333.... .433....\n4343.... 5444....\n444..... 555.....\n........ ........\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n........ ........\n..T..I.. ..T..I..\n.TT..II. .tT..Ii.\n.T....I. .t....i.\n........ ........\n.LL..EE. .LL..EE.\n..LLEE.. ..llee..\n........ ........\nCase #4: POSSIBLE\nthe.CODE AAB.CDDE\nJam.2018 FFB.CGGE\n........ ........\nWorld... HHIIJ...\n.FiNALS. .KLLJMM.\n.cup.... .KNN....\n........ ........\nTRIUMPH! OOPPQQRR\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  The sample output displays one set of answers to the sample cases. Other\n  answers may be possible.\n</p><p>\n  In Sample Case #2, there is no possible set of red cells that would make\n  the puzzle solvable regardless of which of the two tiles is chosen.\n</p><p>\n  In Sample Cases #3 and #4, note that the chosen set of red cells is not\n  required to be contiguous. Also note that the dots in the input for a tile\n  are not considered part of the tile, and have no significance in creating\n  the puzzle. For example, the given answer would also be acceptable for the\n  following input:\n</p>\n<p><code>\n    ... ...<br/>\n    .@. .@.<br/>\n    ... .@.<br/>\n</code></p>\n<p>\n  Moreover, that input is isomorphic with Sample Case #4, and would not appear\n  in the same test set along with Sample Case #4.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":28}],"title":"Two-Tiling","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\nWe begin modeling the problem as a\n<a href=\"https://en.wikipedia.org/wiki/Flow_network\">flow network</a>.\nWe construct a directed graph G\nwhere the set of nodes is {source, sink} &cup; S &cup; B where S is the set of blocks that\ncontain a station and B is the set of blocks that do not contain a station and are within\nreach of some station. The edges of the graph are\n{source &rarr; s : s &in; S} &cup; {s &rarr; b : s &in; S, b &in; B} &cup;\n{b &rarr; sink : b &in; B}.\nNotice that each path from source to sink links a specific station with a specific block.\nIf we refine G by assign capacity |B| to each edge source &rarr; s, and capacity 1 to each other\nedge, a valid flow of the network is a union of paths from source to sink, and due to the\ncapacities, each station will belong to at most one of those paths. Moreover, a maximum flow will\ncover all stations, so there is a bijection between maximum flows and station assignments. In this\nway, we can reframe the problem as minimizing the difference between maximum and minimum flows\ngoing through edges that come out of the source in a maximum flow of G.\n</p><p>\nIf we want to set an upper bound U for the flow going through edges coming out of the source,\nwe can adjust the capacities of those edges to U. If we want to set a lower bound L on those\nquantities, we can add a second copy of each of those edges with capacity L and have a cost of\n0 in the new edges and 1 in the max-capacity version (plus, cost 0 for all other types of edges).\nUsing <a href=\"https://en.wikipedia.org/wiki/Minimum-cost_flow_problem\">min-cost max-flow</a>\ninstead of max flow will give preference to flows that use at least L capacity through each\nstation, and if the retrieved flow doesn't use the full capacity, it means that one doesn't exist.\n</p><p>\nWith the above, we can just try every possibility for L and U, discarding the combinations that\ndon't achieve a max flow of |B| that saturates all the cost 0 edges coming out of the source.\nThe non-discarded combination with minimum U-L is the answer.\nBoth U and L are bounded by |B|, which is bounded by <b>R</b> &times; <b>C</b>. The size of\nG is O(<b>S</b> &times; <b>R</b> &times; <b>C</b>), and min-cost max-flow on a graph with only\n0 and 1 costs takes only linear time per augmenting path, so quadratic time overall. This means\nthe described algorithm takes time\nO(<b>S</b><sup>2</sup> &times; <b>R</b><sup>4</sup> &times; <b>C</b><sup>4</sup>). This can be too\nslow even for test set 1, but there are some optimizations that will shed some of that time,\nand you only need one of them to pass test set 1.\n</p><ul>\n<li>Instead of trying all combinations of L and U, you can try only the ones that have a chance\nto improve: if a combination (L, U) doesn't work, then we know (L+1,U), (L+2,U), etc will also\nnot work, so we can move on to (L, U+1). If a combination (L, U) works, we know that\n(L, U+1), (L, U+2), etc will also work but will yield a larger difference, so we can skip them and\nmove directly to (L+1, U). This requires us to test a linear (instead of quadratic) number of\ncombinations of L and U.</li>\n<li>An even simpler version of the optimization above is to try all possibilities for only one\nof L or U, and then use binary search to find the optimal choice for the other. This doesn't\ntake the number of combinations down to linear in |B|,\nbut it does make it\n<a href=\"https://en.wikipedia.org/wiki/Time_complexity#Quasilinear_time\">quasilinear</a>.</li>\n<li>A flow for the combination (L, U) is also a valid flow for the combination (L, U+1), so instead\nof starting the flow from scratch, we can use it, dramatically reducing the number of augmenting\npaths we need to find overall.</li>\n</ul>\n<h3>Test set 2</h3>\n<p>\nFor test set 2, the values of <b>R</b> and <b>C</b> are too high to appear linearly in the\nrunning time of the algorithm. That means we have to improve upon the solution above in at least\ntwo fronts: the size of G, which is linear on <b>R</b> and <b>C</b> and ultimately impacts any\nalgorithm we want to run on G, and the number of combinations\nof L and U we try, which is also linear or more.\n</p><p>\nWe start by defining G for test set 2 a little differently, using a technique commonly known as\ncoordinate compression. We define B' as a set of sets of blocks that form a partition of B above.\nThe way to partition is by taking the full grid and cutting through up to 2<b>S</b> horizontal\nand 2<b>S</b> vertical lines at the boundaries of the jurisdiction of each station. The resulting\nrectangles have the property that the set of stations that can reach any block of the rectangle\nis the same. Rectangles only represent the blocks within them that do not contain a station.\nWe can now define G as having nodes {source, sink} &cup; S &cup; B' and edges\n{source &rarr; s : s &in; S} &cup; {s &rarr; b' : s &in; S, b' &in; B'} &cup;\n{b' &rarr; sink : b' &in; B'}.\nNote that each node in B' now represents a set of blocks, so we also have to fiddle with\ncapacities. Edges source &rarr; s have capacity |B| (effectively infinity) as before, and so do\nedges s &rarr; b'. Edges b' &rarr; sink, however, have capacity |b'|. In this way, each node b' is\nthe union of many nodes b from the previous version of G, so its outgoing edge has the sum of the\ncapacities of the outgoing edges from those nodes b. The size of this G is O(<b>S</b><sup>3</sup>)\nwith O(<b>S</b><sup>2</sup>) nodes.\n</p><p>\nNow, in G, each path source &rarr; s &rarr; b' &rarr; sink that carries flow X represents that X\nblocks from set b' are assigned to station s. Notice that there is no longer a bijection between\nflows and station assignments, but there is a bijection if we consider permutations of blocks\nwithin a rectangle to be equivalent. Since all those blocks are equivalent for the purpose of\nthis problem, this bijection is enough. As before, we now have to find a maximum flow in G such\nthat the difference between the maximum and minimum flow in edges going out of the sink is\nminimized.\n</p><p>\nSince we cannot try all possibilities for L and U, we will use a little theory. Let G<sub>C</sub>\nbe a copy of G, but with the capacities of all edges source &rarr; s changed to C.\nG = G<sub>|B|</sub>. Notice that a valid flow in G<sub>C</sub> is also a valid flow in any\nG<sub>C'</sub> with C' &ge; C.\n</p><p>\nNow, let U be minimum such that G<sub>U</sub> allows a flow of total size |B|. Let L be\nmaximum such that there exists a maximum flow of size |S| &times; L in G<sub>L</sub>, that is,\nthere is a flow that saturates all edges of type source &rarr; s. Any maximum\nflow in G has at least one edge of type source &rarr; sink carrying flow at least U (otherwise,\nsuch maximum flow is a valid flow in G<sub>U-1</sub>, contradicting the definition of U). Also,\nany maximum flow in G has at least one edge of type source &rarr; sink carrying at most L\n(otherwise, we can subtract flow from any path sink to source that carries more than L+1 to obtain\na flow that carries exactly L+1 through all nodes, and thus it would be a valid flow in\nG<sub>L+1</sub> of size |S| &times; (L+1), contradicting the definition of L). Finally, if we start\nwith the flow in G<sub>L</sub> that justifies the definition of L and use it as a valid flow in\nG<sub>U</sub>, we know that it can be extended to a maximum flow F in G<sub>U</sub> via augmenting\npaths. Since the augmenting paths don't contain cycles, they don't decrease flow in edges of type\nsource &rarr; s. Therefore, F is a maximum flow in G<sub>U</sub> such that the difference between\nthe maximum and minimum flow going through edges coming out of the source is exactly U - L. And by\ndefinition, a maximum flow of G<sub>U</sub> is a maximum flow of G. The previous observations show\nthat there is no flow in G with such a difference less than U - L, so U - L is the answer to the\nproblem. We can binary search for L and U independently using their original definitions, which\nyields an algorithm that takes time O(<b>S</b><sup>5</sup> &times; log (<b>R</b> &times; <b>C</b>)).\n</p>\n","id":"000000000004dbbd","statement":"<h3>Problem</h3>\n<p>\n  The city of Gridtopia is a matrix of square cells (\"blocks\") with\n  <b>R</b> rows and <b>C</b> columns; rows are numbered (starting from 1) from\n  top to bottom, and columns are numbered (starting from 1) from left to right.\n  The city is served by <b>S</b> different police stations; the i-th station is\n  in the block located in the <b>R<sub>i</sub></b>th row and the\n  <b>C<sub>i</sub></b>th column, and no block contains more than one station.\n</p><p>\n  Each station is only able to patrol blocks that are no more than\n  <b>D<sub>i</sub></b> blocks away from that station, either horizontally or\n  vertically. That is, the i-th station can only patrol the block in row R' and\n  column C' if max(|R' - <b>R<sub>i</sub></b>|, |C'- <b>C<sub>i</sub></b>|)\n  &le; <b>D<sub>i</sub></b>. Put another way, the i-th station can patrol only\n  blocks within the square of side length 2<b>D<sub>i</sub></b> + 1 centered\n  on that station.\n</p><p>\n  As the new police commissioner, you need to assign some blocks within the city\n  to exactly one station that is able to patrol it. Blocks that contain stations\n  and blocks that no station is able to patrol should not be assigned. All other\n  blocks have to be assigned. Moreover, you must distribute this assignment load as\n  evenly as possible among stations. Let A<sub>i</sub> denote the\n  number of blocks assigned to the i-th station; then your goal is to minimize\n  the difference between the maximum of all the A<sub>i</sub> values and the\n  minimum of all of the A<sub>i</sub> values. If you make optimal assignments,\n  what is the smallest possible difference?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with one line with three\n  integers <b>R</b>, <b>C</b>, and <b>S</b>: respectively, the numbers of rows\n  and columns in the grid of cells, and the number of stations. Then, there\n  are <b>S</b> more lines. The i-th of these has three integers\n  <b>R<sub>i</sub></b>, <b>C<sub>i</sub></b>, and <b>D<sub>i</sub></b>:\n  respectively, the row and column in which the i-th station is located, and\n  the parameter that determines which blocks that station is able to patrol, as\n  described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the difference described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>S</b> &le; 15.<br/>\n  1 &le; <b>R<sub>i</sub></b> &le; <b>R</b>, for all i.<br/>\n  1 &le; <b>C<sub>i</sub></b> &le; <b>C</b>, for all i.<br/>\n  For all i &ne; j, <b>R<sub>i</sub></b> &ne; <b>R<sub>j</sub></b> and/or\n    <b>C<sub>i</sub></b> &ne; <b>C<sub>j</sub></b>. (No two stations are in\n    the same block.)<br/>\n  1 &le; <b>D<sub>i</sub></b> &lt; max(<b>R</b>, <b>C</b>), for all i.<br/>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>R</b> &le; 20.<br/>\n  1 &le; <b>C</b> &le; 20.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>R</b> &le; 10<sup>9</sup>.<br/>\n  1 &le; <b>C</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">2\n3 4 2\n1 1 1\n3 3 2\n5 5 2\n4 1 2\n3 2 2\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: 4\nCase #2: 0\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  In Sample Case #1, the city consists of a grid with 3 rows and 4 columns,\n  with one station in the upper left block and one station in the block to the\n  left of the lower right block. The first station can only patrol the three\n  blocks that touch the edge or corner of its block; every other block is at a\n  horizontal or vertical distance of more than 1 away. The second station\n  can patrol any block in the grid (except for the blocks containing the\n  stations). The difference in number of blocks assigned is minimized if you\n  assign station 1 all three of the blocks it can patrol, and then assign the\n  remaining seven blocks to station 2.\n</p><p>\n  In Sample Case #2, one optimal strategy is to assign the blocks as follows.\n  In this picture, <code>1</code> represents station 1, <code>2</code>\n  represents station 2, <code>!</code> represents a block assigned to station\n  1, <code>@</code> represents a block assigned to station 2, and\n  <code>.</code> represents a block assigned to neither station (because\n  neither station can patrol it). Notice that a station's assigned blocks do\n  not need to form a single continuous area.\n</p><p>\n  <code>\n    @@@@.<br/>\n    !!!@.<br/>\n    !2!@.<br/>\n    1!!@.<br/>\n    !@!@.<br/>\n  </code>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Jurisdiction Restrictions","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000007766","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2018"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
