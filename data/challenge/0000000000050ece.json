{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1489260600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000050ece","is_practice_available":true,"my_user_type":0,"my_user_type__str":"NONE","recap":"<p>\nIn our fourth annual Code Jam to I/O for Women contest, we had an immediate burst of activity on the scoreboard. Within 16 minutes, at least one contestant had solved two full problems out of four. The others proved to be more difficult, though; there were no Large submissions for C (or any submissions for D) within the first hour of the contest. Then, solutions for both came trickling in, but the majority of D-Large attempts used an incorrect approach. The first and only completely correct set of submissions came from Taube, with a total penalty time of 2:23:44. Most contestants who reached the top 150 did so by solving all of A and B and C-Small; a combination of speed and accuracy was necessary.\n</p><p>\n<i>Ticket Trouble</i> was a warm-up problem that alluded to our 2017 Google I/O venue, Shoreline Amphitheatre. This was followed by <i>Understudies</i>, a probability problem with a greedy solution, and <i>Word Search</i>, in which contestants had to construct a letter grid under specific tight constraints. Rounding out this year's set, we had <i>Where Ya Gonna Call?</i>, a challenging graph problem. You can check out the analysis for each problem for more information.\n</p><p>\nOver 600 contestants made it onto the scoreboard with at least one correct submission! Thanks to everyone who participated, and we hope to see all of you again in next year's contest! Before that, though, there's <a href=\"https://codejam.withgoogle.com/codejam\" target=\"_blank\">Google Code Jam 2017</a>; registration is open through the end of the Qualification Round on April 9.\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>Ticket Trouble</i>): Written and prepared by Ian Tullis.\n</p><p>\nProblem B (<i>Understudies</i>): Written and prepared by Ian Tullis.\n</p><p>\nProblem C (<i>Word Search</i>): Written and prepared by Ian Tullis.\n</p><p>\nProblem D (<i>Where Ya Gonna Call?</i>): Written and prepared by Pablo Heiber.\n</p>\n<p>\nSolutions and other problem preparation and review by Liang Bai, Shane Carr, Yinfu Chen, John Dethridge, Lauren Mancino Gallagher, Jackson Gatenby, Lalit Kundu, Zhusong Li, Rohan Mukkamala, Igor Naverniouk, Chieu Nguyen, Trung Thanh Nguyen, and Erick Wong.\n</p><p>\nProblem analyses by Pablo Heiber and Ian Tullis.\n</p>\n","registration_gives_participant":false,"result_status":20,"result_status__str":"FULLY_VISIBLE","start_ms":1489251600000,"tasks":[{"analysis":"<h2>Ticket Trouble: Analysis</h2>\n<p>\n  There are two minor hurdles to deal with in this problem:\n</p>\n<ul>\n  <li>Two tickets with the same numbers (e.g., both <code>1 2</code>) can never\n    both be in the same row, so they cannot both contribute to the maximum\n    value that is the answer. Therefore, it is safe to eliminate or ignore one\n    ticket from each such pair. You can sort the tickets so that duplicates end\n    up next to each other, or use a data structure such as a set to eliminate\n    them.</li>\n  <li>A ticket might have the same number twice (e.g., <code>1 1</code>). This\n    can throw off an attempted solution that just counts how many times each\n    number appears anywhere in any ticket.</li>\n</ul>\n<p>\n  A possible solution for the Small is to note that each of the <b>F</b>\n  tickets might either be correct as is, or it might have its numbers reversed.\n  You can try all 2<sup><b>F</b></sup> possible scenarios and find the largest\n  number of friends that ever end up together in the same row. The only tricky\n  part is that duplicate tickets can cause illegal scenarios that put two\n  friends in the same seat, so you must either check for these scenarios, or\n  remove the duplicates in advance as mentioned earlier.\n</p><p>\n  An even simpler solution that works for the Large is to determine the number\n  of tickets that could possibly be in each row. For each ticket (ignoring one\n  ticket from each duplicate pair), check the two numbers. If they are the\n  same, add 1 to the count for that row number. If they are different, add 1 to\n  the count for each of those row numbers. The maximum among these numbers is\n  the answer. Note that in this solution, we do not need to explicitly consider\n  any particular arrangement of the friends, and the solution would also work\n  if the problem had asked about columns instead of rows.\n</p>\n","id":"0000000000050df6","statement":"<h3>Problem</h3>\n<p>\n  A group of <b>F</b> friends is attending a conference held at an\n  amphitheater, and they have bought tickets to see a concert there afterwards.\n  The amphitheater is a grid of seats with <b>S</b> rows and <b>S</b> columns.\n  For each seat, the amphitheater has sold a single ticket (although some of\n  the tickets might not have been sold to this group of friends). Each ticket\n  is normally labeled with a pair of integers giving the row and column numbers\n  of one seat, in that order. For example, a ticket might normally say (2, 1),\n  meaning row 2, column 1, or (2, 2), meaning row 2, column 2.\n</p><p>\n  When the tickets were printed, there was a malfunction, and the two numbers\n  in each pair always came out in sorted (that is, nondecreasing) order! So,\n  for example, a ticket labeled (1, 2) might actually be for the seat in row 1,\n  column 2, or it might actually be for the seat in row 2, column 1. If two\n  friends have tickets labeled (1, 2), then one must actually be for row 1,\n  column 2, and the other must actually be for row 2, column 1.\n</p><p>\n  The friends will consult the box office on the day of the concert to find\n  out what their actual seat numbers are, but for now, it is unclear! Given the\n  printed pairs on the tickets, what is the largest possible number of the\n  friends that could actually be seated all in the same-numbered row of seats?\n  (The friends do <i>not</i> necessarily need to be seated in consecutive seats\n  in that row.)\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with two integers\n  <b>F</b> and <b>S</b>, representing the number of friends and the dimension\n  of the grid of seats. Then, <b>F</b> more lines follow. The i-th of those\n  lines has two integers <b>A<sub>i</sub></b> and <b>B<sub>i</sub></b>,\n  representing the two numbers printed on the i-th friend's ticket.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is largest possible number of the friends that could actually be seated all\n  in the same-numbered row of seats.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  <b>F</b> &le; <b>S</b><sup>2</sup>.<br/>\n  1 &le; <b>A<sub>i</sub></b> &le; <b>B<sub>i</sub></b> &le; <b>S</b>, for all\n  i.<br/>\n  No pair appears more than twice in a test case.<br/>\n  No pair containing the same number twice appears more than once in a test\n  case.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>T</b> &le; 50.<br/>\n  2 &le; <b>F</b> &le; 3.<br/>\n  2 &le; <b>S</b> &le; 3.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>F</b> &le; 100.<br/>\n  2 &le; <b>S</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 3\n1 2\n1 2\n3 3\n1 2\n2 3\n2 2\n3 3\n1 1\n2 2\n1 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 3\nCase #3: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In sample case #1, one ticket must actually be for row 1, column 2, and the\n  other must actually be for row 2, column 1, even though we do not know which\n  is which. So we know that the friends are not seated in the same row, and\n  the largest number of friends in any row is 1. Also note that the seats\n  have a third row and column, but none of the tickets use the third row or\n  column.\n</p><p>\n  In sample case #2, one of the tickets is definitely for seat 2 in row 2, and\n  it is possible that two of the other tickets could be for seats 1 and 3 in\n  row 2. So there may be as many as 3 friends in the same row.\n</p><p>\n  In sample case #3, either there are two friends in row 1 and one in row 2,\n  or there are two friends in row 2 and one in row 1. In either case, the\n  answer is 2.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Ticket Trouble","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Word Search: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  One surprisingly viable approach for the Small dataset is to create random\n  grids of random sizes and count the numbers of <code>I/O</code>s in them\n  until we happen to find a grid with the desired number. Even if we only try\n  square grids with a random size and random contents, this is easily fast\n  enough to pass. Other optimizations are possible &mdash; we can vary the\n  frequencies of <code>I</code>, <code>/</code>, and <code>O</code>, or try to\n  edit grids that are close &mdash; but not necessary.\n</p><p>\n  Another possibility is to directly construct a grid with the desired number\n  of <code>I/O</code>s.  Better yet, we can construct one grid with at least\n  287 <code>I/O</code>s, and then use it in every test case, eliminating\n  <code>I/O</code>s individually until we have the desired number. To ensure\n  that <code>I/O</code>s do not interfere with each other, let's space them out\n  in a field of <code>O</code>s like this:\n</p><p>\n  <code>I/OOI/OOI/OO</code>...<br>\n  <code>OOOOOOOOOOOO</code>...<br>\n  <code>I/OOI/OOI/OO</code>...<br>\n  <code>OOOOOOOOOOOO</code>...<br>\n  <code>I/OOI/OOI/OO</code>...<br>\n  ...<br>\n</p><p>\n  If we extend this pattern to fill a 50 by 50 grid, we will have 25 rows with\n  12 <code>I/O</code>s each; 25 &times; 12 = 300, which is more than enough. We\n  can eliminate an individual <code>I/O</code> by changing its <code>/</code>\n  into another <code>O</code>. With this grid setup, that change cannot\n  possibly affect other existing <code>I/O</code>s or create new ones. Other\n  similar strategies are possible.\n</p>\n<h3>Large dataset</h3>\n<p>\n  The particular construction strategy above cannot produce enough\n  <code>I/O</code>s when each of our grid dimensions is capped at 15. Nor will\n  random generation help; we would be lucky to get a random 15 x 15 grid for\n  <b>N</b> = 80, let alone 287. We need to pack as many <code>I/O</code>s into\n  the grid as possible. Let's start with a single row; we can fit many\n  <code>I/O</code>s in, overlapping forward ones with backward ones:\n</p><p>\n  <code>I/O/I/O/I</code>...<br>\n</p><p>\n  If we stack these rows on top of each other, we will also form many diagonal\n  <code>I/O</code>s:\n</p><p>\n  <code>I/O/I/O/I</code>...<br>\n  <code>I/O/I/O/I</code>...<br>\n  <code>I/O/I/O/I</code>...<br>\n  ...<br>\n</p><p>\n  How many <code>I/O</code>s are in the 15 by 15 version of this grid? Let's\n  count by looking only at the <code>/</code>es. Any <code>/</code> in the top\n  or bottom row is part of exactly one <code>I/O</code>, running horizontally.\n  Any other <code>I/O</code> is part of exactly three <code>I/O</code>s: one\n  horizontal and two diagonal. There are 7 <code>/</code>es in each row; the 14\n  in the top and bottom row contribute 14 <code>I/O</code>s, and the 13 &times;\n  7 = 91 in the other rows contribute 91 &times; 3 = 273. That's a total of\n  287, which is conveniently exactly the maximum number of <code>I/O</code>s we\n  could be asked to produce. Note that we do not need to prove that this\n  arrangement packs in as many <code>I/O</code>s as possible; we only had to\n  find a way to fit at least 287 in.\n</p><p>\n  Now, in each test case, we only need to whittle the number of\n  <code>I/O</code>s down from 287 to <b>N</b>. As we do this, we must be\n  careful not to create any new <code>I/O</code>s or destroy more\n  <code>I/O</code>s than we want to. One safe strategy is to change\n  <code>/</code>es into <code>O</code>s, as in the Small strategy above.\n  Changing a <code>/</code> in the top or bottom row eliminates one\n  <code>I/O</code>, and changing any other <code>/</code> eliminates three. We\n  can reach any value of <b>N</b> by first removing as many \"threes\" as\n  possible (without going below <b>N</b>) and then removing as many \"ones\" as\n  possible (without going below <b>N</b>). For example, for <b>N</b> = 280, we\n  remove two \"threes\" and one \"one\". For <b>N</b> = 4, we remove everything\n  except for four of the \"ones\". Since there are only 288 possible test cases,\n  we can even precompute answers to all of them before downloading the dataset\n  (but this is not necessary).\n</p>\n","id":"0000000000050df7","statement":"<h3>Problem</h3>\n<p>\n  In honor of Google I/O 2017, we would like to make an I/O-themed word search\n  grid. This will be a rectangular grid in which every cell contains one of\n  the three characters <code>I</code>, <code>/</code>, or <code>O</code>. The\n  people solving our word search will look for all instances of the string\n  <code>I/O</code> that appear contiguously forwards or backwards in a row,\n  column, or diagonal. For example, the following grid contains eight instances\n  of <code>I/O</code>, representing all eight possible directions in which the\n  string can appear:\n</p>\n<code>\n  OOOOO<br>\n  O///O<br>\n  O/I/O<br>\n  O///O<br>\n  OOOOO<br>\n</code>\n<p>\n  To control the difficulty level of our word search, we would like the string\n  to appear <i>exactly</i> <b>N</b> times in the grid. Moreover, we do not\n  want the grid to be too large; it cannot have more than <b>D</b> rows or more\n  than <b>D</b> columns.\n</p><p>\n  Can you help us design a grid that meets these specifications?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case consists of one line with two\n  integers <b>D</b> and <b>N</b>, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, first output one line containing <code>Case #x:</code>.\n  Then output R lines of exactly C characters each, representing the\n  rectangular grid. Each of those characters must be either <code>I</code>,\n  <code>/</code>, or <code>O</code>. You may choose any values of R and C as\n  long as both are at least 1 and neither exceeds <b>D</b>. Your grid must\n  contain <i>exactly</i> <b>N</b> instances of the string <code>I/O</code>, per\n  the rules described in the statement.\n</p><p>\n  If there are multiple valid answers, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  0 &le; <b>N</b> &le; 287.<br/>\n  It is guaranteed that at least one valid grid exists for each test case.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>T</b> &le; 25.<br/>\n  <b>D</b> = 50.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  <b>D</b> = 15.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n50 1\n50 0\n50 3\n50 8\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\nO\n/\nI\nCase #2:\nIO\nCase #3:\nIIIOOO\n/I/O/O\nIIIOOO\nCase #4:\nOOOOO\nO///O\nO/I/O\nO///O\nOOOOO\n\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  The sample output displays one set of answers to the sample cases. Other\n  answers may be possible. Note that these cases would only appear in the\n  Small dataset.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Word Search","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Understudies: Analysis</h2>\n\n<h3>Small dataset</h3>\n<p>\n  There can be at most four roles and eight performers in a Small test case. We\n  could write code to enumerate all of the different ways to pair up the\n  performers, but this can be tricky to get right; however, the limits allow an\n  even easier brute-force solution. It is simple to generate all possible\n  permutations of performers using, for example, Python's\n  <code>itertools.permutations</code>. For each permutation, we can pair the\n  first performer in the list with the second, the third with the fourth, and\n  so on, and then check the overall success probability in the way described in\n  the sample case explanations. The maximum probability we encounter is the\n  answer. This method will check equivalent casting decisions multiple times,\n  but it doesn't matter; 8! is under 50 thousand, so your computer should not\n  even break a sweat.\n</p>\n<h3>Large dataset</h3>\n<p>\n  Brute force will not cut it for a musical with up to 40 roles &mdash; we\n  must be giving <i>Cats</i> and <i>A Chorus Line</i> a run for their money!\n  &mdash; so we need a more thoughtful strategy. Is it better to pair up\n  reliable performers with other reliable performers, making some roles secure\n  and others risky? Or should we pair our most reliable performers with our\n  least reliable ones, spreading out the risk more evenly across roles? Or is\n  the solution something more complex? Intuition can easily fool us when it\n  comes to probability problems, so it's best to make a mathematical argument.\n</p><p>\n  Suppose that we have paired up our performers in some arbitrary way. Let's\n  consider two of the roles and the four performers. Without loss of\n  generality, let's label the four performers A, B, C, and D, such that their\n  probabilities of becoming unavailable follow the order P<sub>A</sub> &ge;\n  P<sub>B</sub> &ge; P<sub>C</sub> &ge; P<sub>D</sub>. Our key claim is that we\n  will maximize these four performers' contribution to the overall probability\n  of the show's success by pairing A with D and B with C, if they are not\n  already paired in that way.\n</p><p>\n  Let's prove that pairing A with D is better than pairing A with C. If we pair\n  A with D, the probability that both of these roles will be successfully\n  filled is as follows:\n</p><p>\n  (1 - P<sub>A</sub>P<sub>D</sub>)(1 - P<sub>B</sub>P<sub>C</sub>) =\n  1 - P<sub>A</sub>P<sub>D</sub> - P<sub>B</sub>P<sub>C</sub> +\n  P<sub>A</sub>P<sub>B</sub>P<sub>C</sub>P<sub>D</sub>.\n</p><p>\n  If we instead pair A with C, the probability of success is:\n</p><p>\n  (1 - P<sub>A</sub>P<sub>C</sub>)(1 - P<sub>B</sub>P<sub>D</sub>) =\n  1 - P<sub>A</sub>P<sub>C</sub> - P<sub>B</sub>P<sub>D</sub> +\n  P<sub>A</sub>P<sub>B</sub>P<sub>C</sub>P<sub>D</sub>.\n</p><p>\n  Subtracting the second quantity from the first, we get:\n</p><p>\n  P<sub>A</sub>P<sub>C</sub> + P<sub>B</sub>P<sub>D</sub> -\n  P<sub>A</sub>P<sub>D</sub> - P<sub>B</sub>P<sub>C</sub> =\n  P<sub>A</sub>(P<sub>C</sub> - P<sub>D</sub>) + P<sub>B</sub>(P<sub>D</sub> -\n  P<sub>C</sub>) =\n  (P<sub>A</sub> - P<sub>B</sub>)(P<sub>C</sub> - P<sub>D</sub>).\n</p><p>\n  Since we know that P<sub>A</sub> &ge; P<sub>B</sub>, and P<sub>C</sub> &ge;\n  P<sub>D</sub>, both of the terms in the final expression above must be\n  positive or zero, and so their product is also positive or zero. That means\n  that we are at least as likely to succeed if we pair A with D as we are if we\n  pair A with C. (The contributions from performers other than A, B, C, and D\n  are identical across these two cases, so we don't need to consider them\n  here.) A similar argument shows that pairing A with B cannot possibly be\n  better than pairing A with D.\n</p><p>\n  So we have proven that in any arrangement, for any pair of roles, we should\n  reassign the four performers as necessary to pair up the most reliable and\n  least reliable of the four in one role, and the other two performers in the\n  other. This implies that the most and least reliable performers in the entire\n  cast should be assigned to the same role. (If they are in two different\n  roles, just apply the argument above to that pair of roles.) Similarly, the\n  second-most and second-least reliable performers should be in the same role,\n  and so on. Only the rank orders of the performers' probabilities turn out to\n  matter; the actual values are not important!\n</p><p>\n  This makes our solution very simple: sort the probabilities and then pair up\n  the extremes, and then the remaining extremes, and so on. This is O(<b>N</b>\n  log <b>N</b>) &mdash; it would be linear if not for the sorting step\n  &mdash; and it would easily work for values of <b>N</b> much larger than 40.\n</p>\n","id":"0000000000050ed4","statement":"<h3>Problem</h3>\n<p>\n  You are a casting director for an upcoming musical. The musical has <b>N</b>\n  roles, and for each role, you want to cast two performers: one primary\n  performer and one understudy. A primary performer or understudy trains for\n  only one particular role, and the job of the understudy is to play the role\n  if the primary performer becomes unavailable. At least one of the two\n  performers for each role must be available for the show to succeed.\n</p><p>\n  You have selected 2<b>N</b> performers to be in the musical. They are all\n  quite talented, and any of them can be cast as a primary performer or\n  understudy for any of the roles. However, you are worried that some of them\n  may be tempted to run away to join the cast of <i>Hamiltonian!</i>, the smash\n  hit musical about quantum mechanics, before your show opens. Luckily, you are\n  an excellent judge of character. You know that the i-th performer has a\n  probability <b>P<sub>i</sub></b> of becoming unavailable. (These\n  probabilities are all independent of each other, and a given performer has\n  their probability regardless of their assigned role or whether they are\n  a primary performer or understudy.)\n</p><p>\n  You wish to assign one primary performer and one understudy for each role in\n  a way that maximizes the probability that the show will succeed. That is,\n  you want to minimize the probability that there will be at least one role\n  for which the primary performer and understudy both become unavailable.\n</p><p>\n  If you make optimal casting choices, what is the probability that your show\n  will succeed?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each consists of two lines. The first line\n  contains a single integer <b>N</b>: the number of roles. The second line\n  contains 2<b>N</b> rational numbers <b>P<sub>i</sub></b>; the i-th of these\n  gives the probability that the i-th performer will become unavailable for\n  your show. All of these probabilities are specified to exactly four decimal\n  places of precision.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the probability that your show will succeed. <code>y</code> will be\n  considered correct if it is within an absolute or relative error of\n  10<sup>-6</sup> of the correct answer. See the\n  <a href=\"/codejam/faq.html#floating_point\">FAQ</a> for an explanation of what\n  that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  0.0000 &le; <b>P<sub>i</sub></b> &le; 1.0000, for all i.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 4.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 40.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2\n0.2500 0.5000 0.5000 0.2500\n3\n0.0000 0.0000 0.0000 0.0009 0.0013 0.1776\n1\n1.0000 0.1234\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.765625\nCase #2: 1.000000\nCase #3: 0.876600\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n\n<p>\n  In sample case #1, one optimal casting choice is to make the two 0.5000\n  performers leads for the two roles, and the two 0.2500 performers\n  understudies. For a given role, the probability that both performers will\n  become unavailable is 0.5 &times; 0.25 = 0.125. So the probability that a\n  role will be filled by at least one of its actors is 1 - 0.125 = 0.875. The\n  probability that both roles will be filled (and thus that the show will\n  succeed) is 0.875 &times; 0.875 = 0.765625.\n</p><p>\n  If we instead cast the two 0.5000 performers for one role and the two 0.2500\n  performers for the other role, the probability of success would be\n  (1 - 0.50 &times; 0.50) &times; (1 - 0.25 &times; 0.25) = 0.703125, which is\n  lower.\n</p><p>\n  In sample case #2, the show will succeed for sure as long as you cast exactly\n  one of the 0.0000 performers (who will never become unavailable) in each role.\n</p><p>\n  In sample case #3, the 1.0000 performer will always become unavailable, so\n  the probability of success is equal to 1 minus the probability that the other\n  performer will become unavailable.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Understudies","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Where Ya Gonna Call?: Analysis</h2>\n<p>\nWe can model the input as a\n<a href=\"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)\">\nweighted undirected graph</a>. The question to be answered is similar\nto finding the graph's\n<a href=\"https://en.wikipedia.org/wiki/Distance_(graph_theory)#Related_concepts\">radius</a>.\nIn fact, we are asked to minimize the input graph's radius by possibly\nadding a single node inside an existing edge. This view is not only a succinct and\naccurate way to describe the problem, but also a first step towards a solution.\n</p>\n<h3>Small dataset</h3>\n<p>\nOne solution for the Small relies on a simple fact: the\nresult is always an integer multiple of 1/2, and if the optimal location is inside an edge,\nit is always at a point that is at a distance from one of\nthe incident nodes that is an integer multiple of 1/2. This property\nis not hard to prove: if the location is in a building, all distances\nto it are integers. If not, let L be a location and B be a farthest\nbuilding at distance D. Let B' be the farthest building among those\nwhose minimum path approaches L from the other side of the edge as B's\nminimum path, with distance D'. If there were no buildings whose minimal path approaches L\nfrom the other side, L would not be an optimal location, since we could move L towards B\ndecreasing all distances.\nIf D' &lt; D, we could move the location slightly towards B\nand decrease the overall minimum, so D' &le; D, which together with D' &ge; D\nby definition implies D' = D. Notice that\nthe fractional parts of both D and D' only depend on where L is located\non the edge, because the rest of each distance comes from a distance between buildings,\nwhich is an integer. Therefore, since the fractional parts\nof D and D' are equal, the fractional parts of the edge on both sides\nof L are equal, and thus an integer multiple of 1/2.\n</p><p>\nWith this property in mind, and the limitation that the maximum edge length is 2 in the Small\ndataset, there are only 3 positions on each edge\nthat can contain an optimal location (at distances 0.5, 1, and 1.5 from one end).\nFor each of these, we can find the farthest building. To do that, we can\nuse <a href=\"https://en.wikipedia.org/wiki/Dijkstra's_algorithm\">Dijkstra's algorithm</a>.\nWe also have to\nconsider the radius of the original graph (which represents choosing a\nlocation in a building), which we can do by running the same algorithm\nstarting at each building. Then, we just take the minimum farthest\ndistance from all of those options. The running time of this solution\nis O(M<b>B</b><sup>4</sup>) where M is the maximum length of an edge. This is\nbecause we need to run Dijkstraâ€™s algorithm 2M-1 times per edge for up to\nO(<b>B</b><sup>2</sup>) edges and once per node for O(<b>B</b>) nodes\n(a total of O(M<b>B</b><sup>2</sup>) times), and each run\ntakes O(<b>B</b><sup>2</sup>) time.\n</p>\n<h3>Large dataset</h3>\n<p>\nThe approach outlined for the Small dataset does not work for the Large,\nbecause the edges can be really long and thus the number of locations\nto try is too large, even when restricted to integer multiples of 1/2.\n</p><p>\nWhat we can do to simplify the problem is to use\n<a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">binary search</a>. That is,\nwrite an algorithm to determine whether there is a location with farthest\ndistance D or less. The statement is clearly false for some interval\n[0, X) of values for D and true for [X, infinity), so we can\nsimply binary search for X.\n</p><p>\nThe simplification that we obtain is that we can now check for a fixed\ndistance. We start by finding the distance between all pairs of\nbuildings. We can either run Dijkstra's algorithm once per building as mentioned above, or use\nsomething simpler for all pairs like\n<a href=\"https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\">Floyd-Warshall's</a>.\nWe can then iterate over each edge to see whether there is a viable location within it.\nFor a fixed edge, we iterate over each building and see where in the edge a\nlocation could be at a distance D or less from that building. To go to a point\ninside edge (I,J) from building K, there are two options: go from K to\nI and then move inside the edge, or go from K to J and then move inside\nthe edge. Since we now know the distance from K to I and J, we can calculate\nthe interval of positions within the edge that can be reached with\ndistance D from each end I and J. Then, if those intervals cover the\nentire edge (by overlapping or because one of them is big enough), then\nany location inside (I,J) is reachable from K with a distance D or less.\nOtherwise, there is some interval\nof unreachable locations. We record such intervals for each building\nand then check whether the union of all those intervals\ncovers all of (I,J). If it does, no location inside (I,J) is viable.\nOtherwise, there is at least one that is.\n</p><p>\nTo check if a given set of intervals fully covers another interval A there is a\ngreedy algorithm: sort the intervals by starting point and process them\nwhile keeping a current covered upper bound U, which is initialized to the lower bound of A.\nWhile U is less than the upper bound of A, for each interval,\nif its lower bound L is greater than U, then there\nis an uncovered interval (U, L) and we are done. Otherwise, if the upper bound H of the current\ninterval is greater than U, set U := H. If\nthe iteration finishes due to U becoming larger than A's upper bound,\nall of A is covered. Otherwise we either found a hole or there is one between the\nlast value of U and the upper bound of A.\n</p><p>\nFor this solution we run Floyd-Warshall's which takes O(<b>B</b><sup>3</sup>) time and then\nrun a procedure for each of O(<b>B</b><sup>2</sup>) edges. This procedure iterates all <b>B</b>\nnodes within a binary search, which takes O(log <b>B</b>M) to converge (remember M is the maximum\nlength of an edge, so <b>B</b>M is an upper bound on the output), which makes it take time\nO(<b>B</b><sup>3</sup> log <b>B</b>M) overall.\n</p><p>\nNotice that since we are\nbinary searching for X, precision is not an issue, as a bad decision due to precision\nwould only give a slightly larger or slightly smaller result. Additionally,\nwe could use the property of the result being a multiple of 1/2 to\ndo all calculations on integers by doubling all edges in the input and\ndividing by 2 at the very end.\n</p><p>\nA number of people tried to use <a href=\"https://en.wikipedia.org/wiki/Ternary_search\">ternary\nsearch</a> to solve this problem. Ternary search assumes a convex or concave function, and the\nfunction in this case (the farthest distance for each point within an edge) is neither. The\ndistance from each point to a single fixed building is indeed a concave function. However, the\nmaximum of many concave functions is not a concave nor a convex function. Some ternary search\nimplementations may suceed in the Small because of the really small number of critical points,\nwhich may all be tried even under the flawed assumption.\n</p>\n","id":"0000000000050ed5","statement":"<h3>Problem</h3>\n<p>\n  Gooli is a huge company that owns <b>B</b> buildings in a hilly area. The\n  buildings are numbered from 1 to <b>B</b>.\n</p><p>\n  Last year, they built a set of slides between buildings that are now the\n  favorite form of transportation between buildings. Slides have been upgraded\n  with suction technology to make them two-way, so a slide between two\n  buildings can be used to travel between those buildings in either direction.\n  Some slides were built with turns, so their lengths do not necessarily follow\n  common sense; for instance, they do not necessarily comply with the triangle\n  inequality. Also, there is at most one slide between any pair of buildings.\n</p><p>\n  Gooli is going to choose a location to install a special super secure phone\n  for the CEO to talk to other important people. They want to minimize the\n  distance by slide from any building to the meeting location, so as to\n  minimize the time that it would take the CEO to reach it from any building.\n  Gooli does not have any more carbon kilotubes to build more slides, and the\n  CEO refuses any other type of transportation, so Gooli's communication\n  security team needs to find the best location that is reachable using only\n  already existing slides. The location could be in a building or a point\n  somewhere within a slide.\n</p><p>\n  When traveling using the slides, the CEO may use a slide, arrive at a\n  building, then use a slide that starts there, arrive at another building, and\n  so on, until she arrives at the desired location.\n  Slides used from\n  end to end contribute their full length to the total distance. If the CEO enters\n  a slide and stops inside it because she found the phone, on the other hand, only\n  the used part of the slide contributes to the total distance.\n  When measuring distance, only the slide distance is important.\n  Distance traveled within buildings to\n  connect to a new slide or reach the phone is considered to be zero.\n</p><p>\n  Given the buildings and slides in existence, can you find any optimal\n  location for the super secure phone and return the distance from a farthest\n  building to it? Note that the distance is the same for any optimal location.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> lines follow. Each test case starts with one line with a single\n  integer <b>B</b>, the number of buildings on Gooli's campus. Then, <b>B</b> -\n  1 lines follow. For i = 2, 3, ..., <b>B</b>, the (i-1)-th of these lines\n  contains (i-1) integers <b>D</b><sub>i1</sub>, <b>D</b><sub>i2</sub>, ...,\n  <b>D</b><sub>i(i-1)</sub>. <b>D</b><sub>ij</sub> is -1 if there is no slide\n  between the i-th building and the j-th building, or the length of that slide\n  otherwise. All buildings are reachable from any other building using only\n  slides, possibly passing through intermediate buildings.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the distance from an optimal location for the phone to a building farthest\n  from it. <code>y</code> will be considered correct if it is within an\n  absolute or relative error of 10<sup>-6</sup> of the correct answer. See the\n  <a href=\"/codejam/faq.html#floating_point\">FAQ</a> for an explanation of what\n  that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 100 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  2 &le; <b>B</b> &le; 50.<br/>\n  All buildings are reachable from any other building using only slides,\n  possibly passing through intermediate buildings.<br/>\n  <b>D</b><sub>ij</sub> &ne; 0, for all i, j.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  -1 &le; <b>D</b><sub>ij</sub> &le; 2, for all i, j.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  -1 &le; <b>D</b><sub>ij</sub> &le; 10<sup>9</sup>, for all i, j.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3\n-1\n1 2\n3\n1\n1 1\n3\n4\n2 3\n4\n9\n10 7\n7 -1 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.500000\nCase #2: 1.000000\nCase #3: 2.500000\nCase #4: 8.500000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Note that the last two cases would not appear in the Small dataset.\n</p><p>\n  In Case #1, all buildings are in a line. The only optimal location is of\n  course the middle point of the line, as any other location would make one of\n  the buildings at the end of the line be farther away.\n</p><p>\n  Case #2 depicts an equilateral triangle. Any of the three buildings would be\n  an optimal location for the phone.\n</p><p>\n  Case #3 is also a triangle, but with sides of different lengths. If we pick\n  any building, the farthest building would be at distance at least 3 from it.\n  On the other hand, if we choose a location inside the slide of size 3, at distance\n  0.5 from building 3, the distance to a farthest building is improved to 2.5.\n</p><p>\n  In Case #4, the optimal location is inside the slide of length 10 between\n  buildings 1 and 3, at distance 1.5 from building 3 and distance 8.5 from\n  building 1.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Where Ya Gonna Call?","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000050ece","type":0,"type__str":"NONE"},"title":"Code Jam to I/O for Women 2017"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
