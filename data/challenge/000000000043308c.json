{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1335583800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043308c","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1A had two fairly approachable problems and one quite difficult problem.  Solving the first two problems within two hours and fifteen minutes was sufficient to advance.\n</p>\n\n<p>\nProblem A was a straightforward simulation with probabilities.  A greedy algorithm can be used for Problem B.\n</p>\n\n<p>\nProblem C was a constraint satisfaction problem, and was quite challenging to implement in time.  Only 22 people solved the large input.\n</p>\n\n<p>\nSnapDragon got first place, completing problems A and B in 15 minutes each and problem C in 45 minutes.  He was followed by pieguy, dzhulgakov, squark, wata, Plagapong, and omeometo all finishing within two hours.\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>\nProblem A. <i>Password Problem</i> Written by Bartholomew Furrow. Prepared by David Arthur and Alexander Georgiev.\n</p>\n\n<p>\nProblem B. <i>Kingdom Rush</i> Written by Bartholomew Furrow. Prepared by Bartholomew Furrow and Onufry Wojtaszczyk.\n</p>\n\n<p>\nProblem C. <i>Cruise Control</i> Written by Onufry Wojtaszczyk. Prepared by Onufry Wojtaszczyk and David Arthur.\n</p>\n\n<p>\nContest analysis presented by David Arthur, Bartholomew Furrow, and Onufry Wojtaszczyk.\n</p>\n\n<p>\nSolutions and other problem preparation by Tomek Czajka, John Dethridge, Khaled Hafez, Sean Henderson, Luka Kalinovcic, Nikolay Kurtov, Yiming Li, Igor Naverniouk, and Adam Polak.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1335574800000,"tasks":[{"analysis":"<p>\nThis problem was an interesting one to create.  In the actual game Kingdom Rush, there are three stars per level, \"challenge\" levels, and you can't try level 2 until you've beaten level 1 with at least one star.  Coming up with a problem that was solvable, while maintaining the same feeling as the game that inspired it, was a balancing act.\n</p>\n<p>\nWe solved this problem with a <b>greedy</b> algorithm.  At every step of the algorithm, Ryan will make a decision about which level to play, and his decision will be based simply on the properties of the levels available, and what he's done so far.\n<p>\nFirst, let's observe that Ryan should only complete a level if he's never completed it before, or if he can go from a one-star rating to a two-star rating.  There's simply no point in beating a level otherwise.  When we're talking about levels below, we'll ignore levels that he shouldn't complete for this reason.\n</p>\n<p>\nSecond, if Ryan ever reaches a state where he can't complete any of the remaining levels, then he is \"TOO BAD\" to beat the game.  This will happen independent of the order in which he completes the levels.\n</p>\n<p>\nThird, if Ryan can complete a level with a two-star rating, he should do it immediately.  There's no reason for him to wait: he can earn those two stars (or one star) with one level completion either now or later.  If there are multiple levels with two-star ratings that Ryan could complete, he should choose one arbitrarily; he can do the other one next.\n</p>\n<p>\nNow we've covered all situations except for one: when the only levels Ryan can complete are levels that he can complete with a one-star rating.  Consider two levels like that, level 0 and level 1:<br/>\n<code>\na<sub>0</sub> b<sub>0</sub><br/>\na<sub>1</sub> b<sub>1</sub><br/>\n</code>\nThe values of <code>a<sub>0</sub></code> and <code>a<sub>1</sub></code> don't matter: by assumption, Ryan has at least that many stars already.  Let's assume without loss of generality that <code>b<sub>0</sub> &lt; b<sub>1</sub></code>.  Which level should Ryan complete first?\n</p>\n<p>\nLet's remember that Ryan's objective is to complete levels the minimum number of times.  In the worst case, it will take Ryan 4 completions to finish those two levels: two to get him a one-star rating in both levels, and two more to get him a two-star rating in both levels.  But earning stars from these levels (or other levels) might allow him to complete one of them with a two-star rating without having to complete it with a one-star rating first.\n</p>\n<p>\nHere's a possible series of events.  Assume Ryan starts with <code>S</code> stars.  We'll decide later whether <code>k</code> is 0 or 1:\n<ol>\n<li>Ryan completes level <code>k</code> with a 1-star rating and earns 1 star.</li>\n<li>Ryan completes other levels and earns <code>s</code> stars.</li>\n<li>Ryan completes level <code>1-k</code> with a 2-star rating.</li>\n</ol>\nWhich choice of <code>k</code> makes this scenario possible?  If <code>k=0</code>, then this is possible iff <code>S + 1 + s &ge; b<sub>1</sub></code>.  If <code>k=1</code>, then this is possible iff <code>S + 1 + s &ge; b<sub>0</sub></code>.  Since <code>b<sub>0</sub> &lt; b<sub>1</sub></code>, then this is possible with <code>k=0</code> only if it's possible with <code>k=1</code>.  So we might as well simply choose <code>k=1</code>, and have Ryan choose the level with the highest value of <b>b</b>.\n</p>\n<p>\nSo to summarize, Ryan's strategy should be:\n<ol>\n<li>While there is any level remaining that Ryan hasn't completed yet, or any level for which he can earn a higher rating than he previously had:\n<ul>\n  <li>If he can earn a two-star rating on any of those levels, he should complete one of those levels (chosen arbitrarily).</li>\n  <li>Otherwise, if there is some set of levels on which he can earn a one-star rating, he should complete the one of those levels with the highest value of <b>b</b>.</li>\n</ul>\n</li>\n<li>If Ryan has beaten all levels with a two-star rating, he's done.  Otherwise he's TOO BAD.</li>\n</ol>\n</p>\n<p>\nBy simulating this strategy, we can see whether Ryan can beat Kingdom Rush, and the smallest number of level completions he can do it in.\n</p>","id":"0000000000432dfd","statement":"<h3>Problem</h3>\n\n<p>\nRyan is playing Kingdom Rush, a single-player tower defense game developed by Ironhide Game Studio.  In Kingdom Rush, players earn stars by completing levels, in a way described below.  Having more stars makes the player more powerful; so while Ryan might not be able to complete level 2 right away, he might be able to complete it after earning stars from level 1.\n</p>\n<p>\nThe real game Kingdom Rush doesn't work in quite the same way as this problem. It isn't important to have played the game in order to solve the problem.\n</p>\n<p>\nIn this problem's version of Kingdom Rush, when a player completes a level, he or she is given a 1-star rating or a 2-star rating.  That rating might allow the player to earn stars as follows:\n<ul>\n<li>If the player has never completed the level before and completes it with a 1-star rating, that player earns 1 star.</li>\n<li>If the player has never completed the level before and completes it with a 2-star rating, that player earns 2 stars.</li>\n<li>If the player has only completed the level before with a 1-star rating and completes it this time with a 2-star rating, the player earns 1 more star.</li>\n</ul>\nOtherwise there is no way for a player to earn stars.\n</p>\n<p>\nRyan might not be able to complete every level right away.  For each level, before he can complete it with a 1-star rating, he needs to have earned a certain number of stars; and he will need a larger or equal number of stars to complete that level with a 2-star rating.\n</p>\n<p>\nFor example, suppose there are two levels:<br/>\n<ul>\n<li>Level 1 requires 0 stars to complete with a 1-star rating, and 1 star to complete with a 2-star rating.</li>\n<li>Level 2 requires 0 stars to complete with a 1-star rating, and 2 stars to complete with a 2-star rating.</li>\n</ul>\nHere's a possible series of events for Ryan:\n<ol>\n<li>Ryan starts with 0 stars.  He can choose to complete either level 1 or level 2 with a 1-star rating.  He chooses to complete level 1 with a 1-star rating.  Now he has 1 star.</li>\n<li>Now Ryan can either complete level 2 with a 1-star rating, or level 1 with a 2-star rating.  He chooses to complete level 1 with a 2-star rating.  Now he has 2 stars.</li>\n<li>Now Ryan can complete level 2 with a 2-star rating.  He does that, and now he has 4 stars.</li>\n<li>Now he is done, having completed all levels with 2-star ratings and earned 4 stars (2 per level).  He has completed levels 3 times: level 1 twice, and level 2 once.</li>\n</ol>\n</p>\n<p>\nRyan is great at tower defense games, but he needs some help to beat Kingdom Rush as quickly as possible.  Your job is to figure out how many times he needs to complete levels in order to earn a 2-star rating on every level.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case starts with a line containing a single integer <b>N</b>, indicating how many levels are in the game.  <b>N</b> lines follow.  The <code>i</code>th line contains two integers <b>a<sub>i</sub></b> and <b>b<sub>i</sub></b>: the number of stars it takes to earn a one-star rating or a two-star rating, respectively, on level <code>i</code>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where <code>x</code> is the case number (starting from 1) and <code>y</code> is the minimum number of times Ryan must complete levels in order to have earned a 2-star rating on every level.  If it is impossible for Ryan to earn a 2-star rating on every level, <code>y</code> should instead be the string \"Too Bad\" (without the \" characters, but with that exact capitalization).  This indicates that Ryan is too bad at Kingdom Rush to finish the whole game.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 30 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &le; <b>a<sub>i</sub></b> &le; <b>b<sub>i</sub></b> &le; 2001.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 10.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2\n0 1\n0 2\n3\n2 2\n0 0\n4 4\n1\n1 1\n5\n0 5\n0 1\n1 1\n4 7\n5 6\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 3\nCase #3: Too Bad\nCase #4: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nKingdom Rush was created by Ironhide Game Studio.  Ironhide Game Studio does not endorse and has no involvement with Google Code Jam.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Kingdom Rush","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>This is a challenging problem requiring some insights and a careful implementation, making it a really tough nut to crack!</p>\n\n<br/>\n<p><b>Solving the small - simulation</b></p>\n<p>Let's look at some car <i>A</i>. If there is no car that <i>overlaps</i> with <i>A</i> (that is - no car that is less than five meters ahead or behind of <i>A</i>), then it does not matter which lane <i>A</i> currently is in, as it can change lanes instantaneously with impunity. Thus, the crucial moment when we have to make a decision is when <i>A</i> overtakes some other car <i>B</i> in front of it (that is, at the moment when <i>A</i> is five meters behind <i>B</i> and getting closer), or when some other car <i>C</i> overtakes <i>A</i>.</p>\n\n<p>Since all cars go at a constant speed, after any car <i>A</i> overtakes a car <i>B</i>, car <i>B</i> will never overtake <i>A</i>. This means that cars will not overtake each other very many times in the small case - the total number will be at most the number of pairs of cars, i.e. 15. Also notice that when one car overtakes another, there are only two possibilities that we need to explore: either the faster car takes the right lane and the slower car takes the left lane, or the reverse happens. If neither possibility is viable (because one of the cars is not able to take the lane we want it to take), then someone has to turn off cruise control. These two observations allow us to do a direct simulation of all possibilities.</p>\n\n<p>To do this, we begin by finding out all moments in time when two cars would intercept one another, and we then look at them in order starting from the earliest. Whenever two cars meet, we check which lane they are in right now, and whether they can change to the other lane. If both cars can change lanes, we have two possibilities, and we branch out to explore them both. If one of the cars is blocked, we have only one possibility - the car which is free to switch lanes has to take the free lane, and we continue without branching. The same thing happens if both cars are blocked but are in different lanes. If the two cars are blocked in the same lane, we know someone has to turn off cruise control, and we return the current time from this branch. Finally, if we process all the overtaking events and still nobody needs to turn cruise control off, we have found a way for everybody to drive on cruise control indefinitely - we now already know the answer for the whole test case!</p>\n\n<p>Since we want everybody to continue without turning off cruise control as long as possible, in the case with two branches, we should choose the branch which returned the higher value. As we branch at most 15 times, and we are able to check whether a car can change lanes simply by examining all other cars, our solution will easily run in time.<p>\n\n<br/>\n<p><b>Solving the large - postponing choice</b></p>\n<p> The previous strategy will obviously not cut it for the large test case. With 50 cars, there could be 1225 interceptions, and there is no way you can try 2<sup>1225</sup> different possibilities! We will have to postpone making choices for as long as possible to avoid branching.</p>\n\n<p>Suppose we have two cars: <i>A</i> and <i>B</i>, and <i>A</i> overtakes <i>B</i> at some point. They now drive side by side with <i>A</i> gaining on <i>B</i> over time. One of them is occupying the right lane and one is occupying the left lane, but we do not know which is which. If <i>A</i> manages to move a full five meters ahead of <i>B</i>, it is again free to change lanes, and the choice - which side it passed <i>B</i> on - is irrelevant.</p>\n\n<p>On the other hand, let's see what happens when a third car, <i>C</i>, comes along and tries to overtake whoever is in the back (let's say it's still <i>A</i>); moreover assume that <i>C</i> is driving in the right lane, and cannot switch to the left. This means that if <i>A</i> is in the right lane, we will have to turn cruise control off now; on the other hand if <i>A</i> is in the left lane, we will be able to drive on for a while. This means that putting <i>A</i> in the left lane was a strictly better choice.</p>\n\n<p> This leads to the idea of postponed choices. Although the choice of which lane <i>A</i> takes had to be made some time ago, it becomes relevant only now - so let's say we reveal our choice only now. Before <i>C</i> came along, we think of <i>A</i> and <i>B</i> as being in an indeterminate state, with either car possibly being in the left lane, and the exact choice is forced on us only with the arrival of <i>C</i> (one of the Googlers working on this problem said it reminded him strongly of <a href=\"http://en.wikipedia.org/wiki/Schr%C3%B6dinger's_cat\" target=\"_blank\">Schroedinger's cat</a>).</p>\n\n<br/>\n<p><b>Solving the large - undetermined lanes</b></p>\n<p> To formalise this approach, we will say that at any given moment of time, a car either is in a fixed lane or in an undetermined lane. For instance, in the situation described before, car <i>C</i> was fixed in the right lane, while cars <i>A</i> and <i>B</i> were initially in undetermined lanes. When <i>C</i> overtook <i>A</i>, the lanes of <i>A</i> and <i>B</i> became fixed (to the left and right lane, respectively).</p>\n\n<p> Notice that we also had additional information - although <i>A</i> and <i>B</i> were in undetermined lanes, we knew that they were nonetheless in different lanes. In fact, the state of the whole system can be described at any given time by the following information:<ul>\n<li> for each car, whether it is fixed in the right lane, fixed in the left lane, or in an undetermined lane,</li>\n<li> for each pair of cars in undetermined lanes, whether they are necessarily in the same lane, in different lanes, or whether they are independent of each other.</li>\n</ul>\nAt this point, you might wonder how two undetermined-lane cars could be forced to be in the same lane. The way this happens is that there is a third car (also undetermined) that blocks them both from changing lanes. If you examine the fourth sample case thoroughly, you will find that this is exactly what happens at the twelfth second. The cars with speeds 2 and 4 are in undetermined lanes but they are necessarily the same lane, and so one of them has to turn off cruise control.</p>\n\n<p>The initial state of the system is easy to calculate. Any car that is initially adjacent to another one is in a fixed lane (the lane it starts in). Any other car is in an undetermined lane, and independent from all others. The tricky question is how to update this state over time.</p>\n\n<br/>\n<p><b>Solving the large - updating the state</b></p>\n<p> The state changes in two situations - when two cars get close to each other (and their states stop being independent), and when two cars stop being close to each other. We can calculate all these events up front and order them by time, just as in the small case. This takes O(N<sup>2</sup> log N) time.</p>\n\n<p>When two cars become close, they become <i>interdependent</i> - they have to be in different lanes. If one of them has a fixed lane, the other one now also has its lane fixed; if both were undetermined and independent, they are now still undetermined, but they have to be in different lanes. In other cases either nothing happens - like when one of the cars was fixed in the right lane, and the other one was fixed in the left lane; or someone has to turn off cruise control and we have solved the problem - like when both cars are forced in the left lane, or both are undetermined but they are forced to be in the same lane.</p>\n\n<p>Moreover, when an undetermined car becomes fixed lane, it impacts all the other cars that are dependent on it - they also become fixed lane. Similarly, if two independent cars <i>A</i> and <i>B</i> become interdependent and we had a car <i>C</i> in the same lane as <i>A</i> and a car <i>D</i> in a different lane from <i>B</i>, we gain the information that <i>C</i> and <i>D</i> must be in the same lane. More generally, whenever we gain information due to a pair of cars <i>A</i> and <i>B</i> becoming close, we have to update information about any other pair of cars <i>C</i> and <i>D</i> with <i>C</i> dependent on <i>A</i> and <i>D</i> dependent on <i>B</i>. Fortunately, updating the state is very straightforward! A nice trick is to use +1 and -1 to denote the left and right lanes; and to use -1 to mean two cars are in a different lane, and +1 to mean they are in the same lane (and 0 to mean \"undetermined\" and \"independent\"). Then if, for example, we learn that <i>A</i> is in the right lane (<i>A = -1</i>), and we know that <i>A</i> and <i>B</i> are in different lanes (<i>AB = -1</i>), then <i>B</i> is in lane <i>A * AB = 1</i> - the left lane. Try this out and see how it works!</p>\n\n<p>What happens when two cars stop being close? Well, if neither of them can change lanes (due to some other adjacent cars), nothing happens. They remain dependent, just as they were. The only moment when something does change is when a car is free to change lanes - its state immediately becomes undetermined and independent from all other cars.</p>\n\n<br/>\n<p><b>Solving the large - putting it together</b></p>\nSo let's see how the solution will work. We first determine the list of events (two cars becoming close or becoming far away), ordered by time. We also determine the initial state of each car (initially each car is either fixed-lane, or undetermined and independent from all others). We keep the state of each car in an array, and the dependency information for each pair of cars in a two-dimensional array. </p>\n\n<p>For each event when two cars become close, we check if they are able to take opposite lanes (that is - they are not both fixed to the same lane, and they are not dependent to be in the same lane). If yes, we update their dependency (and possibly lane-fixedness), and update the dependencies between all their dependents). This takes O(N<sup>2</sup>) time.</p>\n\n<p>For each event when two cars stop being close, we check whether either of them can change lanes freely. If yes, we mark that car as undetermined and independent from all others. This takes O(N) time.</p>\n\n<p>As we have at most O(N<sup>2</sup>) events to process, the whole solution will run in O(N<sup>4</sup>) time, which is fast enough for the limit of 50 we have on N.</p>\n\n<br/>\n<p><b>Solving the large - optimizing</b></p>\n<p>It's not hard to see that the solution we have could be optimized. To do this, let's notice that instead of keeping (and updating) the full dependency matrix, we can think in terms of groups of cars, since if <i>A</i> and <i>B</i> are dependent and <i>B</i> and <i>C</i> are dependent, then <i>A</i> and <i>C</i> are dependent as well. The exact nature of the dependency can be deduced from the other two dependencies. Thus, we need only keep one representative from each group of co-dependent cars, and for each car in the group remember whether it is in the same lane as the representative, or in a different lane. When two groups merge, we can merge them in O(N) time now: first we check whether the representatives are in the same lane, and then we switch everybody in one of the groups to use the representative from the other group. This makes our solution run in O(N<sup>3</sup>) time. For extra credit, you might want to consider how to make the solution run in O(N<sup>2</sup> log N). </p>\n\n<p><b>Fun fact:</b> This problem was conceived when the author was driving on US interstate highways, and was annoyed by having to turn off cruise control frequently due to sub-optimal choices by other drivers who were unable to solve this problem.</p>","id":"0000000000432fe6","statement":"<h3>Problem</h3>\n<p>\n<i>Cruise control</i> is a system that allows a car to go at a constant speed, while the driver controls only the steering wheel. The driver can, of course, turn off the cruise control to avoid collisions. </p>\n\n<p> In this problem, we will consider a one-way road with two lanes, and <b>N</b> cars using cruise control on the road.  Each car is 5 meters long and goes at some constant speed.  A car can change lanes at any time if it would not cause the car to collide with some other car (touching does not count as collision). Assume that changing lanes is instantaneous and simply causes the car to switch to the other lane.  We are interested in whether any driver will have to turn off cruise control eventually to avoid a collision, or is it possible for all of them to drive (possibly switching lanes, but at constant speed) without collisions indefinitely. Note that even though changing lanes is instantaneous, two cars driving side by side <i>cannot</i> exchange places by changing lanes at the same time.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input file gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case begins with the number <b>N</b>. <b>N</b> lines follow, each describing a single car.  Each line contains a character <b>C<sub>i</sub></b> (denoting whether the car is initially in the left or the right lane), two integers describing the speed <b>S<sub>i</sub></b> of the car (in meters per second), and the initial position <b>P<sub>i</sub></b>    of the car (in meters), denoting the distance between the rear end of the car and some fixed line across the road.  All the cars are moving away from this line, and no car is behind the line.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is either the word \"Possible\" (quotes for clarity only), if the cars can drive at the given constant speeds indefinitely, or the maximum number of seconds they can drive before somebody has to change speed to avoid a collision.  Answers accurate to within 10<sup>-5</sup> absolute or relative error will be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 40 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 30. <br/>\n1 &le; <b>S<sub>i</sub></b> &le; 1000. <br/>\n0 &le; <b>P<sub>i</sub></b> &le; 10000. <br/>\nEach of the <b>C<sub>i</sub></b> characters will be either <i>L</i>, denoting the left lane, or <i>R</i>, denoting the right lane.<br/>\nInitially the cars' positions are such that they do not collide, that is, if two cars <i>i</i> and <i>j</i> have the same initial starting lane (that is, <i>C<sub>i</sub> = C<sub>j</sub></i>), then <i>|P<sub>i</sub> - P<sub>j</sub>| &ge; 5</i>.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 6.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 50.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2\nL 5 10\nL 100 0\n3\nL 100 0\nR 100 0\nL 50 505\n6\nL 30 0\nR 30 2\nL 10 39\nR 10 42\nL 25 13\nL 15 29\n4\nL 4 0\nL 2 29\nL 1 35\nL 1 44\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: Possible\nCase #2: 10.0\nCase #3: 1.4\nCase #4: 12.0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>In the first case, the faster car can shift over to the right lane and easily overtake the slower one. In the second case, the two cars driving side-by-side at 100 m/s will reach the car going 50 m/s in 10 seconds, and somebody will have to change speed, as both lanes will be blocked. </p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":17},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Cruise Control","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe first challenge with Password Problem is wrapping your head around expected values. These things come up all the time and are extremely useful, so they are well worth learning. (For example, expected value is key to solving our last problem on the 2011 finals!)\n</p>\n\n<p>\nOnce you understand what the problem is asking, you mainly need to evaluate the expected number of keystrokes for each strategy:\n\n<ul>\n<li><i>Strategy 1:</i> Finish typing the password, then press \"enter\".<br/><br/>\nThe probability that this works on the first try is x = p<sub>1</sub> * p<sub>2</sub> * ... * p<sub><b>A</b></sub>. In this case, you need <b>B</b> - <b>A</b> + 1 keystrokes. In the other case, you need 2<b>B</b> - <b>A</b> + 2 keystrokes. Therefore, the expected number of keystrokes for this strategy is:\n<br/><br/>\n<b>B</b> - <b>A</b> + 1 + (<b>B</b> + 1) * (1 - x).\n<br/><br/>\n\n<li><i>Strategy 2:</i> Hit backspace k times, then proceed as in Strategy 1.<br/><br/>\nThe probability that this works on the first try is x<sub>k</sub> = p<sub>1</sub> * p<sub>2</sub> * ... * p<sub><b>A</b>-k</sub>. In this case, you need <b>B</b> - <b>A</b> + 2k + 1 keystrokes. In the other case, you need 2<b>B</b> - <b>A</b> + 2k + 2 keystrokes. Therefore, the expected number of keystrokes for this strategy is \n<br/><br/>\n<b>B</b> - <b>A</b> + 2k + 1 + (<b>B</b> + 1) * (1 - x<sub>k</sub>).\n<br/><br/>\n\n<li><i>Strategy 3:</i> Press enter immediately, and retype the whole password.<br/><br/>\nThis always takes <b>B</b> + 2 keystrokes.\n</ul>\n\n<p>\nThe problem is asking you to calculate the minimum of all these values. There is one more catch though: if you compute each x<sub>i</sub> from scratch, your program will probably be too slow. It might take 99999 multiplications to calculate x, 99998 multiplications to calculate x<sub>1</sub>, 99997 multiplications to calculate x<sub>2</sub>, and so on. Instead, you should calculate them all together:\n\n<ul>\n<li> x<sub><b>A</b></sub> = 1\n<li> x<sub><b>A</b>-1</sub> = x<sub><b>A</b></sub> * p<sub>1</sub>\n<li> x<sub><b>A</b>-2</sub> = x<sub><b>A</b>-1</sub> * p<sub>2</sub>\n<li> etc.\n</ul>\n\nMaking sure your solution is fast enough to complete in the time limit is an important part of the Google Code Jam!\n</p>\n\n<p>\nHere is a short Python solution:\n</p>\n\n<pre>\nimport sys\n\nfor tc in xrange(1, int(sys.stdin.readline())+1):\n  A, B = [int(w) for w in sys.stdin.readline().split()]\n  p = [float(w) for w in sys.stdin.readline().split()]\n  best, x = B + 2.0, 1\n  for i in xrange(A):\n    x *= p[i]\n    best = min(best, (B - i) + (A - i - 1) + (B + 1) * (1 - x))\n  print 'Case #%d: %f' % (tc, best)\n</pre>\n\n<p><b>The Large Input and Underflow</b></p>\n\n<p>There is one trick on this problem that caught quite a few contestants, and that involves a subtlety with how floating point numbers work. Let's suppose you calculate x<sub>i</sub> in a slightly different way:</p>\n\n<ul>\n<li> x = p<sub>1</sub> * p<sub>2</sub> * ... * p<sub><b>A</b></sub>\n<li> x<sub>1</sub> = x / p<sub><b>A</b></sub>\n<li> x<sub>2</sub> = x<sub>1</sub> / p<sub><b>A</b>-1</sub>\n<li> etc.\n</ul>\n\n<p>At first glance, this looks completely equivalent to the solution above. Unfortunately, it is wrong to do this for two reasons. First, if one of the p<sub>i</sub> values is 0, you are in trouble. Second, it turns out that even a 64-bit floating point number reserves only 11 bits for the exponent. This means that it cannot store values much less than 2<sup>-1000</sup>. These very small values get rounded down to 0. Normally, you wouldn't care about values this small, but if you are multiplying 100,000 probabilities together, it becomes an issue. After rounding to 0, you will end up with every x value, including x<sub><b>A</b></sub>, being 0, and then you are in trouble!</p>\n\n<p>Some people reported failing tests due to this bug, and were then able to fix it by switching to the \"long double\" data type in C++. However, they were lucky! Even long double has the same issues.</p>\n\n<p>If you ever need to combine a lot of multiplications and divisions in the future, where intermediate values might get very small, it helps to work in log space:</p>\n\n<pre>\nA * B / C = exp( log(A) + log(B) - log(C) )\n</pre>\n\n<p>Do you see why this approach avoids the problem?</p>","id":"000000000043319b","statement":"<h3>Problem</h3>\n<p>\nI have a really long password, and sometimes I make a mistake when I type it.  Right now I've typed part of my password, but I might have made some mistakes. In particular, I might have pressed the wrong key while typing one or more of the previous characters. Given how likely I was to get each character right, what should I do?\n</p>\n\n<p>\nI have three options:\n<ol>\n  <li>Finish typing the password, then press \"enter\".  I know I'll type the rest of the characters perfectly.  If it turns out that one of the earlier characters was wrong, I'll have to retype the whole thing and hit \"enter\" again -- but I know I'll get it right the second time.</li>\n  <li>Hit \"backspace\" some number of times, deleting the last character(s) I typed, and then complete the password and press \"enter\" as in option 1.  If one of the characters I didn't delete was wrong, I'll have to retype the whole thing and press \"enter\", knowing I'll get it right the second time.</li>\n  <li>Give up by pressing \"enter\", retyping the password from the start, and pressing \"enter\" again.  I know I'll get it right this time.</li>\n</ol>\n</p>\n\n<p>\nI want to minimize the <i>expected</i> number of keystrokes needed.  Each character in the password costs 1 keystroke; each \"backspace\" costs 1 keystroke; pressing \"enter\" to complete an attempt or to give up costs 1 keystroke.\n</p>\n\n<p>\n<i>Note:</i> The \"expected\" number of keystrokes is the average number of keystrokes that would be needed if the same situation occurred a very large number of times. See the example below.\n</p>\n\n<h3>Example</h3>\n\n<p>\nSuppose my password is \"guest\" and I have already typed the first two characters, but I had a 40% chance of <i>making a mistake</i> when typing each of them. Then there are four cases:\n<ul>\n<li>I typed \"<code>gu</code>\" without error. This occurs with probability 0.6 * 0.6 = 0.36.\n<li>I typed the 'g' correctly but I made a mistake typing the 'u'. Then I have two letters typed still, but the second one is wrong: \"<code>gX</code>\". (Here, the 'X' character represents a mistyped letter.) This occurs with probability 0.6 * 0.4 = 0.24.\n<li>I typed the 'u' correctly but I made a mistake typing the 'g': \"<code>Xu</code>\". This occurs with probability 0.4 * 0.6 = 0.24.\n<li>I made a mistake typing both letters, so I have two incorrect letters: \"<code>XX</code>\". This occurs with probability 0.4 * 0.4 = 0.16.\n</ul>\n</p>\n\n<p>\nI don't know how many mistakes I actually made, but for any strategy, I can calculate the <i>expected</i> number of keys required to use it. This is shown in the table below:\n</p>\n\n<p>\n<table>\n<tr>\n<td></td>\n<td>\"<code>gu</code>\"&nbsp;&nbsp;&nbsp;</td>\n<td>\"<code>gX</code>\"&nbsp;&nbsp;&nbsp;</td>\n<td>\"<code>Xu</code>\"&nbsp;&nbsp;&nbsp;</td>\n<td>\"<code>XX</code>\"&nbsp;&nbsp;&nbsp;</td>\n<td>Expected</td>\n<tr>\n<td>Probability</td><td>0.36</td><td>0.24</td><td>0.24</td><td>0.16</td><td>-</td>\n<tr>\n<td>Keystrokes if I keep typing</td><td>4</td><td>10</td><td>10</td><td>10</td><td>7.84</td>\n<tr>\n<td>Keystrokes if I press backspace once</td><td>6</td><td>6</td><td>12</td><td>12</td>\n<td>8.4</td><tr>\n<td>Keystrokes if I press backspace twice&nbsp;&nbsp;</td><td>8</td><td>8</td><td>8</td><td>8</td><td>8</td>\n<tr>\n<td>Keystrokes if I press enter right away</td><td>7</td><td>7</td><td>7</td><td>7</td><td>7</td>\n</table>\n</p>\n\n<p>\nIf I keep typing, then there is an 0.36 probability that I will need 4 keystrokes, and an 0.64 probability that I will need 10 keystrokes. If I repeated the trial many times, then I would use 4 keystrokes 36% of the time, and 10 keystrokes the remaining 64% of the time, so the average number of keystrokes needed would be 0.36 * 4 + 0.64 * 10 = 7.84. In this case however, it is better to just press enter right away, which requires 7 keystrokes.\n<p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case begins with a line containing two integers, <b>A</b> and <b>B</b>. <b>A</b> is the number of characters that I have already typed, and <b>B</b> is the total number of characters in my password.</p>\n\n<p>\nThis is followed by a line containing <b>A</b> real numbers: p<sub>1</sub>, p<sub>2</sub>, ..., p<sub><b>A</b></sub>. p<sub>i</sub> represents the probability that I <i>correctly</i> typed the i<sup>th</sup> letter in my password. These real numbers will consist of decimal digits and at most one decimal point. The decimal point will never be the first or the last character in a number.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the expected number of additional keystrokes I need, not counting the letters I have typed so far, and assuming I choose the optimal strategy. y must be correct to within an absolute or relative error of 10<sup>-6</sup>.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 40 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n0 &le; p<sub>i</sub> &le; 1 for all i.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>A</b> &le; 3.<br/>\n<b>A</b> &lt; <b>B</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>A</b> &le; 99999.<br/>\n<b>A</b> &lt; <b>B</b> &le; 100000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 5\n0.6 0.6\n1 20\n1\n3 4\n1 0.9 0.1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 7.000000\nCase #2: 20.000000\nCase #3: 4.500000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Password Problem","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043308c","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2012"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
