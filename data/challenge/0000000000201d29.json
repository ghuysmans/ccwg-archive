{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1506283200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201d29","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Thanks to everyone who participated! Kickstart Round G will take place next\n  month; check the Kickstart\n  schedule\n  for more details.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Problem A (Kicksort): Written and prepared by Ian Tullis.\n</p><p>\n  Problem B (Dance Battle): Written by Ian Tullis and prepared by Jonathan Irvin Gunawan.\n</p><p>\n  Problem C (Catch Them All): Written and prepared by Celestine Lau.\n</p><p>\n  Problem D (Eat Cake): Written and prepared by Xianghong Luo.\n</p><p>\n  Solutions and other problem preparation and review by Ian Tullis, Yiming Li, Tony Wong, Xuanang Zhao, Jonathan Irvin Gunawan, Trung Thanh Nguyen and Xiaomeng Yang. Thanks for their great help!\n</p>\n</p><p>\nAnalysis authors:\n</p>\n<ul>\n  <li>Kicksort: Ian Tullis</li>\n  <li>Dance Battle: Ian Tullis</li>\n  <li>Catch Them All: Xiaomeng Yang, Tony Wong</li>\n  <li>Eat Cake: Jonathan Irvin Gunawan</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1506240000000,"tasks":[{"analysis":"<h2>Kicksort: Analysis</h2>\n<p>\n  In Quicksort, the best pivots at any stage are the ones that are closest to\n  the <i>median</i> of the current list (although we would have no way of\n  knowing which ones those are without doing some additional work before\n  choosing!) This problem hinges on a misinterpretation of that idea, in which\n  we take pivots from near the middle <i>index</i> of the list instead. Unless\n  our sequence happens to be already sorted or close to sorted, this is no\n  better than choosing an arbitrary index!\n</p>\n<h3>A Small-only approach</h3>\n<p>\n  The sequences in the Small dataset can have between 2 and 4 elements. There\n  are only 2! + 3! + 4! = 32 different permutations that meet these criteria.\n  This enables some strategies that do not usually work in Kickstart. For\n  example, we can pre-solve each case by hand, or use nested conditional\n  statements that take advantage of the small size of the sequence. But we\n  recommend using one of the two approaches below instead.\n</p>\n<h3>A quadratic simulation approach</h3>\n<p>\n  The most straightforward general approach is to actually run the Kicksort\n  algorithm on the given sequence, and see whether it ever picks a pivot that\n  is <i>not</i> worst-case. One possible complication is figuring out how to\n  have this recursive algorithm pass information up the call chain if it does\n  find a non-worst-case pivot; one option is to have it throw an exception that\n  can then be caught. We must also be careful not to overflow the stack with\n  recursive calls, since there can be <b>N</b> of them; one way to avoid this\n  is to use our language's provided way to change the system's stack size.\n  (Warning: This sort of system tweaking can be dangerous in real-world\n  applications, which tend to avoid deep recursive strategies like this one.)\n</p><p>\n  Quicksort is famously O(<b>N</b><sup>2</sup>) when it consistently picks\n  worst-case pivots, and that is what many of our simulations will do, so this\n  strategy takes O(<b>N</b><sup>2</sup>) time. This is still fast enough to\n  solve the Large dataset, but can we do better?\n</p>\n<h3>A linear approach</h3>\n<p>\n  First of all, let us consider different sequences of the same length that\n  have \"YES\" answers &mdash; that is, the ones for which Kicksort will always\n  pick worst-case pivots. Even though the pivots themselves may have different\n  values, Kicksort will always use the same <i>indexes</i>, in the same order,\n  as pivots. For a sequence of length 6, for example, it will pick index 2 as a\n  pivot, and then divide the other values into one empty list (which is\n  unimportant since no pivot is chosen from it) and one list of length 5\n  containing the remaining values. (It turns out not to matter for our purposes\n  whether that list is the \"low\" or \"high\" one.) Then it will pick index 2 from\n  that list of length 5, which corresponds to index 3 in the original list. If\n  we continue to trace such a case, we find that the indexes chosen from the\n  original list will be 2, 3, 1, 4, 0, 5. That is, we are starting at index\n  floor(<b>N</b> - 1) / 2, then jumping 1 to the right, then 2 to the left,\n  then 3 to the right, and so on. This does not depend at all on the values in\n  the list!\n</p><p>\n  A similar pattern holds for lists of odd length, although in that case, the\n  first jump is 1 to the left. Knowing this, we can visit the indexes of our\n  pivots in order, without doing any simulation. It is not too hard to\n  implement the pattern of changing direction and adding a distance of 1 with\n  each new jump.\n</p><p>\n  Each time we visit a new index, we check whether it holds either the lowest\n  or highest value that has not already been used. If this continues all the\n  way through the last index, we have a \"YES\" case. However, if we ever\n  encounter a value that does not satisfy those conditions, then we have a \"NO\"\n  case and we can stop.\n</p><p>\n  At this point, we can take advantage of the fact that our sequences are\n  permutations of numbers from 1 to <b>N</b>. (Of course, in real life, we\n  could \"sort\" such sequences in constant time, without ever reading them, if\n  we knew the length in advance!) We know at the outset that our lowest unused\n  value is 1 and our highest unused value is <b>N</b>. When our current value\n  matches this lower bound, we increment it by 1, because we already know that\n  the next lowest value is exactly 1 more than the previous lowest; similarly,\n  when our pivot matches the upper bound, we increment our upper bound by 1. We\n  only need to keep track of these two values as we go.\n</p><p>\n  Since we potentially have to bounce around the entire sequence, this strategy\n  takes O(<b>N</b>) time. It is unusual for a problem about sorting to have\n  a solution that takes less than O(<b>N</b> log <b>N</b>) time, but in this\n  case, it is a consequence of having restricted our sequences to permutations.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U19eWfYPcVnWpwjOzHmN5Dfptc6UcR2NAw733o0atlUHUoOnlsqSKfqsGfPy5xbOsqJCUxkhHSA/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000201b7c","statement":"<h3>Problem</h3>\n<p>\n  Here at Kickstart, we are fans of the well-known\n  <a href=\"https://en.wikipedia.org/wiki/Quicksort\" target=\"_blank\">Quicksort</a> algorithm,\n  which chooses a <i>pivot</i> value from a list, moves each other value into\n  one of two new lists depending on how it compares with the pivot value, and\n  then recursively sorts each of those new lists. However, the algorithm might\n  choose a pivot that causes all of the other values to end up in only one of\n  the two new lists, which defeats the purpose of the divide-and-conquer\n  strategy. We call such a pivot a <i>worst-case pivot</i>.\n</p><p>\n  To try to avoid this problem, we have created our own variant, Kicksort.\n  Someone told us that it is good to use a value in the middle as a pivot, so\n  our algorithm works as follows:\n</p>\n<pre>\n  Kicksort(A): // A is a 0-indexed list with E elements\n    If E &le; 1, return A.\n    Otherwise:\n      Create empty new lists B and C.\n      Choose A[floor((E-1)/2)] as the pivot P.\n      For i = 0 to E-1, except for i = floor((E-1)/2):\n        If A[i] &le; P, append it to B.\n        Otherwise, append it to C.\n    Return the list Kicksort(B) + [P] + Kicksort(C).\n    // [P] is a new list with just P; + means concatenate\n</pre>\n<p>\n  For practice, we are trying Kicksort out on lists that are permutations of\n  the numbers 1 through <b>N</b>. Unfortunately, it looks like Kicksort still\n  has the same problem as Quicksort: it is possible for every pivot to be a\n  worst-case pivot!\n</p><p>\n  For example, consider the list <code>1 4 3 2</code>. Kicksort will choose\n  <code>4</code> as a pivot, and all of the other values <code>1 3 2</code>\n  will end up in one of the two new lists. Then, when Kicksort is called on\n  that list <code>1 3 2</code>, it will choose <code>3</code>, and once again,\n  all of the other values will end up in one of the two new lists. Finally, it\n  will choose <code>1</code> from the list <code>1 2</code>, and the other\n  value <code>2</code> will of course end up in only one of the two new lists.\n  In every case, the algorithm will choose a worst-case pivot. (Notice that\n  when Kicksort is called on a list with 0 or 1 elements, it does not choose a\n  pivot at all.)\n</p><p>\n  Please help us investigate this further! Given a permutation of the numbers\n  1 through <b>N</b>, determine whether Kicksort will choose only worst-case\n  pivots.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each consists of two lines. The first line has\n  one integer <b>N</b>: the number of elements in the permutation. The second\n  line contains <b>N</b> integers <b>A<sub>i</sub></b>, which are a permutation\n  of the values from 1 through <b>N</b>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is <code>YES</code> if Kicksort will choose only worst-case pivots when\n  sorting this list, or <code>NO</code> otherwise.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.<br/>\n  The values <b>A<sub>i</sub></b> are a permutation of the values from 1 to\n    <b>N</b>.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>T</b> &le; 32.<br/>\n  Time limit: 20 seconds.<br/>\n  2 &le; <b>N</b> &le; 4.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 200 seconds.<br/>\n  2 &le; <b>N</b> &le; 10000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2mJVQXI3oyGJiCCWKWQldTB1t032egKnHCwpLxi82ZwhdVEACogpOTQ-TUOgLfEFYxFVz2MfF79UhwtO_ddBB4Ik7ZD1q-_Q/kicksort_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n4\n1 4 3 2\n4\n2 1 3 4\n2\n2 1\n3\n1 2 3\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2vfxYVMb9bI1I7OSC8354YpSi0693SwE0FnPIAAX9DZuwAjX5v8lIHnnR5w8uOfl96ZgfpyS6H5KLovYnrxN24STtwR9uCKXI/kicksort_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: YES\nCase #2: NO\nCase #3: YES\nCase #4: NO\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Sample Case #1 is the one described in the problem statement.\n</p><p>\n  In Sample Case #2, our first pivot will be <code>1</code>, which is a\n  worst-case pivot, because it causes all of the other values\n  <code>2 3 4</code> to end up in one of the two new lists. However, the\n  Kicksort call on the list <code>2 3 4</code> will choose <code>3</code> as a\n  pivot. This is not a worst-case pivot, because it puts <code>2</code> in one\n  of the new lists, and <code>4</code> in the other.\n</p><p>\n  In Sample Case #3, Kicksort will start by choosing the worst-case pivot\n  <code>2</code>, and then it has no other pivot choices to make.\n</p><p>\n  In Sample Case #4, Kicksort will start by choosing <code>2</code>, which is\n  not a worst-case pivot.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Kicksort","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Dance Battle: Analysis</h2>\n<p>\n  Even before solving the Small dataset, we need to reduce the number of\n  options available to us, because the Delay action could allow a dance battle\n  to go on forever! A critical initial insight is that we can use Delay to\n  sort the opponents and face them in whatever order we want: we can delay\n  against everyone else until we face our first desired opponent, then take\n  some other non-delay action on that opponent, then keep delaying until we\n  face our second desired opponent, and so on.\n</p>\n<h3>Small dataset</h3>\n<p>\n  Once we know that we can use Delay to sort, the Small dataset's problem space\n  allows us to use brute force. We will consider the worst case, <b>N</b> = 5.\n  We can choose one of 5! possible orders in which to face the opponents; for\n  each opponent, we choose one of the three other actions (Dance, Truce, or\n  Recruit). That is a total of 5! &times; 3<sup>5</sup> = only 29160 possible\n  scenarios. We can simulate each of them to make sure that our energy does not\n  drop below 1, and our honor does not drop below 0. Then, we take the maximum\n  honor value among all valid scenarios. Each simulation takes linear time, so\n  the overall time complexity of this strategy is O(<b>N</b>! &times;\n  3<sup><b>N</b></sup> &times; <b>N</b>).\n</p>\n<h3>Large dataset</h3>\n<p>\n  The brute force method above will not scale to 1000 opponents. Let us devise\n  an alternate strategy. For starters, we can observe that we cannot use the\n  Recruit action until we have defeated at least one opponent (and gained a\n  point of honor) by using Dance. So, if our starting energy level does not\n  let us defeat the opponent with the lowest dancing skill, then our best\n  option is to use Truce on everyone and finish with 0 honor.\n</p><p>\n  Suppose that we can defeat at least one opponent by using Dance. Then we have\n  no reason not to choose the opponent with the lowest dancing skill, since all\n  opponents give the same amount of honor when defeated via Dance. Moreover, we\n  may as well continue dancing against the weakest remaining opponent as long\n  as we have the energy to do so.\n</p><p>\n  What happens when we do not have enough energy to Dance against any remaining\n  opponent? We can either use Truce to send everyone else away, or Recruit some\n  opponent. If we are going to recruit someone, we should pick the opponent\n  with the highest energy, since the cost of recruiting any opponent is the\n  same. But how do we decide whether to use Recruit or Truce?\n</p><p>\n  As long as there are at least two opponents remaining, it cannot hurt us to\n  recruit the one with the most energy, because after that, we can surely\n  defeat at least the one with the least energy. Even if we can defeat only\n  one, and that one has the same skill as the opponent we recruited, we have\n  lost one honor and gained one honor, and we have had no net change in energy,\n  so we are no worse off than if we had used Truce to remove the same two\n  opponents.\n</p><p>\n  So, we can sort the opponent list from lowest to highest energy, and start\n  with one pointer at each end. Setting aside the case in which we cannot\n  defeat anyone: first, we move our left pointer forward, defeating opponents\n  by dancing until we no longer can. Then, as long as there are at least two\n  step, recruiting the strongest opponent and gaining energy. We repeat this\n  until the pointers meet, or we have one opponent left that we cannot defeat\n  (in which case we should use Truce instead of wasting a point of honor by\n  using Recruit). Whatever amount of honor we have at that point is our answer.\n</p><p>\n  This algorithm has an O(<b>N</b> log <b>N</b>) sorting step followed by an\n  O(<b>N</b>) execution step. Other O(<b>N</b>) execution steps are possible;\n  for example, we can notice that the algorithm above will terminate with the\n  pointers either zero or one opponent apart, so we can use partial sums and\n  binary search to directly find that point.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1E2qyQIotlKZB2YavSvak7ET9Svs5chUyPwEzFukvUD-43v8yb5McwKkt6vkOpCFfHY1xepo-w/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000201c02","statement":"<h3>Problem</h3>\n<p>\n  Your team is about to prove itself in a dance battle! Initially, your\n  team has <b>E</b> points of energy, and zero points of honor. There are\n  <b>N</b> rival teams who you must face; the i-th of these teams is the i-th\n  in a lineup, and has a dancing skill of <b>S<sub>i</sub></b>.\n</p><p>\n  In each round of battle, you will face the next rival team in the lineup, and\n  you can take one of the following actions:\n</p>\n<ol>\n  <li><i>Dance</i>: Your team loses energy equal to the dancing skill of the\n    rival team, and that team does not return to the lineup. You gain one point\n    of honor. You cannot take this action if it would make your energy drop\n    to 0 or less.</li>\n  <li><i>Delay</i>: You make excuses (\"our shoes aren't tied!\") and the rival\n    team returns to the back of the lineup. Your energy and honor do not\n    change.</li>\n  <li><i>Truce</i>: You declare a truce with the rival team, and that team does\n    not return to the lineup. Your energy and honor do not change.</li>\n  <li><i>Recruit</i>: You recruit the rival team onto your team, and that team\n    does not return to the lineup. Your team gains energy equal to the\n    dancing skill of the rival team, but you lose one point of honor. You\n    cannot take this action if it would make your honor drop below 0.</li>\n</ol>\n<p>\n  The battle is over when there are no more rival teams in the lineup. If you\n  make optimal decisions, what is the maximum amount of honor you can have when\n  the battle is over?\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each consists of two lines. The first line\n  consists of two integers <b>E</b> and <b>N</b>: your team's energy, and the\n  number of rival teams. The second line consists of <b>N</b> integers\n  <b>S<sub>i</sub></b>; the i-th of these represents the dancing skill of the\n  rival team that is i-th in line at the start of the battle.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the maximum amount of honor you can have when the battle is over.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>E</b> &le; 10<sup>6</sup>.<br/>\n  1 &le; <b>S<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 5.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2C6BkgGyCuiakko7GxWNzcRXkxBqiBfWGVEKyaNbKtcxeXHlU-F-cQ6j9JYt8sQ58JOTrYrq_4ItQz3g4LZDnktjvhEI7J7rojQBw/dance_battle_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n100 1\n100\n10 3\n20 3 15\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3q33_hWmpgDX6mLPM9cE7jYqddeJuFGepUxA5KMkWd6Gm4GnftZlwIYfhMgWivQKoxKqyA71-zM_qH6ZTBLskti6gc1c99t0wpgeYk/dance_battle_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 0\nCase #2: 1\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n</sampleio>\n\n<p>\n  In Sample Case #1, there is only one rival team. You cannot dance against\n  them because it would make your energy fall to 0, and you cannot recruit them\n  because it would make your honor fall below 0. Delaying does not help, so\n  the only option is to declare a truce. You finish with 0 honor.\n</p><p>\n  In Sample Case #2, one optimal strategy is:\n</p>\n<ol>\n  <li>Delay against the first rival team. They go to the back of the\n    lineup.</li>\n  <li>Dance against the second rival team. Your energy drops to 7, and your\n    honor increases to 1.</li>\n  <li>Recruit the third rival team. Your energy increases to 22, and your\n    honor decreases to 0.</li>\n  <li>Dance against the first rival team (which is now at the head of the\n    lineup again). Your energy drops to 2, and your honor increases to 1.</li>\n</ol>\n<p>\n  You finish with 1 point of honor.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Dance Battle","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Catch Them All: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  We can start by computing the shortest distance between each pair of\n  locations using the\n  <a href=\"https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\">Floyd-Warshall</a> algorithm. We will use dis[i, j] to represent the shortest\n  distance between locations i and j.\n</p>\n<p>\n  Let dp[K, L] be the expected time needed to catch K Codejamons when starting\n  from location L. Then we can use a dynamic programming algorithm with the\n  following state transition equation:\n</p>\n<pre>\n  if (K == 0):\n    dp[K, L] = 0;\n  else:\n    dp[K, L] = &Sigma;<sub>i!=L</sub>(dp[K-1, i] + dis[L, i]) / (<b>N</b>-1).\n</pre>\n<p>\n  The algorithm above takes O(<b>N</b><sup>2</sup><b>P</b>) time, which is fast\n  enough to solve the Small dataset.\n</p>\n<h3>Large dataset</h3>\n<p>\n  We can find that for each dp[K, L], the answer is a linear expression of\n  dp[K-1, i] when K != 0. So, we can rewrite the state transition equation as\n  the product of a matrix and a column vector, as shown below.\n</p>\n<p>\nLet S[i] = &Sigma;<sub>j!=i</sub>(dis[i, j]).\n</p>\n<pre>\n  +----------+   +---------------------------------------------+   +------------+\n  | dp[K, 1] |   |    0   , 1/(N-1), ... , 1/(N-1), S[1]/(N-1) |   | dp[K-1, 1] |\n  | dp[K, 2] |   | 1/(N-1),    0   , ... , 1/(N-1), S[2]/(N-1) |   | dp[K-1, 2] |\n  |   ...    | = |   ...  ,   ...  , ... ,   ...  ,     ...    | * |    ...     |\n  | dp[K, N] |   | 1/(N-1), 1/(N-1), ... ,    0   , S[N]/(N-1) |   | dp[K-1, N] |\n  |    1     |   |    0   ,    0   , ... ,    0   ,     1      |   |     1      |\n  +----------+   +---------------------------------------------+   +------------+\n</pre>\n<p>\n  Let F<sub>K</sub> denote the column vector of dp[K, i], and let A denote the\n  transition matrix. Then we have F<sub>K</sub> = A * F<sub>K-1</sub> =\n  A<sup>K</sup> * F<sub>0</sub>.\n</p>\n<p>\n  With the approach above, we can use\n  <a href=\"https://en.wikipedia.org/wiki/Exponentiation_by_squaring\">exponentiation by squaring</a>\n  to accelerate the computation of A<sup>K</sup>. This gives us an\n  O(<b>N</b><sup>3</sup>log<b>P</b>) algorithm which can solve the Large\n  dataset.\n</p>\n\n<h3>Other solutions</h3>\n<p>\n  Let Pr<sub>t</sub> be the probability of being at location 1 after catching t\n  Codejamons. Initially, Pr<sub>0</sub> = 1. Since at any time, the\n  probabilities of being at locations 2, 3, ..., <b>N</b> (let's call them the\n  \"other locations\") are the same, we can calculate the probability of the next\n  Codejamon appearing at location 1 by multiplying the probability of being at\n  any of the other locations by the probability of location 1 being chosen.\n  Therefore, we have Pr<sub>t</sub> = (1 - Pr<sub>t-1</sub>) / (<b>N</b>-1).\n</p>\n<p>\n  After computing the values of Pr<sub>i</sub> for i = 1, 2,..., <b>P</b>-1,\n  the answer to the problem is:\n</p>\n<p>\n  &Sigma;(Pr<sub>i</sub> * (expected distance from location 1) + &Sigma;(1 - Pr<sub>i</sub>) / (N-1) * (expected distance from location j) for j = 2, 3, ..., N) for i = 0, 1, ..., <b>P</b>-1.\n</p>\n<p>\n  Note: the expected distance from location i equals &Sigma;dis[i, j] /\n  (<b>N</b>-1) for j = 1, 2, ..., <b>N</b>.\n</p>\n<p>\n  We might not have enough time to compute all <b>P</b> values of the sequence\n  Pr<sub>i</sub>, but one may notice that this sequence converges quickly\n  (except for <b>N</b>=2, which we can handle separately). Intuitively, as the\n  game progresses, the probabilities of you being at each of the <b>N</b>\n  locations become more equal. For example, if <b>N</b>=4, the first few values\n  for Pr<sub>t</sub> are 1, 0, 0.333, 0.222, 0.259, 0.247, 0.251, 0.250, ...\n  Once this value gets very close to 1 / <b>N</b>, after some threshold like\n  i = 100 (depending on the numerical error allowed), we can simply approximate\n  Pr<sub>i</sub> = 1/<b>N</b> for all i larger than the threshold. Then\n  i = 100, 101, ..., <b>P</b>-1 in the previous summation can be replaced by a\n  multiplication: (<b>P</b>-100) * &Sigma;(expected distance from location j) /\n  <b>N</b> for j = 1, 2, ..., <b>N</b>.\n</p>\n<p>\n  The time complexity for the above algorithm is O(<b>N</b><sup>3</sup> + C),\n  where C depends on the numerical error allowed.\n</p>\n<p>\n  Using the sequence of Pr<sub>t</sub> values, it is also possible to calculate\n  the exact answer. Let's make another sequence A<sub>i</sub> =\n  Pr<sub>i</sub> - 1/<b>N</b>. This sequence converges to 0 and is a geometric\n  progression because:\n</p>\n<ul>\n  <li>Pr<sub>i</sub> = (1 - Pr<sub>i-1</sub>) / (<b>N</b>-1)</li>\n  <li>A<sub>i</sub> + 1/<b>N</b> = (1 - A<sub>i-1</sub> - 1/<b>N</b>) /\n    (<b>N</b>-1)</li>\n  <li>A<sub>i</sub> + 1/<b>N</b> = -A<sub>i-1</sub> / (<b>N</b>-1) +\n    1/<b>N</b></li>\n  <li>A<sub>i</sub> = -A<sub>i-1</sub> / (<b>N</b>-1).</li>\n</ul>\n<p>\n  &Sigma;A<sub>i</sub> for i = 0, 1, ..., <b>P</b>-1 can be calculated using\n  the formula for the sum of a\n  <a href=\"https://en.wikipedia.org/wiki/Geometric_progression#Geometric_series\">geometric series</a>.\n  With &Sigma;A<sub>i</sub>, we can obtain &Sigma;Pr<sub>i</sub>\n  = 1/<b>N</b> * <b>P</b> + &Sigma;A<sub>i</sub>, and ultimately the answer.\n  The time complexity for the above algorithm is O(<b>N</b><sup>3</sup>).\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2IbuSr8Bq0JWX-Vba8WZDS32ORduApKJf1KxE-o4OIoc29gOnVUeax4wSDtQJjlkKdyqQYO2ZD/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000201c9b","statement":"<h2>Problem</h2>\n\n<p>\n  After the release of <i><b>Codejamon Go</b></i>, you, like many of your friends,\n  took to the streets of your city to catch as many of the furry little creatures\n  as you could. The objective of the game is to catch <i>Codejamon</i> that appear\n  around your city by going to their locations. You are wondering how long it would\n  take for you to catch them all!\n</p>\n\n<p>\n  Your city consists of <b>N</b> locations numbered from 1 to <b>N</b>. You start at\n  location 1. There are <b>M</b> bidirectional roads (numbered from 1 to <b>M</b>).\n  The i-th road connects a pair of distinct locations (U<sub>i</sub>, V<sub>i</sub>),\n  and it takes <b>D<sub>i</sub></b> minutes to travel on it in either direction.\n  It is guaranteed that it is possible to reach any other location from location\n  1 by travelling on one or more roads.\n</p>\n\n<p>\n  At time 0, a <i>Codejamon</i> will appear at a uniformly random location other\n  than your current location (which is location 1 at time 0). Uniformly random means\n  that the probability that it will appear at each of the <b>N</b> - 1 locations\n  other than your current location is exactly 1 / (<b>N</b> - 1). The instant that\n  a <i>Codejamon</i> appears, you can immediately start moving towards it.\n  When you arrive at a location containing a <i>Codejamon</i>, you instantly catch\n  it, and then a new <i>Codejamon</i> will instantly appear at a uniformly random\n  location other than your current location, and so on. Notice that only one\n  Codejamon is present at any given time, and you must catch the existing one before\n  the next will appear.\n</p>\n\n<p>\n  Given the layout of your city, calculate the expected time to catch <b>P</b>\n  <i>Codejamon</i>, assuming that you always take the fastest possible route between\n  any two locations.\n</p>\n\n<h3>Input</h3>\n\n<p>\n  The input starts with one line containing one integer <b>T</b>: the number of\n  test cases. <b>T</b> test cases follow.\n</p>\n\n<p>\n  Each test case begins with one line containing 3 integers <b>N</b>, <b>M</b> and\n  <b>P</b>, indicating the number of locations, roads, and <i>Codejamon</i> to catch,\n  respectively.\n</p>\n\n<p>\n  Then, each test case continues with <b>M</b> lines; the i-th of these lines\n  contains three integers <b>U<sub>i</sub></b>, <b>V<sub>i</sub></b> and\n  <b>D<sub>i</sub></b>, indicating that the i-th road is between locations\n  <b>U<sub>i</sub></b> and <b>V<sub>i</sub></b>, and it takes <b>D<sub>i</sub></b>\n  minutes to travel on it in either direction.\n</p>\n\n<h3>Output</h3>\n\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is\n  the test case number (starting from 1) and <code>y</code> is the expected time in\n  minutes to catch <b>P</b> <i>Codejamon</i>. Your answer will be considered\n  correct if it is within an absolute or relative error of 10<sup>-4</sup> of the\n  correct answer.\n  See the <a href=\"https://codingcompetitions.withgoogle.com/kickstart/faq\" target=\"_blank\">FAQ</a>\n  for an explanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n1 &le; <b>T</b> &le; 100.<br>\nTime limit: 40 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n<b>N</b> - 1 &le; <b>M</b> &le; (<b>N</b> * (<b>N</b> - 1)) / 2.<br>\n1 &le; <b>D<sub>i</sub></b> &le; 10, for all i.<br>\n1 &le; <b>U<sub>i</sub></b> &lt; <b>V<sub>i</sub></b> &le; <b>N</b>, for all i.<br>\nFor all i and j with i &ne; j, <b>U<sub>i</sub></b> &ne; <b>U<sub>j</sub></b> and/or\n  <b>V<sub>i</sub></b> &ne; <b>V<sub>j</sub></b>. (There is at most one road between\n  any two locations.)<br/>\nIt is guaranteed that it is possible to reach any other location from location 1\n  by travelling on one or more roads.<br/>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n2 &le; <b>N</b> &le; 50.<br>\n1 &le; <b>P</b> &le; 200.<br>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n2 &le; <b>N</b> &le; 100.<br>\n1 &le; <b>P</b> &le; 10<sup>9</sup>.<br>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2AfLJ9z8C65X8plshN7VXP7LeqjFTkCVEEH6RBfRv_P89X4mqVdDLnjL83frAqwdv1CNXtL-Bxpywyy3ctICR2JKzeJdx-4m3vLjDpXw/catch_them_all_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n5 4 1\n1 2 1\n2 3 2\n1 4 2\n4 5 1\n2 1 200\n1 2 5\n5 4 2\n1 2 1\n2 3 2\n1 4 2\n4 5 1\n3 3 1\n1 2 3\n1 3 1\n2 3 1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1IJzYbrygntLzOeVt2RbUQWd4J8U8zpSbE9b7DhbwlCWoVfIsRTMfe5lFq5RdZk4EBwGgtNIMNjypg-69CENnBwFZHkMDD_DmVH42Wg_s/catch_them_all_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 2.250000\nCase #2: 1000.000000\nCase #3: 5.437500\nCase #4: 1.500000\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, there is only one Codejamon for us to catch. With equal\n  probability, it will appear at locations 2, 3, 4, and 5, which are at distances of\n  1, 3, 2, and 3, respectively, from our starting location 1. So the expected time it\n  will take is (1 + 3 + 2 + 3) / 4 = 2.25 minutes.\n</p><p>\n  In Sample Case #2, there are only two locations connected by one road. Every time\n  a Codejamon appears, it will be in the location other than our current one, and we\n  will have to take the road to get there. So we take the road 200 times, taking 5\n  minutes each time, for a total of 1000 minutes.\n</p><p>\n  Sample Case #3 uses the same map as Sample Case #1. There are 16 ordered-pair\n  possibilities for where the two Codejamon will appear, and doing the math yields\n  an expected 87/16 = 5.4375 minutes.\n</p><p>\n  In Sample Case #4, the one Codejamon we need to catch will appear at location 2 or\n  location 3. If it appears at location 2, it is better for us to get there in two\n  minutes via the 1-to-3 and 3-to-2 roads, instead of taking the more time-consuming\n  1-to-2 road. So the expected time taken is (2 + 1) / 2 = 1.5 minutes.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Catch Them All","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Eat Cake: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  Let f(<b>N</b>) be the minimum number of cakes that have to be eaten such that\n  the total combined area of the eaten cakes is <b>N</b>. To compute\n  f(<b>N</b>), we can start by checking all possible sizes that we could use\n  for the first cake that we eat. If the first eaten cake has an area of\n  A &times; A, then we need to eat remaining cake(s) with a total combined area\n  of <b>N</b> - A &times; A, which requires at least f(<b>N</b> - A &times; A)\n  cakes to be eaten. Therefore, f(<b>N</b>) can be recursively computed as\n  follows:\n</p><pre>\nf(N)\n  if (N = 0)\n    return 0\n  ans = infinity\n  for i in [1, sqrt(N)]\n    ans = min(ans, f(N - i * i) + 1)\n  return ans\n</pre><p>\n  The algorithm above is fast enough to solve the Small dataset.\n</p>\n<h3>Large dataset</h3>\n<p>\n  We need to use\n  <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">dynamic programming</a>\n  (DP) / memoization to solve the large dataset. If the value of f(<b>N</b>)\n  has been recursively computed before, then the next time we need to know that\n  value, we can simply use the previously computed value. Since the DP table of\n  values has size O(<b>N</b>), and computing each value of f(<b>N</b>) takes\n  O(<b>N</b><sup>0.5</sup>) time, the total time for this algorithm is\n  O(<b>N</b><sup>1.5</sup>).\n</p><pre>\nf(N)\n  if (N = 0)\n    return 0\n  if (dp[N])\n    return dp[N]\n  dp[N] = infinity\n  for i in [1, sqrt(N)]\n    dp[N] = min(dp[N], f(N - i * i) + 1)\n  return dp[N]\n</pre>\n<h4>Alternative solution</h4>\n<p>\n  There is another solution that does not even require a recursive strategy.\n  From\n  <a href=\"https://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem\">Lagrange's four-square theorem</a>,\n  we know that f(<b>N</b>) cannot be larger than 4. Therefore, for each k\n  (1 &le; k &le; 3), we can simply have k nested loops of possible cake areas\n  to determine whether k cakes are enough. If 3 cakes are still not enough,\n  then the answer must be 4 (and we do not actually need to determine which\n  cakes are used).\n</p><pre>\nf(N)\n  for i in [1, sqrt(N)]\n    if (i * i = N)\n      return 1\n  for i in [1, sqrt(N)]\n    for j in [i, sqrt(N)]\n      if (i * i + j * j = N)\n        return 2\n  for i in [1, sqrt(N)]\n    for j in [i, sqrt(N)]\n      for k in [j, sqrt(N)]\n        if (i * i + j * j + k * k = N)\n          return 3\n  return 4\n</pre><p>\n  Since each layer of the triply nested loop adds O(<b>N</b><sup>0.5</sup>)\n  time, the total time for this algorithm is also O(<b>N</b><sup>1.5</sup>).\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0P08GphCKeiFyVMfDJCkeHN6-n5i0XoB1Vjrz9LNLuLman-zIS5FxHqDWFHlQYHntznKTOhMhs/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000201d2a","statement":"<h2>Problem</h2>\n\n<p>\nWheatley is at the best party in the world: it has infinitely many cakes! Each cake is a square with an integer side length (in cm). The party has infinitely many cakes of every possible integer side length. The cakes all have the same depth, so we will only consider their areas.\n</p><p>\nWheatley is determined to eat one or more cakes that have a total combined area of <i>exactly</i> <b>N</b> cm<sup>2</sup>. But, since he is health-conscious, he wants to eat as few cakes as possible. Can you help him calculate the minimum number of cakes he can eat?\n</p>\n\n<h3>Input</h3>\n\n<p>\n  The input starts with one line containing one integer <b>T</b>, which is the number of test cases. <b>T</b> test cases follow. Each case consists of one line with one integer <b>N</b>, which is the exact total cake area that Wheatley wants to eat.\n</p>\n\n<h3>Output</h3>\n\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the test case number (starting from 1) and <code>y</code> is the minimum number of cakes that Wheatley can eat while eating the exact total area <b>N</b>.\n</p>\n\n<h3>Limits</h3>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 50.<br>\n1 &le; <b>N</b> &le; 50.<br>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 100.<br>\n1 &le; <b>N</b> &le; 10000.<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2ASCtVtrtyILKhv0Hvqyw7RYvFVM8O3jQjhqegKQQbzbKJaBMIfp7sAN8Nk_8fKmu0mtGZR29lQgRvdV-_c0yjR2BC/cake_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n3\n4\n5</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3ws6T_m4bbAJXrNoAql8v8S81PqblboVMlgcPUUoir6YsAcb26N6w5oUD5XD9T2mMJ9JeAfe2w7AHBoJQ7GaE_FCSDhg/cake_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 3\nCase #2: 1\nCase #3: 2</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, the only possible strategy is for Wheatley to eat three cakes of side length 1.\n</p><p>\n  In Sample Case #2, Wheatley can eat one cake of side length 2, which requires fewer cakes than eating four cakes of side length 1.\n</p><p>\n  In Sample Case #3, the best strategy is for Wheatley to eat one cake of side length 2 and one cake of side length 1.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Cake","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201d29","type":1,"type__str":"SPECTATOR"},"title":"Round F 2017"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
