{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1222713600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000436baa","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\r\n  For the admins, the big question in this contest was whether anyone would\r\n  solve Problem D, King. Despite the confidence that you'll see in the problem's\r\n  editorial, we strongly suspected that this would be the first problem in\r\n  Google Code Jam 2008 that would go unsolved. The point value for its large\r\n  dataset reflected our pessimism: it was worth as much as the other three\r\n  larges put together!\r\n</p><p>\r\n  By the end of the contest, we had our answer: nobody had successfully solved\r\n  D-large, and the AMER local onsites were our first match where nobody solved\r\n  every problem. When we looked at some submissions, though, we found a story\r\n  behind the scenes: <b>Ying</b>, with great determination and only slightly too\r\n  much confidence, went for D immediately. Among the few attempts on D-large\r\n  (others of which used random methods), his was the only one that hit on the\r\n  key of the solution. Unfortunately a single error in a single line made his\r\n  program fail on a single test case, and he was left with too little time to\r\n  solve the other problems.\r\n</p><p>\r\n  The problems here were, in our view, the hardest among the three regional\r\n  onsites, and every problem required some careful thinking or implementation.\r\n  Only nine contestants submitted everything except D-large; some had minor\r\n  errors, and only three solved all seven datasets. In the end\r\n  <b>Bohua</b> claimed victory in this match, almost 8 minutes faster than\r\n  second-place <b>SkidanovAlexander</b>.\r\n</p>\r\n\r\n<hr>\r\n<p>\r\n  <b>Credits</b>\r\n</p><p>\r\n  Problem A. <i>Mixing Bowls</i>\r\n  Written by John Dethridge. Prepared by Igor Naverniouk and Lovro Puzar.\r\n</p><p>\r\n  Problem B. <i>Code Sequence</i>\r\n  Written by John Dethridge. Prepared by Bartholomew Furrow and Lovro Puzar.\r\n</p><p>\r\n  Problem C. <i>Test Passing Probability</i>\r\n  Written by Robert Renaud. Prepared by Robert Renaud and Marius Andrei.\r\n</p><p>\r\n  Problem D. <i>King</i>\r\n  Written by Cosmin Negruseri. Prepared by Tomek Czajka and Bartholomew Furrow.\r\n</p><p>\r\n  Contest analysis presented by Sebastian Kanthak, Bartholomew Furrow, Xiaomin\r\n  Chen, and Cosmin Negruseri.\r\n</p>\r\n","registration_gives_participant":false,"result_status":20,"result_status__str":"FULLY_VISIBLE","start_ms":1222706400000,"tasks":[{"analysis":"<h3>The Problem</h3>\n<p>\n  There are 4<sup>Q</sup> points in the space, each of which contains an\n  <i>answer combination</i> -- one answer for each of the <b>Q</b> questions.\n  Because the answers to the questions are independent of each other, the\n  probability of success at each point can be computed simply as the product of\n  the probabilities from each problem.\n</p><p>\n  So the simple mathematical model involves 4<sup>Q</sup> points, each with a\n  probability value. There is a single, hidden good point among the\n  4<sup>Q</sup> points; you may pick up to <b>M</b> points; and you win the\n  game if one of them is the good point. After you select a point, you learn if\n  it is good or not, but that does not change the relative probabilities of the\n  remaining points. The best strategy is simply looking at the points in the\n  order of their probability. Your task in this problem is to compute the\n  summation of the highest (up to) M among the 4<sup>Q</sup> values.\n</p>\n\n<h3>Solutions</h3>\n<p>\n  While Q looks moderate, 4<sup>Q</sup> steps of computation can be a huge task\n  that is probably not within your computer's capacity (or any computer's). The\n  important restriction in this problem is the fact that M is also moderate, and\n  we can compute the highest M values one by one.\n</p><p>\n  One solution uses a priority queue <b>L</b> that keeps all the answer\n  combination candidates for the <i>next</i> highest value -- after we computed\n  the first <b>k</b> values. A bit of thought should convince your that the\n  next-highest (the k+1<sup>th</sup>) combination must be gotten by taking one\n  of the first k combinations, and moving the answer to one of the questions one\n  step \"worse\", to the next-most-probable answer. So in each step we can get the\n  first element <b>S</b> (the one with the highest probability) from L, then add\n  (up to) Q new candidates back to L. Each of the new candidates is created by\n  moving one answer in S one step worse. The size of L will never exceed MQ, and\n  the time complexity is O(MQ log MQ).\n</p><p>\n  Another solution has an even simpler implementation: the idea is to add the\n  questions one by one. For the first <b>k</b> questions, there are\n  4<sup>k</sup> possible solution combinations, each with its own probability\n  of answering all of the first k questions correctly. When we add the\n  k+1<sup>th</sup> question, the new set of possible solution combinations,\n  along with its probabilities, can be calculated by taking each of the\n  4<sup>k</sup> previous values and multiplying it by the four probabilities\n  for each answer to question k+1. We can easily compute all of these values\n  and truncate to the top M, then repeat the process for the remaining\n  questions. The truncation is O(M log M), and this process is repeated Q\n  times, for a total time complexity of O(QM log M).\n</p>\n\n<h3>More information</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=discrete+probability\" target=\"_blank\">Discrete Probability</a> -\n  <a href=\"http://www.google.com/search?q=joint+distribution\" target=\"_blank\">Joint Distribution</a>\n</p>\n","id":"00000000004364fc","statement":"<h3>Problem</h3>\n<p>\n  Dave is taking a multiple choice test on the Internet. Dave possibly gets many\n  opportunities to submit his answers to the test, but he passes only if he gets\n  all the questions correct. He must answer every question on the test to make a\n  submission. The only information he receives after he submits is whether he\n  has passed.\n</p><p>\n  For each question, he estimates the probability that each of 4 responses is\n  correct, independent of his responses to other questions. Given a fixed number\n  of submissions he can make, Dave wants to choose his responses so that he\n  maximizes the probability of passing the test.\n</p><p>\n  What is the probability that Dave will pass the test if he chooses his\n  responses optimally?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>C</b>. <b>C</b> test\n  cases follow.\n</p><p>\n  Each test case starts with a line containing\n  <b>M</b> and <b>Q</b>. Dave is allowed to make <b>M</b> submissions to solve\n  the test. There are <b>Q</b> questions on the test. <b>Q</b> lines follow,\n  each containing 4 probabilities of correctness. There will be at most 6 digits\n  after the decimal point. The probabilities for each line are non-negative and\n  sum to 1.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>X</b>: <b>Y</b>\"\n  where <b>X</b> is the number of the test case (starting from 1), and\n  <b>Y</b> is the probability of success.<br>\n  Answers with a relative or absolute error of at most 10<sup>&minus;6</sup>\n  will be considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.<br>\n  1 &le; <b>C</b> &le; 100\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  Time limit: 60 seconds.<br>\n  1 &le; <b>Q</b> &le; 6<br>\n  1 &le; <b>M</b> &le; 1000\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  Time limit: 180 seconds.<br>\n  1 &le; <b>Q</b> &le; 30<br>\n  1 &le; <b>M</b> &le; 10000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n10 2\n0.25 0.25 0.25 0.25\n0.25 0.25 0.25 0.25\n64 3\n0.3 0.4 0.0 0.3\n1.0 0.0 0.0 0.0\n0.2 0.2 0.2 0.4\n3 2\n0.5 0.17 0.17 0.16\n0.5 0.25 0.25 0.0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.625\nCase #2: 1.0\nCase #3: 0.5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Test Passing Probability","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  Looking at the restrictions on the recipe, it should be obvious that the\n  recipes form a tree. It is also clear that basic ingredients can be ignored:\n  You just throw them into whatever bowl you're currently working on.\n</p><p>\n  Lets consider a recipe with <b>k</b> mixtures <b>m<sub>1</sub></b>,\n  ..., <b>m<sub>k</sub></b>. How many bowls do we need to prepare this recipe?\n  It does not make sense to work on more than one mixture at a time, so let's\n  try preparing the mixtures in the given order.\n</p><p>\n  We'll need <b>b<sub>1</sub></b> bowls to prepare the first mixture. For the\n  second mixture, we can reuse these bowls, except for one bowl that we need to\n  hold the first mixture. While preparing the third mixture (which requires\n  <b>b<sub>3</sub></b> bowls in itself) we will need two additional bowls to\n  hold the first two mixtures, and so on. Finally, once we have prepared all the\n  mixtures, they sit in <b>k</b> different bowls, and we'll need one additional\n  bowl to put everything together, and finish the recipe.\n</p><p>\n  How many bowls did we use in total? Keeping in mind that we can reuse bowls\n  from the previous step (except for the bowls to hold finished mixtures), we\n  will need <b>b</b> = max(<b>b<sub>i</sub></b> + <b>i</b> - 1) bowls to prepare\n  all mixtures, for a total of max(<b>b</b>, <b>k</b> + 1) to put everything\n  together.\n</p><p>\n  Looking at this formula, it is obvious that the number of bowls will be\n  minimized if we prepare the mixtures requiring the most bowls first. Thus, our\n  algorithm will first invoke itself recursively for every ingredient, sort the\n  results in descending order, and then use the formula given above to return a\n  result.\n</p>\n","id":"00000000004365f5","statement":"<h3>Problem</h3>\n<p>\n  You are following a recipe to create your lunch.\n</p><p>\n  The recipe is a mixture made by combining ingredients together in a bowl. Each\n  ingredient will be either:\n</p>\n<ul>\n  <li>Another mixture which you must make first in a separate bowl; or</li>\n  <li>\n    A basic ingredient you already have in your kitchen, which can be added\n    directly.\n  </li>\n</ul>\n<p>\n  To make a mixture, you need to have all its ingredients ready, take an empty\n  bowl and mix the ingredients in it. It is not possible to make mixtures by\n  adding ingredients to an already-existing mixture in a bowl.\n</p><p>\n  For example, if you want to make CAKE (a mixture) out of CAKEMIX (a mixture)\n  and lies (a basic ingredient), then you must first make CAKEMIX in its own\n  bowl, then add the CAKEMIX and lies to a second bowl to make the CAKE.\n</p><p>\n  Once you have used a mixture as an ingredient and emptied the bowl it was\n  prepared in, you can re-use that bowl for another mixture. So the number of\n  bowls you need to prepare the recipe will depend on the order in which you\n  decide to make mixtures.\n</p><p>\n  Determine the minimum number of bowls you will need.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line will contain an integer <b>C</b>, the number of test cases in\n  the input file.\n</p><p>\n  For each test case, there will be:\n</p>\n<ul>\n  <li>\n    One line containing an integer <b>N</b>, the number of mixtures in the test\n    case.\n  </li>\n  <li><b>N</b> lines, one for each mixture, containing:</li>\n  <ul>\n    <li>One string giving the mixture name;</li>\n    <li>An integer <b>M</b>, the number of ingredients in this mixture;</li>\n    <li>\n      <b>M</b> strings, giving the names of each of the ingredients of this\n      mixture.\n    </li>\n  </ul>\n</ul>\n<p>\n  The tokens on one line will be separated by single spaces.\n</p><p>\n  The first mixture in a test case is the recipe you are making.\n</p><p>\n  The names of mixtures are strings of between 1 and 20 UPPERCASE letters.\n</p><p>\n  The names of basic ingredients are strings of between 1 and 20 lowercase\n  letters.\n</p><p>\n  Each mixture is used in exactly one other mixture, except for the recipe,\n  which is not used in any other mixture. Each ingredient will appear at most\n  once in the ingredient list for a mixture. No mixture will (directly or\n  indirectly) require itself as an ingredient.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>X</b>: <b>Y</b>\"\n  where <b>X</b> is the number of the test case, starting from 1, and\n  <b>Y</b> is the minimum number of mixing bowls required.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>C</b> &le; 10<br>\n  2 &le; <b>M</b> &le; 10\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 1000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\nSOUP 3 STOCK salt water\nSTOCK 2 chicken VEGETABLES\nVEGETABLES 2 celery onions\n5\nMILKSHAKE 4 milk icecream FLAVOR FRUIT\nFRUIT 2 banana berries\nFLAVOR 2 SPICES CHOCOLATE\nSPICES 2 nutmeg cinnamon\nCHOCOLATE 2 cocoa syrup\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In the first case, to satisfy your craving for SOUP, you follow these steps:\n</p>\n<ol>\n  <li>Make VEGETABLES by mixing celery and onions in a bowl.</li>\n  <li>\n    Make STOCK in a second bowl by mixing chicken and VEGETABLES from the\n    first bowl. The first bowl becomes empty.\n  </li>\n  <li>Make SOUP in the first bowl by mixing STOCK, salt and water.</li>\n</ol>\n<p>\n  In the second case, you have a choice of whether to make FLAVOR or FRUIT\n  first before mixing them with milk and icecream to make MILKSHAKE.\n</p><p>\n  If we make FRUIT first, we use four bowls:\n</p>\n<ol>\n  <li>Make FRUIT in a bowl by mixing banana and berries.</li>\n  <li>\n    Make SPICES in a second bowl by mixing nutmeg and cinnamon, and CHOCOLATE\n    in a third bowl by mixing cocoa and syrup. (In either order)\n  </li>\n  <li>Make FLAVOR in a fourth bowl by mixing SPICES and CHOCOLATE.</li>\n  <li>\n    Make MILKSHAKE in the second or third bowl by mixing FRUIT, FLAVOR, milk\n    and icecream.\n  </li>\n</ol>\n<p>\n  However if we make FRUIT after FLAVOR, we use three bowls:\n</p>\n<ol>\n  <li>\n    Make SPICES in a bowl by mixing nutmeg and cinnamon, and CHOCOLATE in a\n    second bowl by mixing cocoa and syrup. (In either order)\n  </li>\n  <li>Make FLAVOR in a third bowl by mixing SPICES and CHOCOLATE.</li>\n  <li>Make FRUIT in the first bowl by mixing banana and berries.</li>\n  <li>\n    Make MILKSHAKE in the second bowl by mixing FRUIT, FLAVOR, milk and\n    icecream.\n  </li>\n</ol>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":9}],"title":"Mixing Bowls","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  The problem corresponds to a relatively unknown game named Slither. This game\n  was popularized by Martin Gardner in one of his columns written for Scientific\n  American. It wasn't solved then, but eventually William Anderson developed a\n  solution. Of course Code Jam participants are much smarter, so we thought the\n  problem would easily get solved in two hours.\n</p><p>\n  I'll explain first the solution for a simpler variant of the problem. Suppose\n  we have a <i>3x3</i> board with the king being in one of the corner cells. Now\n  let's cover the rest of the board with dominoes of size <i>2x1</i>. This\n  tiling of the board shows us a winning strategy for the second player. Each\n  time the first player moves to one cell of a domino, the second player will\n  move to the other cell of that domino. Since the second player can always make\n  a move after the first player moves, the second player has a winning strategy.\n</p><p>\n  The general solution goes along the same lines: the domino tiling corresponds\n  to a maximum matching. We think of the board as a graph where the cells are\n  the nodes, and neighboring cells have edges between them. The dominoes, then,\n  correspond to edges in the maximum matching.\n</p><p>\n  The solution is given by the following theorem:\n  <i>\n    \"The first player has a winning strategy if and only if all maximum\n    matchings contain the king's node\"\n  </i>.\n</p><p>\n  This means that no alternating path starting from the king's node ends in a\n  vertex that is not in the matching, because if it ended in a unmatched vertex\n  we could construct another matching with the same number of edges that doesn't\n  use the king's node. Thus the first player could always move along a matched\n  edge.\n</p><p>\n  If there is a maximum matching that doesn't contain the king's node, then in\n  this graph every alternating path that starts from the kings node ends in a\n  matched node, otherwise we could increase the size of the matching which\n  contradicts the assumption that the matching is maximum. Thus now the second\n  player can always move in the second node of the matching edges. So the second\n  player has a winning strategy.\n</p><p>\n  The graph in our problem is not bipartite so we can't use the standard\n  algorithm for bipartite matching. Instead we use a solution that combines\n  brute force and dynamic programming. Our solution will be exponential rather\n  than polynomial, but the size of the problem is small so we can afford it. We\n  go row by row from left to right, and for each cell <i>(i, j)</i> and each\n  subset <i>S</i> of <i>{0, 1, .. n - 1}</i> we compute the best matching that\n  has the following nodes matched already: nodes on the active line\n  (<i>[i][0..j], [i-1][j+1 .. n - 1]</i>) that correspond to the numbers in\n  <i>S</i>, and matched nodes from before the active line.\n</p><p>\n  Here's Derek Kisman's code that implements this solution:\n</p>\n<pre>\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint gx, gy;\nchar g[15][15];\n\nchar memo[15][15][1&lt;&lt;16];\nchar doit(int x, int y, int b) {\n  if (x == gx) {\n    x = 0;\n    if (++y == gy) return 0;\n  }\n  char&amp; ret = memo[x][y][b];\n  if (ret != -1) return ret;\n  int b2 = (b&lt;&lt;1) &amp; ((1&lt;&lt;(gx+1))-1);\n  if (g[y][x] != '.') {\n    ret = doit(x+1, y, b2);\n  } else {\n    ret = doit(x+1, y, b2+1);\n    if (x &amp;&amp; (b&amp;1)) ret &gt;?= 1 + doit(x+1, y, b2-2);\n    if (x &amp;&amp; (b&amp;(1&lt;&lt;gx)))\n      ret &gt;?= 1 + doit(x+1, y, b2);\n    if (b&amp;(1&lt;&lt;(gx-1)))\n      ret &gt;?= 1 + doit(x+1, y, b2-(1&lt;&lt;gx));\n    if (x &lt; gx-1 &amp;&amp; (b&amp;(1&lt;&lt;(gx-2))))\n      ret &gt;?= 1 + doit(x+1, y, b2-(1&lt;&lt;(gx-1)));\n  }\n  return ret;\n}\n\nmain() {\n  int N, prob=1;\n  for (cin &gt;&gt; N; N--;) {\n    cin &gt;&gt; gy &gt;&gt; gx;\n    int kx, ky;\n    for (int y = 0; y &lt; gy; y++)\n    for (int x = 0; x &lt; gx; x++) {\n      cin &gt;&gt; g[y][x];\n      if (g[y][x] == 'K') {kx = x; ky = y;}\n    }\n    memset(memo, -1, sizeof(memo));\n    int m1 = doit(0, 0, 0);\n    g[ky][kx] = '.';\n    memset(memo, -1, sizeof(memo));\n    int m2 = doit(0, 0, 0);\n    cout &lt;&lt; \"Case #\" &lt;&lt; prob++\n         &lt;&lt; \": \" &lt;&lt; ((m2 &gt; m1) ? 'A' : 'B')\n         &lt;&lt; endl;\n  }\n}\n</pre>\n","id":"0000000000436bf4","statement":"<h3>Problem</h3>\n<p>\n  Alice and Bob want to play a game. The game is played on a chessboard with\n  <b>R</b> rows and <b>C</b> columns, for a total of <b>RC</b> squares. Some of\n  these squares are burned.\n</p><p>\n  A king will be placed on an unburned square of the board, and Alice and Bob\n  will make successive moves with the king.\n</p><p>\n  In a move, the player must move the king to any of its 8 neighboring squares,\n  with the following two conditions:\n</p>\n<ul>\n  <li>The destination square must not be burned</li>\n  <li>The king must never have been in the destination square before.</li>\n</ul>\n<p>\n  If a player can't make a move, he or she loses the game. Alice will move\n  first; you need to determine who will win, assuming both players play\n  optimally.\n</p>\n\n<h3>Input</h3>\n<p>The first line of input gives the number of cases, <b>N</b>.</p><p>\n  <b>N</b> test cases follow. The first line of each case will contain two\n  integers, <b>R</b> and <b>C</b>. The next <b>R</b> lines will contain strings\n  of length <b>C</b>, representing the <b>C</b> squares of each row. Each string\n  will contain only the characters '.', '#' and 'K':\n</p>\n<ul>\n  <li>'#' means the square is burned;</li>\n  <li>'.' means the square is unburned, and unoccupied; and</li>\n  <li>'K' means the king is in that cell at the beginning of the game.</li>\n</ul>\n<p>\n  There will be only one 'K' character in each test case.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>X</b>: \" (where\n  <b>X</b> is the case number, starting from 1) followed by A if Alice wins, or\n  B if Bob wins.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.<br>\n  1 &le; <b>N</b> &le; 100\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  Time limit: 30 seconds.<br>\n  1 &le; <b>R</b>, <b>C</b> &le; 4\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  Time limit: 180 seconds.<br>\n  1 &le; <b>R</b>, <b>C</b> &le; 15\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2 2\nK.\n.#\n4 2\nK#\n.#\n.#\n.#\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: B\nCase #2: A\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":38}],"title":"King","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>The Problem</h3>\n<p>\n  Normally when you count in base 2, each bit is worth a fixed amount: {..., 8,\n  4, 2, 1}. So when you count 0000, 0001, 0010, 0011, and so on, you get the\n  sequence [0, 1, 2, 3, ...]. In this problem, we ask you to consider what would\n  happen if the bits were worth hidden amounts, \"bit values,\" specified by us.\n  For example, if the bits were worth {..., 200, 10, 1}, then you could get the\n  sequence [0, 1, 10, 11, 200, 201, ...].\n</p><p>\n  What this problem asks you to do is find the next number in the generated\n  sequence. To make things more difficult, we don't necessarily start at 0000 or\n  0001, so what may seem obvious:\n</p>\n<pre>[1, 10, 11, 200, 201, ?, ...]</pre>\n<p>\n  ...may not be. This could have come from the bit values {..., 200, 10, 1},\n  which would give <b>210</b>; but it could also have come from bit values {...,\n  -1180, 1190, 990, 190, 1}. If we start counting from 10000, that gives:\n</p>\n<pre>[-1180, -1179, -990, -989, -190, -189, <b>0, 1, 10, 11, 200, 201, 1000</b>]</pre>\n\n<h3>The Solution</h3>\n<p>\n  So how do we solve the problem? Let's have a look at the generated sequence\n  above, and look for interesting features. One thing that may strike you is\n  that every second number is 1 higher than the last, so let's look at the\n  sequence of differences between adjacent numbers:\n</p>\n<pre>(1, 189, 1, 799, 1, 189, 1, 9, 1, 189, 1, 799)</pre>\n<p>\n  The differences of 1 make a lot of sense: every <i>second</i> increase in a\n  binary number just changes the lowest bit from 0 to 1. So if your sequence of\n  differences looks like (x, a, x, b), or (a, x, b), then the next difference\n  must be x. Figuring that out should let you solve the small input.\n</p><p>\n  But how far can we take this? Let's eliminate all the times only the lowest\n  bit was changed. This leaves us with the following sequence of differences:\n</p>\n<pre>(189, 799, 189, 9, 189, 799)</pre>\n<p>\n  Every second number there is a 189. That makes sense too: every\n  <i>fourth</i> increase in a binary number is the same, changing the lowest two\n  bits from 01 to 10. Likewise, every <i>eighth</i> increase changes the lowest\n  three bits from 011 to 100.\n</p><p>\n  So where does this leave us? Looking for repetition; seeing if we can use it;\n  and if not, eliminating it. For example, if our generated sequence is:\n</p>\n<pre>[0, 1, 3, 4, 7, 8, 17, 18, 21, 22, 24, 25]</pre>\n<p>\n  Our sequence of differences is:\n</p>\n<pre>(1, 2, 1, 3, 1, 9, 1, 3, 1, 2, 1)</pre>\n<p>\n  Since the sequence ends with the repeated number, 1, we don't know yet what\n  comes next. Eliminating the 1s, we arrive at:\n</p>\n<pre>(2, 3, 9, 3, 2)</pre>\n<p>\n  Aha! The next difference must be 3, and the answer is 28. If that hadn't\n  worked, we would have kept going recursively until we found the answer.\n</p><p>But what if the sequence of differences is:</p>\n<pre>(1, 2, 1, 2, 1)</pre>\n<p>\n  Here, we can't tell if the lowest bit was changing for a difference of 1 or a\n  difference of 2, so we can't say for sure what's next. We (eventually) arrive\n  at the same problem in all of the following sequences of differences:\n</p>\n<pre>\n(1, 2)\n(3)\n(4, 3, 4)\n(5, 4, 5, 3, 5, 4, 5)\n(6, 5, 6, 4, 6, 5, 6, 3, 6, 5, 6, 4, 6, 5, 6)\n</pre>\n<p>\n  Here it's IMPOSSIBLE to find the answer: that (1, 2) could be (1, 2, 1) or (1,\n  2, 10, 2). (4, 3, 4) could have come from:\n</p>\n<pre>\n10001 10010 10011 10100 10101\n(4, 3, 4, <b>3</b>)\n</pre>\n<p>\n  or from:\n</p>\n<pre>\n00100 00101 00110 00111 01000\n(4, 3, 4, <b>?</b>)\n</pre>\n<p>\n  There's no way to tell where you are in the range [0, 1000000000], so you\n  could be about to hit a whole new bit and you wouldn't know it.\n</p>\n\n<h3>Comments</h3>\n<p>\n  When we add up the values of our bits, we work modulo 10007. I used negative\n  numbers earlier because the concept is well-defined in mod space: \"-1180\" mod\n  10007 is 8827, which is to say that adding 8827 to anything higher than 1180\n  is the same as subtracting 1180 from it.\n</p><p>\n  One of the nice things about Code Jam is that you can test your assumptions.\n  When writing the input generator for this problem, I asserted that the\n  difference must look like [x, a, x, b, x, c, ...] or [a, x, b, x, c, x, ...].\n  This let me catch a bug in my code: I wasn't taking the differences mod 10007!\n  In a live contest, I would have had time to fix that and submit.\n</p><p>\n  Finally, there's one limit that's a red herring: that the sequence can't go\n  past 10<sup>9</sup>. It isn't hard to convince yourself that the restriction\n  is meaningless: any sequence of length 1000 can't affect more than 11 separate\n  bits, so it doesn't matter if the highest bit is #13 or #32.\n</p>\n","id":"0000000000436e29","statement":"<h3>Problem</h3>\n<p>\n  You are trying to compute the next number in a sequence S<sub>n</sub>\n  generated by a secret code. You know that the code was generated according to\n  the following procedure.\n</p><p>\n  First, for each k between 0 and 29, choose a number C<sub>k</sub> between 0\n  and 10006 (inclusive).\n</p><p>\n  Then, for each integer n between 0 and\n  1<sub>&nbsp;</sub>000<sub>&nbsp;</sub>000<sub>&nbsp;</sub>000 (inclusive):\n</p>\n<ul>\n  <li>Write n in binary.</li>\n  <li>\n    Take the numbers C<sub>k</sub> for every bit k that is set in the binary\n    representation of n. For example, when n=5, bits 0 and 2 are set, so\n    C<sub>0</sub> and C<sub>2</sub> are taken.\n  </li>\n  <li>\n    Add these C<sub>k</sub> together, divide by 10007, and output the remainder\n    as S<sub>n</sub>.\n  </li>\n</ul>\n<p>\n  You will be given a series of consecutive values of sequence S, but you don't\n  know at which point in the sequence your numbers begin (although you do know\n  that there is at least one more number in the sequence), and you don't know\n  what values of C<sub>k</sub> were chosen when the sequence was generated.\n</p><p>\n  Find the next number in the sequence, or output UNKNOWN if this cannot be\n  determined from the input data.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line will contain an integer <b>T</b>, the number of test cases in\n  the input file.\n</p><p>\n  For each test case, there will be:\n</p>\n<ul>\n  <li>\n    One line containing the integer <b>N</b>, the number of elements of sequence\n    S that you have.\n  </li>\n  <li>\n    One line containing <b>N</b> single-space-separated integers between 0 and\n    10006, the known elements of the sequence.\n  </li>\n</ul>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>X</b>: <b>Y</b>\"\n  where <b>X</b> is the number of the test case, starting from 1, and\n  <b>Y</b> is the next number in the sequence, or the string UNKNOWN if the next\n  number cannot be determined.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>T</b> &le; 20\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 5\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 1000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n7\n1 2 3 4 5 6 7\n4\n1 10 11 200\n4\n1000 1520 7520 7521\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: UNKNOWN\nCase #2: 201\nCase #3: 3514\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In the first case, C<sub>0</sub>, C<sub>1</sub> and C<sub>2</sub> might have\n  been 1, 2 and 4, and the values of S<sub>n</sub> we have starting at n=1. If\n  this is correct, we don't know C<sub>3</sub>, so the next number in the\n  sequence could be anything! Therefore the answer is unknown.\n</p><p>\n  In the second case, we cannot know all the values of C<sub>k</sub> or even\n  what n is, but we can prove that in any sequence, if 1, 10, 11, 200 occur in\n  order, then the next value will always be 201.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Code Sequence","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000436baa","type":1,"type__str":"SPECTATOR"},"title":"AMER Semifinal 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
