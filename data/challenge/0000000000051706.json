{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1556476200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000051706","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Round 1B opened with <i>Manhattan Crepe Cart</i>, which became a lot easier\n  if you realized that the multiple dimensions in the problem could be handled\n  independently. In <i>Draupnir</i>, just as in this year's other interactive\n  problems so far, you were able to ask for only a very small amount of data,\n  from which you had to extract a lot of information. (Code Jam authors don't\n  always attend the opera, but when they do, they end up writing contest\n  problems in their heads instead of paying attention!) Finally,\n  <i>Fair Fight</i> presented a dueling challenge that was tough even for a\n  third Round 1 problem.\n</p><p>\n  <b>Benq</b> earned our first perfect score, only 29 minutes and 41 seconds\n  into the contest (plus 4 minutes for one penalty attempt). Just as in 1A, our\n  second perfect score came from a previous Distributed Code Jam champion, and\n  in this case a two-time one: <b>bmerry</b>. That was at 42:35, and the third\n  perfect score was from <b>alex20030190</b> at 52:17. By the end of the\n  contest, there were almost 200 perfect scores &mdash; our contestants never\n  cease to impress us!\n</p><p>\n  This time, the (tentative) cutoff for advancement is 51 points plus a small\n  enough penalty time. That corresponds to solving all of the first problem and\n  the Visible test sets of the other two. Once again, our interactive problem\n  turned out to be a bit tougher than anticipated!\n</p><p>\n  As usual, we will need some time to review the submissions before finalizing\n  the results, but if you make the cut, you can expect confirmation within the\n  next few days. Otherwise, next weekend's Round 1C will be the last chance to\n  advance to Round 2. Good luck!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Manhattan Crepe Cart: Written by Shane Carr. Prepared by Anubhav Srivastava.\n</p><p>\n  Draupnir: Written by Ian Tullis. Prepared by Pablo Heiber.\n</p><p>\n  Fair Fight: Written by Kevin Tran. Prepared by Darcy Best and Kevin Tran.\n</p><p>\n  Solutions and other problem preparation and review by Patrick Au, Liang Bai,\n  Darcy Best, Shane Carr, Jonathan Irvin Gunawan, Md Mahbubul Hasan,\n  Andy Huang, Ray Robinson, and Kevin Tran.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Manhattan Crepe Cart: Ian Tullis</li>\n  <li>Draupnir: Darcy Best</li>\n  <li>Fair Fight: Darcy Best and Pablo Heiber</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1556467200000,"tasks":[{"analysis":"<p>\n  In this problem, we need to determine the number of each type of\n  X-day ring by querying the total number of rings in existence at the\n  end of a certain day.\n</p><p>\n  Let R<sub>1</sub> be the number of 1-day rings, R<sub>2</sub> be the number\n  of 2-day rings, ... etc. at the end of day 0. The\n  number of X-day rings doubles at the end of every day that is a\n  multiple of X. Thus, the total number of rings on day i is\n  <pre>\n    R<sub>1</sub>*2<sup>i</sup> + R<sub>2</sub>*2<sup>floor(i/2)</sup> + R<sub>3</sub>*2<sup>floor(i/3)</sup> + R<sub>4</sub>*2<sup>floor(i/4)</sup> + R<sub>5</sub>*2<sup>floor(i/5)</sup> + R<sub>6</sub>*2<sup>floor(i/6)</sup>.\n  </pre>\n</p>\n<h3>Test set 1</h3>\n<p>\n  In the first test set, we are allowed six queries to determine the\n  six unknown variables.  Note that if we query any day number larger\n  than 63, then the number of 1-day rings on that day will be a\n  multiple of 2<sup>63</sup> (equivalently, it is 0 modulo\n  2<sup>63</sup>). Similarly, if we query any day number larger than\n  X*63, then the number of X-day rings will be 0 modulo 2<sup>63</sup>\n  on that day.\n</p><p>\n  Thus, on day 315 (=5*63), the total number of rings, modulo\n  2<sup>63</sup>, is R<sub>6</sub>*2<sup>52</sup> (since the number\n  of 1-day, 2-day, ..., 5-day rings are all 0 modulo\n  2<sup>63</sup>). Since R<sub>6</sub> &le; 100, we know that\n  R<sub>6</sub>*2<sup>52</sup> does not exceed 2<sup>63</sup>, so we\n  can directly determine R<sub>6</sub>. Then, on day 252 (=4*63), the\n  total number of rings, modulo 2<sup>63</sup>, is\n  R<sub>6</sub>*2<sup>42</sup> + R<sub>5</sub>*2<sup>50</sup>. Since\n  we already know R<sub>6</sub> and we know this sum cannot be more\n  than 2<sup>63</sup>, we can solve for R<sub>5</sub>. We may continue\n  this process by querying days 189 (=3*63), 126 (=2*63), 63 (=1*63)\n  and 1 to determine R<sub>4</sub>, R<sub>3</sub>, R<sub>2</sub> and\n  R<sub>1</sub>, respectively.\n</p>\n<h4>Alternative</h4>\n<p>\n  Note that since we are querying six days and attempting to solve for\n  six variables, we may choose to query (for example) days 1,2, ... , 6.\n  This gives us a system of equations with six equations and six variables.\n  Since these equations are linearly independent, we can solve this system,\n  via <a href=\"https://en.wikipedia.org/wiki/Gaussian_elimination\">Gaussian elimination</a>\n  for example, to get the solution.\n</p>\n<h3>Test set 2</h3>\n<p>\n  The second test set requires another insight. We are only given two\n  queries, so we must be able to solve for multiple R<sub>i</sub> at\n  once.\n</p><p>\n  Let's think about what information we get by querying day 189\n  (=3*63). This gives R<sub>6</sub>*2<sup>31</sup> +\n  R<sub>5</sub>*2<sup>37</sup> + R<sub>4</sub>*2<sup>47</sup>, modulo\n  2<sup>63</sup>.  However, it is possible that there is some\n  overlap between R<sub>6</sub>*2<sup>31</sup> and\n  R<sub>5</sub>*2<sup>37</sup>. For example, all other things being equal, we\n  would not be able to differentiate between the case where R<sub>6</sub>=64 and\n  R<sub>5</sub>=0 and the case where R<sub>6</sub>=0 and\n  R<sub>5</sub>=1. Both of these would have 2<sup>37</sup> total rings.\n</p><p>\n  We must use the fact that R<sub>i</sub> &le; 100. In order for the\n  number of i-day rings to not interfere with the number of (i-1)-day\n  rings on day d, we need 2<sup>floor(d/(i-1))</sup> > 100 *\n  2<sup>floor(d/i)</sup> (note that this is equivalent to\n  floor(d/(i-1)) &ge; floor(d/i)+7 since 2<sup>7</sup> > 100). If we\n  ignore the modulo 2<sup>63</sup> restriction, then we could solve\n  the question in a single query of (for example) 1000. This would\n  give us\n  <pre>\n    R<sub>1</sub>*2<sup>1000</sup> + R<sub>2</sub>*2<sup>500</sup> + R<sub>3</sub>*2<sup>333</sup> + R<sub>4</sub>*2<sup>250</sup> + R<sub>5</sub>*2<sup>200</sup> + R<sub>6</sub>*2<sup>166</sup>.\n  </pre>\n  Since R<sub>i</sub> &le; 100, we coud determine R<sub>6</sub> by\n  taking this value modulo 2<sup>200</sup> to get\n  R<sub>6</sub>*2<sup>166</sup>, then by dividing by 2<sup>166</sup>.\n  We then could iteratively determine R<sub>5</sub>, R<sub>4</sub>, ...,\n  R<sub>1</sub>. However, this idea does not work since the problem is\n  modulo 2<sup>63</sup>. There is no single query that can\n  give us all of the information we need, modulo 2<sup>63</sup>.\n</p><p>\n  We will use one query to determine the values of\n  R<sub>4</sub>, R<sub>5</sub>, and R<sub>6</sub>, followed by a\n  second query to determine the values of R<sub>1</sub>,\n  R<sub>2</sub>, and R<sub>3</sub>. We saw above that a query of 189\n  (=3*63) will not work. However, a query of (for example) 200 will\n  work:\n  <pre>\n    R<sub>4</sub>*2<sup>50</sup> + R<sub>5</sub>*2<sup>40</sup> + R<sub>6</sub>*2<sup>33</sup>,\n  </pre>\n  and then solve for each in the same way as for the 1000 case. We can\n  then make a second query of (for example) 56:\n  <pre>\n    R<sub>1</sub>*2<sup>56</sup> + R<sub>2</sub>*2<sup>28</sup> + R<sub>3</sub>*2<sup>18</sup> + R<sub>4</sub>*2<sup>14</sup> + R<sub>5</sub>*2<sup>11</sup> + R<sub>6</sub>*2<sup>9</sup>.\n  </pre>\n  We know the value of R<sub>4</sub>, R<sub>5</sub>, and R<sub>6</sub>\n  from the first step, so we may substitute those in and then solve\n  for R<sub>1</sub>, R<sub>2</sub>, and R<sub>3</sub> one-by-one.\n</p><p>\n  Note that the choice of 200 and 56 above were not the only possible\n  options. In this problem, we could either guess-and-check for these\n  values offline or (preferably) write a loop in the program to find\n  two values that satisfy the criteria. We also need to ensure that\n  the term with the largest exponent is not too large. For example,\n  we cannot use a query of 250 in the first step since this gives\n  R<sub>4</sub>*2<sup>62</sup> + R<sub>5</sub>*2<sup>50</sup> +\n  R<sub>6</sub>*2<sup>41</sup>, because the first term\n  (R<sub>4</sub>*2<sup>62</sup>) may be at least 2<sup>63</sup>.\n</p>\n","id":"0000000000122837","statement":"<h3>Problem</h3>\n<p>\n  Odin has some magical rings which produce copies of themselves. Each\n  \"X-day ring\" produces one more X-day ring every X days after the day it came\n  into existence. These rings come in six possible varieties: 1-day, 2-day,\n  ..., all the way up to 6-day.\n</p><p>\n  For example, a 3-day ring that came into existence on day 0 would do nothing\n  until day 3, when it would produce another 3-day ring. Then, on day 6, each\n  of those two rings would produce another 3-day ring, and so on.\n</p><p>\n  You know that Odin had no rings before day 0. On day 0, some rings came into\n  existence. At the end of day 0, Odin had R<sub>i</sub> i-day rings, for each\n  1 &le; i &le; 6. You know that 0 &le; R<sub>i</sub> &le; 100, for all i,\n  and at least one of the R<sub>i</sub> values is positive.\n</p><p>\n  Fortunately, you also have access to the secret well of knowledge. Each time\n  you use it, you can find out the <i>total</i> number of rings that Odin had\n  at the end of a particular day between day 1 and day 500, inclusive. The well\n  will give you the answer modulo 2<sup>63</sup>, because even it can only hold\n  so much information! Moreover, you can only use the well up to <b>W</b>\n  times.\n</p><p>\n  Your goal is to determine how many rings of each type Odin had at the end of\n  day 0 &mdash; that is, you must find each of the R<sub>i</sub> values.\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the\n  information in the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\">\n  Interactive Problems section</a> of our FAQ.\n</p><p>\n  Initially, your program should read a single line containing two integers\n  <b>T</b>, the number of test cases, and <b>W</b>, the number of times you are\n  allowed to use the well of knowledge per test case. Then, you need to\n  process <b>T</b> test cases.\n</p><p>\n  In each test case, your program processes up to <b>W</b> + 1 exchanges\n  with our judge. You may make up to <b>W</b> exchanges of the following form:\n</p>\n<ul>\n  <li>Your program outputs one line with a single integer D between 1 and 500,\n    inclusive.\n  </li>\n  <li>The judge responds with one line with a single integer: the total number\n    of rings that Odin had at the end of day D, modulo 2<sup>63</sup>. If you\n    send invalid data (e.g., a number out of range, or a malformed line), the\n    judge instead responds with <code>-1</code>.\n  </li>\n</ul>\n<p>\n  After between 0 and <b>W</b> exchanges as explained above, you must perform\n  one more exchange of the following form:\n</p>\n<ul>\n  <li>Your program outputs one line with six integers R<sub>1</sub>,\n    R<sub>2</sub>, R<sub>3</sub>, R<sub>4</sub>, R<sub>5</sub>, R<sub>6</sub>,\n    where R<sub>i</sub> represents the number of i-day rings\n    that Odin had at the end of day 0.\n  </li>\n  <li>\n    The judge responds with one line with a single integer: <code>1</code> if\n    your answer is correct, and <code>-1</code> if it is not (or you have\n    provided a malformed line).\n  </li>\n</ul>\n<p>\n  After the judge sends <code>-1</code> to your input stream (because of either\n  invalid data or an incorrect answer), it will not send any other output.\n  If your program continues to wait for the judge after receiving\n  <code>-1</code>, your program will time out, resulting in a Time Limit\n  Exceeded error. Notice that it is your responsibility to have your program\n  exit in time to receive a Wrong Answer judgment instead of a Time Limit\n  Exceeded error. As usual, if the memory limit is exceeded, or your program\n  gets a runtime error, you will receive the appropriate judgment.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 50.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>W</b> = 6.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>W</b> = 2.<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1561aFSkJY9JSNXPlh13x0bDAicC6-HeIT7DAPZPYDBDP4xgOnJiJAnBJlLWNRvcSPR-AXf-3PfvtxlR1T/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n<p>\n  This interaction corresponds to Test set 1. Suppose that, unbeknownst to us,\n  the judge has decided that Odin had one ring of each of the six types at\n  the end of day 0.\n</p>\n<pre>\n  t, w = readline_int_list()   // Reads 50 into t and 6 into w\n  printline 3 to stdout        // Asks about day 3.\n  flush stdout\n  n = readline_int()           // Reads 15 into n.\n  printline 1 to stdout        // Asks about day 1.\n  flush stdout\n  n = readline_int()           // Reads 7 into n.\n  printline 1 1 1 3 0 0 to stdout\n  flush stdout                 // We make a guess even though we could have\n                               // queried the well up to four more times.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n</pre>\n<p>\n  Notice that even though the guess was consistent with the information we\n  received from the judge, we were still wrong because we did not find the\n  correct values.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Draupnir","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  Let us call a pair (L, R) <i>fair</i> if choosing it produces a fair fight. Notice that\n  since there are only 100 entries, there are at most 100*101/2 = 5050 possible intervals.\n  For each interval, we may simply search for the maximum value is in each array via a\n  linear search and check if those maximum values are close enough.\n</p>\n<h3>Test set 2</h3>\n<p>\n  Notice the random choice of sword in case of ties does not change whether (L, R)\n  is fair or not, so we can further assume that, if there are ties, they are broken by choosing\n  the sword with smallest index. To simplify the write-up below, we assume that each\n  <b>C</b><sub>i</sub> is distinct.\n</p><p>\n  Let us consider a sub-problem: for each sword i that Charles can choose, how many fair\n  intervals (L,R) are there which Charles chooses sword i? Let us call this value F<sub>i</sub>.\n  The answer to the original problem is simply the sum of the F<sub>i</sub>s. For each interval\n  (L,R), there are three properties we are concerned with:\n</p><ul>\n  <li>(P1) Charles chooses sword i. That is, L &le; i &le; R and\n    max(<b>C</b><sub>L</sub>,<b>C</b><sub>L+1</sub>,...,<b>C</b><sub>R</sub>) = <b>C</b><sub>i</sub>.\n  </li>\n  <li>(P2) Charles' sword is <i>good enough</i>. That is,\n    max(<b>D</b><sub>L</sub>,<b>D</b><sub>L+1</sub>,...,<b>D</b><sub>R</sub>) &le; <b>C</b><sub>i</sub> + <b>K</b>.\n  </li>\n  <li>(P3) Charles' sword is <i>too good</i>. That is,\n    max(<b>D</b><sub>L</sub>,<b>D</b><sub>L+1</sub>,...,<b>D</b><sub>R</sub>) &lt; <b>C</b><sub>i</sub> - <b>K</b>.</li>\n</ul><p>\n  So we have F<sub>i</sub> = (# of intervals that satisfy P1 and P2) - (# of intervals that satisfy\n  P1 and P3). These two quantities are computed very similarly since they just have a different\n  bound on the right-hand side of the inequality in P2 and P3. We explain below just how to compute\n  (# of intervals that satisfy P1 and P2) and leave computing (# of intervals that satisfy P1 and P3)\n  to the reader.\n</p><p>\n  Note that if an interval (L,R) satisfies P2, then any subinterval of (L,R) also satisfies P2.\n  Similarly, if (L,R) satisfies P1, then any subinterval of (L,R) that still contains i\n  also satisfies P1. Thus, we are really only interested in how far left L can go with R=i (and\n  how far right R can go with L=i). One option is to do a linear search for how far left L can go,\n  but this is too slow. Instead, we\n  <a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">binary search</a>\n  for how far away the left-endpoint is. A\n  left-endpoint is too far left if P1 or P2 are no longer true. Otherwise, the left endpoint\n  can be pushed further left. Once we know the furthest left L can go (let this index be L<sub>i</sub>)\n  and the furthest right R can go (let this index be R<sub>i</sub>), then\n  (# of intervals that satisfy P1 and P2) = (i - L<sub>i</sub> + 1) &times; (R<sub>i</sub> - i + 1).\n  Calculating the maximum element in a range can be computed efficiently using a\n  <a href=\"https://en.wikipedia.org/wiki/Range_minimum_query\">range minimum (maximum) query</a>-type\n  data structure in O(1) time per query, meaning O(log <b>N</b>) total time for the binary search.\n</p><p>\n  In terms of time complexity, for each i, we need to perform 4 binary searches, which take\n  O(log <b>N</b>) time each, for an overall O(<b>N</b> log <b>N</b>) total time.\n  Setting up the range maximum query data structure takes an additional\n  O(<b>N</b> log <b>N</b>) time, yielding an overall O(<b>N</b> log <b>N</b>) time for\n  the full algorithm. There are solutions that can compute all of\n  the required L<sub>i</sub> and R<sub>i</sub> values (defined above) in O(<b>N</b>) total time\n  by doing a couple of clever sweeps of the data to count the number of unfair\n  intervals, but this was not needed for this problem.\n</p>\n","id":"0000000000122838","statement":"<h3>Problem</h3>\n<p>\n  En garde! Charles and Delila are about to face off against each other in the\n  final fight of the Swordmaster fencing tournament.\n</p><p>\n  Along one wall of the fencing arena, there is a rack with <b>N</b> different\n  types of swords; the swords are numbered by type, from 1 to <b>N</b>. As the\n  head judge, you will pick a pair of integers (L, R) (with 1 &le; L &le; R\n  &le; <b>N</b>), and only the L-th through R-th types of swords (inclusive)\n  will be available for the fight.\n</p><p>\n  Different types of sword are used in different ways, and being good with one\n  type of sword does not necessarily mean you are good with another! Charles\n  and Delila have skill levels of <b>C<sub>i</sub></b> and\n  <b>D<sub>i</sub></b>, respectively, with the i-th type of sword. Each of\n  them will look at the types of sword you have made available for this fight,\n  and then each will choose a type with which they are most skilled. If there\n  are multiple available types with which a fighter is equally skilled, and\n  that skill level exceeds the fighter's skill level in all other available\n  types, then the fighter will make one of those equally good choices at\n  random. Notice that it is possible for Charles and Delila to choose the same\n  type of sword, which is fine &mdash; there are multiple copies of each type of\n  sword available.\n</p><p>\n  The fight is <i>fair</i> if the absolute difference between Charles's skill\n  level with his chosen sword type and Delila's skill level with her chosen\n  sword type is at most <b>K</b>. To keep the fight exciting, you'd like to\n  know how many different pairs (L, R) you can choose that will result in a\n  fair fight.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with a line containing the two\n  integers <b>N</b> and <b>K</b>, as described above. Then, two more lines\n  follow. The first of these lines contains <b>N</b> integers\n  <b>C<sub>i</sub></b>, giving Charles' skill levels for each type of sword, as\n  described above. Similarly, the second line contains <b>N</b> integers\n  <b>D<sub>i</sub></b>, giving Delila's skill levels.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the number of choices you can make that result in a fair fight, as\n  described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  0 &le; <b>K</b> &le; 10<sup>5</sup>.<br/>\n  0 &le; <b>C<sub>i</sub></b> &le; 10<sup>5</sup>, for all i.<br/>\n  0 &le; <b>D<sub>i</sub></b> &le; 10<sup>5</sup>, for all i.<br/>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>N</b> = 10<sup>5</sup>, for exactly 8 test cases.<br/>\n  1 &le; <b>N</b> &le; 1000, for all but 8 test cases.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">6\n4 0\n1 1 1 8\n8 8 8 8\n3 0\n0 1 1\n1 1 0\n1 0\n3\n3\n5 0\n0 8 0 8 0\n4 0 4 0 4\n3 0\n1 0 0\n0 1 2\n5 2\n1 2 3 4 5\n5 5 5 5 10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 4\nCase #3: 1\nCase #4: 0\nCase #5: 1\nCase #6: 7\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the fight is fair if and only if Charles can use the last\n  type of sword, so the answer is 4.\n</p><p>\n  In Sample Case #2, there are 4 fair fights: (1, 2), (1, 3), (2, 2), and\n  (2, 3). Notice that for pairs like (1, 3), Charles and Delila both have\n  multiple swords they could choose that they are most skilled with; however,\n  each pair only counts as one fair fight.\n</p><p>\n  In Sample Case #3, there is 1 fair fight: (1, 1).\n</p><p>\n  In Sample Case #4, there are no fair fights, so the answer is 0.\n</p><p>\n  In Sample Case #5, remember that the <i>duelists</i> are not trying to make\n  the fights fair; they choose the type of sword that they are most skilled\n  with. For example, (1, 3) is not a fair fight, because Charles will choose\n  the first type of sword, and Delila will choose the third type of sword.\n  Delila will not go easy on Charles by choosing a weaker sword!\n</p><p>\n  In Sample Case #6, there are 7 fair fights: (1, 3), (1, 4), (2, 3), (2, 4),\n  (3, 3), (3, 4), and (4, 4).\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":28}],"title":"Fair Fight","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  Test sets 1 and 2 differ only in how large the available grid area is. In the\n  first test set, people can only be standing in cells with coordinates\n  between 0 and 10, inclusive, in either dimension. Moreover, we can notice\n  that the cart can only be in a cell within this area. The cart's horizontal\n  and vertical coordinates must both be nonnegative per the rules of a problem.\n  Moreover, it cannot have a coordinate larger than 10 (in either dimension).\n  Suppose, for example, that the cart had a horizontal coordinate greater than\n  10; then that would imply that there must be at least one person standing at\n  horizontal coordinate 10 and facing east. Otherwise, placing the cart at\n  horizontal coordinate 10 would be even better, per the tiebreaker rules.\n  But the rules of the problem do not allow people at (horizontal/vertical)\n  coordinate 10 to face (east/north).\n</p><p>\n  Therefore, to solve test set 1, we can create an array to represent all of\n  the blocks in the allowed area, and initialize each cell's value to 0. Then,\n  for each person, we increment all of the cells of the array that they are\n  walking toward. Finally, we find the cell of the array with the maximum\n  value, using the tiebreaker rules as needed. This solution takes\n  O(<b>P</b> &times; <b>Q</b><sup>2</sup>) time.\n</p>\n<h3>Test set 2: a quadratic solution</h3>\n<p>\n  In problems that involve multiple dimensions, it is often worth checking\n  whether those dimensions are independent. In this case, they are! A person\n  heading west, for example, gives us a \"vote\" for the crepe cart being to the\n  west of them, but tells us nothing at all about the north-south location of\n  the cart. So we can solve the two dimensions as separate one-dimensional\n  problems; the horizontal problem includes only the people heading west or\n  east (and their horizontal positions), and the vertical problem includes only\n  the people heading south or north (and their vertical positions). Let us\n  consider the horizontal dimension for now; our arguments also apply to the\n  vertical dimension.\n</p><p>\n  Even if our people are widely spread out along the horizontal axis, the crepe\n  cart can only possibly be in a limited number of horizontal positions. In\n  fact, it must be either at position 0, or at a cell that is one cell to the\n  east of some person. To see why, suppose that the cart is in some other cell\n  1 &leq; C &leq; <b>Q</b>. Let W denote the cell one unit to the west of C. We\n  know by assumption that W does not contain a person. But then if we move the\n  cart from C to W, we will not be losing any votes (i.e. any person voting for\n  C is also voting for W), and we many even gain votes (if there were people in\n  C who were heading west). (Notice that a person does not vote for the cell\n  they are in.) Even if we do not gain votes, our tiebreaker gets better. So we\n  should always make this move, and, therefore, we should always move the cart\n  west until it is at 0 or immediately to the east of someone. Observe that\n  this might find only a locally optimal solution, but if we check all such\n  cells, we will surely find the globally optimal solution.\n</p><p>\n  These observations reduce the number of cells we need to check to\n  O(<b>P</b>) rather than O(<b>Q</b>). To check a cell, we can make a linear\n  pass over all of the people, and count whether each one is voting for that\n  cell. One such check takes O(<b>P</b>) time. Then we choose the cell that\n  got the most votes, breaking a tie if needed by choosing the westernmost of\n  the tied cells. The overall time complexity is O(<b>P</b><sup>2</sup>) for\n  the one-dimensional problem, and solving it twice (for two dimensions) is\n  still O(<b>P</b><sup>2</sup>).\n</p>\n<h3>Test set 2: a (nearly) linear solution</h3>\n<p>\n  Although the above solution is fast enough to solve test set 2, we can do\n  even better by avoiding making a linear pass over the data for each person.\n</p><p>\n  We can first process our data into a set of tuples like the following:\n  (coordinate, number of people at that coordinate facing west, number of\n  people at that coordinate facing east). Let us denote these as\n  (C<sub>i</sub>, W<sub>i</sub>, E<sub>i</sub>). (Remember that for the\n  purposes of the horizontal subproblem, we are ignoring people facing north or\n  south.) Using a hash-based dictionary, this processing takes time linear in\n  <b>P</b>. As we do this, we should also determine the total numbers W and E\n  of people facing west and east.\n</p><p>\n  Then, we sort these tuples in ascending order of their first values. It\n  is probably most convenient to use a common sorting algorithm (or one built\n  into your language), making this step nonlinear. (We will leave a spirited\n  discussion of which sorting algorithms are truly linear for another day.)\n</p><p>\n  Once we have sorted the tuples, we start by considering cell 0 as a\n  candidate location, and we determine the votes for that cell. We know that\n  quantity is equal to W minus the number of people in cell 0, if any. We make\n  a note of this number of votes and set 0 as our best candidate so far.\n  Then, we look at the first tuple in our sorted list, which represents the\n  people at some cell C (which might be cell 0). The number of votes for cell\n  C + 1 (the cell one unit to the east of C) should be the same as the number\n  of votes we found for cell 0, plus the number of people in cell C facing east\n  (which is all of them in this case), minus the number of people in cell C\n  facing west. If cell C is a better candidate, we store it and its number of\n  votes.\n</p><p>\n  We can do this for every tuple in our list to get our final answer. If we\n  have one or more people on the eastern border, we do not need to check the\n  cell one unit to the east of them, since (as explained at the start of the\n  analysis) the cart can never have a coordinate larger than <b>Q</b>. Since\n  the check for each entry of the tuple takes constant time, the full pass\n  takes O(<b>P</b>) time.\n</p>\n","id":"000000000012295c","statement":"<h3>Problem</h3>\n<p>\n  There are a lot of great streetside food vendors in Manhattan, but without a\n  doubt, the one with the tastiest food is the Code Jam Crepe Cart!\n</p><p>\n  You want to find the cart, but you do not know where it is, except that it is\n  at some street intersection. You believe that people from across Manhattan\n  are currently walking toward that intersection, so you will try to identify\n  the intersection toward which the most people are traveling.\n</p><p>\n  For the purposes of this problem, Manhattan is a regular grid with its axes\n  aligned to compass lines and bounded between 0 and <b>Q</b>, inclusive, on\n  each axis. There are west-east streets corresponding to gridlines\n  y&nbsp;=&nbsp;0, y&nbsp;=&nbsp;1, y&nbsp;=&nbsp;2, &hellip;,\n  y&nbsp;=&nbsp;<b>Q</b> and south-north streets corresponding to gridlines\n  x&nbsp;=&nbsp;0, x&nbsp;=&nbsp;1, x&nbsp;=&nbsp;2, &hellip;,\n  x&nbsp;=&nbsp;<b>Q</b>, and people move only along these streets.\n  The points where the lines meet &mdash; e.g., (0, 0) and (1, 2) &mdash; are\n  intersections. The shortest distance between two intersections is measured via the\n  <a href=\"https://en.wikipedia.org/wiki/Taxicab_geometry\">Manhattan distance</a>\n  &mdash; that is, by the sum of the absolute horizontal difference and the\n  absolute vertical difference between the two sets of coordinates.\n</p><p>\n  You know the locations of <b>P</b> people, all of whom are standing at\n  intersections, and the compass direction each person is headed: north\n  (increasing y direction), south (decreasing y direction), east (increasing x\n  direction), or west (decreasing x direction). A person is moving toward a\n  street intersection if their current movement is on a shortest path to that\n  street intersection within the Manhattan grid. For\n  example, if a person located at (x<sub>0</sub>, y<sub>0</sub>) is moving\n  north, then they are moving toward all street intersections that have\n  coordinates (x, y) with y &gt; y<sub>0</sub>.\n</p><p>\n  You think the crepe cart is at the intersection toward which the most people\n  are traveling. Moreover, you believe that more southern and western parts of\n  the island are most likely to have a crepe cart, so if there are multiple\n  such intersections, you will choose the one with the smallest non-negative\n  <code>x</code> coordinate, and if there are multiple such intersections with\n  that same <code>x</code> coordinate, the one among those with the smallest\n  non-negative <code>y</code> coordinate. Which intersection will you choose?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case starts with one line containing\n  two integers <b>P</b> and <b>Q</b>: the number of people, and the maximum\n  possible value of an x or y coordinate in Manhattan, as described above.\n  Then, there are <b>P</b> more lines. The i-th of those lines contains two\n  integers <b>X<sub>i</sub></b> and <b>Y<sub>i</sub></b>, the current location\n  (street corner) of a person, and a character <b>D<sub>i</sub></b>, the\n  direction that person is headed. <b>D<sub>i</sub></b> is one of the uppercase\n  letters <code>N</code>, <code>S</code>, <code>E</code>, or <code>W</code>,\n  which stand for north, south, east, and west, respectively.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #t: x y</code>,\n  where <code>t</code> is the test case number (starting from 1) and\n  <code>x</code> and <code>y</code> are the horizontal and vertical coordinates\n  of the intersection where you believe the crepe cart is located.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>P</b> &le; 500.<br/>\n  0 &le; <b>X<sub>i</sub></b> &le; <b>Q</b>, for all i.<br/>\n  0 &le; <b>Y<sub>i</sub></b> &le; <b>Q</b>, for all i.<br/>\n  For all i, if <b>X<sub>i</sub></b> = 0,\n    <b>D<sub>i</sub></b> &ne; <code>W</code>.<br/>\n  For all i, if <b>Y<sub>i</sub></b> = 0,\n    <b>D<sub>i</sub></b> &ne; <code>S</code>.<br/>\n  For all i, if <b>X<sub>i</sub></b> = <b>Q</b>,\n    <b>D<sub>i</sub></b> &ne; <code>E</code>.<br/>\n  For all i, if <b>Y<sub>i</sub></b> = <b>Q</b>,\n    <b>D<sub>i</sub></b> &ne; <code>N</code>.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>Q</b> = 10.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>Q</b> = 10<sup>5</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1 10\n5 5 N\n4 10\n2 4 N\n2 6 S\n1 5 E\n3 5 W\n8 10\n0 2 S\n0 3 N\n0 3 N\n0 4 N\n0 5 S\n0 5 S\n0 8 S\n1 5 W\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 6\nCase #2: 2 5\nCase #3: 0 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<p>\n  In Sample Case #1, there is only one person, and they are moving north from\n  (5, 5). This means that all street corners with y &ge; 6 are possible\n  locations for the crepe cart. Of those possibilities, we choose the one with\n  lowest x &ge; 0 and then lowest y &ge; 6.\n</p><p>\n  In Sample Case #2, there are four people, all moving toward location (2, 5).\n  There is no other location that has as many people moving toward it.\n</p><p>\n  In Sample Case #3, six of the eight people are moving toward location (0, 4).\n  There is no other location that has as many people moving toward it.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Manhattan Crepe Cart","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000051706","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2019"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
