{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1252780200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432b7a","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1B had easier problems, but it was not easy to qualify from. ACRush, the Code Jam 2008 Champion, finished all the problems in less than 45 minutes.\nSolving problem B alone was not enough to qualify.\n</p>\n<p>\nProblem A was not the favorite choice of the contestants, probably because of the long statement, although it was mostly about parsing. Problem B was easier to implement, but it required a little more thinking. Problem C needed some optimizations and was the last one to be implemented by most of the contestants.\n<p>\n63 people got 100 points, just one less than Round 1A. 3 of them submitted in the last minute.<br/>\nCongratulations to all the people that qualified for Round 2!\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Decision Tree</i> Written by Pavel Nalivaiko. Prepared by Frank Chu and Igor Naverniouk.</p>\n<p>Problem B. <i>The Next Number</i> Written by John Dethridge. Prepared by Frank Chu and Marius Andrei.</p>\n<p>Problem C. <i>Square Math</i> Written by Junbin Teng. Prepared by Xiaomin Chen and Daniel Rocha.</p>\n<p>Contest analysis presented by Marius Andrei, Igor Naverniouk, and Xiaomin Chen.</p>\n<p>Solutions and other problem preparation provided by Tomek Czajka, Pablo Dal Lago, Ante Derek, Derek Kisman, Petr Mitrichev, and Cosmin Negruseri. </p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1252771200000,"tasks":[{"analysis":"<p>The hard part here was parsing the tree. An easy way to do this is by using a technique called <i>recursive descent</i>. The tree grammar is defined recursively, so it makes sense to parse it recursively, too. Here is a solution in Python.</p>\n<pre>\nimport re\nimport sys\ninp = sys.stdin\n\ntokens = None\nti = -1\n\ndef ReadInts():\n  \"\"\"Reads several space-separated integers on a line.\n  \"\"\"\n  return tuple(map(int, inp.readline().strip().split(\" \")))\n\ndef NextToken():\n  \"\"\"Consumes the next token from 'tokens'.\n  \"\"\"\n  global ti\n  assert 0 &lt;= ti &lt; len(tokens)\n  ti += 1\n  return tokens[ti - 1]\n\ndef ParseNode():\n  \"\"\"Parses from 'tokens' and returns a tree node.\n  \"\"\"\n  global ti\n  assert NextToken() == \"(\"\n  node = {\"weight\": float(NextToken())}\n  tok = NextToken()\n  if tok == \")\":\n    return node\n  node[\"feature\"] = tok\n  node[True] = ParseNode()\n  node[False] = ParseNode()\n  assert NextToken() == \")\"\n  return node\n\ndef ParseTree(s):\n  \"\"\"Initializes 'tokens' and 'ti' and parses a tree.\n  \"\"\"\n  global tokens\n  global ti\n  s = re.compile(r\"\\(\").sub(\" ( \", s)\n  s = re.compile(r\"\\)\").sub(\" ) \", s)\n  s = re.compile(r\"[ \\n]+\").sub(\" \", \" %s \" % s)\n  tokens = s[1:-1].split(\" \")\n  ti = 0\n  return ParseNode()\n\ndef Evaluate(tree, features):\n  ans = tree[\"weight\"]\n  if \"feature\" in tree:\n    ans *= Evaluate(tree[tree[\"feature\"] in features], features)\n  return ans\n\nif __name__ == \"__main__\":\n  N = ReadInts()[0]\n  for prob in xrange(1, N + 1):\n    n_lines = ReadInts()[0]\n    lines = [inp.readline() for _ in xrange(n_lines)]\n    tree = ParseTree(\" \".join(lines))\n    n_queries = ReadInts()[0]\n    print \"Case #%d:\" % prob\n    for _ in xrange(n_queries):\n      features = set(inp.readline().strip().split(\" \")[2:])\n      print \"%.7f\" % Evaluate(tree, features)\n</pre>\n\n<p>\nFor each test case, we read the 'n_lines' lines containing the tree definition, we glue them together using spaces and pass the resulting string to ParseTree().\n</p>\n\n<p>\nIn ParseTree(), we do some \"massaging\" to make the string easier to parse. First, we put spaces around each parenthesis by using two simple regular expressions. Next, we replace each sequence of whitespace characters by a single space and make sure there is always exactly one space character at the beginning and the end of the input. Finally, we strip off the leading and trailing spaces and split the rest into tokens.\n</p>\n\n<p>\nThe ParseNode() function does the rest. It uses the NextToken() function to read one token at a time from the 'tokens' list and returns a simple dictionary representation of a tree node.\n</p>\n\n<p>\nOnce we have the tree as a dictionary, we then use Evaluate() to do a tree traversal from the root to a leaf and compute the answer for each input animal.\n</p>\n\n<b>Using the parsers built into dynamic languages</b>\n\n<p>\nA number of contestants have noticed that there is an even easier way to parse the tree. Most dynamic, interpreted languages give you access to their built-in parser, and by manipulating the input a little bit, it is possible to use make the language's interpreter do the parsing for you! This means using \"eval\" in JavaScript or Python, or \"read\" in Lisp. Check out some of the shortest solutions at <a href=\"http://1b-a.pastebin.com/d4631e678\" target=\"_blank\">1b-a.pastebin.com/d4631e678</a>.","id":"0000000000432910","statement":"<h3>Problem</h3>\n<p>Decision trees -- in particular, a type called classification trees --\nare data structures that are used to classify <i>items</i> into <i>categories</i>\nusing <i>features</i> of those items.  For example, each animal is either\n\"cute\" or not. For any given animal, we can decide whether it is cute\nby looking at the animal's features and using the following decision tree.\n</p>\n<pre>\n(0.2 furry\n  (0.81 fast\n    (0.3)\n    (0.2)\n  )\n  (0.1 fishy\n    (0.3 freshwater\n      (0.01)\n      (0.01)\n    )\n    (0.1)\n  )\n)\n</pre>\n\n<p>A decision tree is defined recursively. It always has a root node and a\nweight. It also, optionally, has a feature name and two sub-trees, which are\nthemselves decision trees.</p>\n\n<p>More formally, a decision tree is defined using the following grammar.\n<pre>\n<i>tree</i> <b>::=</b> (<i>weight</i> <b>[</b><i>feature</i> <i>tree</i> <i>tree</i><b>]</b>)\n<i>weight</i> is a real number between 0 and 1, inclusive\n<i>feature</i> is a string of 1 or more lower case English letters\n</pre>\nThe part inside the square brackets, <b>[]</b>, is optional. The parentheses,\n(), <i>weight</i> and <i>feature</i> are tokens. There will be at least one\nwhitespace character between any two tokens, except (possibly) after an open-bracket '(' or before a close-bracket ')'. Whitespace characters are\nspace (' ') and endline ('\\n').</p>\n\n<p>To figure out how likely the animal is to be cute, we start at the root\nof the tree with probability <i>p</i> set to 1. At each node, we multiply\n<i>p</i> by the weight of the node. If the node is a leaf (has no sub-trees),\nthen we stop, and the value of <i>p</i> is the probability that our animal\nis cute. Otherwise, we look at the feature associated with the node. If our\nanimal has this feature, we move down into the first sub-tree and continue\nrecursively. If it does not have this feature, then we move down into the\nsecond sub-tree and continue in the same way.</p>\n\n<p>For example, a beaver is an animal that has two features: <i>furry</i> and\n<i>freshwater</i>. We start at the root with <i>p</i> equal to 1. We multiply\n<i>p</i> by 0.2, the weight of the root and move into the first sub-tree\nbecause the beaver has the <i>furry</i> feature. There, we multiply <i>p</i>\nby 0.81, which makes <i>p</i> equal to 0.162. From there we move further down\ninto the second sub-tree because the beaver does not have the <i>fast</i> feature.\nFinally, we multiply <i>p</i> by 0.2 and end up with 0.0324 -- the probability\nthat the beaver is cute.</p>\n\n<p>You will be given a decision tree and a list of animals with their features.\nFor each item, you need to return the probability that the animal is cute.</p>\n\n<h3>Input</h3>\n<p>The first line of input contains a single integer, <b>N</b>, the number of\ntest cases.  <b>N</b> test cases follow.</p>\n\n<p>Each test case description will start with a line that contains an integer\n<b>L</b> -- the number of lines that describe a decision tree. The next <b>L</b>\nlines will contain a decision tree in the format described above. The line\nafter that will contain <b>A</b> -- the number of animals. The next <b>A</b>\nlines will each contain the description of one animal in the following format.\n<pre>\n<i>animal</i> <b>n</b> <i>feature</i><sub>1</sub> <i>feature</i><sub>2</sub> ... <i>feature</i><sub><b>n</b></sub>\n</pre>\n</p>\n\n<h3>Output</h3>\n<p>For each test case, output one line containing \"Case #<b>x</b>:\"\nfollowed by exactly <b>A</b> lines, one per animal, in the same order as they\nappear in the input. Each line should contain the probability that the animal\nis cute. Answers that are precise to within an absolute or relative error of\n10<sup>-6</sup> will be considered correct.\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>N</b> &le; 100<br>\nAll weights will be between 0 and 1, inclusive.<br>\nAll weights will consist of only digits with at most one decimal point.<br>\nThe weights will not start or end with a decimal point.<br>\nThe weights will not have more than one 0 before a decimal point.<br>\nAll animals and features will consist of between 1 and 10 lower case\nEnglish letters.<br>\nAll animal names within a test case will be distinct.<br>\nAll feature names for a single animal will be distinct.<br>\nEach of the <b>L</b> lines in a decision tree definition will have at most 80\ncharacters, not including the endlines.<br>\n</p>\n\n<h3>Small dataset</h3>\n<p>\n1 &le; <b>L</b> &le; 10<br>\n1 &le; <b>A</b> &le; 10<br>\n0 &le; <b>n</b> &le; 5<br>\n</p>\n\n<h3>Large dataset</h3>\n<p>\n1 &le; <b>L</b> &le; 100<br>\n1 &le; <b>A</b> &le; 100<br>\n0 &le; <b>n</b> &le; 100<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n3\n(0.5 cool\n  ( 1.000)\n  (0.5 ))\n2\nanteater 1 cool\ncockroach 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n0.5000000\n0.2500000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":11}],"title":"Decision Tree","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe problem would be a lot easier if there were only plus signs used. With the presence of the negative signs, a valid expression might get to a large value in the middle, then decrease back to the value we are looking for. Will that be the shortest answer for a certain query at all?\n</p>\n<br/>\n<h3>The best path cannot be long</h3>\n<p>\nFirst of all, let us denote a non-zero digit in the square <i>pos</i> if it has at least one neighbor that is a plus sign; call it <i>neg</i> if it has one minus sign as its neighbor. A digit can be both pos and neg. We assume there are both pos digits and neg digits in the square. Let <b>q</b> be the value we are looking for.<br/>\nLet g be the gcd (greatest common divisor) of all the digits in the square. If g is not 1, in order to find a solution for q, it must be a multiple of g. Dividing everything by g, we may assume from now on that the gcd of all the numbers in the square is 1. The situation is further simplified when all our numbers are between 0 and 9 -- in this case, the above implies that there must be two digits, <b>a</b> and <b>b</b>, in the square, such that gcd(a, b) = 1.\n</p>\n<p>\n<i>Case 1</i>. <b>a</b> is pos and <b>b</b> is neg. Take any shortest path <b>P</b> from <b>a</b> to <b>b</b> in the square. Let <b>q'</b> be the value of this path. q' is between [-200, 200]. Let t = q - q'. We prove the case t &ge; 0; the other case is similar and left to the readers.<br/>\nSince gcd(a, b)=1, one of the numbers t, t+b, t+2b, ..., t+(a-1)b is a multiple of <b>a</b>. This means we can find non-negative numbers x and y such that ax - by = t, where y &lt; a (therefore x &lt; t/a + b). We start from <b>a</b>, since it is a positive digit, we use the plus sign to repeat at <b>a</b> x times, then follow <b>P</b>. After reaching <b>b</b>, we use the minus sign to repeat y times. The path just described evaluates to the query <b>q</b>.\n</p>\n<p>\n<i>Case 2</i>. Both <b>a</b> and <b>b</b> are pos, there is a neg digit <b>c</b>. If <b>c</b> is co-prime with either <b>a</b> or <b>b</b>, we handle it as Case 1. Otherwise c has to be 6.<br/>\nPick any shortest path <b>P</b> that connects <b>a</b>, <b>b</b>, and <b>c</b>. Suppose it evaluates to q'. Pick a non-negative z such that q - q' + 6z &ge; ab - a - b + 1. We use a basic fact in number theory here\n<blockquote>\nIf positive integers a and b are co-prime, then for any t &ge; ab - a - b + 1, there exist non-negative integers x and y such that ax + by = t.\n</blockquote>\nTo get an answer for query q, we use the path <b>P</b>, repeat <b>a</b> x times with plus sign, <b>b</b> y times with plus sign, and <b>c</b> z times with minus sign.\n</p>\n<p>\n<i>Case 3</i>. Both <b>a</b> and <b>b</b> are neg. This is similar to Case 2, and we leave it to the readers.\n</p>\n<p>\nThus we proved that for any solvable query, there is a path that is not long, as well as any partial sum on the path cannot be too big. The rough estimate shows that any of the paths cannot take more than 1000 steps. One can get a better bound by doing more careful analysis. \n</p>\n<br/>\n<h3>The algorithm</h3>\n<p>\nOur solution is a BFS (breadth first search). The search space consists all the tuples (r, c, v), where (r, c) is the position of a digit, and denote A(r, c, v) to be the best path that evaluates to v, and ends at the position (r, c).\nWe know there are at most 200 such (r, c)'s (20<sup>2</sup>/2), and at most (much less than) 20000 such v's from the bound we get.\n</p>\n<p>\nThe only difference with a standard BFS is that, because of the lexicographical requirement, we may need to update the answer on a node. But we never need to re-push it into the queue, since it is not yet expanded.\n</p>\n","id":"0000000000432f36","statement":"<h3>Problem</h3>\n\n<p>Say we have a square that has <b>W</b> cells on each side and, therefore, <b>W</b><sup>2</sup> cells total. Let's go further and fill each cell with one of the following:\n<ul>\n<li> A digit from 0 to 9;\n<li> The addition sign (+);\n<li> The subtraction sign (-).\n</ul>\nIf, finally, we add a constraint that no 2 digits are horizontally or vertically adjacent and no 2 operators (+ or -) are horizontally or vertically adjacent, then our square can be called an \"arithmetic square\".</p>\n\n<p>Square Math is the name of a puzzle where, given an arithmetic square, we start from any numeric cell and move either horizontally or vertically a cell at a time, finally ending in a numerical cell. The mathematical expression we get from the traversal is evaluated to get a single value.  For example:\n\n<pre>\n2+3\n+4-\n1+0\n</pre>\n\n<p>The above is a valid arithmetic square of size <b>W</b> = 3.  If we start from \"2\", move horizontally right, then vertically down, we'll get \"2+4\", which gives a value of \"6\".  If we further move horizontally right, then vertically up, we'll get \"2+4-3\", which is equal to \"3\".</p>\n\n<p>In Square Math, there is no limit to how many times you can use a particular cell. It is perfectly legal to move from a cell to its neighbor, then back to the original cell. Given an arithmetic square and a list of queries, your task is to find a Square Math expression which evaluates to each query.</p>\n\n<h3>Input</h3>\nThe first line of input contains a single integer, <b>T</b>. <b>T</b> test cases follow. The first line of each test case contains 2 integers, <b>W</b> and <b>Q</b>. <b>W</b> lines follow, each containing <b>W</b> characters, representing the arithmetic square. Don't worry, all arithmetic squares in the input are well-formed. The following line contains a space separated list of <b>Q</b> integers, representing the values which need to be computed by using Square Math (the queries). You can assume that all given values will have at least one possible Square Math solution.</p>\n\n<h3>Output</h3>\n<p>For each test case, begin output with \"Case #<b>X</b>:\" on a line by itself, where <b>X</b> is the test case number, starting from 1. Then, for each query within the test case, print the Square Math expression which evaluates to the query on a line by itself.</p>\n<p>In the case where there are multiple possible Square Math expressions, print the one that is shortest. If there is still a tie, print the lexicographically smallest expression. Remember that '+' is lexicographically smaller than '-'.</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 60<br>\n</p>\n<h3>Small dataset</h3>\n<p>\nTime limit: 30 seconds.<br/>\n2 &le; <b>W</b> &le; 10<br>\n1 &le; <b>Q</b> &le; 20<br>\n1 &le; each query &le; 50<br>\n</p>\n<h3>Large dataset</h3>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>W</b> &le; 20<br>\n1 &le; <b>Q</b> &le; 50<br>\n1 &le; each query &le; 250<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5 3\n2+1-2\n+3-4+\n5+2+1\n-4-0-\n9+5+1\n20 30 40\n3 2\n2+1\n+4+\n5+1\n2 20\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n1+5+5+9\n3+4+5+9+9\n4+9+9+9+9\nCase #2:\n2\n5+5+5+5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":32}],"title":"Square Math","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nLet <b>x</b> be our input. We want to find the next number <b>y</b>. We denote L(<i>s</i>) to be the length of <i>s</i>, i.e., the number of digits in <i>s</i>. </p>\n<p>\n<i>Case 1</i>. If all the digits in <i>x</i> are non-increasing, for example <i>x</i> = 776432100, then <i>x</i> is already the biggest one among the numbers in the list with L(<i>x</i>) digits. The next number, <i>y</i>, must have one more digit, that is, one more 0. Actually <i>y</i> must be the smallest one with L(<i>x</i>)+1 digits. To get <i>y</i>, we put the smallest non-zero digit in front, and all the other digits are put in non-decreasing order.\n</p>\n<p>\n<i>Case 2</i>. Otherwise, <i>x</i> can be written as the concatenation <i>x</i> = <i>a</i><i>b</i>, where <i>b</i> is the longest non-increasing suffix of <i>x</i>, so <i>d</i>, the last digit of <i>a</i> is smaller than the first digit of <i>b</i>. Let <i>d'</i> be the smallest among all the digits in <i>b</i> that are bigger than <i>d</i>. <br/>\nBecause <i>b</i> is non-increasing, <i>x</i> is the biggest number among those who has L(x) digits and starts with prefix <i>a</i>. The first L(<i>a</i>) digits of <i>y</i> must be bigger than <i>a</i>. The smallest we can do is to replace <i>d</i> with <i>d'</i>, and then for the rest digits, we arrange them in non-decreasing order.<br/>\nLet us do another example. <i>x</i> = 134266530. Then <i>a</i> = 1342, <i>b</i> = 66530, <i>d</i> = 2, and <i>d'</i> = 3. The next number is <i>y</i> = 134302566. \n</p>\n<p>\nIn fact, we can unify the two cases above. Since the number of 0's is not restricted, we can just imagine there is one more 0 in the beginning of <i>x</i>, thus Case 1 is reduced to Case 2.\n</p>\n<p>\nThe above described is actually exactly the procedure to get the next permutation of a finite sequence in certain languages. Below is a solution that is essentially one line in C++. From the author:\n<pre>\n  deque&lt;char&gt; f;\n  ...\n  f.push_front('0');\n  next_permutation(f.begin(), f.end());\n  if (f.front() == '0') f.pop_front();\n</pre>\n</p>\n","id":"00000000004330f8","statement":"<h3>Problem</h3>\n<p>You are writing out a list of numbers.  Your list contains all numbers with exactly <b>D<sub>i</sub></b> digits in its decimal representation which are equal to <b>i</b>, for each <b>i</b> between 1 and 9, inclusive.  You are writing them out in ascending order.</p>\n\n<p>For example, you might be writing every number with two '1's and one '5'.  Your list would begin 115, 151, 511, 1015, 1051.</p>\n\n<p>Given <b>N</b>, the last number you wrote, compute what the next number in the list will be.</p>\n\n<h3>Input</h3>\n<p>The first line of input contains an integer <b>T</b>, the number of test cases in the input. <b>T</b> lines follow, one for each test case, each containing a single integer <b>N</b>.</p>\n\n<h3>Output</h3>\n<p>For each test case, output <pre>Case #<b>X</b>: <b>K</b></pre> where <b>X</b> is the test case number, starting from 1, and <b>K</b> is the next integer in the list.</p>\n<br/>\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n</p>\n<h3>Small dataset</h3>\n<p>\nTime limit: 20 seconds.<br/>\n1 &le; T &le; 50<br/>\n1 &le; N &le; 10<sup>6</sup>\n</p>\n<h3>Large dataset</h3>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; T &le; 500<br/>\n1 &le; N &le; 10<sup>20</sup>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n115\n1051\n6233\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 151\nCase #2: 1105\nCase #3: 6323\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":26}],"title":"The Next Number","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432b7a","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2009"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
