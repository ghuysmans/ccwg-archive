{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1371313800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043319e","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nA few contestants started this round by quickly solving D-small. Soon after, mozeda took an early lead with the more clasic approach of solving problem A first. The other three problems turned out to be a lot more difficult. It wasn't until almost an hour into the contest when the first correct submission for C-large came in from team5. A few minutes later, Breakun became the first contestant to solve B-large. The first contestant to solve D-large was pieguy at the 1h20m mark.\n</p>\n<p>\nAt that point, it was clear that none of the problems was impossible, and the race was on for the coveted Onsite Finals spots. Eastern Europeans were dominating this round, with 10 of the top 10 spots and just over an hour left to go, when veteran SnapDragon broke into the top 3 with a correct C-large. Gennady.Korotkevich attempted B-large in the last few seconds of the round, but ran out of time. That didn't stop him from winning the round though.\n</p>\n<p>\nOverall, this ended up being a very difficult round. Each of the top 25 contestants fully solved one problem other than A, but nobody managed to solve three full problems! Congratulations to the finalists. We hope to see you in London.\n</p>\n\n<hr>\n\n<p>Problem A. <i>Cheaters</i> Written by Jan Kuipers. Prepared by Wojciech Tyczynski and Jan Kuipers.</p>\n\n<p>Problem B. <i>Rural Planning</i> Written by David Arthur. Prepared by Tomek Czajka, Onufry Wojtaszczyk, and Ahmed Aly.</p>\n\n<p>Problem C. <i>Are We Lost Yet?</i> Written by David Arthur. Prepared by Tomek Czajka and Ahmed Aly.</p>\n\n<p>Problem D. <i>Observation Wheel</i> Written by David Arthur. Prepared by Tomek Kulczy≈Ñski and Petr Mitrichev.</p>\n\n<p>Contest analysis presented by Topraj Gurung,  Onufry Wojtaszczyk, Petr Mitrichev, Denis Savenkov, Matt Fontaine, Nadeem Mohsin, Nicholas Beato, Lianghao Chen, Yijie Wang, and Zhongtian Jiang.</p>\n\n<p>Solutions and other problem preparation by Hackson Leung, Yiming Li, Ian Tullis, Ilya Kornakov, Steve Thomas, Tiancheng Lou, and Adrian Kuegel.</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1371304800000,"tasks":[{"analysis":"<h2>Introduction</h2>\n<p> The problem asks you to determine which part of a path E<sub>1</sub>, E<sub>2</sub>, ..., E<sub>k</sub> can be a prefix of some shortest path from 1 to 2. This would be easy if not for the fact we don't know the exact edge costs - we only know ranges into which they fall.</p>\n<h2>Small dataset</h2>\n<p>Let's concentrate on any fixed prefix E<sub>1</sub>, E<sub>2</sub>, ..., E<sub>p</sub> of the proposed path, and try to make it a prefix of some shortest path. If we decide on a shortest path candidate (that includes our prefix), it's obivously advantageous to assume the edges on our path are as short as possible, and the other edges are as long as possible.</p>\n<p>Notice that a consequence of this is that we can just restrict ourselves to looking at graphs in which each of the edges is either as long or as short as possible. Thus, since in the small dataset the number of edges is only 20, we can simply check all possibilities - make some of the edges short, the rest long, find the shortest path in the resulting graph (preferring the proposed path by, for instance, decreasing the cost of the edges on this path by a small epsilon), and then out of all the possibilities pick the one that takes the most steps along the proposed path.</p>\n\n<h2>Large dataset</h2>\n<p> This is obviously not going to fly for the large dataset. Again, we fix a prefix E<sub>1</sub>, E<sub>2</sub>, ..., E<sub>p</sub> of the proposed path and try to make it a prefix of the shortest path. Assume E<sub>p</sub> ends in Tokyo. Thus, we will try to get from Tokyo to London as fast as possible, while still not allowing for a shorter path from Mountain View to London that doesn't begin with our prefix. If we want to optimize for speed, we can do a binary search for the longest prefix that can be a start of some shortest path; if we optimize for simplicity, we can just iterate over all prefixes.</p>\n<p>Imagine two robots that try to reach London as fast as possible. One starts from Tokyo, and has a handicap of the cost to travel from the Mountain View to Tokyo along the proposed path (we call this the \"good\" robot). When this robot goes across an edge, it will always take the minimal cost - this robot represents the shortest path we hope to construct. The other robot starts from Mountain View, and tries to reach London via some other path. We call this the \"bad\" robot and will try to force it to take as long as possible. The question is whether we can make the good robot be at least as fast as the bad robot (the bad robot can obviously be equally fast simply by following the good robot).</p>\n\n<p>We already set the costs for the edges E<sub>1</sub> to E<sub>p</sub> to the low values. Since our aim is to make the good robot move fast and the bad robot move slow, a naive approach is to simply have the good robot pay the low cost for all other edges, and the bad robot pay the high cost. However, we will still encounter a problem in this model. If two robots go across a same edge, they are actually taking different costs, which is not possible in a fixed configuration.</p>\n\n<p>Notice, however, that the two robots are walking the same graph. Thus, if they reach a same node at a different time, the one that arrived earlier will always beat the other one if the shortest path goes through that node, because it can always follow the other one's route. This means the later robot does not have any purpose in visiting this node at all. Since ties are resolved in favor of the good robot, we can simply decrease the good robot's handicap by 0.5 to avoid any ties.</p>\n\n<p>Thus, we can solve the problem with a single run of Dijkstra's algorithm. We begin with two starting points - one in Mountain View at time 0, and the other in Tokyo with time equal to the cost of travel along the proposed path to Tokyo minus 0.5. When processing a node, we calculate the costs of outgoing edges as follows:</p>\n<ul>\n<li> If the edge is one of E<sub>1</sub>, ..., E<sub>p</sub>, we take the low cost.</li>\n<li> If the current node is processed because the good robot reached it (which we know because the cost of the current node is not an integer, it ends with 0.5), the cost is the low cost.</li>\n<li> Otherwise, we are processing the node because the bad robot reached it, and the cost is the high cost.</li>\n</ul>\n<p>As Dijkstra's algorithm visits a node only once to process outgoing edges, we will never have a robot visit a node that the other robot reached earlier.</p>\n","id":"0000000000432b87","statement":"<h3>Problem</h3>\n<p>\nIt is time for the Google Code Jam Finals, and we all want to be there! Unfortunately, a few of us accidentally ended up going to Mountain View instead of the correct location: London, England. But don't worry - we can take the free Google shuttle service from Mountain View to London!\n</p>\n\n<p>\nThe shuttle service consists of <b>M</b> one-way routes connecting pairs of cities. For every route, you know from which city and to which city it's going, but unfortunately you do not know exactly how long these routes are. Instead, for every route, you only know that its length can be any integer value from <b>a<sub>i</sub></b> to <b>b<sub>i</sub></b>, inclusive.\n</p>\n\n<p>\nI have taken Google shuttles many times before, so I have suggested a path of routes from Mountain View to London. But you worry that my path-finding skills are not as good as yours, and you want to check my work.\n</p>\n\n<p>\nGiven the path I am suggesting, could it possibly be a shortest path from Mountain View to London? If not, what is the ID of the first shuttle route on my path that is definitely not part of a shortest path (assuming that all previous shuttle routes have been taken according to the path I suggested)?\n</p>\n\n<p>\nFor example, suppose we have the following list of shuttle routes:\n<pre>\nID | Start City     |  Destination City  |  Shuttle Length\n---+----------------+--------------------+----------------\n1  | Mountain View  |  London            |  [100, 1000]\n2  | Mountain View  |  Paris             |  [500, 5000]\n3  | Paris          |  London            |  [400, 600]\n4  | Paris          |  Moscow            |  [500, 5000]\n5  | Moscow         |  London            |  [1, 10000]\n</pre>\nI suggest the path Mountain View -&gt; Paris -&gt; Moscow -&gt; London. The true shortest path might either be the direct route from Mountain View to London, or the path Mountain View -&gt; Paris -&gt; London. This means that the second route on my path (Paris -&gt; Moscow) was the first one that is definitely not part of a shortest path.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow. Each test begins with a line containing three positive integers <b>N</b>, <b>M</b>, and <b>P</b>. <b>N</b> represents the total number of cities (cities are numbered from 1 to <b>N</b>), <b>M</b> represents the total number of shuttle routes, and <b>P</b> represents the number of shuttle routes on my path from Mountain View (city #1) to London (city #2).\n</p>\n\n<p>\nThis is followed by <b>M</b> lines, each consisting of four integers, <b>u<sub>i</sub></b>, <b>v<sub>i</sub></b>, <b>a<sub>i</sub></b>, <b>b<sub>i</sub></b>. Each line represents the fact that there is a one-way shuttle route from city <b>u<sub>i</sub></b> to city <b>v<sub>i</sub></b>, and you know that its length can be any integer value from <b>a<sub>i</sub></b> to <b>b<sub>i</sub></b>, inclusive. The routes are given IDs from 1 to <b>M</b> in the same order of the input.\n</p>\n\n<p>\nThis is followed by a line consisting of <b>P</b> unique integers in the range from 1 to <b>M</b>. These represent, in order, the shuttle routes I am taking you on. Each one is an ID of a route from the previous list.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: n\", where x is the case number (starting from 1) and n is the ID of the first shuttle route in my path that could not possibly be part of the shortest path from Mountain View to London. If there is no such route, print \"Looks Good To Me\" instead.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 60 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 10.<br/>\n1 &le; <b>u<sub>i</sub></b>, <b>v<sub>i</sub></b> &le; N.<br/>\n1 &le; <b>a<sub>i</sub></b> &le; <b>b<sub>i</sub></b> &le; 1000000.<br/><br/>\nMy path is guaranteed to be a valid path from Mountain View (city #1) to London (city #2).<br/><br/>\nThere might be more than one shuttle route between the same two cities, and there might be a shuttle route going from a city to itself. Also the suggested path might visit the same city more than once, but it will not use the same shuttle route more than once.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 20.<br/>\n1 &le; <b>M</b> &le; 20.<br/>\n1 &le; <b>P</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>M</b> &le; 2000.<br/>\n1 &le; <b>P</b> &le; 500.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 5 3\n1 2 100 1000\n1 3 500 5000\n3 2 400 600\n3 4 500 5000\n4 2 1 10000\n2 4 5\n3 3 2\n1 3 1 1\n3 2 1 1\n1 2 1 2\n1 2\n5 6 3\n1 3 1 1\n4 2 1 9\n1 4 1 1\n3 5 2 2\n5 2 2 2\n3 4 1 2\n1 6 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: Looks Good To Me\nCase #3: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Are We Lost Yet?","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Background</h2>\n<p>This problem challenges us with an 'intelligent' roulette game where the ball always lands on one of the numbers that has the least total money bet on it. Armed with this knowledge, we go to calculate the maximum expected profit. We know the current bets (need to be integers) and our budget. We now place bets (also integers) to maximize our expected profit.</p>\n\n<h2>Examples and insights</h2>\n<p>Before we delve into the solution, let's go through a few examples to get an intuition for the solution strategy. First off, we describe the convention used in the figures.</p>\n<ul>\n<li>a square in the figure represents a single unit of money</li>\n<li>a column in the figure represents the current bet (pile of money) on some number</li>\n<li>colors of squares:<ul>\n<li>a red square represents the existing bets by other betters</li>\n<li>a white square means there are no bets</li>\n<li>a green square represents the bets we have already placed</li>\n<li>a yellow square represents a bet we are considering</li>\n<li>a blue square represents our bets that we are pointing out</li>\n</ul>\n<li>In our figures, we show only 8 columns (different numbers) even though in our roulette game we have 37 different numbers, we assume all other numbers have much higher bets on them already</li>\n<li>We sort the piles of money (red columns) by increasing height going from left to right</li>\n</ul>\n<p>\nLet's start out with a toy example (see figure a). Here, we have piles of heights 0, 0, 0, 2, 2, 3,  4, 4. Let's say we have 3 units to bet: which piles should we bet on and how much should we bet per pile? In this case, we can bet on the three piles with height 0 (see figure b) which gives us an expected profit of 33.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0liO5uxhqPnnL2GWF9Tf0fD2R-uUAFCocomkhB6kDUAhXLP82rSPO2s5wQ-H6MgDcKZb4l/boxing.png\">\n<p><i>Observation #1:</i> As only the piles with minimum-height have a chance to win, we want to try and place our bets on piles resulting in a minimum-height.</p>\n\n<p>What if we had 6 units to bet? We can again place bets on piles with height 0 (see figure c). The result is 5 piles with height 2 (3 green piles and 2 red piles). Our expected profit is 37.2. By the way, if the red piles of height 2 were instead of height 3, our expected profit would have been 66!</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2SrV_csy3RkIrfJ6rDZLT8AGfSB2HrNBCBWAH_kwrmzzARuoMr7vdGbvOK_HXnPLmsubY/ghost.png\">\n\n<p>What if we had 7 units to bet? We can place 6 units as described above. But where should we place the 7th one? We could try placing it in the blue locations in figure d, but that does not help at all. Or we could try placing it in any of the blue locations in figure e, which will change our expected profit as it will decrease the total number of piles with minimum-height 2. If we placed the 7th unit in the yellow position as in figure f, we will reduce our expected profit! But if we placed it as in figure g, our expected profit will increase to 47! It increases as we have decreased the number of piles with minimum-height that weren't contributing to our expected profit.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1-xPy8lCAJ3Wc2uJRWwrC2g769Rv4VKCrxe2F49nN645mLa-IUvrCMVjPWKFYo4d1OZGClbKVnQmM/wheelbarrow.png\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0c5qA3yXfYybKsR8xU79M0m2DxSyxIE9u4kmBiY9UJuSqTbAk91K91-raSDVmFmMqHTVDU5YXI/architect.png\">\n\n<p><i>Observation #2:</i> We can possibly increase the expected profit by decreasing the number of piles with minimum-height. </p>\n\n<p> What if we had 8 units to bet? You guessed it. We can place it as in figure h and get an expected profit of 64. In general, our optimal set of bets will have a step like figure of minimum-height <b>h</b>, and height <b>h</b>+1 or higher (as shown by the blue squares in figure i). </p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3bkwEzNbSRQ2xtlmsNbM4f8A9oVe44FTakgt5dFw6NigcXnDSKEcdyhGWuz7X18tAlUg/belt.png\">\n<h2>Simple strategy</h2>\n<p>Our simple strategy (for the small input) is to lay the bets one by one as shown in figure j. Each time we put a bet (e.g. in 1), we calculate the expected profit then place the next bet (i.e. 1 <i>and</i> 2) then calculate the expected profit, then repeat for the next one (1, 2 <i>and</i> 3). We retain the maximum expected profit.</p>\n\n<p>This strategy works fine when the bet we have to place is small, but amount of money we can bet can get as large as 10<sup>12</sup>! Therefore we need to use a strategy that will run faster.</p>\n<h2>Advanced strategy</h2>\n<p><i>Observation #3:</i> For the optimal solution, the step from minimum-height <b>h</b> to <b>h</b>+1 (or higher) will occur at some vertical location (see figure k). At that vertical location, we want the highest minimum-height <b>h</b> possible with the amount of money we have.</p>\n\n<p>Armed with this observation, we will essentially fix a vertical location and try to build as tall a step as possible. For example if we had 7 units of money and we fixed the vertical step location after the first column as shown in figure k, then the highest step we could build is shown in figure l, which uses 5 units of money (2 units remain unused). For the vertical step location after the fourth block as shown in figure m, we use all 7 units of money.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1vEi1iK2kaqabt9oX_KkPI4TlOSYIsX1yhJD_GF3hwXH-550IaKIYBq2__3RzjsxiIwC6MpqRKqg/foundation.png\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2hNEMEqtSLUZHd1PHWSCQvT9g5X2t-t-yecug8l5TFhg7498FBSzq5A8S7rcsbQFC1Jg/bulb.png\">\n<p>Therefore the strategy is to try all possible vertical locations, calculate the highest 'step' we can generate for each vertical location and calculate the expected profit. As usual, we retain the maximum one.</p>\n\n<p>So how do we calculate the highest possible step given a vertical location? Doing it by adding squares one-by-one is going to be too slow, therefore we turn to our trusty friend binary search. We want to determine the highest minimum-height step for that vertical location. Notice that since the amount of money (squares) required to build each 'step' is monotonically increasing, we can perform binary search.</p>\n\n","id":"0000000000432dff","statement":"<h3>Problem</h3>\n<p>\nYou've been playing roulette for a while in a local casino.\nRoulette is a simple casino game in which multiple players place bets\non one or more numbers between 0 and 36\n(inclusive). Next, a wheel is spun in one direction with a ball\nspinning in the other direction. The roulette wheel contains the same\nnumbers 0 to 36. Some real roulette wheels also have a space labeled 00, but ours does not.\nEventually, the ball falls on one of\nthe numbers. If a player placed a bet on that particular number, he\nreceives 36 times his bet (so the profit of that bet is 35 times the\nbet). All bets placed on other numbers lose.\n</p>\n\n<p>\nUnfortunately, luck hasn't been on your side, and you have been losing all night long. At one point, you started to wonder whether the roulette game was fair or not, and after observing the game some more, you noticed a pattern that must be profitable for the casino: the ball always lands on one of the numbers that has the least total money bet on it! If multiple numbers tie for the least total money bet, the ball lands on one of those uniformly at random.\n</p>\n\n<p>\nOf course, you'll be notifying the authorities about this foul play,\nbut first you want to win your money back by exploiting your new-found\nknowledge. To do so, you wait until all other players have placed\ntheir bets and then place bets of your own. Unfortunately, you\nhave a limited budget left, so you cannot bet more than that. You are allowed to bet on zero or more different numbers, and each of those bets can be any positive integer amount (perhaps with different amounts for different numbers), so as long as the sum of your bets does not exceed your budget.\nWhat is the maximum expected profit you can make?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of input gives the number of cases, <b>T</b>.\n<b>T</b> test cases follow. \nEach test case consists of two lines. The first line contains two\nintegers: the budget you still have, <b>B</b>, and the number\nof numbers other players have placed bets on, <b>N</b>. The second\nline contains <b>N</b> integers <b>X<sub>i</sub></b>, the total amounts of money bet by other players on each of those different numbers.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: \"\nfollowed by the maximum expected profit that you make\nif you place your bets optimally. A profit will be considered correct if it is within an absolute or relative error of 10<sup>-6</sup> of the correct answer.  See the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an explanation of what that means, and what formats of floating-point numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 37.<br/>\n</p>\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>B, <b>X<sub>i</sub></b></b> &le; 1,000.<br/>\n</p>\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>B, <b>X<sub>i</sub></b></b> &le; 10<sup>12</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n100 1\n10\n34 3\n5 6 7\n34 4\n1 1 10 10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 2\nCase #3: 0.9428571429\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn example 2, bet 1 on each of the 34 empty numbers for a guaranteed payback of 36, and a profit of 36 - 34 = 2. In example 3, bet 1 on each of the 33 empty numbers, so that you win 36 with probability 33/35. The gives an expected profit of 33/35 * 36 - 33.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Cheaters","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Introduction</h2>\n<p>In this problem, we are given a set of points on a 2D plane. The goal is to construct a single simple polygon that uses all of the points. To make things interesting, the area of the resulting polygon has an additional constraint; it must be strictly more than half of the area of the largest polygon constructed from any subset of points. A polygon that takes up maximum area but can use a subset of the points is always the convex hull of the points.</p>\n\n\n<h2>Small</h2>\n<p>For the small data case, we choose an exhaustive approach that finds the polygon with maximal area. Assuming that it is possible to construct a polygon with a large enough area (see the explanation of the large case for justification), the maximal area polygon will be a solution. The question now becomes how to construct a polygon of largest area. We permute the order of the fence posts. For each ordering, we verify the polygon has no intersecting edges (being careful of edges that pass through fence posts). We keep the polygon with the largest area. With <b>N</b>=10 fence posts, this takes no more than O(<b>N</b>! * T), where T is how long it takes to validate a polygon and compute its area. Verification can be implemented easily in O(<b>N</b><sup>2</sup>) time. Polygon area can be done in O(<b>N</b>) time. So the resulting runtime is O(<b>N</b>! * <b>N</b><sup>2</sup>). For <b>N</b>=10, this is around 500 million basic operations, which is relatively quick.</p>\n\n<h2>Large</h2>\n<p>For the large case, <b>N</b> = 1000, exhausting even a subset of fence post permutations it too costly. An algorithm over O(<b>N</b>^3) may take too long to compute. We explore a more direct method.</p>\n\n<p>As mentioned earlier, the polygon with the largest possible area using a subset of the fence posts is the convex hull. Suppose we break the convex hull into two polygons, one of these polygons must contain at least half of the convex hull's area. Notice that regardless of how the convex hull is split, one of the resulting polygons is always at least half of the area.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1_pbLPQVyvEY2rDInTilbuAABNXEx8IJ_3g0UVB2L9nACm3Jq5bVguMuMG6h3xx5hS4Dzbgg/blanket.png\">\n<p>Suppose we have a way to split the convex hull using the interior fence posts. This results in a polygon with at least half of the area of the convex hull, and at least one isolated vertex on the exterior of the polygon. We just need to connect the isolated vertices to the polygon without introducing intersecting edges. This process could only possibly add more area to the polygon, hence the final polygon is strictly more than half of the convex hull's area.</p>\n\n<p>Making the above observation as the basis of our solution, we can arbitrarily split the convex hull into the upper half and lower half.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U39KFM8L-KLDW800IDvpLGv7IDxKn3KDNWa02AduH6_XTdtl4rqaO-QHUmdLtVEOdjluw/race.png\">\n<p>Note that the union of upper and lower polygon contains the full area of the convex hull. Furthermore the interior path cannot cause intersecting edges, because we chose to sort the points from left to right (note, special care must be taken when ties are involved, see special cases). One of these polygons has at least half the area of the convex hull, as explained above.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1EutBXprm-wkS0Qj9WAOT8URS1NaDMwSx_A5UmDaidelBbJH4Zs0XVtKpjysPp85nHKQ/turf.png\">\n<p>As mentioned, the larger of the two polygons will not contain all of the points. However, we can extend the polygon to use all the points. This is done by iteratively adding a point to the polygon. Because all exterior points are on the convex hull, the polygon must increase in area as we do this. The points are added to the polygon by taking an exterior point and \"connecting\" it to the point left and right of it on the polyline dividing the convex hull. For an optimization, the exterior points can be added at the same time as forming the polyline if you know the exterior points when constructing the polyline.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1AKEtPVZvt6OHawF0tSm2n6KouBNS6zF9zd-DX_dGrvpf6moFxOY8AU4zDq_P9ZejQWw/wave.png\">\n<h2>Special cases</h2>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1gHxp5y0l0nlD2R7ouNNRyub2UIM1EHuKeHRvAZtIWTNIe2r3P_9J42qxZbSPKVTiy7gmc/aerial.png\">\n<p>On the left example, the leftmost and rightmost points are connected. In this case, the convex hull is split into the full polygon and a line segment. The full polygon, a.k.a. the convex hull, can simply be used as the final answer.</p>\n<p>The second special case, above on the right, can occur when points share the same x coordinate and \"left to right\" is not well defined. An elegant way to handle this case is to project all of the points onto a \"nearly horizontal\" line and retain the scalar project values. If we pick a line that is not parallel or orthogonal to the line formed by any two points in our input, then each projected point will have a unique position on the \"horizontal\" line. A line that passes through points (0,0) and (200000,1) will work.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0x6ZI-wzG3DjLIvQ6rXbSw3Q-3_Jee0G4HjLmQ2V3rjE5yYCtw9OwUFIfATObBdnrp8zyT5w/paddock.png\">\n<p>Once all points are projected onto the line, the sort order of the points is determined by the projected value. If we take a collection of points and go through them in this order we form a polyline.</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2cxji4bCMkQfD7L6k-zKavVew2_w52W1_h6sI7QQS1hB3fUBUMlMq-J9gXM4Tki7Sw/saw.png\">\n<p>We can show that running this algorithm including the two endpoints of one of our half hulls and all the middle points will create a closed polygon. Notice that when you also expand the middle set to also contain all points that are in the half hulls that the polygon grows in size. This is because the points added are outside our current polygon as a property of the half hull. A line coming from the middle points will move away from the first polygon towards the hull and back to the middle points when following our order. This technique ensures that the area of our polygon grows bigger than the polygon with just the middle points. </p>\n<h2>Putting it all together</h2>\n<p>To sum up the solution, we will reiterate the main steps of our algorithm:</p>\n<ul>\n<li>Take the input and turn it into three sets of points cut using line (0,0) to (200000,1):<ul><li>upper hull</li><li>lower hull</li><li>middle points</li></ul></li>\n<li>Run the closing algorithm on using upper hull and combining lower hull and middle points.</li>\n<li>Run the closing algorithm on using lower hull and combining upper hull and middle points.</li>\n<li>Print the solution with the larger polygon. </li>\n</ul>\n","id":"0000000000432fe8","statement":"<h3>Problem</h3>\n<p>\nYou have recently purchased a nice big farmyard, and you would like to build a fence around it. There are already <b>N</b> fence posts in your farmyard.</p>\n\n<p>You will add lengths of fence in straight lines connecting the fence posts. Unfortunately, for reasons you don't fully understand, your lawyers insist you actually have to use <i>all</i> the fence posts, or things will go bad.</p>\n\n<p>In this problem, the posts will be represented as points in a 2-dimensional plane. You want to build the fence by ordering the posts in some order, and then connecting the first with the second, second with third, and finally the last one with the first. The fence segments you create should be a polygon without self-intersections. That is, at each fence-post there are only two fence segments, and at every other point there is at most one fence segment.\n</p>\n\n<p>Now that's easy, but you also actually want to preserve the fact your farmyard is big! It's not really fun to wall off most of your farmyard with the fences. So you would like to create the fence in such a way that the enclosed area is <i>more</i> than half of the maximum area you could enclose if you were allowed not to use all the posts.</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. The first line of each test case contains the number <b>N</b> of posts. The posts are numbered from 0 to <b>N</b> - 1. Each of the next <b>N</b> lines contains two integers <b>X<sub>i</sub></b> and <b>Y<sub>i</sub></b> separated by a single space: the coordinates of the <b>i</b>-th post.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: \", where x is the case number (starting from 1), followed by <b>N</b> distinct integers from 0 to <b>N</b> - 1, separated by spaces. They are the numbers of the posts, in either clockwise or counter-clockwise direction, that you will use to build the fence. Note that the first and last posts are connected.\n<br><br>\nIf there are multiple solutions, print any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nThe posts will be at <b>N</b> unique points, and will not all lie on the same line.<br/>\n</p>\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>T</b> &le; 100<br/>\n3 &le; <b>N</b> &le; 10<br/>\n-100 &le; <b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b> &le; 100<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>T</b> &le; 30<br/>\n3 &le; <b>N</b> &le; 1000<br/>\n-50000 &le; <b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b> &le; 50000<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n1 2\n2 0\n0 0\n1 1\n5\n0 0\n1 1\n2 2\n0 2\n2 0\n3\n0 0\n1 0\n0 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 1 2 3\nCase #2: 0 1 4 2 3\nCase #3: 0 2 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first test case, there are three polygons we can construct, and two of them have a large enough area &mdash; the ones described by sequences 0 1 2 3 and 0 2 1 3. The polygon described by 0 1 3 2 would be too small. In the second test case, we have make sure the polygon does not intersect itself, so, for instance, 0 1 2 3 4 or 0 1 3 4 2 would be bad. In the third case, any order describes the same triangle and is fine.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Rural Planning","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Small dataset</h3>\n\n<p>In this problem we are interested in calculating the average amount of money we will make from filling up every gondola on our observation wheel. Because of linearity of expectation, this is equivalent to summing up the expected amount of money paid by each person. Given the fact that the amount a person pays doesn't depend on the order in which gondolas got occupied, we can represent the current free/occupied state of gondolas as a bitmask and use dynamic programming to solve the small case.</p>\n\n<p>Let <b>E</b>(<b>mask</b>) be the expected amount of money we make starting from the configuration represented by <b>mask</b>, where 0 represents an empty gondola, and 1 represents an occupied gondola. A person has a probability of 1/<b>N</b> of starting at any given position. Once that starting position is fixed, we simply find the first 0 following it (in cyclic order), and that's where the person will eventually end up. </p>\n\n<p>We'll define <b>f</b>(<b>i</b>) as the index of the gondola occupied by a person who starts at position <b>i</b>. Similarly, let <b>c</b>(<b>i</b>) be the amount of money this person pays, as per the problem statement. Then we have the following recurrence:</p>\n\n<p><b>E</b>(<b>mask</b>)=1/<b>N</b>*&#8721;<sub><b>i</b>=0..<b>N</b>-1</sub>(<b>E</b>(<b>mask</b> | (1 &lt;&lt; <b>f</b>(<b>i</b>)) ) + <b>c</b>(<b>i</b>))</p>\n\n<p>The bitwise operation here simply sets the bit corresponding to the gondola the user occupied. The base case is when there are no empty positions, in which case the expected amount of money is 0.</p>\n\n<p>There are 2<sup><b>N</b></sup> states, each of which can be computed in linear time, so our time complexity is O(<b>N</b>*2<sup><b>N</b></sup>). This is pretty easy for the small data set, but unfortunately it's far too slow for the large case.</p>\n\n<h3>Large dataset</h3>\n\n<p>Let's analyze the problem from the end: one of our gondolas will be the last to become occupied, so we have several cases, one per each free gondola at the beginning. The expected amount of money we will get is equal to the sum of the expected amount of money we make in each of those cases multiplied by the probability of that case.</p>\n\n<p>At first, it doesn't seem we've reduced the complexity of the problem: instead of having to find just the expected amount for the whole process, we now have to find both the expected amount and the probability for several cases! However, we can repeat the above trick. Take one of those cases, let's say that gondola <b>i</b> is the last to become occupied. Let's look at which gondola will be occupied directly before it. Let's say it's gondola <b>j</b>. And here's the breakthrough: as soon as we've fixed that gondolas <b>i</b> and <b>j</b> are the last two to become occupied, the observation wheel has been separated into two independent parts that don't affect each other: those between <b>i</b> and <b>j</b>, and those between <b>j</b> and <b>i</b>. They don't affect each other since <b>i</b> and <b>j</b> stay empty, and thus no person approaching one part of the wheel will end up in the other part.</p>\n\n<p>Our approach in general will be to compute <b>E</b>(<b>i</b>, <b>j</b>), the expected amount of money we get from all gondolas from <b>i</b>-th until (<b>j</b>-1)-th, excluding <b>j</b>-th gondola itself which will stay empty. It is possible to have <b>i</b> &gt; <b>j</b> since we're dealing with a cyclic problem, so keep this in mind when implementing things. We basically start at <b>i</b> and proceed around the circle, stopping just short of <b>j</b>.</p>\n\n<p>To compute expectations, we're going to need probabilities, so first let's look at <b>P</b>(<b>i</b>, <b>j</b>), the probability that <b>j</b>-th gondola will stay empty while we fill up all gondolas from the interval [<b>i</b>, <b>j</b>) assuming each coming person approaches some gondola in inteval [<b>i</b>, <b>j</b>] (note that j is included here). We can develop a recurrence to compute this.</p>\n\n<p>Suppose we know that the last person enters the gondola at position (<b>i</b> + <b>k</b>). This splits the interval into two parts, with <b>a</b> empty squares on the left, <b>b</b> empty squares on the right, and 1 more empty square at (<b>i</b>+<b>k</b>). </p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3n2y_DV0Su6hhQBdvJyINvOWpvTcLutMOW9L61CyUcs7iQNBqdjdF2b1ez42E4AIGSYz7hbG34d8o/yiVNpBUiihL.png\"/>\n\n<p>The probability that gondola <b>j</b> stays empty while we fill interval [<b>i</b>, <b>j</b>) and that gondola at position (<b>i</b>+<b>k</b>) is filled last is <b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) and can be computed as:</p>\n\n<p><b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) = <b>C</b>(<b>a</b>+<b>b</b>, <b>a</b>)*((<b>k</b>+1)/(<b>j</b>-<b>i</b>+1))<sup><b>a</b>+1</sup>*((<b>j</b>-<b>i</b>-<b>k</b>)/(<b>j</b>-<b>i</b>+1))<sup><b>b</b></sup>*<b>P</b>(<b>i</b>, <b>i</b>+<b>k</b>)*<b>P</b>(<b>i</b>+<b>k</b>+1, <b>j</b>)</p>\n\n<p>Here <b>C</b>(<b>n</b>, <b>k</b>) is the binomial coefficient representing the number of ways to choose <b>k</b> objects from a set of <b>n</b>. The equation above amounts to choosing <b>a</b> people from (<b>a</b>+<b>b</b>) to go on the left side of the final empty space, and then making sure that (<b>a</b>+1) people go to the left side (including the person to fill up gondola <b>i</b>+<b>k</b>) and <b>b</b> people go to the right side. The probability that gondola <b>i</b>+<b>k</b> will stay empty is <b>P</b>(<b>i</b>, <b>i</b>+<b>k</b>), and the probability that gondola j will stay empty is <b>P</b>(<b>i</b>+<b>k</b>+1, <b>j</b>).</p> \n\n<p>This assumes that (<b>i</b>+<b>k</b>) is empty initially, otherwise we define <b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) = 0.</p>\n\n<p>Of course, we can't actually fix the final person, but since every way to fill up the interval has some final person, we can just compute the probability that gondola <b>j</b> will stay empty as the sum of <b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) over all possible final positions <b>k</b>, giving:</p>\n\n<p><b>P</b>(<b>i</b>, <b>j</b>)=&#8721;<sub><b>k</b>=0..<b>j</b>-<b>i</b>-1</sub><b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>)</p>\n\n<p>For our base case, we have <b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>) = 1  if the interval [<b>i</b>, <b>j</b>) contains no free gondolas. This also includes the case where the interval is of size 0. Don't forget, we're still in a cyclic situation!</p>\n\n<p>On to computing expectations! We'll use the same trick of splitting around the last person. The expected money we get while filling out the interval [<b>i</b>, <b>j</b>) so that the last filled gondola is at position (<b>i</b>+<b>k</b>) is:</p>\n\n<p><b>E</b>(<b>i</b>, <b>j</b>, <b>k</b>) = <b>E</b>(<b>i</b>, <b>i</b>+<b>k</b>) + <b>E</b>(<b>i</b>+<b>k</b>+1, <b>j</b>) + <b>N</b> - <b>k</b>/2</p>\n\n<p>Summing over all possible <b>k</b> to get the expectation, we get:</p>\n\n<p><b>E</b>(<b>i</b>, <b>j</b>)=(&#8721;<sub><b>k</b>=0..<b>j</b>-<b>i</b>-1</sub><b>P</b>(<b>i</b>, <b>j</b>, <b>k</b>)*<b>E</b>(<b>i</b>, <b>j</b>, <b>k</b>))/<b>P</b>(<b>i</b>, <b>j</b>)</p>\n\n<p>The way the first equation works is to combine the expectations from the left interval and the right interval, and then we need the expected number of skips to place the final person. There are (<b>k</b>+1) starting positions, corresponding to 0 skips, 1 skip, ‚Ä¶, <b>k</b> skips. Each of these is equally likely, so the expectation is <b>N</b> - 1/(<b>k</b>+1)*(0 + 1 + ... + <b>k</b>)=<b>N</b> - <b>k</b>/2.</p>\n\n<p>As before <b>E</b>(<b>i</b>, <b>j</b>, <b>k</b>) = 0 if gondola at position (<b>i</b>+<b>k</b>) is occupied.</p>\n\n<p>To compute the final answer, we'll repeat the same trick in the final step. We try all possible empty positions as the last gondola to be filled and compute the expected number of skips. If the last empty position is i, then the expected money we get is:</p>\n\n<p><b>P</b>(<b>i</b>+1, <b>i</b>)*(<b>E</b>(<b>i</b>+1, <b>i</b>) + (<b>N</b>+1)/2), </p>\n\n<p>and the total expected amount of money is just the sum of this quantity over all empty positions.</p>\n\n<p>This algorithm is O(<b>N</b><sup>3</sup>), which is easily within the time limit for the large case.</p> \n","id":"0000000000433337","statement":"<h3>Problem</h3>\n<p>\nAn <i>observation wheel</i> consists of <b>N</b> passenger <i>gondolas</i> arranged in a circle, which is slowly rotating. Gondolas pass the entrance one by one, and when a gondola passes the entrance, a person may enter that gondola.\n</p>\n\n<p>\nIn this problem, the gondolas are so small that they can take just one person each, so if the gondola passing by the entrance is already occupied, the person waiting at the entrance will have to wait for the next one to arrive. If that gondola is also occupied, the person will have to wait for the next one after that, and so on, until a free gondola arrives. For simplicity, we will not consider people exiting the gondolas in this problem&nbsp;&mdash; let's assume that all people do is enter the gondolas, and then rotate with the wheel for an arbitrarily long time.\n</p>\n\n<p>\nWe want to make sure people are not disappointed because of long waiting times,  and so we have introduced a flexible pricing scheme: when a person approaches the wheel, and the first gondola passing by the entrance is free, she pays <b>N</b> dollars for the ride. If the first gondola is occupied and she has to wait for the second one, she pays <b>N</b>-1 dollars for the ride. If the first two gondolas are occupied and she has to wait for the third one, she pays <b>N</b>-2 dollars for the ride. Generally, if she has to wait for <b>K</b> occupied gondolas to pass by, she pays <b>N</b>-<b>K</b> dollars. In the worst case, when she has to wait for all but one gondola to pass, she will pay just 1 dollar.\n</p>\n\n<p>\nLet's assume that people approach our wheel at random moments in time, so for each person approaching the wheel, the first gondola to pass the entrance is picked uniformly and independently. Let's also assume that nobody will come to the wheel while there's already at least one person waiting to enter, so that we don't have to deal with queueing. A person will always take the first free gondola that passes the entrance.\n</p>\n\n<p>\nYou are given the number of gondolas and which gondolas are already occupied. How much money are we going to make, on average, until all gondolas become occupied?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow. Each line describes one test case and contains only '.' (dot) or 'X' (capital letter X) characters. The number of characters in this line gives you <b>N</b>. The <b>i</b>-th character is 'X' when the <b>i</b>-th gondola is already occupied, and '.' when it's still free. The gondolas are numbered in the order they pass the entrance, so the 1st gondola is followed by the 2nd gondola, and so on, starting over from the beginning after the last gondola passes.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the average amount of money we will get, in dollars. Answers with absolute or relative error no larger than 10<sup>-9</sup> will be accepted. See the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an explanation of what that means, and what formats of floating-point numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>N</b> &le; 20.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 200.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n.X.\nX.X.\n.XX.\nX..XX.\n.XX..X\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4.66666666666667\nCase #2: 6.00000000000000\nCase #3: 5.75000000000000\nCase #4: 13.4722222222222\nCase #5: 13.5277777777778\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Notes</h3>\n<p>\nHere's how the first example works. There are nine possibilities, each with probability 1/9:\n</p>\n\n<p>\nThe first person comes. If the next gondola to pass the entrance is:\n<ul>\n<li>The 1st gondola, which is free, the first person enters it and pays 3 dollars. Then, some time later, the second person comes. If the next gondola to pass the entrance is:\n<ul>\n<li>The 1st gondola, which is occupied, and so is the 2nd gondola, the second person has to wait until the 3rd gondola, and thus she pays just 1 dollar before entering it. In total, we've earned 4 dollars.\n<li>The 2nd gondola, which is occupied, the second person has to skip it and enter the 3rd gondola and thus pays 2 dollars. In total, we've earned 5 dollars.\n<li>The 3rd gondola, which is free, so the second person pays 3 dollars. In total, we've earned 6 dollars.\n</ul>\n<li>The 2nd gondola, which is occupied, the first person has to skip it and enter the 3rd gondola, paying 2 dollars. Then, some time later, the second person comes. If the next gondola to pass the entrance is:\n<ul>\n<li>The 1st gondola, which is free, the second person pays 3 dollars. In total, we've earned 5 dollars.\n<li>The 2nd gondola, which is occupied (as is the 3rd gondola), the second person has to wait until the 1st gondola, and thus she pays just 1 dollar before entering it. In total, we've earned 3 dollars.\n<li>The 3rd gondola, which is occupied, the second person has to skip it and enter the 1st gondola and thus pays 2 dollars. In total, we've earned 4 dollars.\n</ul>\n<li>The 3rd gondola, which is free, the first person enters it and pays 3 dollars. Then, some time later, the second person comes. If the next gondola to pass the entrance is:\n<ul>\n<li>The 1st gondola, which is free, the second person pays 3 dollars. In total, we've earned 6 dollars.\n<li>The 2nd gondola, which is occupied (as is the 3rd gondola), the second person has to wait until the 1st gondola, and thus she pays just 1 dollar before entering it. In total, we've earned 4 dollars.\n<li>The 3rd gondola, which is occupied, the second person has to skip it and enter the 1st gondola and thus pays 2 dollars. In total, we've earned 5 dollars.\n</ul>\n</ul>\n</p>\n\n<p>We have nine possibilities, earning 3 dollars in one of them, 4 dollars in three of them, 5 dollars in three of them, and 6 dollars in two of them. On average, we earn (1*3+3*4+3*5+2*6)/9=42/9=4.6666666666... dollars.</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Observation Wheel","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043319e","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2013"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
