{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1252026000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432cc4","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>This was the first round of Google Code Jam 2009, and what an exciting round it was!  8600 people solved at least one problem, and about 7830 of those people solved a problem fully and got to advance to Round 1.  2420 people solved all three problems, and 3080 were properly welcomed to Code Jam.</p>\n<p>The round was marred by an outage early on: a nearly two-hour period in which contestants would often get error messages when they tried to download an input.  To make up for that we extended the round by two hours, and offer our sincerest apologies to everyone affected.</p>\n<p>Over 10,000 contestants, representing 111 countries, used 40 languages to solve the problems.  We hope you enjoyed the problems, and we look forward to seeing 7830 of you in Round 1!</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Credits</p>\n<p>Problem A. <i>Alien Language</i> Written by Junbin Teng. Prepared by Marius Andrei.</p>\n<p>Problem B. <i>Watersheds</i> Written by Andrew Gove. Prepared by Xiaomin Chen and Igor Naverniouk.</p>\n<p>Problem C. <i>Welcome to Code Jam</i> Written by Xiaomin Chen. Prepared by Xiaomin Chen and Bartholomew Furrow.</p>\n<p>Contest analysis presented by Bartholomew Furrow, Marius Andrei, Igor Naverniouk, and Xiaomin Chen.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1251932400000,"tasks":[{"analysis":"<p>\nIn this problem, every one is welcomed by a (somehow) standard dynamic programming problem.\n</p>\n<p>\nThe word we want to find is <b>S</b> = \"welcome to code jam\", in a long string <b>T</b>. In fact the solution is not very different when we want to find any <b>S</b>. It is actually illustrative to picture the cases for short words.\n</p>\n<p>In case <b>S</b> is just a single character, you just need to count how many times this character appears in <b>T</b>. If <b>S</b> = \"xy\" is a string of length 2, instead of brute force all the possible positions, one can do it in linear time, start from left to the right. For each occurrence of 'y', one needs to know how many 'x's appeared before that 'y'.\n</p>\n<p>The general solution follows this pattern. Let us again use <b>S</b> = \"welcome to code jam\" as an example. The formal solution will be clear from the example; and you can always download the good solutions (with nice programming techniques) from the scoreboard.</p>\n<p>\nSo, let us define, for each position i in <b>T</b>, <b>T<sup>(i)</sup></b> to be the string consists of the first i characters of <b>T</b>. And write\n<ul>\n<li>Dp[i,1]: How many times we can find \"w\" in <b>T<sup>(i)</sup></b>?</li>\n<li>Dp[i,2]: How many times we can find \"we\" in <b>T<sup>(i)</sup></b>?</li>\n<li>Dp[i,3]: How many times we can find \"wel\" in <b>T<sup>(i)</sup></b>?</li>\n<li>Dp[i,4]: How many times we can find \"welc\" in <b>T<sup>(i)</sup></b>?</li>\n<li>...</li>\n<li>Dp[i,18]: How many times we can find \"welcome to code ja\" in <b>T<sup>(i)</sup></b>?</li>\n<li>Dp[i,19]: How many times we can find \"welcome to code jam\" in <b>T<sup>(i)</sup></b>?</li>\n</ul>\nAssume Dp[i,j] is computed for each j, let us see how easy we can compute, say, Dp[i+1,4]:\n<ol>\n<li>If the (i+1)-th character of <b>T</b> is not 'c', then Dp[i+1,4] = Dp[i,4].</li>\n<li>If the (i+1)-th character of <b>T</b> is 'c', then we can include all the \"welc\"s found in <b>T<sup>(i)</sup></b>, as well as those \"welc\"s ends exactly on the (i+1)-th character, so Dp[i+1,4] = Dp[i,4] + Dp[i,3].</li>\n</ol>\nFinally, let <b>n</b> be the length of the text <b>T</b>, Dp[n,19] will be our answer.\n</p>\n<p>\nThat's it. Welcome to Code Jam; and we hoped you enjoyed this round.\n</p>","id":"0000000000432a82","statement":"<h3>Problem</h3>\n<p>So you've registered.  We sent you a welcoming email, to welcome you to code jam.  But it's possible that you still don't feel welcomed to code jam.  That's why we decided to name a problem \"welcome to code jam.\"  After solving this problem, we hope that you'll feel very welcome.  Very welcome, that is, to code jam.</p>\n<p>If you read the previous paragraph, you're probably wondering why it's there. But if you read it very carefully, you might notice that we have written the words \"welcome to code jam\" several times: 400263727 times in total.  After all, it's easy to look through the paragraph and find a 'w'; then find an 'e' later in the paragraph; then find an 'l' after that, and so on.  Your task is to write a program that can take any text and print out how many times that text contains the phrase \"welcome to code jam\".</p>\n<p>To be more precise, given a text string, you are to determine how many times the string \"welcome to code jam\" appears as a sub-sequence of that string.  In other words, find a sequence <i>s</i> of increasing indices into the input string such that the concatenation of input[s[0]], input[s[1]], ..., input[s[18]] is the string \"welcome to code jam\".</p>\n<p>The result of your calculation might be huge, so for convenience we would only like you to find the last 4 digits.</p>\n\n<h3>Input</h3>\n<p>The first line of input gives the number of test cases, <b>N</b>.  The next N lines of input contain one test case each.  Each test case is a single line of text, containing only lower-case letters and spaces. No line will start with a space, and no line will end with a space.</p>\n\n<h3>Output</h3>\n<p>For each test case, \"Case #x: dddd\", where x is the case number, and dddd is the last four digits of the answer. If the answer has fewer than 4 digits, please add zeroes at the front of your answer to make it exactly 4 digits long.</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n</p>\n\n1 &le; <b>N</b> &le; 100<br/>\n\n<h3>Small dataset</h3>\n\nEach line will be no longer than 30 characters.\n\n<h3>Large dataset</h3>\n\nEach line will be no longer than 500 characters.\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\nelcomew elcome to code jam\nwweellccoommee to code qps jam\nwelcome to codejam\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0001\nCase #2: 0256\nCase #3: 0000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Welcome to Code Jam","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nFor each cell, we need to determine its eventual sink. Then, to each\ngroup of cells that share the same sink, we need to assign a unique\nlabel.\n</p>\n<p>\nThe inputs to this problem are small enough for a simple brute-force\nsimulation algorithm. Start with a cell and trace the path that water\nwould take by applying the water flow rules repeatedly. Here is one\npossible solution in Python.\n</p>\n\n<pre>\nimport sys\n\ndef ReadInts():\n  return list(map(int, sys.stdin.readline().strip().split(\" \")))\n\ndef Cross(a, b):\n  for i in a:\n    for j in b:\n      yield (i, j)\n\ndef Neighbours(ui, uj, m, n):\n  if ui - 1 &gt;= 0: yield (ui - 1, uj)\n  if uj - 1 &gt;= 0: yield (ui, uj - 1)\n  if uj + 1 &lt; n: yield (ui, uj + 1)\n  if ui + 1 &lt; m: yield (ui + 1, uj)\n\nN = ReadInts()[0]\nfor prob in xrange(1, N + 1):\n  # Read the map\n  (m, n) = ReadInts()\n  maze = [ReadInts() for _ in xrange(m)]\n  answer = [[\"\" for _ in xrange(n)] for _ in xrange(m)]\n\n  # The map from sinks to labels.\n  label = {}\n  next_label = 'a'\n\n  # Brute force each cell.\n  for (ui, uj) in Cross(xrange(m), xrange(n)):\n    (i, j) = (-1, -1)\n    (nexti, nextj) = (ui, uj)\n    while (i, j) != (nexti, nextj):\n      (i, j) = (nexti, nextj)\n      for (vi, vj) in Neighbours(i, j, m, n):\n        if maze[vi][vj] &lt; maze[nexti][nextj]:\n          (nexti, nextj) = (vi, vj)\n\n    # Cell (ui, uj) drains to (i, j).\n    if (i, j) not in label:\n      label[(i, j)] = next_label\n      next_label = chr(ord(next_label) + 1)\n    answer[ui][uj] = label[(i, j)]\n\n  # Output the labels.\n  print \"Case #%d:\" % prob\n  for i in xrange(m):\n    print \" \".join(answer[i])\n</pre>\n\n","id":"0000000000432bd8","statement":"<h3>Problem</h3>\n<p>\nGeologists sometimes divide an area of land into different regions based on where rainfall flows down to. These regions are called <i>drainage basins</i>.\n</p>\n<p>\nGiven an elevation map (a 2-dimensional array of altitudes), label the map such that locations in the same drainage basin have the same label, subject to the following rules.\n<ul>\n  <li>From each cell, water flows down to at most one of its 4 neighboring cells.</li>\n  <li>For each cell, if none of its 4 neighboring cells has a lower altitude than the current cell's, then the water does not flow, and the current cell is called a <i>sink</i>.</li>\n  <li>Otherwise, water flows from the current cell to the neighbor with the lowest altitude.</li>\n  <li>In case of a tie, water will choose the first direction with the lowest altitude from this list: North, West, East, South.</li>\n</ul>\n\nEvery cell that drains directly or indirectly to the same sink is part of the same drainage basin. Each basin is labeled by a unique lower-case letter, in such a way that, when the rows of the map are concatenated from top to bottom, the resulting string is lexicographically smallest. (In particular, the basin of the most North-Western cell is always labeled 'a'.)\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input file will contain the number of maps, <b>T</b>. <b>T</b> maps will follow, each starting with two integers on a line -- <b>H</b> and <b>W</b> -- the height and width of the map, in cells. The next <b>H</b> lines will each contain a row of the map, from north to south, each containing <b>W</b> integers, from west to east, specifying the altitudes of the cells.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output 1+<b>H</b> lines. The first line must be of the form\n<pre>Case #<b>X</b>:</pre>\nwhere <b>X</b> is the test case number, starting from 1. The next <b>H</b> lines must list the basin labels for each of the cells, in the same order as they appear in the input.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  <b>T</b> &le; 100;<br>\n</p>\n\n<h3>Small dataset</h3>\n<p>\nTime limit: 25 seconds.<br/>\n  1 &le; <b>H</b>, <b>W</b> &le; 10;<br/>\n  0 &le; altitudes &lt; 10.<br/>\n  There will be at most two basins.\n</p>\n\n<h3>Large dataset</h3>\n<p>\nTime limit: 30 seconds.<br/>\n  1 &le; <b>H</b>, <b>W</b> &le; 100;<br>\n  0 &le; altitudes &lt; 10,000.<br>\n  There will be at most 26 basins.<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3 3\n9 6 3\n5 9 6\n3 5 9\n1 10\n0 1 2 3 4 5 6 7 8 7\n2 3\n7 6 7\n7 6 7\n5 5\n1 2 3 4 5\n2 9 3 9 6\n3 3 0 8 7\n4 9 8 9 8\n5 6 7 8 9\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\na b b\na a b\na a a\nCase #2:\na a a a a a a a a b\nCase #3:\na a a\nb b b\nCase #4:\na a a a a\na a b b a\na b b b a\na b b b a\na a a a a\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Notes</h3>\n<p>\nIn Case #1, the upper-right and lower-left corners are sinks.  Water from the diagonal flows towards the lower-left because of the lower altitude (5 versus 6).\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Watersheds","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"First we store all the words in a 2 dimensional array.<br/>\nAfter that, we read each pattern, parse it, and count how many words match.<br/>\n<br/>\nOne possible way of storing a pattern is a 2 dimensional array P[15][26]. P[i][j] is True only if the <b>i</b>-th token contains the <b>j</b>-th letter of the alphabet, otherwise False. In other words, P[i] is a bitmap of the letters contained by the <b>i</b>-th token.<br/>\n<br/>\nParsing can be done like this:<br/>\n- read one character <b>c</b><br/>\n- if <b>c</b> is '(', read characters until we hit ')'. The characters read are the token.<br/>\n    else the token is the character <b>c</b><br/>\n- populate P[i] for the characters in the token<br/>\n<br/>\nTo count how many words match, we make sure that each letter <b>i</b> from the word is contained in the bitmap P[i].<br/>\n<br/>\nTotal complexity is O(N * L * D).<br/>\n<br/>\nIn some programming languages this can solved by transforming the pattern into a regular expression. For instance in python replace '(' and ')' with '[' and ']'.\n","id":"0000000000433154","statement":"<h3>Problem</h3>\n<p>After years of study, scientists at Google Labs have discovered an alien language transmitted from a faraway planet.  The alien language is very unique in that every word consists of exactly <b>L</b> lowercase letters.  Also, there are exactly <b>D</b> words in this language.</p>\n\n<p>Once the dictionary of all the words in the alien language was built, the next breakthrough was to discover that the aliens have been transmitting messages to Earth for the past decade.  Unfortunately, these signals are weakened due to the distance between our two planets and some of the words may be misinterpreted. In order to help them decipher these messages, the scientists have asked you to devise an algorithm that will determine the number of possible interpretations for a given pattern.</p>\n\n<p>A pattern consists of exactly <b>L</b> tokens.  Each token is either a single lowercase letter (the scientists are very sure that this is the letter) or a group of unique lowercase letters surrounded by parenthesis ( and ). For example: (ab)d(dc) means the first letter is either a or b, the second letter is definitely d and the last letter is either d or c.  Therefore, the pattern (ab)d(dc) can stand for either one of these 4 possibilities: add, adc, bdd, bdc.</p>\n\n<h3>Input</h3>\n<p>The first line of input contains 3 integers, <b>L</b>, <b>D</b> and <b>N</b> separated by a space. <b>D</b> lines follow, each containing one word of length <b>L</b>. These are the words that are known to exist in the alien language. <b>N</b> test cases then follow, each on its own line and each consisting of a pattern as described above. You may assume that all known words provided are unique.</p>\n\n<h3>Output</h3>\n<p>For each test case, output <pre>Case #<b>X</b>: <b>K</b></pre> where <b>X</b> is the test case number, starting from 1, and <b>K</b> indicates how many words in the alien language match the pattern.</p>\n<br/>\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n</p>\n\n<h3>Small dataset</h3>\n<p>\n1 &le; <b>L</b> &le; 10<br>\n1 &le; <b>D</b> &le; 25<br>\n1 &le; <b>N</b> &le; 10<br>\n</p>\n<h3>Large dataset</h3>\n<p>\n1 &le; <b>L</b> &le; 15<br>\n1 &le; <b>D</b> &le; 5000<br>\n1 &le; <b>N</b> &le; 500<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3 5 4\nabc\nbca\ndac\ndbc\ncba\n(ab)(bc)(ca)\nabc\n(abc)(abc)(abc)\n(zyx)bc\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 1\nCase #3: 3\nCase #4: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Alien Language","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432cc4","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2009"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
