{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1586575800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000019fd74","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Round 1A was the second of three weekend contests in a row! This time, we\n  opened with <i>Pattern Matching</i>, which was not as difficult as it\n  may have initially seemed. <i>Pascal Walk</i> was an ad hoc problem that\n  could be solved via various graph searching strategies, or with a more\n  \"mathy\" insight. <i>Square Dance</i> required some thought about data\n  structures. We hope there was something for everyone!\n</p><p>\n  <b>Benq</b> took a lead early on by solving the first and last problems in\n  under 20 minutes, but then our six-time defending champion\n  <b>Gennady.Korotkevich</b> snagged first place with a perfect score only 33\n  minutes and 19 seconds into the round! Next up was <b>vepifanov</b> at 43:01,\n  followed by <b>ecnerwala</b>, <b>semiexp.</b>, and <b>Geothermal</b>.\n</p><p>\n  Almost 12000 contestants submitted attempts in this round! Pattern Matching\n  got a lot of solves, but Pascal Walk was tougher, and many contestants never\n  made it to Square Dance. Even so, there were over 400 perfect scores! The\n  tentative cutoff for advancement to Round 2 from this round (top 1500) is 63\n  points, plus a fast enough penalty time; that corresponds to solving the\n  first two problems.\n</p><p>\n  As usual, we will aim to finalize the results well before next weekend's\n  Round 1B. If you advanced in this round, you can relax until Round 2 in\n  mid-May, but if not, you have two more chances coming up! Either way,\n  consider practicing with some past problems from our\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/archive\" target=\"_blank\">archive</a>.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Pattern Matching: Written by Pablo Heiber. Prepared by Mohamed Yosri Ahmed,\n  Jonathan Irvin Gunawan, and Ian Tullis.\n</p><p>\n  Pascal Walk: Written by Ian Tullis. Prepared by Artem Iglikov.\n</p><p>\n  Square Dance: Written by Pablo Heiber. Prepared by Yossi Matsumoto.\n</p><p>\n  Solutions and other problem preparation and review by Mohamed Yosri Ahmed,\n  Liang Bai, Timothy Buzzelli, Kevin Gu, Jonathan Irvin Gunawan, Md Mahbubul\n  Hasan, and Artem Iglikov.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Pattern Matching: Pablo Heiber</li>\n  <li>Pascal Walk: Ian Tullis</li>\n  <li>Square Dance: Artem Iglikov</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1586566800000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  The answer for <b>N</b> &le; 500 can always be constructed by walking along the leftmost\n  positions of the rows of the triangle: (1, 1), (2, 1), ..., (<b>N</b>-1, 1), (<b>N</b>, 1).\n</p><p>\n  We can handle the case <b>N</b> = 501 by making a detour to pick up the 2 in the third row before\n  returning to the left side. That is, our walk takes us through the positions (1, 1), (2, 2),\n  (3, 3), (3, 2), (3, 1), (4, 1), ..., (498, 1).\n</p>\n<h3>Test set 2</h3>\n<p>\n  With only 1000 possible test cases to consider, we can find an answer to each one before\n  submitting. One way to do this is to walk over the triangle in e.g. a breadth-first or random\n  way, taking care never to reuse a position or visit more than 500 positions. We can check our\n  cumulative sum at each position, and whenever we encounter a sum that we have never seen before,\n  we record the sequence of positions that we used to obtain it. When our sum exceeds 1000, we\n  backtrack in our search or start over with a new random path, and so on, until we have an answer\n  for every possible <b>N</b>. It's difficult to prove a priori that this will work, but we can be\n  optimistic given that the top few rows of the triangle have many small values to work with.\n  Indeed, this method finds a full set of solutions very quickly.\n</p><p>\n  An alternate method is to observe that the positions immediately to the right of the leftmost\n  positions &mdash; named (x, 2) for each x &ge; 2 &mdash; are 1, 2, 3, 4, 5, and so on. We can\n  move from the top position in the triangle down to the 1 at position (2, 1), then follow that\n  line to the 2 at (3, 2), the 3 at (4, 3), etc., until our next move would cause the cumulative\n  sum to exceed our target. Then, we can instead make a move to the left to reach a 1 on the left\n  edge of the triangle, and then proceed downward along that edge, taking as many extra 1s as we\n  need. Since the sum of the first 45 natural numbers is over 1000, we can be sure that we will\n  never need to take more than 45 of these extra 1s, or visit more than 45 of the positions along\n  this line of natural numbers. This ensures we never use more than 90 positions in total.\n</p>\n<h3>Test set 3</h3>\n<p>\n  There are various ways to solve the third test set, but one of our favorites takes advantage of a\n  special property of Pascal's triangle: the entries in the r-th row (counting starting from 1) sum\n  to 2<sup>r-1</sup>. This is to be expected from the way in which each row is constructed from the\n  previous one: each element in a row contributes to two elements in the next row, so the sum\n  doubles with each row.\n</p><p>\n  This observation suggests a strategy for constructing any <b>N</b> that we want: write <b>N</b> in\n  binary, and then look through that representation, starting from the least significant bit. If\n  the r-th least significant bit (counting starting from 1) is a 1, our path should consume all of\n  the elements in the r-th row. If the r-th least significant bit is a 0, we should skip that row\n  somehow. We only need the first 30 rows of the triangle, since the 31st row's sum is\n  2<sup>30</sup>, which is larger than the maximum possible <b>N</b> of 10<sup>9</sup>. Even if we\n  used every element in these first 30 rows (which we would never need to), that would only use 465\n  positions, which is within the limit of 500.\n</p><p>\n  This doesn't quite work as written, though, because our path must be continuous, and so there is\n  no way to skip a row. But we can get close via the following variant: proceed down one side of\n  the triangle (that is, the diagonal line of 1s) as long as we keep encountering 0 bits. Whenever\n  we encounter a 1 bit, we send our path horizontally across the corresponding row, sending us to\n  the other side of the triangle. This almost gets us the number we want, but we probably overshoot\n  because we have consumed some extra 1s from the rows corresponding to 0 bits. We can be sure that\n  there are fewer than 30 of those, though, since we visit at most 30 rows.\n</p><p>\n  So, we can use that variant, but instead of constructing <b>N</b>, we construct <b>N</b>-30\n  instead. Once we finish, we can tack on additional 1s from our current edge of the triangle until\n  we reach <b>N</b>. (We can handle cases with <b>N</b> &le; 30 specially, and just go down one\n  edge of the triangle.)\n</p><p>\n  There are other less elaborate ways to solve this test set, though! One is to walk down the\n  centers of the rows (e.g., going from (1, 1) to (2, 1) to (3, 2) to (4, 2) to (5, 3)...). This is\n  where the largest numbers live, so we will grow our sum as rapidly as possible. At some point,\n  though, when moving downward would make our sum grow too much, we can instead move to a one step\n  away from the center and continue zigzagging downward, and so on. Eventually we will reach the\n  edge full of 1s, and we can take as many more as we need. We must be careful not to increase the\n  sum so fast that we will not be able to \"escape\" to the edge of 1s. Nor should we reach the edge\n  too early, since we can only take so many 1s. However, it's not too difficult to get this method\n  to work.\n</p>\n","id":"00000000002b1353","statement":"<h3>Problem</h3>\n<p>\n  Pascal's triangle consists of an infinite number of rows of an increasing\n  number of integers each, arranged in a triangular shape.\n</p><p>\n  Let us define (r, k) as the k-th position from the left in the r-th row,\n  with both r and k counted starting from 1.\n  Then Pascal's triangle is defined by the following rules:\n</p>\n<ul>\n  <li>The r-th row contains r positions (r, 1), (r, 2), ..., (r, r).</li>\n  <li>The numbers at positions (r, 1) and (r, r) are 1, for all r.</li>\n  <li>The number at position (r, k) is the sum of the numbers at positions\n    (r - 1, k - 1) and (r - 1, k), for all k with 2 &le; k &le; r - 1.</li>\n</ul>\n<p>\n  The first 5 rows of Pascal's triangle look like this:\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U08hY2U7Nhfy0PDDNywvgVhYTgAoSR1c9AdDkQWTmDU7ME9eEj8dzFLdclKE5f7DZWFeV4FEo5d7ZehVypaUVmw-__9/pascal_triangle.png\" style=\"width:250px;height:auto;\"/>\n</p>\n<p>\n  In this problem, a <i>Pascal walk</i> is a sequence of s positions\n  (r<sub>1</sub>, k<sub>1</sub>),  (r<sub>2</sub>, k<sub>2</sub>), ...,\n  (r<sub>s</sub>, k<sub>s</sub>)\n  in Pascal's triangle that satisfy the following criteria:\n</p>\n<ul>\n  <li>r<sub>1</sub> = 1 and k<sub>1</sub> = 1.</li>\n  <li>Each subsequent position must be within the triangle and adjacent (in\n    one of the six possible directions) to the previous position. That is,\n    for all i &ge; 1, (r<sub>i + 1</sub>, k<sub>i + 1</sub>) must be one of\n    the following that is within the triangle:\n    (r<sub>i</sub> - 1, k<sub>i</sub> - 1), (r<sub>i</sub> - 1, k<sub>i</sub>),\n    (r<sub>i</sub>, k<sub>i</sub> - 1), (r<sub>i</sub>, k<sub>i</sub> + 1),\n    (r<sub>i</sub> + 1, k<sub>i</sub>), (r<sub>i</sub> + 1, k<sub>i</sub> + 1).\n  </li>\n  <li>No position may be repeated within the sequence. That is, for every i\n    &ne; j, either r<sub>i</sub> &ne; r<sub>j</sub> or k<sub>i</sub> &ne;\n    k<sub>j</sub>, or both.</li>\n</ul>\n<p>\n  Find any Pascal walk of S &le; 500 positions such that the sum of the numbers\n  in all of the positions it visits is equal to <b>N</b>. It is guaranteed\n  that at least one such walk exists for every <b>N</b>.\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of a single line containing a\n  single integer <b>N</b>.\n</p>\n<h3>Output</h3>\n<p>\n  For each test case, first output a line containing <code>Case #x:</code>,\n  where <code>x</code> is the test case number (starting from 1). Then, output\n  your proposed Pascal walk of length S &le; 500 using S additional lines. The i-th of\n  these lines must be <code>r<sub>i</sub> k<sub>i</sub></code> where\n  (r<sub>i</sub>, k<sub>i</sub>) is the i-th position in the walk. For example, the first line\n  should be <code>1 1</code> since the first position for all valid walks is (1, 1).\n  The sum of the numbers at the S positions of your proposed Pascal walk must be exactly <b>N</b>.\n</p>\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>N</b> &le; 501.<br/>\n</p>\n\n<h4>Test set 2 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n<h4>Test set 3 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1\n4\n19\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n1 1\nCase #2:\n1 1\n2 1\n2 2\n3 3\nCase #3:\n1 1\n2 2\n3 2\n4 3\n5 3\n5 2\n4 1\n3 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, only the starting position is needed.\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3BCzZkPRgYgXGHd2moZx60T8esD0aZwryPZ34fMheUGi2JJzokbmBsXCBOo2HiNbjODz_Cas3aekmP_akYEQnSuQ/sample_case_1.png\" style=\"width:250px;height:auto;\"/>\n</p>\n<p>\n  In Sample Case #2, notice that although a shorter path exists, the path does\n  not need to be of minimal length, as long as it uses no more than 500\n  positions.\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0T2qlFBk5BEY8T_rc6FtCLAGx89AxiUiDRfrQwcJz6sh2ESQ3e11sGPRgZ8x8_HTVS-XFueMJ4Jlf4wHZ2tfEJgA/sample_case_2.png\" style=\"width:250px;height:auto;\"/>\n</p>\n<p>\n  The following image depicts our solution to Sample Case #3:\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3E4MCsOjqJ2t7cR1HkTcoBHfBH2uKPbhYgXDnRatYocg9D1A1bPmN3tn3jYoTs9PdLypdjQ9CeP8EVKaRD8avu0w/sample_case_3.png\" style=\"width:250px;height:auto;\"/>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":3},{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Pascal Walk","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  Test Set 1 can be solved by simulating the competition:\n</p>\n<ol>\n  <li>\n    Iterate through all the cells of the floor. For each cell, if there is a dancer in that cell:\n    <ul>\n      <li>Add their level to the interest level of the competition.</li>\n      <li>Loop through their row and column to find all of their compass neighbors.</li>\n      <li>Count the number of their compass neighbors, and sum up their levels.</li>\n      <li>If the average level of the neighbors (calculated as sum of their levels divided by how\n        many neighbors there are) is greater than the level of the current dancer, add this dancer\n        to an elimination list.</li>\n    </ul>\n  </li>\n  <li>\n    Go through the elimination list and eliminate the dancers.\n  </li>\n  <li>\n    If the elimination list is empty, we are done. Otherwise, start again from step 1.\n  </li>\n</ol>\n<p>\n  Each iteration of the above algorithm has a time complexity of\n  O(<b>R</b>&times;<b>C</b>&times;(<b>R</b> + <b>C</b>)), and there are as\n  many iterations as there are rounds in the competition. The number of rounds in a competition\n  cannot be larger than the total number of dancers, <b>R</b> &times; <b>C</b>. So the total time\n  complexity is O(<b>R</b><sup>2</sup>&times;<b>C</b><sup>2</sup>&times;(<b>R</b> + <b>C</b>)).\n</p>\n<h3>Test Set 2</h3>\n<p>\n  Let's optimize our Test Set 1 solution &mdash; specifically, the following parts of it:\n</p>\n<ul>\n  <li>\n    For each round, we iterate through all <b>R</b>&times;<b>C</b> cells and check whether each\n    dancer is eliminated.\n  </li>\n  <li>\n    For each dancer, we may have to iterate through a significant part of their row and column in\n    order to find their compass neighbors.\n  </li>\n</ul>\n<p>\n  To improve the situation described in the first point above, we can observe that for i &gt; 1,\n  if dancer d is not eliminated in round i-1 and they are eliminated in round i,\n  their set of compass neighbors must have changed in between. For that to have happened,\n  at least one compass neighbor of d must have been eliminated in round i-1.\n</p>\n<p>\n  Using this observation, instead of checking every dancer in round i, we can limit the check to the\n  compass neighbors of those eliminated in round i-1. Since a dancer has at most 4 compass\n  neighbors at the time of elimination, the length of the list of candidates to check in round i is\n  at most 4 times the length of the elimination list for round i-1. The sum of the lengths of all\n  elimination lists is at most <b>R</b> &times; <b>C</b>; therefore, the sum of the lengths of all\n  lists of candidates to check is at most 4 &times; <b>R</b> &times; <b>C</b>. With the initial\n  check of all dancers, this means that we do O(<b>R</b> &times; <b>C</b>) checks overall with\n  this improvement.\n</p>\n<p>\n  To optimize finding compass neighbors, notice that when we remove a dancer, their eastern\n  neighbor becomes the eastern neighbor of their western neighbor and vice versa. The same thing\n  happens to the southern and northern neighbors. So, instead of finding the neighbors each\n  time we need them, we can maintain the specific location of the neighbor in each direction\n  for each dancer, and update their locations in constant time whenever we eliminate one. This is\n  effectively like keeping a linked list to represent each row and column, and this structure\n  allows us to remove and find neighbors in constant time.\n</p>\n<p>\n  Since we do O(<b>R</b> &times; <b>C</b>) checks thanks to the first optimization, and each check\n  can be done in constant time thanks to the second optimization, this yields an\n  O(<b>R</b> &times; <b>C</b>) time algorithm that solves the problem fast enough for Test Set 2.\n</p>\n","id":"00000000002b1355","statement":"<h3>Problem</h3>\n<p>\n  You are organizing an international dancing competition. You have already obtained all of the\n  following:\n</p>\n  <ul>\n    <li>A dance floor with <b>R</b> rows and <b>C</b> columns, consisting of unit square cells;</li>\n    <li><b>R &times; C</b> competitors;</li>\n    <li>A cutting-edge automated judge for the competition.</li>\n  </ul>\n<p>\n  But you are still missing an audience! You are worried that the competition might not be\n  interesting enough, so you have come up with a way to calculate the <i>interest level</i>\n  for the competition.\n</p>\n<p>\n  Each competitor occupies one square unit cell of the floor and stays there until they are\n  eliminated. A <i>compass neighbor</i> of a competitor x is another competitor y chosen such that\n  y shares a row or column with x, and there are no competitors still standing in cells in\n  between x and y. Each competitor may have between 0 and 4 compass neighbors, inclusive,\n  and the number may decrease if all the other competitors in one orthogonal direction\n  are eliminated.\n</p><p>\n  The competition runs one round at a time.\n  In between rounds i and i+1, if a competitor d had at least one compass neighbor during\n  round i, and d's skill level is strictly less than the average skill level of all of d's\n  compass neighbors, d is eliminated and is not part of the competition for rounds\n  i+1, i+2, i+3, etc.\n  Notice that d still counts as a neighbor of their other compass neighbors for the purpose\n  of other eliminations that may also happen between rounds i and i+1.\n  Competitors that do not have any compass neighbors are never eliminated.\n  If after a round no competitor is eliminated, then the competition ends.\n</p><p>\n  The <i>interest level of a round</i> is the sum of skill levels of the competitors dancing in\n  that round (even any competitors that are to be eliminated between that round and the next).\n  The <i>interest level of the competition</i> is the sum of the interest levels of all of the\n  rounds.\n</p>\n<p>\n  Given the skill levels of the dancers that are on the floor for the first round,\n  what is the interest level of the competition?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case begins with a line containing\n  two integers <b>R</b> and <b>C</b>. Then, there are <b>R</b> more lines containing <b>C</b>\n  integers each. The j-th value on the i-th of these lines, <b>S<sub>i, j</sub></b>,\n  represents the skill level of the dancer in the cell in the i-th row and j-th\n  column of the floor.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing\n  <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1) and\n  <code>y</code> is the interest level of the competition.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 40 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>S<sub>i,j</sub></b> &le; 10<sup>6</sup>, for all i and j.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>R</b> &times; <b>C</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n  10 &le; <b>T</b> &le; 100.<br/>\n  1000 &lt; <b>R</b> &times; <b>C</b> &le; 10<sup>5</sup>, in exactly 10 cases.<br/>\n  1 &le; <b>R</b> &times; <b>C</b> &le; 1000, in exactly <b>T</b> - 10 cases.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 1\n15\n3 3\n1 1 1\n1 2 1\n1 1 1\n1 3\n3 1 2\n1 3\n1 2 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 15\nCase #2: 16\nCase #3: 14\nCase #4: 14\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  In Sample Case #1, only one competitor is on the floor. Since the competitor does not have any\n  compass neighbors, they dance in one round, and then the competition is over. Thus the answer is\n  equal to the dancer's skill level, 15.\n</p>\n<p>\n  In Sample Case #2, the interest level of the first round is\n  1+1+1+1+2+1+1+1+1=10.\n</p><p>\n  The competitors that are not in the center nor in a corner have a skill level of 1, but the\n  average of their compass neighbors is 4 / 3, which is greater than 1, so they are eliminated.\n  The floor during the second round looks like this:\n</p>\n<pre>\n1 . 1\n. 2 .\n1 . 1\n</pre>\n<p>\n  This round is the last one. The competitors in the corner have two compass neighbors each,\n  but the average of their skill level is equal to their own. The competitor in the center has\n  no compass neighbor. The interest level of the round is 1+1+2+1+1=6.\n  This means the interest level of the competition is 10+6=16.\n</p>\n<p>\n  In Sample Case #3, the competitor with skill level 1 is eliminated after the first round, while\n  the other two remain. In the second round, the two other competitors become compass neighbors,\n  and this causes the competitor with skill level 2 to be eliminated. There is a single competitor\n  in the third round, which makes it the last one. The interest levels of the rounds are 6, 5 and 3,\n  making the interest level of the competition 14.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":28}],"title":"Square Dance","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  In Test Set 1, each pattern forces our answer to have a certain suffix, and\n  we first need to check whether the patterns introduce conflicting\n  requirements for that suffix.\n</p><p>\n  Consider the letter strings coming after the initial asterisk in each pattern.\n  We can find the longest of those strings (or any\n  longest, if there is a tie); call that string L. Then at least one answer\n  exists if (and only if) every other string is a suffix of L; note that we\n  are considering L itself to be a suffix of L. We can check each other string\n  against L by starting at the ends of both strings and stepping backwards\n  through them in tandem until we find a discrepancy or run out of letters to\n  check. If we ever find a discrepancy, then the case has no answer, but\n  otherwise, we know that L itself is an acceptable answer.\n</p>\n<h3>Test Set 2</h3>\n<p>\n  In Test Set 2, we can divide the patterns into (1) patterns that start with\n  an asterisk, (2) patterns that end with an asterisk, and (3) patterns with an\n  asterisk in the middle.\n</p><p>\n  A type (1) pattern requires the output word to have a certain suffix, just\n  as in Test Set 1. A type (2) pattern requires the output word to have a\n  certain prefix. A type (3) pattern introduces both of these requirements,\n  and we can split it into a suffix requirement and a prefix requirement, and\n  then handle those separately.\n</p><p>\n  Then, we can apply our strategy from Test Set 1 twice: once for the prefix\n  constraints (with the algorithm modified to compare prefixes instead), and\n  once for the suffix constraints. We can concatenate the two results together\n  to obtain a valid answer that is certainly short enough (since it can be at\n  most 99+99 characters long).\n</p>\n<h3>Test Set 3</h3>\n<p>\n  We can generalize the idea above into a solution for Test Set 3. Each pattern\n  p in Test Set 3 also prescribes a prefix of the output word (the prefix of p\n  up to the first asterisk) and a suffix of the output word (the suffix of p\n  starting after the last asterisk). If we allow empty prefixes and suffixes,\n  we get exactly one of each for every pattern. We can handle those in the same\n  way we did for Test Set 2, ending up with a prefix P and a suffix S for the\n  output as long as we do not find a discrepancy in either phase.\n</p><p>\n  However, for patterns that have more than one asterisk, we can also have a\n  middle part, which imposes a new type of requirement. Suppose we parse the\n  parts between the asterisks of a pattern so that X is the prefix up to the\n  first asterisk, Y is the suffix after the last asterisk, and\n  M<sub>1</sub>, M<sub>2</sub>, ..., M<sub>k</sub> are the strings in between\n  the asterisks, in order. After checking that X is a prefix of P and Y is a\n  suffix of S, as before, all that remains to ensure is that the pattern\n  M<sub>1</sub><code>*</code>M<sub>2</sub><code>*</code>...<code>*</code>M<sub>k</sub> is present somewhere within the output word, strictly between P and S.\n</p><p>\n  Let us call M<sub>1</sub>M<sub>2</sub>...M<sub>k</sub> &mdash; that is, the\n  word that occurs in between the first and last asterisks with any other\n  asterisk removed &mdash; the <i>middle word</i>. If we make sure a pattern's\n  middle word occurs in the output word outside of P and S, then we fulfill the\n  extra requirement. We can then build a full valid output then by starting\n  with P, then adding the middle word of every pattern in any order, then\n  appending S. We make sure to correctly handle words with a single asterisk or\n  only consecutive asterisks by making their middle words the empty string.\n  Since each middle word contains at most 98 characters, and the prefix and\n  suffix contain at most 99 characters each, the output built this way has at\n  most 99 &times; 2 + 50 &times; 98 characters, which is within the limit of\n  10<sup>4</sup>.\n</p>\n","id":"00000000002b3034","statement":"<h3>Problem</h3>\n<p>\n  Many terminals use asterisks (<code>*</code>) to signify \"any string\",\n  including the empty string. For example, when listing files matching\n  <code>BASH*</code>, a terminal may list <code>BASH</code>,\n  <code>BASHER</code> and <code>BASHFUL</code>. For <code>*FUL</code>, it may\n  list <code>BEAUTIFUL</code>, <code>AWFUL</code> and <code>BASHFUL</code>.\n  When listing <code>B*L</code>, <code>BASHFUL</code>, <code>BEAUTIFUL</code>\n  and <code>BULL</code> may be listed.\n</p><p>\n  In this problem, formally, a <i>pattern</i> is a string consisting of only\n  uppercase English letters and asterisks (<code>*</code>), and a <i>name</i>\n  is a string consisting of only uppercase English letters. A pattern <i>p</i>\n  matches a name <i>m</i> if there is a way of replacing every asterisk in\n  <i>p</i> with a (possibly empty) string to obtain <i>m</i>. Notice that each\n  asterisk may be replaced by a different string.\n</p><p>\n  Given <b>N</b> patterns, can you find a single name of at most 10<sup>4</sup>\n  letters that matches all those patterns at once, or report that it cannot be done?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case starts with a line with a single\n  integer <b>N</b>: the number of patterns to simultaneously match. Then,\n  <b>N</b> lines follow, each one containing a single string\n  <b>P<sub>i</sub></b> representing the i-th pattern.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is any name containing at most 10<sup>4</sup> letters such that each\n  <b>P<sub>i</sub></b> matches <code>y</code> according to the definition\n  above, or <code>*</code> (i.e., just an asterisk) if there is no such name.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>N</b> &le; 50.<br/>\n  2 &le; length of <b>P<sub>i</sub></b> &le; 100, for all i.<br/>\n  Each character of <b>P<sub>i</sub></b> is either an uppercase English letter\n  or an asterisk (<code>*</code>), for all i.<br/>\n  At least one character of <b>P<sub>i</sub></b> is an uppercase English\n  letter, for all i.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  Exactly one character of <b>P<sub>i</sub></b> is an asterisk\n  (<code>*</code>), for all i.<br/>\n  The leftmost character of <b>P<sub>i</sub></b> is the only asterisk\n  (<code>*</code>), for all i.<br/>\n</p>\n<h4>Test set 2 (Visible Verdict)</h4>\n<p>\n  Exactly one character of <b>P<sub>i</sub></b> is an asterisk\n  (<code>*</code>), for all i.<br/>\n</p>\n\n<h4>Test set 3 (Visible Verdict)</h4>\n<p>\n  At least one character of <b>P<sub>i</sub></b> is an asterisk\n  (<code>*</code>), for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n*CONUTS\n*COCONUTS\n*OCONUTS\n*CONUTS\n*S\n2\n*XZ\n*XYZ\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: COCONUTS\nCase #2: *\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, there are other possible answers, including\n  <code>COCOCONUTS</code> and <code>ILIKECOCONUTS</code>.\n  Neither <code>COCONUTSAREGREAT</code> nor <code>COCOANUTS</code> would be\n  acceptable. Notice that the same pattern may appear more than once within a\n  test case.\n</p><p>\n  In Sample Case #2, there is no acceptable name, so the answer is\n  <code>*</code>.\n</p><p>\n  The following cases could not appear in Test Set 1, but could appear in Test\n  Set 2 or Test Set 3:\n</p>\n<pre>\n  4\n  H*O\n  HELLO*\n  *HELLO\n  HE*\n</pre>\n<p>\n  <code>HELLO</code> and <code>HELLOGOODBYEHELLO</code> are examples of\n  acceptable answers. <code>OTHELLO</code> and <code>HELLOO</code> would not be\n  acceptable.\n</p>\n<pre>\n  2\n  CO*DE\n  J*AM\n</pre>\n<p>\n  There is no name that matches both patterns, so the answer would be\n  <code>*</code>.\n</p>\n<pre>\n  2\n  CODE*\n  *JAM\n</pre>\n<p>\n  <code>CODEJAM</code> is one example of an acceptable answer.\n</p>\n\n<p>\n  The following cases could not appear in Test Set 1 or Test Set 2, but could\n  appear in Test Set 3:\n</p>\n<pre>\n  2\n  A*C*E\n  *B*D*\n</pre>\n<p>\n  <code>ABCDE</code> and <code>ABUNDANCE</code> are among the possible\n  acceptable answers, but <code>BOLDFACE</code> is not.\n</p>\n<pre>\n  2\n  A*C*E\n  *B*D\n</pre>\n<p>\n  There is no name that matches both patterns, so the answer would be\n  <code>*</code>.\n</p>\n<pre>\n  2\n  **Q**\n  *A*\n</pre>\n<p>\n  <code>QUAIL</code> and <code>AQ</code> are among the possible acceptable\n  answers here.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":18}],"title":"Pattern Matching","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000019fd74","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2020"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
