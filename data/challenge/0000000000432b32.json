{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1367033400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432b32","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1A was our biggest non-Qualification round ever, with 6414 contestants who downloaded at least one input.  Contestants faced three challenging problems: Bullseye could be tricky and cause integer overflow without some careful attention (or the use of Python, or similar languages), and 62% of attempts on the Large input failed as a consequence.  Manage Your Energy gave contestants a similarly hard time, with a 60% failure rate: many people found their algorithms didn't run quickly enough to fill a calendar with 10,000 events.\n</p>\n<p>\nThe toughest problem of all was the non-traditional Good Luck.  The problem required some knowledge of probability, and gave contestants the opportunity to retry the second input set.  It didn't help most of them, though: <b>95%</b> of the people who attempted the problem got it wrong.\n</p>\n<p>\nAt the end of the day, though, an impressive 92% of our contestants solved something, and 23 people got <i>everything</i> right.\n<p>\nWe hope everybody enjoyed the round!  Congratulations to the Top 1000, who have now made it to Round 2; and to everyone else, we'll see you in 1B and 1C!\n</p>\n\n<hr/>\n<p>Cast</p>\n\n<p>Problem A. <i>Bullseye</i> Written by Khaled Hafez. Prepared by Karim Nosseir and Hackson Leung.</p>\n\n<p>Problem B. <i>Manage Your Energy</i> Written by Onufry Wojtaszczyk. Prepared by Zhen Wang and Onufry Wojtaszczyk.</p>\n\n<p>Problem C. <i>Good Luck</i> Written by Petr Mitrichev. Prepared by Tomek Czajka and Petr Mitrichev.</p>\n\nContest analysis presented by Bartholomew Furrow, Hackson Leung, Onufry Wojtaszczyk and Tomek Czajka.\n\nSolutions and other problem preparation by Igor Naverniouk, Bartholomew Furrow, Hao Pan, Jan Kuipers and Victor Passichenko.","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1367024400000,"tasks":[{"analysis":"<h2>The luck factor</h2>\n<p>This problem is unusual in that you do not have full information and are forced to make guesses as part of the solution. We thought it would be a fun change from the usual deterministic setting.</p>\n<p>Nevertheless, luck did not play a huge role in this problem. The first dataset was easy enough for many approaches to work. The second dataset was harder, but we estimated that an optimal solution would have very good chances: the probability of an optimal solution failing is only on the order of 1 in a million! This is because 8000 is a lot of independent guesses, and the limit <b>X</b> is rather conservative: about 5 standard deviations below the expected number of correct guesses.</p>\n\n<h2>The optimal strategy</h2>\n<p>One may be tempted to apply various heuristics to try to reason about what kind of hidden numbers are likely. In this case, it is best to approach the problem scientifically and simply always go for the highest probability of success!</p>\n<p>In order to do that, we compute the probability of each of the 18564 possibilities (for the larger dataset) and pick the largest one.</p>\n<p>Why 18564? There are 7 choices for each of the 12 hidden numbers. That seems to give 7<sup>12</sup> = 13841287201 possibilities, which is a lot. But, the order of hidden numbers doesn't matter, which reduced the number of different possibilities to (12+7-1) choose (7-1) = 18564. Try to derive this formula! Or just generate them all and count.</p>\n\n<h2>A priori probabilities: K=0</h2>\n<p>What if K=0, so we have no information about the hidden numbers at all? It may seem like then it doesn't matter what we guess, since all possibilities are equally likely. Many contestants made this mistake. Some possibilities are more likely a priori than others, even without any additional information!</p>\n<p>For example, for the small dataset: 333 is less likely than 234. 6 times less likely, to be exact. Why? Because 234 may have been generated in 6 different ways (234, 243, 324, 342, 423, 432) while 333 can be generated in only 1 way.</p>\n<p>In general, if digit <b>d</b> appears <b>C<sub>d</sub></b> times among hidden cards, the probability of that set is <b>N</b>! / (<b>C<sub>2</sub></b>! * ... * <b>C<sub>M</sub></b>! * (<b>M</b>-1)<sup><b>N</b></sup>).</p>\n\n<h2>K=1 and Bayes' theorem</h2>\n<p>So we have computed the a priori probability of every set of hidden cards, but that does not use the crucial available information: the <b>K</b> products of random subsets. How do we use that information? Conditional probabilities are the right tool for the job.</p>\n<p>Let's start with <b>K</b>=1. For each set of hidden numbers, <b>A</b>, we already know the probability of that set happening, Pr(<b>A</b>). We also know a product <b>p</b> of a random subset of these numbers. What we are trying to compute is the conditional probability that the hidden set is <b>A</b> given that the product of a random subset is <b>p</b>. Let's write that as Pr(<b>A</b> | <b>p</b>).</p>\n<p>How to compute that? Use the definition of conditional probabilities:<br/>\nPr(<b>A</b> | <b>p</b>) = Pr(<b>A</b> &cap; <b>p</b>) / Pr(<b>p</b>) = Pr(<b>A</b>) * Pr(<b>p</b> | <b>A</b>) / Pr(<b>p</b>)<br/>\nThis derivation is called Bayes' theorem.</p>\n<p>We already know Pr(<b>A</b>), so we only need to know Pr(<b>p</b> | <b>A</b>). We can pre-compute these values for every <b>A</b>. Simply try every possible subset of each possible set of hidden numbers, see what the products are in each case, and build a large table of all these probabilities. There are 18564 * 2<sup>12</sup> &approx; 76 million such subsets.</p>\n<p>Pr(<b>p</b>) can then be computed as the sum of Pr(<b>A</b>) * Pr(<b>p</b> | <b>A</b>) over all <b>A</b>.</p>\n\n<h2>The complete solution</h2>\n<p><b>K</b> is greater than 1, but that's not a problem: we iterate the above reasoning for each of the <b>K</b> products, adjusting the probabilities of the hidden combinations in the process.</p>\n<p>The full solution is then:</p>\n<ul>\n<li>Some precomputation:\n<ul>\n<li>Generate all possible combinations of hidden numbers, ignoring order.</li>\n<li>Compute the initial probability of each of these hidden sets.</li>\n<li>For each possible hidden set, find all possible products of subsets and compute Pr(<b>p</b> | <b>A</b>). Index these values by <b>p</b> for easy lookup later.\n</ul>\n</li>\n<li>For each hidden set:\n<ul>\n<li>Start with the pre-computed initial probability distribution over possible hidden sets.</li>\n<li>Read one product <b>p</b> at a time, and adjust the probability distribution by using Bayes' theorem and the pre-computed conditional probabilities Pr(<b>p</b> | <b>A</b>).</li>\n<li>Output the most probable possibility.\n</ul>\n</li>\n</ul>","id":"0000000000432be5","statement":"<h3>Problem</h3>\n<p>\nMaryam and Peiling have recently been practicing a new number trick, and they need your help to get it right. The trick goes as follows: Maryam starts by picking <b>N</b> independent random integer numbers, each between 2 and <b>M</b>, inclusive, appearing with equal probability, and writes them down on <b>N</b> cards, one number per card. Note that some numbers might be equal. Then, she repeats the following <b>K</b> times: take a random subset of cards (each card is taken with probability 0.5), and write down the product of the numbers on those cards. Having done all that, she shows all <b>K</b> products to Peiling, and Peiling's goal is to guess what the original <b>N</b> numbers were, knowing just <b>N</b>, <b>M</b>, and the products.\n</p>\n<p>\nAn example game with <b>N</b>=3, <b>M</b>=4, <b>K</b>=4 might go like this: first, Maryam picks 3 random numbers between 2 and 4, inclusive - let's say she randomly chose <b>A</b><sub>1</sub>=3, <b>A</b><sub>2</sub>=3 and <b>A</b><sub>3</sub>=4. Then, she calculates four products of random subsets of \nthose three numbers. For example, let's say those products are <b>A</b><sub>1</sub>*<b>A</b><sub>2</sub>=9, <b>A</b><sub>3</sub>=4, <b>A</b><sub>1</sub>*<b>A</b><sub>2</sub>*<b>A</b><sub>3</sub>=36, and 1=1 (the last product has no numbers in it, so it's equal to 1). Peiling receives numbers 9,4,36,1 from her, and she's also told that <b>N</b>=3 and <b>M</b>=4. In this case, just seeing the number 36 is enough to find what the original numbers were, since the only way to represent that as a product of up to 3 numbers, each up to 4, is 3*3*4. So Peiling says that the original numbers were 3, 3 and 4, and the audience is impressed.\n</p>\n<p>\nIn some other cases, guessing the original numbers is not as simple. For example, it might happen that all products are equal to 1.  In that case there is no way to know anything about the hidden numbers, so Peiling cannot always be right. However, Peiling knows that Maryam follows the procedure exactly as described above: she selects the first <b>N</b> numbers as independent uniform integers between 2 and <b>M</b>, and then selects <b>K</b> independent random subsets, picking each number into each subset independently with probability 0.5. Help Peiling use that knowledge to make better guesses!\n</p>\n\n<h3>Solving this problem</h3>\n<p>\nThis problem is a bit unusual for Code Jam. You will be given <b>R</b> independent sets of <b>K</b> numbers each, and should print an answer for each set &mdash; this part is as usual. However, you don't need to get all of your answers right! Your solution will be considered correct if answers for at least <b>X</b> sets are correct, with the value of <b>X</b> given in the Limits for the given input, below. However, you must follow the output format, even for sets in which your answer doesn't turn out to be correct. The <i>only</i> thing that can be wrong on any sets, yet still allow you to be judged correct, is the digits you output; but there should still be exactly <b>N</b> digits printed for each case, and each digit must be between <b>2</b> and <b>M</b>.\n</p>\n<p>\nThis problem involves randomness, and thus it might happen that even the best possible solution doesn't make <b>X</b> correct guesses (remember the situation when all products are equal to 1?) for a certain input.  Because of that, this problem doesn't have a Large input, but instead has two Small inputs.  That means you can try again if you think you got unlucky.  You may only attempt to solve the second Small input once you have solved the first one.  Otherwise, both Small inputs work in the same way as Small inputs for any other problem: you may try multiple times, and there is a 4-minute penalty for incorrect submissions if you later solve that input, even if the only reason you got it wrong was chance.\n</p>\n<p>\nGood luck!\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>, which is always equal to 1.  The second line of the input file contains four space-separated integers <b>R</b>, <b>N</b>, <b>M</b> and <b>K</b>, in that order. The next <b>R</b> lines describe one set of <b>K</b> products each. Each of those lines contains <b>K</b> space-separated integers &mdash; the products that Maryam passes to Peiling. It is guaranteed that all sets in the input are generated independently randomly according to the procedure from the problem statement.\n</p>\n\n<h3>Output</h3>\n<p>\nOn the first line, output \"Case #1:\". On each of the next <b>R</b> lines output <b>N</b> digits &mdash; your guess for Maryam's hidden numbers for the corresponding set of products. You can print the numbers for each set in any order, but there must be exactly <b>N</b> digits, each between 2 and <b>M</b>, inclusive (note that M&lt;10, so none of the numbers will be more than one digit). Do not put spaces between the digits.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 60 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n</p>\n\n<h4>First Small dataset (Test set 1 - Visible)</h4>\n<p>\n<b>T</b> = 1.<br/>\n<b>R</b> = 100.<br/>\n<b>N</b> = 3.<br/>\n<b>M</b> = 5.<br/>\n<b>K</b> = 7.<br/>\nYou need to get at least <b>X</b>=50 sets right.\n</p>\n\n<h4>Second Small dataset (Test set 2 - Visible)</h4>\n<p>\n<b>T</b> = 1.<br/>\n<b>R</b> = 8000.<br/>\n<b>N</b> = 12.<br/>\n<b>M</b> = 8.<br/>\n<b>K</b> = 12.<br/>\nYou need to get at least <b>X</b>=1120 sets right.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n2 3 4 4\n9 4 36 1\n1 1 1 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n343\n222\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Note</h3>\n\n<p>\nThe sample input doesn't follow the limitations for either input.  In the sample input, you need to get at least <b>X</b>=1 sets right.\n</p>\n<p>\nIn the sample input, Maryam picked the numbers 3, 3, 4 the first time, and the numbers 2, 4, 4 the second time.  In the sample output, Peiling guessed correctly the first time, but not the second time.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":1,"type__str":"VISIBLE","value":31}],"title":"Good Luck","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nFirst, we need to know the area of the first black ring. It can be calculated by subtracting the area of a white circle with radius <b>r</b> from a black circle with radius <b>r</b>+1 cm. That is, the area is (<b>r</b>+1)<sup>2</sup>&pi;-<b>r</b><sup>2</sup>&pi; cm<sup>2</sup>. Expanding we get (2<b>r</b>+1)&pi; cm<sup>2</sup>. Since 1mL of paint can cover area &pi; cm<sup>2</sup>, we need exactly 2<b>r</b>+1 mL of paint to draw the first black ring. For the second black ring, we do the same: subtracting the area of a white circle with radius <b>r</b>+2 cm from a black circle with radius <b>r</b>+3 cm, thus we need 2<b>r</b>+5 mL to draw. In general, we need exactly (<b>r</b>+2<b>k</b>-1)<sup>2</sup>-(<b>r</b>+2<b>k</b>-2)<sup>2</sup> = 2<b>r</b>+4<b>k</b>-3 mL of paint to print the <b>k</b>-th black ring.\n</p>\n<p>\nFor small we know that the answer is less than <b>t</b> = 1000 anyway, so that we can try adding black rings one by one until the total amount of paint used including the next black ring exceeds <b>t</b>, then we stop adding and output the number of black rings we have included so far.\n</p>\n<p>\nHowever, this does not work well with the large input as the answer can be much bigger! This can be verified by the fourth sample (we intended to be kind to contestants, but turns out many still failed the large due to integer overflow :-(). How can we improve the algorithm?\n</p>\n<p>\nThe key is the following: if you can paint at most <b>k</b> black rings using <b>t</b> mL of paint, for sure you can also use it to draw 1 black ring, 2 black rings, ... up to <b>k</b>-1 black rings. So instead of searching for the answers linearly, we can perform <a href=\"http://en.wikipedia.org/wiki/Binary_search_algorithm\" target=\"_blank\">binary search</a> on \"Is it possible to use <b>t</b> mL of paint to draw <b>k</b> black rings?\" to find the answer more efficiently. Now the remaining question is how much paint is used to draw <b>k</b> black rings.\n</p>\n<p>\nLooking back about the total amount of paint to draw individual black rings, it is easily observed that they form an arithmetic progression: 2<b>r</b>+1, 2<b>r</b>+5, 2<b>r</b>+9, ... 2<b>r</b>+4<b>k</b>-3. Then the total amount is simply the sum of the progression, which is (2<b>r</b>+1+2<b>r</b>+4<b>k</b>-3)&times;<b>k</b>&divide;2 = (2<b>r</b>+2<b>k</b>-1)<b>k</b> mL. This is sufficient to completely solve the problem.\n</p>\n<p>Here is a complete solution in Python for reference:</p>\n<pre>\nnum_cases = int(raw_input())\nfor casenum in range(1, num_cases+1):\n  r, t = [int(z) for z in raw_input().split()]\n  res, lo, hi = 0, 1, t\n  while lo &lt;= hi:\n    mid = (lo + hi) / 2\n    if mid * (2 * r + 2 * mid - 1) &gt; t:\n      hi = mid - 1\n    else:\n      lo, res = mid + 1, mid\n  print \"Case #%d: %d\" % (casenum, res)\n</pre>\n<p>You might think that you need big integer libraries to solve the large input, in fact you don't. For example, double precision floating point numbers suffice to check the condition correctly. A more elegant way is to find the first range with <b>exponential growth</b> in length so that there exists a value in the range which fails to satisfy the condition. It takes logarithmic time to find the required range. Then we perform binary search on it and compute the answer. Here is a C++ snippet that describes the algorithm without using any big integer library.</p>\n<pre>\n// Check if we can draw k black rings.\nbool Check(long long r, long long t, long long k) {\n  return 2 * k * k + (2 * r - 1) * k &lt;= t;\n}\n\n// Find the maximum number of black rings that can be drawn.\nlong long Solve(long long r, long long t) {\n  long long left = 0, right = 1;\n  // Find the range that the answer lies in.\n  while(Check(r,t,right)) {\n    left = right;\n    right *= 2;\n  }\n\n  // Binary search on the range [left, right) for the answer.\n  while(right - left &gt; 1) {\n    long long k = (left + right) / 2;\n    if (Check(r, t , k))\n      left = k;\n    else\n      right = k;\n  }\n  return left;\n}\n</pre>","id":"0000000000432cd1","statement":"<h3>Problem</h3>\n<p>\nMaria has been hired by the Ghastly Chemicals Junkies (GCJ) company to help them manufacture <b>bullseyes</b>. A <b>bullseye</b> consists of a number of concentric rings (rings that are centered at the same point), and it usually represents an archery target. GCJ is interested in manufacturing black-and-white bullseyes.\n<br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1imGr7FAiKCMmMuGaBBBNBvCNw5IDalHwAmrzhoeJK9hjDCr2hIYwlSjzFj6P311Xm3WlxDeo/bullseye.png\">\n<br/><br/>\nMaria starts with <b>t</b>&nbsp;millilitres of black paint, which she will use to draw rings of thickness 1cm (one centimetre). A ring of thickness 1cm is the space between two concentric circles whose radii differ by 1cm.\n</p>\n<p>\nMaria draws the first black ring around a white circle of radius <b>r</b> cm.  Then she repeats the following process for as long as she has enough paint to do so:\n</p>\n<ol>\n<li>Maria imagines a white ring of thickness 1cm around the last black ring.</li>\n<li>Then she draws a new black ring of thickness 1cm around that white ring.</li>\n</ol>\n<p>\nNote that each \"white ring\" is simply the space between two black rings.\n</p>\n<p>\nThe area of a disk with radius 1cm is <b>&pi;</b>&nbsp;cm<sup>2</sup>. One millilitre of paint is required to cover area <b>&pi;</b>&nbsp;cm<sup>2</sup>.  What is the maximum number of black rings that Maria can draw? Please note that:\n</p>\n<ul>\n<li>Maria only draws complete rings. If the remaining paint is not enough to draw a complete black ring, she stops painting immediately.</li>\n<li>There will always be enough paint to draw at least one black ring.</li>\n</ul>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.  Each test case consists of a line containing two space separated integers: <b>r</b> and <b>t</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>x</b>: <b>y</b>\", where <b>x</b> is the case number (starting from 1) and <b>y</b> is the maximum number of black rings that Maria can draw.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 1000.<br/>\n1 &le; <b>r</b>, <b>t</b>  &le; 1000.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 6000.<br/>\n1 &le; <b>r</b> &le; 10<sup>18</sup>.<br/>\n1 &le; <b>t</b> &le; 2 &times; 10<sup>18</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n1 9\n1 10\n3 40\n1 1000000000000000000\n10000000000000000 1000000000000000000\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 2\nCase #3: 3\nCase #4: 707106780\nCase #5: 49\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Bullseye","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>The small dataset</h2>\n<p>The limits in the small dataset are very small for this problem, and they allow brute-force approaches. With a fast enough language, even an algorithm that for each activity in the row tries each possible amount of energy usage (from 0 to current energy) will run in time.</p>\n\n<p>The large dataset obviously does not allow such a solution &mdash; both the number of activities and the number of possible amounts of energy to consider are significantly too large.</p>\n\n<h2>The highest-valued activity</h2>\n<p>We will begin solving this problem by looking at the highest-value activity (if there is more than one, pick any of them), let this be activity number <b>a</b>. We will prove that there exists an optimal solution that uses full <b>E</b> joules for this activity.</p>\n\n<p>Consider any optimal solution. First assume that we had less than <b>E</b> joules at the start of activity <b>a</b>. This means we spent energy on some other activity before (since we started with <b>E</b> energy), let <b>b</b> be the number of the last activity we spent non-zero energy on before <b>a</b>. Now consider a solution in which we spend one joule less on <b>b</b>. Since our energy wasn't <b>E</b> in the original solution at the beginning of <b>a</b>, if we spend one less joule on <b>b</b>, we will still have at most <b>E</b> energy at the beginning of <b>a</b>, and so it won't go to waste. Thus, we can spend this extra joule on <b>a</b>, and then proceed as in the original solution, since after <b>a</b> we have exactly the same amount of energy as in the original. The difference in values of these two solutions is -<b>v<sub>b</sub></b> + <b>v<sub>a</sub></b>, which is non-negative (since <b>a</b> was one of the highest-value solutions). We can repeat this procedure until we obtain a solution which is no worse than the original (and thus still optimal), and has <b>E</b> joules at the beginning of <b>a</b>.</p>\n\n<p>Now assume that we have an optimal solution that enters <b>a</b> with <b>E</b> joules, but does not use all of them on <b>a</b>. We can change it in a similar fashion. Find the first activity after <b>a</b> on which we spend non-zero energy, call it <b>c</b>. If it doesn't exist, or if any energy is wasted between <b>a</b> and <b>c</b>, we can simply expend one more joule on <b>a</b> and obtain a strictly better solution. Otherwise, we can spend one joule less on <b>c</b> and one more on <b>a</b>, to obtain a solution that's no worse.</p>\n\n<p>After repeating these procedures as long as we can, we obtain an optimal solution in which, indeed, we spend full <b>E</b> joules on <b>a</b>.</p>\n\n<h2>Other activities</h2>\n<p>Notice that the fact we are spending <b>E</b> energy on <b>a</b> has some implications on the nearby activites. For instance, we will have at most <b>R</b> energy available at <b>a</b>+1, at most 2<b>R</b> at <b>a</b>+2, etc. At the same time, we need to leave <b>a</b>-1 with at least <b>E</b>-<b>R</b> energy, leave <b>a</b>-2 with at least <b>E</b>-2<b>R</b> energy, and so on.</p>\n\n<p>Consider the activity <b>d</b> with the next-highest value after <b>a</b>. We have a limit on how much energy we have at most when entering <b>d</b> (it's the lower of two numbers &mdash; <b>E</b> and whatever limit the spending on <b>a</b> imposed); and we know how much energy we have left unspent (the higher of 0 and the limit imposed by <b>a</b>). We will spend anything between these two limits on activity <b>d</b> &mdash; a reasoning identical to the one for <b>a</b> proves that this doesn't prevent us from getting an optimal solution.</p>\n\n<p>We will continue in this fashion. At each step, we will have for each activity an amount of energy that we have to leave after ending it for activities we already considered, and the maximum amount of energy we can have beginning this activity. At each step, we will take the highest-valued activity we haven't considered yet, and assign to it all the energy we can, updating the limits afterwards.</p>\n\n<p>The time complexity of this solution, as formulated, is O(<b>N</b><sup>2</sup>) &mdash; in each of the <b>N</b> steps we find the highest-valued activity not considered yet, assign energy to it, and update limits for all other activities. Due to the constraints on input size that we have this will be fast enough (at least if written reasonably efficiently). It is possible to do better, though.</p>\n\n<h2>An O(<b>N</b> log<b>N</b>) solution</h2>\n<p> First note that finding the highest-valued activity not considered yet can be done faster &mdash; it's enough to just sort the activities by value up front, and then consider them in descending order.</p>\n\n<p>The more difficult part is updating the limits. To do this, we look at how the limits are set again. Each activity we assign imposes a limit on how much energy do we have in later activities, and how much do we have to leave behind in the previous activities. We would like to prove that for each activity <b>a</b> the limit we have to consider comes from the latest activity in the day we considered before <b>a</b> for how much energy we have, and the first activity we considered later in the day than <b>a</b> for how much we need to leave unspent.</p>\n\n<p>This is not surprising. Consider, for instance, the activity <b>b</b>, which is the latest activity considered before <b>a</b>, and some activity <b>c</b> which comes even earlier in the day. If we considered <b>c</b> before <b>b</b>, the loss of energy on activity <b>c</b> is already taken into account when we consider <b>b</b>, so the limits imposed by <b>b</b> will be no less stringent. On the other hand, if we considered <b>c</b> after <b>b</b>, it means that the energy spent on <b>c</b> was already limited so that it would all be recovered by the time we reach <b>b</b> &mdash; and so it does not impact the amount of energy we have available at <b>a</b>. A similar reasoning works for activities later in the day than <b>a</b>.</p>\n\n<p>A solution in which each step takes logarithmic time will take each considered activity and insert it (along with the limits it imposes) into a binary search tree allowing logarithmic-time insertions and lower/upper-bound operations (like the \"set\" structure of many languages). Then, at each subsequent activity, we find the nearest activity already considered before and after it, compute the limits they impose on the current activity, spend all the energy we can (updating the total value) and insert this activity (along with new limits) into the tree.</p>\n\n<p>Note that if <b>R</b> &ge; <b>E</b>, you can just assume <b>R</b> = <b>E</b>, since any energy you regain above <b>E</b> will necessarily go to waste. We observed this and changed the problem statement to avoid this unnecessary case; but we missed some of the inputs in which this should have been corrected, due to which we had to change the statement back and issue a clarification during the contest. We apologize for the confusion this caused.</p>\n\n<h2>An O(<b>N</b>) solution</h2>\n<p>One nice thing about running a contest for a group of very smart people is that they come up with solutions for problems that the authors didn't even think of! This was the case with this problem &mdash; after the contest we learned some contestants came up with a O(<b>N</b>) solution.</p>\n\n<p>The key to this solution is observing that we can actually know up front how much energy we will want to spend at a given day. As seen above, if there is no more valuable activity ahead of us, we should just spend all the energy we have at the moment. On the other hand, if there is something more valuable, it's always a good idea to save up energy if we will be able to use it for the more valuable activity. To make use of this we need to know, for each activity, the nearest activity in the future that's more valuable.</p>\n\n<p>Calculating such an array is a classic problem, it is described, e.g., as the \"Stock Span Problem\" in the <a href=\"http://en.wikipedia.org/wiki/Stack_(abstract_data_type)\" target=\"_blank\">Wikipedia article on stacks</a>. Once we have this array, we can, for each activity in chronological order, do the following:\n<ul>\n<li> If there is no more valuable activity coming up, spend all the energy we have.</li>\n<li> Consider the nearest more valuable activity <b>X</b>. If we can spend any energy, and still have <b>E</b> energy when <b>X</b> comes (assuming we don't spend any between now and <b>X</b>), spend as much as we can while still having <b>E</b> when <b>X</b> comes. Notice the alternative to spending it now would be to spend it between now and <b>X</b> &mdash; but there's no activity more valuable than the current one in the period to make it worthwhile.</li>\n<li> If we can't spend any energy and still have <b>E</b> when <b>X</b> comes, we shouldn't spend any &mdash; all our energy will be better spent at <b>X</b>.</li>\n</ul>\n</p>\n\n<p>Thanks to for pointing this out to us! The credit for this solution goes to  pedrosorio; other O(<b>N</b>) solutions are possible as well (see, e.g., misof's submission).</p>","id":"000000000043315d","statement":"<h3>Problem</h3>\n<p>\nYou've got a very busy calendar today, full of important stuff to do. You worked hard to prepare and make sure all the activities don't overlap. Now it's morning, and you're worried that despite all of your enthusiasm, you won't have the energy to do all of this with full engagement.\n</p>\n\n<p>\nYou will have to manage your energy carefully. You start the day full of energy - <b>E</b> <a href=\"http://en.wikipedia.org/wiki/Joule\" target=\"_blank\">joules</a> of energy, to be precise. You know you can't go below zero joules, or you will drop from exhaustion. You can spend any non-negative, integer number of joules on each activity (you can spend zero, if you feel lazy), and after each activity you will regain <b>R</b> joules of energy.  No matter how lazy you are, however, you <b>cannot</b> have more than <b>E</b> joules of energy at any time; any extra energy you would regain past that point is wasted.\n</p>\n\n<p>\nNow, some things (like solving Code Jam problems) are more important than others. For the <b>i</b>th activity, you have a value <b>v<sub>i</sub></b> that expresses how important this activity is to you. The <i>gain</i> you get from each activity is the value of the activity, multiplied by the amount of energy you spent on the activity (in joules). You want to manage your energy so that your total gain will be as large as possible.\n</p>\n\n<p>\nNote that you <i>cannot</i> reorder the activities in your calendar. You just have to manage your energy as well as you can with the calendar you have.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case is described by two lines. The first contains three integers: <b>E</b>, the maximum (and initial) amount of energy, <b>R</b>, the amount you regain after each activity, and <b>N</b>, the number of activities planned for the day. The second line contains <b>N</b> integers <b>v<sub>i</sub></b>, describing the values of the activities you have planned for today.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>x</b>: <b>y</b>\", where <b>x</b> is the case number (starting from 1) and <b>y</b> is the maximum gain you can achieve by managing your energy that day.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>E</b> &le; 5.<br/>\n1 &le; <b>R</b> &le; 5.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\n1 &le; <b>v<sub>i</sub></b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>E</b> &le; 10<sup>7</sup>.<br/>\n1 &le; <b>R</b> &le; 10<sup>7</sup>.<br/>\n1 &le; <b>N</b> &le; 10<sup>4</sup>.<br/>\n1 &le; <b>v<sub>i</sub></b> &le; 10<sup>7</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n5 2 2\n2 1\n5 2 2\n1 2\n3 3 4\n4 1 3 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 12\nCase #2: 12\nCase #3: 39\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p> In the first case, we can spend all 5 joules of our energy on the first activity (for a gain of 10), regain 2 and spend them on the second activity. In the second case, we spend 2 joules on the first activity, regain them, and spend 5 on the second. In the third case, our regain rate is equal to the maximum energy, meaning we always recover all energy after each activity - so we can spend full 3 joules on each activity.</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Manage your Energy","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432b32","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2013"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
