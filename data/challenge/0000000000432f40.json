{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1339259400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432f40","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThe online rounds for Google Code Jam 2012 are over, and we have our finalists!  They represent twelve different countries, and we'll be seeing a mix of old faces and new ones at our World Finals in New York City.  Our last two champions, Egor and rng..58, have qualified for the finals once more, and rng..58 will have a chance to defend his title.\n</p>\n<p>\nEvery problem was solved by someone, though only misof cracked D-large&mdash;a bold move, and reminiscent of rng..58's victory in 2011, since without the problem he wouldn't have advanced.  Solving A, C and D-small proved to be enough for most contestants, but a simple A-small led to more than a few wrong answers on A-large that knocked their submitters out of a shot at the finals.\n</p>\n<p>\nSolving Problem B ended up being a bad choice strategically for a lot of people.  It was useful only to five of our finalists, and only in combination with C-small (without C-large).  It's very hard to judge what score will get you past the cutoff, both before and during a contest: the top contestant with A, B and D-small ended up in 32nd place, very close indeed to a berth in the finals.\n</p>\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>\nProblem A. <i>Perfect Game</i> Written and prepared by Bartholomew Furrow.\n</p>\n\n<p>\nProblem B. <i>Havannah</i> Written by Marcin Ciura.  Prepared by John Dethridge and Marcin Ciura.\n</p>\n\n<p>\nProblem C. <i>Qualify Food</i> Written by Irvan Jahja.  Prepared by Bartholomew Furrow and Raymond Ho.\n</p>\n\n<p>\nProblem D. <i>Lost Password</i> Written and misunderstood by Bartholomew Furrow.  Correctly written, and prepared, by David Arthur.\n</p>\n\n<p>\nContest analysis presented by Bartholomew Furrow, Alexander Georgiev, Bartholomew Furrow and David Arthur.\n</p>\n\n<p>\nSolutions and other problem preparation by \nIgor Naverniouk,\nAdam Polak,\nAhmed Aly,\nJohn Dethridge,\nLuka Kalinovcic,\nKhaled Hafez,\nOnufry Wojtaszczyk,\nPetr Mitrichev,\nTomek Czajka,\nXof Skovron,\nYiming Li\nand Yiu Yu Ho.\n</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1339250400000,"tasks":[{"analysis":"<p>\nThis problem probably looked a little scary to many competitors at first. (I, for one, remember some nasty problems involving hexagons in other contests). However, this one wasn&#39;t as bad as it looked.\n</p>\n\n<p>\nLet&#39;s first see what kind of cells there are and how to distinguish between them:\n<ul>\n<li><b>Inner Cells</b>: Those were the cells that are not part of the border of the board. They had 6 neighboring cells.</li>\n<li><b>Corner Cells</b>: Those were the cells where two edges of the board overlap. They had 3 neighboring cells.</li>\n<li><b>Edge Cells</b>: Those were the cells that were neither inner cells, nor corner cells. They had 4 neighboring cells.</li>\n</ul>\nNote that it was a bit counter-intuitive that the corner cells were *not* edge cells (as they, in fact, lie on the edges), however that was clearly defined in the statement: &quot;Corners do not count as edges.&quot;.</p>\n\n<p>We can enumerate the edges and the corners of the board. Each edge will have a distinct integer index between 0 and 5, inclusive, and each corner will also have a distinct index between 0 and 5, inclusive. This is okay, but for simplicity later we will give the indices from 0 to 5 to the corners and add 6 to the indices of the edges, to obtain 6 to 11 for the edges. If a cell neither is a corner, nor belongs to any of the edges, we can mark it with -1. Thus, we create a function <code>int checkType(row, col)</code> that checks if the cell at (row, col) is a corner (and which one if it is), part of an edge (and which edge, if it is) or neither.\n<ul>\n<li>Corners are the cells: {(1, 1), (1, S), (S, S * 2 - 1), (S * 2 - 1, S * 2 - 1), (S * 2 - 1, S), (S, 1)}</li>\n<li>Edges are the cells: {(1, X), (X, 1), (X, S * 2 - 1), (S * 2 - 1, X)} where X is any integer, together with all cells for which |row - col| == S - 1.</li>\n</ul>\nDon&#39;t forget that corners are not considered edges, so exclude them when checking for edges.\n</p>\n\n<p>\nNow let&#39;s examine in more detail the winning figures:\n<ul>\n<li><b>Bridge</b>: This was probably the simplest of the three: just a set of stones that connects any two corner cells. The minimal number of stones to achieve it was 2 on a board with S = 2 (which was the minimal possible board).</li>\n<li><b>Fork</b>: This was a bit more complicated. We need a set of stones, that connects 3 distinct edges (i.e. cells from three distinct edges). The minimal number of stones to achieve it was 5 on a board with S = 3 (note that the board with S = 2 does not have any edge cells).</li>\n<li><b>Ring</b>: This was the most complicated figure. We need a set of stones that encircles an empty cell. As it might have been a bit unclear what &quot;encircles&quot; in this case means, the problem statement contained a detailed explanation and an example. The minimal number of stones to achieve it was 6 on a board with S = 3. Note that a ring on a board with S = 2 is impossible, as it inevitably would lead to a bridge first.</li>\n</ul>\n</p>\n\n<p>\nAs many of the competitors might have realized, the Bridge and Fork cases are relatively simple to detect. One way to solve them would be to use binary search over the move in which they are created and check if a Bridge and/or a Fork exists. That was okay, however it didn&#39;t work for Rings. Some competitors used this solution for Forks and Bridges, and another one for Rings. However, this required some extra code, which is rarely a good idea in a speed contest.\n</p>\n\n<p>\nSome competitors probably realized that even an O(M<sup>2</sup>) solution would pass. However, we will describe an O(M) solution, which was very fast and not much harder to implement.\n</p>\n\n<p>\nFirst, it&#39;s a good idea to store the board in a both memory and time efficient way. The thing to notice was that when the board is really big, then it is also really sparse (only 10000 stones in a board with over 9000000 cells). So the way to go was to use any kind of set data structure our programming language of choice provided. In C++, a hashset is fastest, but tree sets are also fine. Putting a stone is a constant operation if we are using a hashset and logarithmic one if we&#39;re using balanced tree set (for example C++ STL set).\n</p>\n<p>\nNow we start putting stones on the board in the order they are given. We need a fast way to check if putting a stone created some of the winning figures. The fork and the bridge needed some cells to be connected (i.e. to belong to the same connected component). In fact, the ring also requires the same thing. As many competitors in this round probably know, these are usually handled using the <a href=\"https://www.google.com/search?q=union+find\" target=\"_blank\">union find</a> algorithm. As a reminder union-find supports the following basic operationss:\n<ul>\n<li> Create a new node, belonging to a group of size 1.\n<li> Merge two new groups into one.\n<li> For a given node, find the group it is.\n</ul>\nImplemented correctly, all of these operations are blazingly fast.\n</p>\n\n<p>We will use union-find here with a minor addition. After putting a stone, we see if some of the neighboring cells contains a stone already. If none do, we add the new stone to its own connected component. If there are stones in adjacent squares, we merge them all to a single connected component that also contains the new stone. Additionally to the straight-forward union-find algorithm, we will store what type of cells each component contains. Since the number of different types of cells we are interested in is relatively small (only 12 types) we can use a mask with 12 bits (corresponding to the indices from 0 to 11 we mentioned earlier). We do this in order to have an easy way to see if a component contains corner or edge cells. When merging the component A to component B, we change the mask of B to contain the bits of the mask of A as well (since now they are the same component). This can be done really easily with the bitwise operation OR. If, after merging, a component ends up with 2 set bits in the first 6, or 3 set bits in the second 6 positions, then we&#39;ve just created a bridge or a fork, respectively.\n</p>\n<p>\nEverything&#39;s fine with that, but we still haven&#39;t answered the question how do we handle rings. Well, having the stones and their respective components makes it easy to check for them. In order for a ring to be created, we must have just added a stone that connects a component to itself. But if it does, it still does not necessarily create a ring. What we can do is check all neighbors of the cell where we are putting the stone, and search for two cells with stones with the same component.</p>\n\n<p>We can represent the neighbors of the given cell as the following:\n\n<pre>\n# 1 2\n6 * 3\n5 4 #\n</pre>\n\nGoing clockwise twice (or counter-clockwise, if you prefer, it doesn&#39;t matter) and looking at the neighbors there should be one of the following sequences (as a subsequence of the created sequence of 12):\n<ol>\n<li>{C, X1, C, Y1, Y2, Y3}</li>\n<li>{C, X1, X2, C, Y1, Y2}</li>\n<li>{C, X1, X2, X3, C, Y1}</li>\n</ol>\nwhere the cells C belong to the same component, and each of the cells X and Y are either empty or belong to some component (not necessarily the same as C, and not necessarily the same as other Xs and Ys).</p>\n\n\n<p>After this move a ring is formed if and only if:\n<ul>\n<li>At least one of the Xs is an empty cell</li>\n<li>At least one of the Ys is an empty cell</li>\n</ul>\n(Note that if there is a {C, X1, C, Y1, Y2, Y3} sub-sequence, then there will be a {C, X1, X2, X3, C, Y1} one, however we&#39;ve included them both for clarity).</p>\n\n<p>\nWhy is this true? Well, if none of the Xs or none of the Ys is an empty cell, then the two Cs were already connected &quot;from this side&quot; and adding the stone doesn&#39;t change it into a ring (obviously). If both some of the X cells and some of the Y cells contain an empty cell, then we&#39;ve just encircled at least one of them! Imagine it this way - a circle has two sides - inside and outside. We know that we created a circle (since we are connecting a component to itself), but we don&#39;t know which side is the inner one and which side is the outer one. Thus, if both contain an empty cell, then we have an empty cell in the inner side for sure.\n</p>\n\n<p>\nWhat is the time complexity of the given algorithm? Since OR is a constant operation, we have a constant number of bits to check when looking for a Fork or a Bridge, and checking for a ring involves also a constant number of operations (equal to the number of neighbors), the complexity is dominated by the speed of the union-find operations. Thus, the total complexity of the algorithm is O(M * RACK(M)), where RACK() is the inverse of the Ackerman function. However, RACK() is so slowly growing, that you can assume the algorithm will run in nearly O(M) for the given constraints.<br>\n</p>\n\n<p>\n<b>Remark:</b> Another nice trick for dealing with rings is to start with all pieces played on the board and work backwards, always considering which empty squares are connected to each other. Removing a stone possibly connects two of these components, and so we can again use union-find to track the state quickly. This is conceptually simpler, but it is slower because we need to first find all the connected components after the pieces are played.\n</p>","id":"0000000000432a00","statement":"<h3>Problem</h3>\n\n<p>Havannah is an abstract strategy board game created by Christian Freeling.  Havannah is a game played on a hexagonal board with <b>S</b> hexagons to each side.  Each hexagon has two horizontal and four slanted edges. The hexagons are identified by pairs of integer values. The hexagon in the bottom corner of the board is (1, 1).\nThe hexagon adjacent to (x, y) in the direction of a two-o'clock hand is (x, y+1).  The hexagon adjacent to (x, y) in the direction of a ten-o'clock hand is (x + 1, y).\n\nHere is an example board with <b>S</b> = 5:</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0J2lPHEPKhPxJeqdHyGq4OCjmX3Oq9rw9mLUjJuX7CUqhP4pPMOe0e5VcTbBflyHagwo46bWr5/havannah1.png\">\n\n<p>In the game of Havannah, each hexagon can be occupied by at most one stone.  Stones once put on the board are never removed or moved.  The goal of the game is to build from stones a <i>connected</i> set of stones of one of three kinds.\nThe winning structures are:</p>\n\n<ul>\n<li>A <b>ring</b> that encircles one or more <i>empty</i> hexagons.  That is, at least one of the inner hexagons must be empty.  More specifically, there is an empty hexagon  that is separated from the outermost boundary of the board by hexagons with stones.  <i>Note that this rule is different from the official game Havannah.</i></li>\n<li>A <b>bridge</b> that connects any two corners of the board.</li>\n<li>A <b>fork</b> that connects any three of the board's six edges.\nCorners do not count as part of either adjacent edge.</li>\n</ul>\n\n<p>This picture shows examples of winning structures:</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0Ixz_KeDb64PVXhvdC_lJLuje634a3EHqhw1ca7hGs0yV0oF3RHkddr6ZbwYmNkRGqZBn7cxJ8/havannah2.png\">\n\n<p>Your program should determine whether a sequence of moves of <b>a single player</b> builds a winning structure. If so, it should output the name of the structure and the number of the move that completed it.  If a move completes multiple rings, connects more than two corners, or connects more than three edges, the structure is still considered a ring, a bridge, or a fork, respectively.  But if a move completes structures of different kinds at once, your program should output the names of all of them.  We are only interested in the first winning move: ignore all moves following the winning one.\nIf there is no winning structure on the board after playing all the moves from the sequence,\nyour program should output <code>none</code>.</p>\n\n<h3>Input</h3>\n\n<p>The first line of input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  The first line of each test case contains two integers <b>S</b> and <b>M</b>, the number of hexagons on each side of the board and the number of moves in the sequence, respectively.  The next <b>M</b> lines provide the sequence of moves, in order, where  each line contains a space-separated pair (x, y) of hexagon identifiers.  All the moves in the sequence lie on the board of size <b>S</b>.  In each test case, the board is initially empty and the moves do not repeat.</p>\n\n<h3>Output</h3>\n\n<p>For each test case, output one line containing \"Case #<b>n</b>: \" followed by one of:</p>\n\n<ul>\n<li><code>none</code></li>\n<li><code>bridge in move </code><i>k</i></li>\n<li><code>fork in move </code><i>k</i></li>\n<li><code>ring in move </code><i>k</i></li>\n<li><code>bridge-fork in move </code><i>k</i></li>\n<li><code>bridge-ring in move </code><i>k</i></li>\n<li><code>fork-ring in move </code><i>k</i></li>\n<li><code>bridge-fork-ring in move </code><i>k</i></li>\n</ul>\n\n<p>The cases are numbered starting from 1.  The moves are numbered starting from 1.</p>\n\n<h3>Limits</h3>\nMemory limit: 1GB.<br/>\n\n<h3>Test set 1 (Visible Verdict)</h3>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>T</b> &le; 200<br/>\n2 &le; <b>S</b> &le; 50<br/>\n0 &le; <b>M</b> &le; 100<br/>\n</p>\n\n<h3>LTest set 2 (Hidden Verdict</h3>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>T</b> &le; 20<br/>\n2 &le; <b>S</b> &le; 3000<br/>\n0 &le; <b>M</b> &le; 10000<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">7\n2 4\n1 1\n1 2\n2 3\n3 3\n3 6\n2 1\n2 2\n2 3\n2 4\n1 2\n4 4\n3 7\n3 3\n2 2\n2 3\n3 4\n4 4\n4 3\n3 2\n3 6\n2 2\n2 3\n3 4\n4 4\n4 3\n3 2\n3 8\n1 1\n2 1\n1 3\n2 4\n1 2\n3 2\n3 3\n3 4\n3 7\n1 1\n2 2\n3 5\n3 4\n5 3\n4 3\n3 3\n3 3\n1 1\n1 3\n3 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: bridge in move 2\nCase #2: fork in move 5\nCase #3: none\nCase #4: ring in move 6\nCase #5: bridge-fork in move 5\nCase #6: bridge in move 7\nCase #7: none\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nHavannah was created by Christian Freeling and MindSports.  MindSports and Christian Freeling do not endorse and have no involvement with Google Code Jam.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Havannah","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Multiple Solutions</h3>\n\n<p>\nSometimes our problemsetters like to come up with big, complicated solutions to their problems, and sometimes it turns out that there are simpler alternatives.  We'll present two solutions here, including the simple one that many problems solvers used, and the more complex one used by the author.\n</p>\n\n<h3>How much does a single delivery cost?</h3>\n\n<p>\nLet's look at the cost of a delivery containing <b>K</b> meals.  It's easy to see that we should order the cheapest meal with a time-to-stale of at least 0, the cheapest meal with a time-to-stale of at least 1, the cheapest meal with a time-to-stale of at least 2, and so on until we order the cheapest meal with a time-to-stale of at least <b>K</b>.  Since <b>K</b> could be very large, we'll solve this problem in O(<b>N</b> log(<b>N</b>)).\n</p>\n\n<p>\nFirst we'll sort the kinds of food by price, and construct an array that contains [(0, 0), (d<sub>1</sub>, c<sub>1</sub>), (d<sub>2</sub>, c<sub>2</sub>), ...], where we should buy food that costs c<sub>i</sub> for the meals between d<sub>i-1</sub> and d<sub>i</sub> after the delivery arrives.  We can then process that into another array containing (d<sub>i</sub>, C<sub>i</sub>), where C<sub>i</sub> is the total cost of a single delivery that lasts d<sub>i</sub> days, and (C<sub>i</sub>-C<sub>i-1</sub>) / (d<sub>i</sub>-d<sub>i-1</sub>) = c<sub>i</sub>.   \n</p>\n\n<p>\nWe only had to do those above steps once.  Now that we have that array, it's an O(log(N)) binary search (or a simpler linear search, since we'll find that we don't need the efficiency for either of our solutions) to find out how much it costs to have a delivery that lasts <b>K</b> days: find i such that d<sub>i-1</sub> &le; <b>K</b> &lt; d<sub>i</sub>, and charge C<sub>i-1</sub> + (K-d<sub>i-1</sub>)*c<sub>i-1</sub>.\n</p>\n\n<p>\nWe'll call that function <code>SingleDeliveryCost(days)</code>, and for convenience later in this editorial we'll also define <code>SingleDayCost(day)</code> to be the cost to buy the cheapest meal with a time-to-stale of at least <code>day</code>.  Observe that <code>SingleDayCost(a) &le; SingleDayCost(b)</code> if <code>a &le; b</code>, and that <code>SingleDeliveryCost(days+1) = SingleDeliveryCost(days) + SingleDayCost(days+1)</code>.\n</p>\n\n<h3>Deliveries should be (almost) the same size</h3>\n\n<p>\nLet's show that all of your deliveries should be almost the same size.  Let's suppose that we have a solution that has a delivery, A, containing <code>a</code> meals, and another delivery, B, that contains <code>b</code> meals, with <code>b &ge; a+2</code>.  Then the cost for those two deliveries is <code>SingleDeliveryCost(a) + SingleDeliveryCost(b)</code>.  If instead we increased delivery A's size to <code>a+1</code> and decreased delivery B's size to <code>b-1</code>, we'd have the same total number of days, but the delivery cost would be:<br/>\n<code>SingleDeliveryCost(a+1) + SingleDeliveryCost(b-1)<br/>\n= SingleDeliveryCost(a) + SingleDayCost(a+1) + SingleDeliveryCost(b) - SingleDayCost(b-1)<br/>\n&le; SingleDeliveryCost(a) + SingleDeliveryCost(b)</code>.\n</p>\n<p>\nThis shows that all our deliveries should be of size <code>a</code> or <code>a+1</code> for some value of <code>a</code>.\n</p>\n\n<h3>Deliveries should be of an \"interesting\" size</h3>\n\n<p>\nLet's say that we want to buy a total of <b>D</b> days' worth of food, and we want to know how big our deliveries should be.  We'll start by considering a number of deliveries <code>X</code> that we're going to show is \"uninteresting\": one such that if we look the size of the largest delivery, <code>ceil(D/X)</code>, then <code>ceil(D/(X-1)) = ceil(D/X) = ceil(D/(X+1))</code>.  In such a case, adding a delivery changes the cost by <code>SingleDeliveryCost(ceil(D/X)) - ceil(D/X)*SingleDayCost(ceil(D/X))</code>.  If we add a delivery, we'll change the cost by the negation of that amount.  One of those two quantities has to be non-negative, which means that we never need to consider making <code>X</code> deliveries.\n</p>\n\n<p>\nThat means that we only need to look at numbers of deliveries such that if we changed the number of deliveries, we'd be changing <code>SingleDayCost(ceil(D/X))</code>.  There are only 2<b>N</b> such delivery sizes, and trying all of them solves the problem in O(N log(N)).\n</p>\n\n<h3>The other approach</h3>\n\nA competitor who couldn't convince himself or herself of the above still has a good chance of solving the problem.  We'll start by presenting a trick (\"Changing the Question\") that you can use whether or not you have the above realization&ndash;it might make the math easier&ndash;and a totally different approach that, admittedly, requires some math of its own.\n\n<h3>Changing the Question</h3>\n\n<p>\nAn observation we can make is that instead of solving the problem that was asked, we can play a trick to let ourselves solve a simpler problem: \"Can I eat quality food for <b>D</b> days?\"  We do this by <b>binary searching on the answer</b>.  We know the answer is between 0 and <b>M</b>, so we can start by solving that problem O(log(M)) times.\n</p>\n\n<h3>How many deliveries should there be?</h3>\n\n<p>\nIf the logic in the previous solution was too complicated, here's an alternative that probably isn't going to make you any happier.  On the other hand, if you were thinking that there weren't enough logarithmic factors in the complexity analysis, or enough -ary searches, this could make you happy.  This was our original solution for the problem, and it makes the I/O author perversely proud to have been part of making a problem to which a binary search in a ternary search in a binary search is a perfectly reasonable solution.\n</p>\n\n<p>\nThe argument here is that we can <a href=\"http://en.wikipedia.org/wiki/Ternary_search\" target=\"_blank\">ternary search</a> for the number of deliveries that minimizes the cost to buy quality food for <b>D</b> days.  In order for a ternary search to be possible, the function has to be strictly decreasing, then strictly increasing (or vice versa).  In this case, the domain of the function is from where the number of deliveries <code>X</code> is the minimum possible number at which we could order <b>D</b> meals (regardless of how expensive they are), to <code>X=<b>D</b></code>.  We'll show that the function decreases, then increases over this domain.\n</p>\n\n<p>\nFirst let's take the <code>SingleDayCost</code> function and extend it over the real numbers.  We already know what it is for the integers; let's just linearly interpolate for the real numbers in between, and call the result <code>G</code>.  This has the nice result that the cost for <code>X</code> deliveries and <b>D</b> days, which we'll call <code>H(X)</code>, is <code>H(X) = G(D/X)*X + X*F</code>.\n</p>\n\n<p>\nNow, we're about to start taking derivatives, and although <code>G</code> is continuous, it isn't differentiable.  There are a couple of ways of getting around this, and we're going to take a physicists' route.  We'll define a function <code>G''</code> to be a sum of <a href=\"http://en.wikipedia.org/wiki/Dirac_delta_function\" target=\"_blank\">delta functions</a> such that the double-integral of <code>G''</code> over <code>X</code> is our original <code>G</code>.  Then we'll define <code>G'</code> to be <code>G''</code>'s integral, and <code>G</code> to be <code>G'</code>'s integral.  That lets us say that the first derivative of <code>G</code> is non-negative everywhere, and so is its second derivative.  Don't try this at home, folks, especially if you live in a math class.\n</p>\n\n<p>\nWhat we're really interested in doing here is proving that <code>H(X)</code> is decreasing and then increasing, which we can do by proving that it has a positive second derivative:<br/>\n<code>H(X) = G(D/X)*X + X*F</code><br/>\n<code>H'(X) = G(D/X) - X*G'(D/X)*X<sup>-2</sup> + F</code><br/>\n<code>H'(X) = G(D/X) - G'(D/X)/X + F</code><br/>\n<code>H''(X) = -X<sup>-2</sup>G'(D/X) + X<sup>-2</sup>G'(D/X) + G''(D/X)X<sup>-3</sup></code><br/>\n<code>H''(X) = G''(D/X)X<sup>-3</sup> &ge; 0</code><br/>\n</p>\n\n<p>\nTherefore <code>H(X)</code> is decreasing and then increasing (or just decreasing or increasing, which is also fine), and can be ternary searched on for the minimum cost of surviving <b>D</b> days.  This algorithm's complexity works out to O(Nlog(N) + log<sup>2</sup>(M)log(N)).\n</p>","id":"0000000000432b35","statement":"<h3>Problem</h3>\n\n<p>You just moved from your hometown to a big metropolitan city! You love everything about your new environment, except for the food.  Your hometown provides the best food in the region (called \"quality food\") and you sure will miss it.</p>\n\n<p>Fortunately, the largest restaurant in your hometown provides a food delivery service. You can purchase any amount of food in one delivery.  There is a constant <i>delivery fee</i> for every delivery, regardless of the amount of food purchased in the delivery.</p>\n\n<p>\nThis restaurant serves different types of food. Each type of food has two properties: a price-per-meal, and a time-to-stale.  One \"meal\" of food will feed you for one day; once a meal has been eaten, it cannot be eaten again.  The time-to-stale of a type of food is the maximum number of days for which that food can still be eaten, counting from when you received it. A time-to-stale of zero means you must eat that type of food on the day of delivery.\n</p>\n<p>\nIn a single delivery you can purchase as many different types of food, and as many meals of each of those types, as you have money for.  Note that if a particular type of food has a time-to-stale of <code>t</code>, it doesn't make any sense to order more than <code>t+1</code> meals of that food in one delivery: at least one meal would go stale before you could eat it.\n</p>\n\n<p>This restaurant has a very fast delivery service, so you will receive all the food in a delivery on the same day that you purchased it, and you may eat some of the food on the same day. Food delivery is the only way for you to receive quality food.</p>\n\n<p>\nGiven an amount of money, which you can spend on meal prices and delivery fees, what is the maximum number of days for which you can eat quality food every day?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case will begin with three integers, <b>M</b>, <b>F</b> and <b>N</b>, denoting the amount of money you have, the delivery fee, and the number of types of food provided by the restaurant, respectively. <b>N</b> lines follow, each will consist of two integers, <b>P<sub>i</sub></b> and <b>S<sub>i</sub></b>, denoting respectively the price-per-meal and time-to-stale of one type of food.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the maximum number of days that you can keep eating at least one meal of quality food everyday. \n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 20 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n1 &le; <b>F</b> &le; <b>M</b>.<br/>\n1 &le; <b>N</b> &le; 200.<br/>\n1 &le; <b>P<sub>i</sub></b> &le; <b>M</b>.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n0 &le; <b>S<sub>i</sub></b> &le; 2,000,000.<br/>\n1 &le; <b>M</b> &le; 2,000,000.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n0 &le; <b>S<sub>i</sub></b> &le; 10<sup>18</sup>.<br/>\n1 &le; <b>M</b> &le; 10<sup>18</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n32 5 2\n5 0\n10 2\n10 10 1\n10 10\n10 1 1\n1 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 0\nCase #3: 8\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nAn example scenario for the first case is by purchasing one meal of the first type and one meal of the second type during your first day in the city (costing a total of 20).  Eat the first type of food that day, and eat the second type the next day.  During your third day, purchase one meal of the first type and eat it on the same day.  This accounts for three days.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Quality Food","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis is certainly an intimidating problem. Even small strings, like the example from The Fellowship of the Ring, are difficult to work through.  When you are trying to combine passwords of length at most 500 into a password string, there are so many possibilities to consider that optimization quickly becomes overwhelming. \n</p>\n\n<br/>\n<p><b>The Small Input</b></p>\n\n<p>\nLet's begin with the small input. In this case, we need to connect up pairs of letters. The key insight here is to imagine everything as a graph. If you have heard of <a href=\"https://www.google.com/search?q=de+bruijn+sequence\" target=\"_blank\">De Bruijn sequences</a> before, that is the perfect thing to build from. We will make a vertex for each letter (the 26 normal letters as well as all the 133t variations), and add an edge between every pair of letters. Each 2-letter word that we need in our password string corresponds to an edge on this graph. For example, \"t0\" corresponds to the edge 't' -&gt; '0'. Let's call these <i>candidate edges</i>.\n</p>\n\n<p>\nNext let's consider a password string. We can think of this as a path on the graph. We start at the first letter, and then continually move to the next letter in the string. For example, \"abc0\" corresponds to the path 'a' -&gt; 'b' -&gt; 'c' -&gt; '0'. Therefore, the problem can be re-stated as follows: what is the length of the shortest path on this graph that includes all the candidate edges?\n</p>\n\n<p>\nHere is it is helpful to think back to another classic algorithm problem: <a href=\"https://www.google.com/search?q=eulerian+path\" target=\"_blank\">Eulerian paths</a>. The problem could also be re-stated as: if we start with just the candidate edges, what is the minimum number of edges we need to add so that the resulting graph has an Eulerian path? Fortunately for us, the Eulerian path problem has been completely solved!\n</p>\n\n<p><b>Fact:</b> A directed graph has an Eulerian path if and only if (1) every vertex has in-degree equal to its out-degree except possibly for two vertices that are off by one, and (2) every vertex with positive degree is connected in the underlying undirected graph.</p>\n\n<p>\nIf you play with some examples, you will see that you will always be connected here, but let's come back to a formal proof when we talk about the large input. The fact that connectivity comes for free is really what makes this problem solvable, and so it is a good thing to think about!\n</p>\n\n<p>\nThe remaining condition says that all we need to do is add edges to balance in-degrees and out-degrees. We can add any edge we want at any time, so the method is simple: choose a vertex u with higher in-degree than out-degree and a vertex v with higher out-degree than in-degree, and then add an edge from u to v. Repeat until there are only two vertices left that are only slightly imbalanced, and we're done! After all that talk, we end up with a very simple greedy algorithm.\n</p>\n\n<br/>\n<p><b>The Large Input</b></p>\n\n<p>\nIn fact, this solution already has most of the key ideas that go into solving the large as well, but we just need to take them further. There are three main challenges:\n</p>\n\n<ul>\n<li> When passwords are length greater than 2, how do we interpret them as edges on a graph?\n<li> When it comes time to balancing degrees, some edges will be impossible to add. How do we adapt the greedy algorithm from before?\n<li> The output password could be huge! Is it really possible to solve the problem in time less than the size of the output password?\n</ul>\n\n<p>\nThe first challenge is the most important, and again, De Bruijn sequences provide a good model to build from. If we are trying to construct all passwords of length k, we will create a graph with vertices corresponding to all lengh-(k-1) phrases. Each candidate password corresponds to the edge between its prefix phrase and its suffix phrase. Let's begin by making this nice and rigorous, although the intuition is exactly the same as in the small input.\n</p><br/>\n\n<p><b>A Minimum-Cost Flow Interpretation</b></p>\n\n<p>Let us call any length-k substring of <b>S</b> (and any of its \"l33tspeak\" equivalents) a \"candidate\", and any length-(k-1) string composed of  digits and lowercase letters a \"phrase\" (whether it is contained in a candidate or not).  For each phrase s, define its weight w(s) to be the number of candidates that end with s minus the number of candidates that begin with s. Note that the sum of w(s) is 0. (The weight of a phrase will measure how far the corresponding vertex is from supporting an Eulerian path.)\n</p>\n\n<p>\nForm a directed graph G with vertices corresponding to the phrases.  For phrases <i>a</i> and <i>b</i>, add an edge from <i>a</i> to <i>b</i> if you can make <i>a</i> into <i>b</i> by adding a letter to the end of <i>a</i> and removing the first letter of <i>a</i>. Now we set up a flow problem: if a phrase <i>s</i> has positive weight, it is a source with capacity |w(s)|; otherwise it is a sink with capacity |w(s)|.  All edges have infinite capacity and cost one.\n</p>\n\n<p>\nLet ANSWER denote the shortest possible length of a password string for <b>S</b>, let C denote the set of all candidates, and let FLOW_EDGES denote the minimum number of edges (i.e. minimum cost) in an \"almost-maximum\" flow. (Specifically, this is a flow that leaves at most 1 capacity unused in some source and at most one 1 capacity unused in some sink).\n</p>\n\n<p><b>Lemma 1:</b> ANSWER = FLOW_EDGES + |C| + k - 1.</p>\n\n<p><b>Proof Part 1:</b> ANSWER &le; FLOW_EDGES + |C| + k - 1</p>\n\n<p>\nLet G' be the directed graph formed as follows:\n<ul>\n<li>Begin with the directed multi-graph formed by the minimum-cost almost-maximum flow on G.\n<li>For each candidate c, add an edge from the prefix phrase of c to the suffix phrase of c.\n</ul>\nFor a given phrase s, let's calculate its out-degree minus its in-degree in G'. After the first step, this value is exactly w(s), except for two vertices that are off by 1. (This is due to the fact that our flow is only almost maximum.) After the second step, this value becomes exactly 0, again except for two vertices that are off by 1.\n</p>\n\n<p>\nTherefore, we know G' satisfies the condition on in-degrees and out-degrees for it to have an Eulerian path. (See the \"Fact\" in the Small Input discussion.) We now show it also satisfies the connectivity condition. This is where we use the specific nature of the problem and the fact that |<b>S</b>| &ge; 2k. Actually, we suspect the last condition is unnecessary in the end, but the proof becomes much harder if this is not true!</p>\n\n<p>\nLet's say a vertex s is a <i>core</i> vertex if it corresponds to a phrase in <b>S</b>, or to a 133tspeak variation of such a phrase.\n<ul>\n<li> If s a core vertex, then s is adjacent in G' to its predecessor and successor phrases within <b>S</b>. (Note that there may be multiple predecessors or successors if the new letter has a leet variation or if <b>S</b> appears multiple times.) Therefore, we can certainly follow the edges of G' to go from s to some phrase a(s) that starts at the first letter of <b>S</b>. We can then walk from there to a phrase b(s) that ends at the last letter of <b>S</b>. Since a(s) and b(s) are completely disjoint, we can choose b(s) to be completely non-leet by always adding on non-leet successor letters. This means b(s) does not depend on s, and hence we have demonstrated every core vertex is connected to a single vertex in G'.\n<li> Now consider a non-core vertex t with positive degree in G'. This can only happen if t has positive degree in G, and therefore it must be connected via the flow to some core vertex s. Since we just showed all core vertices are connected, we conclude the non-core vertices are connected as well.\n</ul>\n</p>\n\n<p>\nTherefore, the underlying undirected graph of G' is indeed connected, and hence G' has an Eulerian path consisting of some vertices s<sub>1</sub>, s<sub>2</sub>, ... s<sub>FLOW_EDGES + |C| + 1</sub>. We can now construct a password string as follows:\n<ul>\n<li>Begin the password string with the k - 1 letters in s<sub>1</sub>.\n<li>For each subsequent vertex s<sub>i</sub>, append to the password string the one letter at the end of s<sub>i</sub> that is not in s<sub>i-1</sub>.\n</ul>\nThis string has length exactly k - 1 + FLOW_EDGES + |C|, as required. Notice that after appending the letter for s<sub>i</sub>, the final k-1 letters in the password string are always precisely equal to s<sub>i</sub>. (This invariant can easily be proven by induction.) Now consider an arbitrary candidate c. Because of how we constructed G', c has prefix s<sub>i-1</sub> and suffix s<sub>i</sub> for some i. But then after appending the letter for s<sub>i</sub>, the last k letters precisely spell out c. Hence, every candidate is in this password string, and the inequality is proven.\n</p>\n\n<p><b>Proof Part 2:</b> ANSWER &ge; FLOW_EDGES + |C| + k - 1</p>\n\n<p>For the second part of the proof, we just need to reverse the previous argument. It is actually a little easier because we do not have to worry about connectivity.</p>\n\n<p>Consider a password string P of length ANSWER. By definition, we know each candidate must appear somewhere in P. Therefore, for each candidate c, we can define pos(c) to the be the character in P where the first occurrence of c begins. Now let's order the candidates c<sub>1</sub>, c<sub>2</sub>, ..., c<sub>|C|</sub> by pos(c).</p>\n\n<p>For each i, consider the substring of P starting with character pos(c<sub>i</sub>) + 1 and ending with character pos(c<sub>i+1</sub>) + k-2. Note that this substring begins with the suffix phrase of c<sub>i</sub> and ends with the prefix phrase of c<sub>i+1</sub>.</p>\n\n<p>By reversing the construction from the previous section, we can interpret this substring as a path in the graph G from the suffix phrase of c<sub>i</sub> to the prefix phrase of c<sub>i+1</sub>. This path has pos(c<sub>i+1</sub>) - pos(c<sub>i</sub>) - 1 edges in it. Now let's think about what happens when we combine all these paths. We get a flow with a source at every suffix phrase except c<sub>|C|</sub> and a sink at every prefix phrase except c<sub>1</sub>. When we add all these sources and sinks together, we get precisely an almost max-flow on G. Furthermore, this flow uses exactly sum<sub>i</sub> [pos(c<sub>i+1</sub>) - pos(c<sub>i</sub>) - 1] = pos(c<sub>|C|</sub>) - pos(c<sub>1</sub>) - |C| + 1 edges.</p>\n\n<p>It follows that FLOW_EDGES &le; pos(c<sub>|C|</sub>) - pos(c<sub>1</sub>) - |C| + 1. Finally, we know pos(c<sub>|C|</sub>) &le; |P| - k = ANSWER - k, and also pos(c<sub>1</sub>) &ge; 0. Therefore, ANSWER &ge; FLOW_EDGES + k + |C| - 1, as required.</p>\n<br/>\n\n<p><b>A Greedy Solution</b></p>\n\n<p>At this point, we still have not solved the whole problem, but we have reduced it to something more tractable. Minimum-cost flow is a complicated problem but it is well known, and at least it can be solved in polynomial time. We can either try to optimize here, or we can use more clever idea to make our life much simpler.</p>\n\n<p><b>Lemma 2:</b> Fix the graph G and assign arbitrary source and sink capacities to arbitrary nodes. Then, a minimum-cost almost-max flow can be achieved by repeatedly taking the shortest path from an unused source to an unused sink, and pushing flow along there (without ever reverting any flow that's already been pushed).</p>\n\n<p><b>Proof:</b> Let F denote a minimum-cost almost-max flow on G, and suppose the shortest path in G between a source and a sink goes from source u to sink x.\nFurthermore, suppose that F contains a path from u to a different sink y, and a path from a different source v to x. We claim that we could replace these two paths with a path from u to x and with a path from v to y to achieve a flow with no more edges. (Since F is only an almost-max flow, it might also be that u and/or x is simply not used in F, but that case is a lot simpler.) Recall that every edge in G has infinite capacity, so the only challenge here is making sure the path lengths work out.</p>\n\n<p>Given two phrases p and q, let's define A(p, q) to be the longest string that is both a suffix of p and a prefix of q. Then the distance from p to q in G is precisely equal to k - 1 - |A(p, q)|. This means we can reformulate the claim as follows: given that |A(u, x)| &ge; max(|A(u, y)|, |A(v, x)|), prove that |A(u, x)| + |A(v, y)| &ge; |A(u, y)| + |A(v, x)|.</p>\n\n<p>Now, notice that A(u, x) and A(u, y) are both suffixes of u, but A(u, x) is at least as long. Therefore, A(u, y) is a suffix of A(u, x). Similarly, A(v, x) is a prefix of A(u, x). Let t = |A(u, y)| + |A(v, x)| - |A(u, x)|. If t &le; 0, the claim is trivial. Otherwise, there must be a length-t string z that is a suffix of A(v, x) and a prefix of A(u, y). Then z is also a suffix of v and a prefix of y. Therefore, |A(v, y)| &ge; |z| = t, and the claim is proven.</p>\n\n<p>We have shown that F can be modified to contain the path from u to x without increasing the number of edges. Now consider the rest of F. It defines a smaller flow, and we can repeat the same argument to show this residual flow can also be modified to contain the shortest path between a remaining source and a remaining sink, and that this modification will not increase the number of edges. Applying this argument repeatedly gives us the flow proposed in the lemma without ever increasing the number of edges, and so we have shown that this flow is indeed optimal.</p>\n<br/>\n\n<p><b>The Implementation</b></p>\n\n<p>Almost there! We have outlined a greedy algorithm, but what does it actually mean when it is put back into the context of the original problem, and how can it be implemented quickly?</p>\n\n<ul>\n<li> The first thing to do is to construct the prefix phrases and the suffix phrases of all candidates. We need to construct an almost max-flow from the suffixes to the prefixes. If a phrase is both a suffix and a prefix, then these two instances cancel out.\n<li> First we should look for a source u and a sink x that are separated by distance 1 in the underlying graph. This is equivalent to saying that there is a length k-2 string that is a suffix of u and a prefix of x.\n<li> Next we should look for a source u and a sink x that are separated by distance 2 in the underlying graph. This is equivalent to saying that there is a length k-3 string is a suffix of u and a prefix of x.\n<li>And so on...\n</ul>\n\n<p>This can be summarized as follows:\n<ul>\n<li>Let P = the multi-set of prefix phrases of all candidates.\n<li>Let S = the multi-set of suffix phrases of all candidates.\n<li>Let x = k + |C| and i = 0.\n<li>(*) While |P| &ge; 2 and |P intersect S| &ge; 1: delete one copy of a common element from both P and S and increment x by i.\n<li>Remove the last letter from every element in P and the first letter from every element in S.\n<li>Increment i by 1, and repeat again from (*) until P and S have just one element.\n<li>Output x.\n</ul></p>\n\n<p>Unfortunately, this is still a little too slow. It will run in time proportional to the output password string length, which could be 10<sup>18</sup>. The final optimization is that if you look at any element in P (or S) in the algorithm above, then all 133tspeak variations of that element should also be in P (or S). You can always treat all variations as one big batch:\n<ul>\n<li>Let P = the map from phrase to the number of times a 133tspeak variation of that phrase appears as the prefix of a candidate.\n<li>Define S similarly for suffixes.\n<li>Let x = k + |C| and i = 0.\n<li>(*) While P and S are non-empty:\n<li>While P and S have a common element t: delete min(P[t], S[t]) from P[t] and S[t] and increment x by i * min(P[t], S[t]).\n<li>Remove the last letter from every element in P and the first letter from every element in S.\n<li>Increment i by 1 and repeat again from (*) until P and S are empty.\n<li>Output x-i+1.\n</ul></p>\n\n<br/>\n<p><b>The Misof Implementation</b></p>\n\n<p>Only one contestant solved this problem during the contest, and he used a variation on the method approached here. Instead of using the greedy algorithm, he implemented the flow directly, grouping together 133t variations in the same way that we did to achieve sub-linear running time in the password string size. It is a little slower and a little harder to implement, but it works just fine. Congratulations to misof for coming up with this!</p>","id":"0000000000432cd4","statement":"<h3>Problem</h3>\n<p>\nAshish has forgotten his password.  He remembers that he used the following algorithm to create his password: Ashish took up to <b>k</b> consecutive words from a passage of text, and took the first letter from each word.  Then, he might have changed some of the letters to their \"l33tspeak\" equivalents.  Specifically, he might have changed \"o\" to \"0\", \"i\" to \"1\", \"e\" to \"3\", \"a\" to \"4\", \"s\" to \"5\", \"t\" to \"7\", \"b\" to \"8\" and/or \"g\" to \"9\".\n</p>\n<p>\nFor example, if Ashish took his password from the first sentence of The Fellowship of the Ring -- <i>\"This book is largely concerned with Hobbits, and from its pages a reader may discover much of their character and a little of their history\"</i> -- Ashish would have reduced that to \"tbilcwhafiparmdmotcaaloth\".  Then the password might be \"tbilcwh\", \"7b1lcwh4f\", \"a\", \"4\", or \"4al07h\", etc.\n</p>\n<p>\nAshish has a special extension installed in his browser that will prevent his computer from uploading any string that contains his password.  In order to figure out which passage of text he took his password from, Ashish has created a webpage to take advantage of this extension.  Every second, the webpage will tell the browser to post a \"password string\" for a new passage of text: a string that contains all of the possible passwords that Ashish could have chosen from that passage of text.  As soon as his browser fails to post such a string, Ashish will know where he took his password from.\n</p>\n<p>\nFor example, if <b>k</b> = 2 and the passage of text contains words starting with the letters \"google\", then one password string for that passage is \"goo0og00gle9o909l3\".  All substrings of length &le; 2 from the original string, and all of their l33tspeak equivalents, are contained in the new string.\n</p>\n<p>\nGiven the first letters of the words in a passage of text, what is the minimum number of characters in the \"password string\" of that passage?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case consists of two lines. The first line contains the integer <b>k</b>. The second line contains a string <b>S</b>, representing the first letters of the words in a passage of text. <b>S</b> contains only the characters 'a' - 'z', with no spaces.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the minimum number of characters in the password string for <b>S</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 40 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n<b>S</b> will contain at least 2 * <b>k</b> characters.<br/>\nThere will exist a password string with at most 10<sup>18</sup> characters.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n<b>S</b> will contain at most 1000 characters.<br/>\n<b>k</b> = 2.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n<b>S</b> will contain at most 5000 characters.<br/>\n2 &le; <b>k</b> &le; 500.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2\npoppop\n2\ngoogle\n2\ntbilcwhafiparmdmotcaaloth\n10\ntbilcwhafiparmdmotcaaloth\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 6\nCase #2: 18\nCase #3: 53\nCase #4: 1136\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first sample input, one possible password string is \"0ppop0\".<br/>\nIn the second sample input, one possible password string is \"goo0og00gle9o909l3\".</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":36}],"title":"Lost Password","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Preamble</h3>\n<p>\nIt will come as no great surprise that this problem was inspired by a video game that the author played: Super Meat Boy.  Turning the real achievement challenge into a Code Jam problem involved a little simplifying: it doesn't take the same amount of time to lose a level as to win it, for example.\n</p>\n\n<h3>Total Expected Time and Number of Attempts</h3>\n\n<p>\nYour total expected time to complete the achievement will be the expected number of attempts, times the expected time per attempt.\n</p>\n\n<p>\nFirst, let's figure out how many attempts it's going to take us to complete the achievement.  The probability of success in any given attempt is easy to compute, since it's simply the probability of succeeding on every level once without failing any of them: <code>(1-P<sub>1</sub>)*(1-P<sub>2</sub>)*...*(1-P<sub>N</sub>)</code>.  The expected number of attempts won't depend on anything other than this probability, and this probability doesn't depend on the order of the levels; so the expected number of attempts doesn't depend on the order of the levels, and we can ignore it when figuring out what order to attempt them in.\n</p>\n\n<p>\nIn case you're curious about what the expected number of attempts is anyway, read on.  Let's say that we're going to try to do something that might fail, like complete this achievement, and that we're going to keep trying until we succeed.  If the probability of success is <code>P</code>, then what we're doing is called a <a href=\"http://en.wikipedia.org/wiki/Bernoulli_trial\" target=\"_blank\">Bernoulli Trial</a>, repeated until we achieve success.  The number of attempts that will take falls into a random distribution called the <a href=\"http://en.wikipedia.org/wiki/Geometric_distribution\" target=\"_blank\">Geometric Distribution</a>.  The expected value of this distribution&ndash;the number of attempts it will take&ndash;is <code>1/P</code>.\n</p>\n\n<p>\nKnowing about the Geometric Distribution lets us compute the expected number of attempts easily.  The chance that we'll complete every level successfully, one after another, is the product of the probabilities of success, which we'll call <code>P</code>; the number of attempts it will take us to complete that is <code>1/P</code>.  As promised, this number doesn't depend on the order in which we attempt the levels, and since what we're trying to do is compute the best order, we're going to ignore it.\n</p>\n\n<h3>Time Per Attempt</h3>\n\n<p>\nLet's choose an arbitrary order for the levels.  Suppose the i<sup>th</sup> of those levels takes t<sub>i</sub> time, and you die in that level with probability p<sub>i</sub>.  In any attempt, you'll definitely reach level 1; you'll reach level 2 with probability <code>1-p<sub>1</sub></code>; you'll reach level 3 with probability <code>(1-p<sub>1</sub>)*(1-p<sub>2</sub>)</code>; and so on.\n</p>\n<p>\nBased on those calculations, the amount of time it takes you to make one attempt will be <code>expected time = t<sub>1</sub> + (1-p<sub>1</sub>)t<sub>2</sub> + (1-p<sub>1</sub>)(1-p<sub>2</sub>)t<sub>3</sub> + ...</code>.  This is because you will try level <code>i</code> only if you pass the first <code>i-1</code> levels.\n</p>\n<p>\nNow, let's consider what would happen to that expected time if we swapped levels <code>i</code> and <code>i+1</code>.  Only two of the terms of the expected time equation would be affected&mdash;the others would simply reverse the order of <code>(1-p<sub>i</sub>)</code> and <code>(1-p<sub>i+1</sub>)</code>, which doesn't matter.  Those two terms themselves have several multiplicative terms in common:\n</p>\n<p>\n<b>Pre-swap:</b><br/><code>(1-p<sub>1</sub>)(1-p<sub>2</sub>)...(1-p<sub>i-1</sub>)t<sub>i</sub> +<br/>(1-p<sub>1</sub>)(1-p<sub>2</sub>)...(1-p<sub>i-1</sub>)(1-p<sub>i</sub>)t<sub>i+1</sub></code>.<br/>\n<b>Post-swap:</b><br/><code>(1-p<sub>1</sub>)(1-p<sub>2</sub>)...(1-p<sub>i-1</sub>)t<sub>i+1</sub> +<br/>(1-p<sub>1</sub>)(1-p<sub>2</sub>)...(1-p<sub>i-1</sub>)(1-p<sub>i+1</sub>)t<sub>i</sub></code>.\n</p>\n<p>\nSo we're better off post-swap iff:<br/>\n<code>t<sub>i</sub> + (1-p<sub>i</sub>)t<sub>i+1</sub> &gt; t<sub>i+1</sub> + (1-p<sub>i+1</sub>)t<sub>i</sub></code><br/>\n<code>t<sub>i</sub>p<sub>i+1</sub> &gt; t<sub>i+1</sub>p<sub>i</sub></code><br/>\n</p>\n<p>\nNow we can compare two adjacent levels to see whether they should be swapped.  Doing this greedily results in a <a href=\"http://en.wikipedia.org/wiki/Sorting_algorithm#Stability\" target=\"_blank\">stable sort</a> of the levels.  With a little more work, you can prove that non-adjacent levels should be swapped under the same conditions, and that the stable sort is thus optimal.\n</p>\n\n<h3>Implementation Details</h3>\n<p>\nOur last inequality above said we should swap iff \n<code>t<sub>i</sub>p<sub>i+1</sub> &gt; t<sub>i+1</sub>p<sub>i</sub></code>.  It's tempting to go one step further, to <code>t<sub>i</sub>/p<sub>i</sub> &gt; t<sub>i+1</sub>/p<sub>i+1</sub></code>, but we can't: <code>p<sub>i</sub></code> or <code>p<sub>i+1</sub></code> could be zero, and dividing by zero isn't a mathematically valid thing to do.\n</p>\n<p>\nAnother reason not to make that final step&ndash;though the final step actually kind of works if you don't mind special-casing <code>p<sub>i</sub>=0</code> to give an infinite score&ndash;is because division almost inevitably makes us deal with floating-point numbers.  In a problem like this where we're trying to make a decision based on numbers, we want to make sure we're doing exact comparisons.  We wouldn't want to reverse two equivalent levels because <code>t<sub>i</sub>/p<sub>i</sub> = 10.0000000001</code> and <code> t<sub>i+1</sub>/p<sub>i+1</sub> = 10.0</code>.\n</p>","id":"0000000000433250","statement":"<h3>Problem</h3>\n<p>\nYou're playing a video game, in which you will get an achievement if you complete all of the levels consecutively without dying.  You can play the levels in any order, and each time you play a level you'll either complete it or die.  Each level has some probability that you'll complete it, and takes some amount of time.  In what order should you play the levels so that the expected time it takes you to get the achievement is minimized?  Assume that it takes equally long to beat a level or to die in it, and that you will start again from the first level in your ordering as soon as you die.\n</p>\n<p>\nNote: If you fail to complete a level, you do not personally die&mdash;only your character in the game dies.  If that were not the case, only a few people would try to earn this achievement.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow, each of which consists of three lines.  The first line of each test case contains a single integer <b>N</b>, the number of levels.  The second line contains <b>N</b> space-separated integers <b>L<sub>i</sub></b>.  <b>L<sub>i</sub></b> is the number of seconds level <code>i</code> lasts, which is independent of whether you complete the level or die.  The third line contains <b>N</b> space-separated integers <b>P<sub>i</sub></b>.  <b>P<sub>i</sub></b> is the percent chance that you will <i><b>die</b></i> in any given attempt to complete level <code>i</code>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: \", where x is the case number (starting from 1), followed by <b>N</b> space-separated integers.  The <code>j</code><sup>th</sup> integer in the list should be the index of the <code>j</code><sup>th</sup> level you should attempt to beat in order to minimize the amount of time you expect to spend earning the achievement.\n</p>\n<p>\nIndices go from <code>0</code> to <code>N-1</code>.  If there are multiple orderings that would give the same expected time, output the lexicographically least ordering.  Out of two orderings, the lexicographically smaller one is the one with the smaller index at the first location where they differ; out of many orderings, the lexicographically least one is the one that is lexicographically smaller than every other ordering.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 20 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &le; <b>P<sub>i</sub></b> &lt; 100.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 20.<br/>\n<b>L<sub>i</sub></b> = 1.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>L<sub>i</sub></b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n1 1 1 1\n50 0 20 20\n3\n100 10 1\n0 50 0\n3\n100 80 50\n40 20 80\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 2 3 1\nCase #2: 1 0 2\nCase #3: 2 0 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>Note that the second and third samples do not satisfy the constraints for the small input.</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":3},{"type":2,"type__str":"HIDDEN","value":7}],"title":"Perfect Game","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432f40","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2012"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
