{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1428804000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433515","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nGoogle Code Jam 2015 is off and running! We had 56,749 registrants! More than 23,000 people correctly solved at least one input, and more than 12,000 had at least 20 points to advance to the next round.  This was our hardest qualification round ever.\n</p>\n\n<p>\nWe opened with <i>Standing Ovation</i> where you had to help your friend who is a prima donna! It required a greedy strategy. Next came <i>Infinite House of Pancakes</i> which involved… pancakes! Then came <i>Dijkstra</i> but the problem wasn't on Dijkstra's algorithm but rather on <i>quaternions</i>. We wrapped up with <i>Ominous Omino</i> which involved <i>Tetris</i>-style blocks.\n</p>\n\n\n<p>\nWe are just getting started with GCJ 2015. Congratulations to all the advancers!\n</p>\n\n<hr>\n\n<p>\nCast\n</p>\n<p>\nProblem A. <i>Standing Ovation</i> Written by Ian Tullis and Prepared by John Dethridge.\n</p>\n<p>\nProblem B. <i>Infinite House of Pancakes</i> Written and Prepared by Ian Tullis.\n</p>\n\n<p>\nProblem C. <i>Dijkstra Written</i> by Ian Tullis and Prepared by Carlos Guia Vera.\n</p>\n\n<p>\nProblem D. <i>Ominous Omino</i> Written and Prepared by Ian Tullis.\n</p>\n\n<p>\nContest analysis presented by Felix Halim, Risan, Topraj Gurung, Tsung-Hsien Lee, Artur Satayev, Ian Tullis, Ilham Kurnia, Jackson Gatenby and Jonathan Shen. Solutions and other problem preparation by Ahmed Aly, Carlos Guia Vera, Chieu Nguyen, David Gomez Cermeno, David Spies, Igor Naverniouk, Jackson Gatenby, John Dethridge, Jonathan Paulson, Md. Arifuzzaman Arif, Md Mahbubul Hasan, Sumudu Fernando and Taman (Muhammed) Islam.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1428706800000,"tasks":[{"analysis":"<h3>What kind of shyness level friends should we invite?</h3>\n<p>\nSince we can invite any friend with any shyness level, the problem seems really complicated.  However, if you think about it you will realize that inviting friends with shyness level 0 is optimal and makes this problem simpler. Friends with shyness level 0 are always better than those with other shyness levels because they always stand up and clap, therefore helping all other audience members who have shyness level greater than 0.  This kind of choice is greedy but makes sense as for any scenario: if you can invite friends with shyness level greater than 0 and solve the problem, then you can always replace them with friends whose shyness level is 0 and still solve the problem.\n</p>\n\n<h3>How many friends should we invite?</h3>\n<p>\nFor audience members with shyness level <b><i>k</i></b>, to meet their needs, we must have at least <b><i>k</i></b> people who already stood up before them. These include both the  audience members whose shyness level is less than <b><i>k</i></b> and the  friends we invited (with shyness level 0). Assuming that there are <b><i>t</i></b> audience members who stood up already, the number of friends we need to invite is <b>max(<i>k - t</i>, 0)</b>. This provides us with an algorithm. Let’s say we are given an array of audience members for which the <b><i>k</i></b><sup>th</sup> entry contains the total audience members of shyness level <b><i>k</i></b>. Now, for each shyness level, we compute the number of friends we need to invite to get the audience members of that level to stand up and clap, and we record the maximum value out of all such values. This max value is the minimum number of friends we need to invite to let every audience member stand up and clap for the prima donna.\n</p>\n<p>\nBelow is a sample implementation in Python:\n</p>\n<pre>\nfor tc in range(input()):\n  smax, string = raw_input().split()\n  t = 0\n  min_invite = 0\n  for k in range(int(smax) + 1):\n    min_invite = max(min_invite, k - t)\n    t += int(string[k])\n  print \"Case #%d: %d\" % (tc + 1, min_invite)\n</pre>\n<p>\nBecause the input of audience members is already given in increasing order, we only need to walk through this array once and compute the result. Since min_invite is initially 0, max(k - t, 0) is redundant (i.e., k - t is sufficient). The overall time complexity is O(<b>S</b><sub>max</sub>).\n</p>","id":"0000000000433738","statement":"<h3>Problem</h3>\n<p>\nIt's opening night at the opera, and your friend is the prima donna (the lead female singer). You will not be in the audience, but you want to make sure she receives a standing ovation -- with every audience member standing up and clapping their hands for her.<br>\n<br>\nInitially, the entire audience is seated. Everyone in the audience has a <i>shyness level</i>. An audience member with shyness level <b>S<sub>i</sub></b> will wait until at least <b>S<sub>i</sub></b> other audience members have already stood up to clap, and if so, she will immediately stand up and clap. If <nobr><b>S<sub>i</sub></b> = 0</nobr>, then the audience member will always stand up and clap immediately, regardless of what anyone else does. For example, an audience member with <b>S<sub>i</sub></b> = 2 will be seated at the beginning, but will stand up to clap later after she sees at least two other people standing and clapping.<br>\n<br>\nYou know the shyness level of everyone in the audience, and you are prepared to invite additional friends of the prima donna to be in the audience to ensure that everyone in the crowd stands up and claps in the end. Each of these friends may have any shyness value that you wish, not necessarily the same. What is the minimum number of friends that you need to invite to guarantee a standing ovation?<br> \n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each consists of one line with <b>S<sub>max</sub></b>, the maximum shyness level of the shyest person in the audience, followed by a string of <nobr><b>S<sub>max</sub> + 1</b></nobr> single digits. The <b>k</b>th digit of this string (counting starting from 0) represents how many people in the audience have shyness level <b>k</b>. For example, the string \"409\" would mean that there were four audience members with <nobr><b>S<sub>i</sub></b> = 0</nobr> and nine audience members with <nobr><b>S<sub>i</sub></b> = 2</nobr> (and none with <nobr><b>S<sub>i</sub></b> = 1</nobr> or any other value). Note that there will initially always be between 0 and 9 people with each shyness level.<br>\n<br>\nThe string will never end in a 0. Note that this implies that there will always be at least one person in the audience.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of friends you must invite.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n0 &le; <b>S<sub>max</sub></b> &le; 6.\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n0 &le; <b>S<sub>max</sub></b> &le; 1000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n4 11111\n1 09\n5 110011\n0 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 1\nCase #3: 2\nCase #4: 0\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn Case #1, the audience will eventually produce a standing ovation on its own, without you needing to add anyone -- first the audience member with <nobr><b>S<sub>i</sub></b> = 0</nobr> will stand up, then the audience member with <nobr><b>S<sub>i</sub></b> = 1</nobr> will stand up, etc.<br>\n<br>\nIn Case #2, a friend with <nobr><b>S<sub>i</sub></b> = 0</nobr> must be invited, but that is enough to get the entire audience to stand up.<br>\n<br>\nIn Case #3, one optimal solution is to add two audience members with <nobr><b>S<sub>i</sub></b> = 2</nobr>.<br>\n<br>\nIn Case #4, there is only one audience member and he will stand up immediately. No friends need to be invited.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Standing Ovation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>As the head server, you have two choices for each minute:\n<ol>\n<li><b>eat</b>: you do nothing and let every diner with a non-empty plate eat one pancake from his or her plate.</li>\n<li><b>move</b>: you ask for the diners' attention for a <i>special</i> minute, choose a diner with a non-empty plate, and move some number of pancakes from that diner's plate to another diner's (empty or non-empty) plate.</li></ol>\n</p>\n\n<p>Imagine that you, as the head server, have planned a strategy to move the pancakes. Let&#39;s call it <b>strategy A</b>. In this strategy, you pick a successive pair of minutes <b>t</b> and <b>t+1</b> such that at minute <b>t</b> you choose <b>eat</b> and at minute <b>t+1</b> you choose <b>move</b>. As a natural philosopher, you start to question your decision, &quot;What if I swap my plan at minute <b>t</b> with my plan at minute <b>t+1</b>, i.e. <b>move</b> pancakes at minute <b>t</b> (instead of <b>t+1</b>) and <b>eat</b> at minute <b>t+1</b> (instead of <b>t</b>)?&quot;. Out of curiosity, you swap your plan at minute <b>t</b> and <b>t+1</b> and calculate the breakfast end time. Surprisingly, breakfast does not take longer. After that, you start to find several other successive pairs of minutes with the same property and do other swaps. You find that breakfast never takes longer than if you strictly follow <b>strategy A</b>. Surprisingly, on certain swaps, breakfast even ends earlier than <b>strategy A</b>!</p>\n\n<p>Of course you become more curious! You start to observe what happened when you did those swaps. If the plan at minute <b>t</b> is <b>eat</b> and the plan at minute <b>t+1</b> is <b>move</b>, you notice that all pancakes that were eaten at time <b>t</b> before you did the swap were also eaten at time <b>t+1</b> after swapping. Hence, the number of pancakes that were eaten after time <b>t+1</b> does not decrease, which implies that breakfast will not take longer. After you swap the plan at <b>t</b> with <b>t+1</b>, you notice that several plates that were empty at time <b>t</b> might become non-empty at time <b>t+1</b> after swapping (and hence, the number of pancakes that were eaten after time <b>t+1</b> might increase by one).</p>\n\n<blockquote> &quot;Whoa! That means if I swap <b>&lt;eat, move&gt;</b> pairs to <b>&lt;move, eat&gt;</b>, the amount of pancakes that were eaten at time <b>t</b> before the swap is either less than or equal to the amount of pancakes that were eaten at time <b>t+1</b> after the swap. Hence, such swaps are always good (i.e. it will not make the  breakfast time longer but might make the breakfast time shorter)!&quot;</blockquote>\n\n<p>Excited with your finding, you grab a whiteboard and start to swap every successive pairs of <b>&lt;eat, move&gt;</b> to be <b>&lt;move, eat&gt;</b>, until none of the <b>&lt;eat, move&gt;</b> pairs are left. You look at your revised strategy.\n\n<blockquote>&quot;<b>Move, move, move, eat, eat, eat, eat, eat</b>&quot; you read out loudly. &quot;Of course! <i>The only strategy without a <b>&lt;eat, move&gt;</b> pair is the strategy in which we do all the moves at the beginning, and always eat after that</i>. If we look at this carefully, swapping pairs of elements that are in the wrong order (in this case <b>eat</b> then <b>move</b>) until none are left will actually <i>sort</i> the strategy. This is basically doing <a href=\"http://en.wikipedia.org/wiki/Bubble_sort\" target=\"_blank\">bubble sort</a> on <b>strategy A</b>!&quot;</p></blockquote>\n\n<p>Knowing that you are going to get a bonus from your boss for ending breakfast early, you quickly present this solution to your boss. Your boss is not convinced. He replies without showing much interest, &quot;Well, I understand that <b>moving</b> pancakes at the beginning will always lead to an optimal solution. But what is more important is that for every <b>move</b>, do you know how you are going to move the pancakes?&quot; You quickly answer, &quot;At least I know that we can always move pancakes to empty plates! There are infinitely many of them, and we do not have any reason to let diners with non-empty plates to eat more than is needed. We cannot even wait for them to finish their existing pancakes!&quot;</p>\n\n<p>Your boss stops reading emails and starts to pay attention to your explanation. &quot;How will you pick the plates to <b>move</b> pancakes from?&quot; he asks. &quot;Perhaps from the customer with the most pancakes on their plate? They need the most help to finish their pancakes,&quot; you reply.</p>\n\n<blockquote>&quot;You mean we can end breakfast earlier if we keep moving several pancakes from the plates with most pancakes to empty plates, and stop moving after several minutes?&quot; he enthusiastically says. &quot;Congratulations! You get a big bonus and extra time off!&quot;</blockquote>\n\n<p>You are extremely happy. You gather all the kitchen staff and explain the new strategy... of course after bragging a bit on social media! A new intern staff raises her hand and asks, &quot;When should we stop <b>moving</b> pancakes? Also, how many pancakes should we move every time?&quot;</p>\n\n<p>The whole kitchen goes silent. Everyone is looking at you expecting answers. Breakfast will start in half an hour. &quot;Quick, think of something useful,&quot; you tell yourself. Your mind feels like it is exploding!</p>\n\n<p>&quot;Erm, honestly I don&#39;t know. Let&#39;s try to simulate breakfast to get some insights. Please bring me two plates of pancakes with <b>15</b> and <b>17</b> pancakes respectively. Ah, don&#39;t forget to bring me several empty plates too,&quot; you order one of your staff.</p>\n\n<p>You start to simulate your new strategy multiple times with different amount of pancakes to be moved and stop moving at different times. Suddenly, your new intern says to you, &quot;Look! You take <b>10</b> pancakes from the <b>plate 1</b> and put it on an <b>empty plate 3</b>. Later, you picked <b>3</b> pancakes from <b>plate 3</b> and moved it to another <b>empty plate 4</b>. Instead of doing that, why didn&#39;t you move <b>7</b> pancakes from first plate to an <b>empty plate 3</b>, and then move <b>3</b> pancakes from first plate to another <b>empty plate 4</b>? That way, you can always move pancakes from plates that are initially non-empty.&quot;</p>\n\n<blockquote>&quot;I see,&quot; you say, &quot;That means we can take half the pancakes from the plate with largest amount of pancakes, then move it to an empty plate, then pick another plate with the largest amount of pancakes and do the same thing multiple times...&quot;</blockquote>\n\n<blockquote>She replies quickly, &quot;Your strategy is bad. Imagine that you had a plate of <b>9</b> pancakes. If we use your strategy, the best we can do is to split the plate into plates with <b>4</b> and <b>5</b> pancakes, and let the diners eat them. It costs us <b>6</b> minutes to end breakfast. But if you split the plate into three plates with <b>3</b> pancakes each (using <b>2 moves</b>), we can finish breakfast in only <b>5</b> minutes!&quot;</blockquote>\n\n<p>&quot;I have a suggestion,&quot; she continues, &quot;If you expect the customer to finish their pancakes <b>x</b> minutes after you stop moving pancakes, any strategy that satisfies this will be equivalent to repeatedly moving at most <b>x</b> pancakes from every initially non-empty plate to an empty plate until the number of pancakes on the initially non-empty plate becomes no more than <b>x</b>.&quot;</p>\n\n<p>&quot;And if you always move exactly <b>x</b> pancakes, for a plate with <b>P<sub>i</sub></b> pancakes you need only <b>M(P<sub>i</sub>)=ceil(P<sub>i</sub>/x)-1</b> moves until the number of pancakes in the plate is no more than <b>x</b>. You cannot do less than that! Overall, we are going to move <b>sum of M(P<sub>i</sub>)</b> times, where <b>P<sub>i</sub></b> is the number of pancakes on <b>plate i</b>. That is the minimum amount of moves that we can do for the given <b>x</b>! We can try all possible values of <b>x</b> to find the optimal <b>x</b> that has earliest breakfast end time!&quot; Everyone gives her a standing ovation.</p>\n\n<blockquote>&quot;Let&#39;s summarize our strategy. First of all, we fix a number <b>x</b> to be the number of minutes that we expect breakfast to end in after we stop moving pancakes. After that, we pick a plate with more than <b>x</b> pancakes, take <b>x</b> pancakes from that plate and move the pancakes to an empty plate. We keep doing that until all plates has at most <b>x</b> pancakes, then we let the customers eat their pancakes and breakfast ends the earliest for that <b>x</b> value! If we move <b>sum of M(P<sub>i</sub>)</b> times, in total, the breakfast ends exactly after <b>x + sum of M(P<sub>i</sub>)</b> minutes,&quot; you say. &quot;And we can try all possible values of <b>x</b>, since the amount of pancakes cannot be more than <b>1000</b>. The complexity of the algorithm is <b>O(D*M)</b>, where <b>D</b> is the number of diners and <b>M</b> is the maximum number of pancakes. This is fast enough to solve our problem. We can use a spreadsheet to...&quot;</blockquote>\n\n<p>&quot;Certainly, but I have prepared for this,&quot; says your intern. She opens her laptop and types some really short functions, of course in <b>C++</b>. &quot;Why? Because <b>C++</b> is cool!&quot;</p>\n\n<pre>\n// Get the minimum possible breakfast end time, given \n// P[i] is the number of pancakes of diner i initially.\nint f(const vector&lt;int&gt;&amp; P) {\n  const int max_pancakes = *max_element(P.begin(), P.end());\n  int ret = max_pancakes;\n  for (int x = 1; x &lt; max_pancakes; ++x) {\n    int total_moves = 0;\n    for (const int Pi : P) {\n      // (Pi - 1) / x is equivalent to M(Pi), \n      // which is ceil(Pi / x) - 1\n      total_moves += (Pi - 1) / x;\n    }\n    ret = min(ret, total_moves + x);\n  }\n  return ret;\n}\n</pre>\n\n<p>&quot;Whooa! Run it, run it!&quot; you exclaim.</p>\n\n<p>&quot;Hold on, hold on. Although the algorithm above is fast enough to solve our problem, I have an even faster algorithm. Notice that the list of <b>ceil(a/1), ceil(a/2), ...</b> only changes values at most <b>2*sqrt(a)</b> times. For example, if <b>a=10</b>, the list is: <b>10, 5, 3, 3, 2, 2, 2, 2, 2, 1, 1, ...</b>. That list only changes value <b>4</b> times which is less than <b>2 * sqrt(10)</b>! Therefore, we can precompute when the list changes value for every diner in only <b>O(D*sqrt(M))</b>. We can keep track these value changes in a table. For example, if <b>P<sub>i</sub>=10</b>, we can have a table <b>T<sub>i</sub></b>: <b>10, -5, -2, 0, -1, 0, 0, 0, 0, -1, 0, ...</b>. Notice that the prefix sum of this table is actually: <b>10, 5, 3, 3, 2, 2, 2, ...</b>. More importantly, this table is sparse, i.e. it has only <b>O(sqrt(M))</b> non-zeroes. If we do vector addition on all <b>T<sub>i</sub></b>, we can get a table where every entry at index <b>x</b> of the prefix sum contains sum of <b>ceil(P<sub>i</sub>/x)</b>. Then, we can calculate sum of <b>ceil(P<sub>i</sub>/x)-1</b> in the code above by subtracting the <b>x<sup>th</sup></b> index of the prefix sum with the number of diners. Hence, only another <b>O(M)</b> pass is needed to calculate candidate answers, which gives us <b>O(D*sqrt(M) + M)</b> running time. A much faster solution!&quot;</p>\n\n<blockquote>&quot;One more thing, we cannot do binary search or ternary search, at least in trivial ways, on a function that maps <b>x</b> to its minimum breakfast end time as the function can have multiple minimas. e.g. for <b>2</b> diners with <b>9</b> pancakes each, the function forms the following mappings: <b>(1,17), (2,10), (3,7), (4,8), (5,7), (6,8), (7,9), (8,10), (9,9)</b>.&quot;</blockquote>\n\n<p>&quot;I don&#39;t need that! The previous algorithm is fast enough. Please run it,&quot; you say impatiently.</p>\n\n<p>&quot;Sigh. I won&#39;t tell you how to code the faster solution then. The answer is...&quot; Everyone gasps while the program blinks. &quot;... <b>42</b>.\"</p>","id":"0000000000433827","statement":"<h3>Problem</h3>\n<p>\nAt the Infinite House of Pancakes, there are only finitely many pancakes, but there are infinitely many diners who would be willing to eat them! When the restaurant opens for breakfast, among the infinitely many diners, exactly  <b>D</b> have non-empty plates; the <b>i</b>th of these has <b>P<sub>i</sub></b> pancakes on his or her plate. Everyone else has an empty plate.<br>\n<br>\nNormally, every minute, every diner with a non-empty plate will eat one pancake from his or her plate. However, some minutes may be <i>special</i>. In a special minute, the head server asks for the diners' attention, chooses a diner with a non-empty plate, and carefully lifts some number of pancakes off of that diner's plate and moves those pancakes onto one other diner's (empty or non-empty) plate. No diners eat during a special minute, because it would be rude.<br>\n<br>\nYou are the head server on duty this morning, and it is your job to decide which minutes, if any, will be special, and which pancakes will move where. That is, every minute, you can decide to either do nothing and let the diners eat, or declare a special minute and interrupt the diners to make a single movement of one or more pancakes, as described above.<br>\n<br>\nBreakfast ends when there are no more pancakes left to eat. How quickly can you  make that happen?  \n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each consists of one line with <b>D</b>, the number of diners with non-empty plates, followed by another line with <b>D</b> space-separated integers representing the numbers of pancakes on those diners' plates.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the smallest number of minutes needed to finish the breakfast.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>D</b> &le; 6.<br/>\n1 &le; <b>P<sub>i</sub></b> &le; 9.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>D</b> &le; 1000.<br/>\n1 &le; <b>P<sub>i</sub></b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1\n3\n4\n1 2 1 2\n1\n4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 2\nCase #3: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn Case #1, one diner starts with 3 pancakes and everyone else's plate is empty. One optimal strategy is:<br>\n<br>\nMinute 1: Do nothing. The diner will eat one pancake.<br>\n<br>\nMinute 2 (special): Interrupt and move one pancake from that diner's stack onto another diner's empty plate. (Remember that there are always infinitely many diners with empty plates available, no matter how many diners start off with pancakes.) No pancakes are eaten during an interruption.<br>\n<br>\nMinute 3: Do nothing. Each of those two diners will eat one of the last two remaining pancakes.<br>\n<br>\nIn Case #2, it is optimal to let the diners eat for 2 minutes, with no interruptions, during which time they will finish all the pancakes.<br>\n<br>\nIn Case #3, one diner starts with 4 pancakes and everyone else's plate is empty. It is optimal to use the first minute as a special minute to move two pancakes from the diner's plate to another diner's empty plate, and then do nothing and let the diners eat for the second and third minutes.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Infinite House of Pancakes","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nWe can solve this problem with the help of the following two insights. First, the product of the whole string must equal -1 (<i>i</i> ⨉ <i>j</i> ⨉ <i>k</i>). Second, we only need a small number of copies of the input string to check for a solution. One way to do this is by finding the shortest prefix of the whole string that reduces to <i>i</i> and the shortest subsequent prefix that reduces to <i>j</i>. If we find such two substrings, there is a solution because the rest of the string reduces to <i>k</i> thanks to the associative property. The rest of this editorial explains the two insights and provides a sample implementation.\n</p>\n\n<h3>No solution if the whole string cannot be reduced to -1</h3>\n<p>\nSuppose the string <b>S</b> is the whole concatenated string formed by repeating the given input string <b>X</b> times. If we can break the string S into three non-empty substrings <b>A</b>, <b>B</b>, <b>C</b> where A + B + C = S such that A reduces to <i>i</i>, B reduces to <i>j</i>, and C reduces to <i>k</i>, then the string S reduces to string \"ijk\", which then reduces to -1. Therefore, if the string S cannot be reduced to -1, then there is no solution. Reducing the string S can be done by simply multiplying all the characters in S into one value.\n</p>\n<p>\nIf the string S can be reduced to -1, it doesn't mean that there is a solution for S. There are many strings (e.g., \"ii\", \"jj\", etc.) that reduces to -1 but do not form a concatenation of three substrings that reduce to <i>i</i>, <i>j</i>, and <i>k</i>, respectively.\n</p>\n<h3>The first two substrings must reduce to <i>i</i> and <i>j</i>, respectively</h3>\n<p>\nFrom now on, we only consider whole strings that reduce to -1. To determine whether a string <b>S</b> can be broken into three non-empty substrings <b>A</b>, <b>B</b>, <b>C</b> where each reduces to <i>i</i>, <i>j</i>, <i>k</i> respectively, we only need to find the first two substrings. The last substring is guaranteed to reduce to <i>k</i> since the whole string reduces to -1. \n</p>\n<p>\n(There are other alternatives. For example, we can find the shortest prefix and the shortest suffix that reduce to <i>i</i> and <i>k</i>, respectively. If the prefix does not overlap with the suffix, then we can reduce the rest to <i>j</i>. Care must be taken as the multiplication operator is not commutative.\n<br>\nExercise: Can the prefix-suffix pair actually overlap while the whole string can still be reduced to ‘ijk’? Answer: No.)\n<p>\n\n<p>\nTo find the first substring, we start from the first character of the string S and start multiplying it with the next characters and so on until we get the value <i>i</i>. Afterward, we repeat the procedure from the current position until we get the value <i>j</i>. The rest of the string is guaranteed to be non-empty and reduce to <i>k</i>. The complexity of finding the first and the second substrings is O(L * X), since we need to scan the whole string S of length L * X.\n</p>\n<p>\nWith these insights, we can solve the small input in O(L * X). Below is a sample implementation in Python:\n</p>\n<pre>\nM = [[ 0,  0,  0,  0,  0 ],\n     [ 0,  1,  2,  3,  4 ],\n     [ 0,  2, -1,  4, -3 ],\n     [ 0,  3, -4, -1,  2 ],\n     [ 0,  4,  3, -2, -1 ]]\n\ndef mul(a, b):\n  sign = 1 if a * b &gt; 0 else -1\n  return sign * M[abs(a)][abs(b)]\n\ndef multiply_all(S, L, X):\n  value = 1\n  for i in range(X):\n    for j in range(L):\n      value = mul(value, S[j])\n  return value\n\ndef construct_first_two(S, L, X):\n  i_value = 1\n  j_value = 1\n  for i in range(X):\n    for j in range(L):\n      if i_value != 2:\n        i_value = mul(i_value, S[j])\n      elif j_value != 3:\n        j_value = mul(j_value, S[j])\n  return i_value == 2 and j_value == 3\n\nfor tc in range(input()):\n  L, X = map(int, raw_input().split())\n  # maps 'i' =&gt; 2, 'j' =&gt; 3, 'k' =&gt; 4\n  S = [(ord(v) - ord('i') + 2) for v in raw_input()]\n  ok1 = multiply_all(S, L, X) == -1\n  ok2 = construct_first_two(S, L, X)\n  print \"Case #%d: %s\" % (tc + 1,\n    \"YES\" if ok1 and ok2 else \"NO\")\n</pre>\n<p>\nThe multiplication matrix M is defined as a 5 x 5 matrix where the first column and the first row are not used (for value 0). The second row and the second column is for an identity value 1. The third, fourth and fifth (rows and columns) represent <i>i</i>, <i>j</i>, and <i>k</i>, respectively, identical to the quaternion multiplication matrix.\n</p>\n\n<h3>Optimizations for the large input</h3>\n<p>\nThe maximum whole string length is 10^16 which is too large for an implementation of the algorithm above to finish within the time limit when it is executed in a today's computer. We need to optimize both of these functions: multiply_all() and construct_first_two().\n</p>\n\n<h3>Optimizing the multiply_all() method</h3>\n<p>\nObserve that the whole string is formed by repeating the input string (of length L) X times, giving the complexity of O(L * X). Since the multiplication operator is associative, we can reduce the input string into a single value before multiplying this value to itself X - 1 times. Thus, we can rewrite the multiply_all() method as follows:\n</p>\n<pre>\ndef multiply_all(S, L, X):\n  value = 1\n  for i in range(L):\n    value = mul(value, S[i])\n  return power(value, X) # computes value^X\n</pre>\n<p>\nTo quickly multiply the value with itself X - 1 times (that is, computing value^X), we can use the <a href=\"http://en.wikipedia.org/wiki/Exponentiation_by_squaring#Basic_method\" target=\"_blank\">exponentiation by squaring</a> technique which runs in O(log(X)):\n</p>\n<pre>\ndef power(a, n):\n  if n == 1: return a\n  if n % 2 == 0: return power(mul(a, a), n // 2)\n  return mul(a, power(mul(a, a), (n - 1) // 2))\n</pre>\n<p>\nWith this optimizations, the multiply_all() complexity is now O(L + log(X)). Since L is at most 10000 and X is at most 10^12, the number of multiplication operations is at most 10040.\n</p>\n<p>\nWe can improve it further to O(L). Observe that the multiplication values (to itself) will always repeat to the original value after 4 consecutive multiplications, thus we only need to do at most X mod 4 multiplications to compute value^X:\n</p>\n<pre>\ndef power(a, n):\n  value = 1\n  for i in range(n % 4):\n    value = mul(value, a)\n  return value\n</pre>\n\n<h3>Optimizing the call to construct_first_two()</h3>\n<p>\nTo find the prefix, we start with an identity value 1 and multiply it with the value of the first position of the input string, and so on until we get a value <i>i</i>. Supposing X is sufficiently large, if we reach the end of the input string and haven't obtained the value <i>i</i>, we repeat this procedure for the next copy of the input string. At this point, the current value may be 1, <i>j</i>, <i>k</i>, -1, -<i>i</i>, -<i>j</i>, or -<i>k</i>. If the current value is 1, we may as well stop here and declare no solution because continuing the multiplication will result in the same value 1 again. However, if the current value is not 1, we can continue the procedure. \n</p>\n<p>\nWe know from the previous section that multiplying a value to itself will repeat to its original value every 4 consecutive multiplication. Thus, if we don't encounter the value <i>i</i> after executing the procedure for 4 copies of the input string, it is impossible to construct the desired prefix. If we do encounter value <i>i</i>, then we can proceed to find the second substring where the same insight applies.\n</p>\n<p>\nThus, we can safely limit the call to construct_first_two() from X repeats:\n</p>\n<pre>\n  ok2 = construct_first_two(S, L, X)\n</pre>\n<p>\nto min(8, X) repeats:\n</p>\n<pre>\n  ok2 = construct_first_two(S, L, min(8, X))\n</pre>\n<p>\nThis reduces the complexity of the construct_first_two() method from O(L * X) to O(L).\n</p>\n<p>\nTherefore, the complexity of the overall algorithm is now O(L) per test case.\n</p>\n","id":"0000000000433a60","statement":"<h3>Problem</h3>\n<p>\nThe Dutch computer scientist Edsger Dijkstra made many important contributions to the field, including the shortest path finding algorithm that bears his name. This problem is not about that algorithm.<br>\n<br>  \nYou were marked down one point on an algorithms exam for misspelling \"Dijkstra\" -- between <code>D</code> and <code>stra</code>, you wrote some number of characters, each of which was either <code>i</code>, <code>j</code>, or <code>k</code>. You are prepared to argue to get your point back using <i>quaternions</i>, an actual number system (extended from complex numbers) with the following multiplicative structure:<br>\n<br>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2dAAAhcWSrhwJdM7yFKTqJZ8jRswnK7btxJ49EDP0qaD-J0ZvLqb-VY67YG-xhMLPv7ALIQKY/quatmult.png\"><br>\n<br>\nTo multiply one quaternion by another, look at the row for the first quaternion and the column for the second quaternion. For example, to multiply <i>i</i> by <i>j</i>, look in the row for <i>i</i> and the column for <i>j</i> to find that the answer is <i>k</i>. To multiply <i>j</i> by <i>i</i>, look in the row for <i>j</i> and the column for <i>i</i> to find that the answer is <i>-k</i>.<br>\n<br>\nAs you can see from the above examples, the quaternions are not commutative -- that is, there are some <b>a</b> and <b>b</b> for which <b>a</b> * <b>b</b> != <b>b</b> * <b>a</b>. However they are associative -- for any <b>a</b>, <b>b</b>, and <b>c</b>, it's true that <b>a</b> * (<b>b</b> * <b>c</b>) = (<b>a</b> * <b>b</b>) * <b>c</b>.<br>\n<br>\nNegative signs before quaternions work as they normally do -- for any quaternions <b>a</b> and <b>b</b>, it's true that <b>-a</b> * <b>-b</b> = <b>a</b> * <b>b</b>, and <b>-a</b> * <b>b</b> = <b>a</b> * <b>-b</b> = <b>-(a * b)</b>.<br>\n<br>\nYou want to argue that your misspelling was equivalent to the correct spelling <code>ijk</code> by showing that you can split your string of <code>i</code>s, <code>j</code>s, and <code>k</code>s in two places, forming three substrings, such that the leftmost substring reduces (under quaternion multiplication) to <i>i</i>, the middle substring reduces to <i>j</i>, and the right substring reduces to <i>k</i>. (For example, <code>jij</code> would be interpreted as <i>j</i> * <i>i</i> * <i>j</i>; <i>j</i> * <i>i</i> is -<i>k</i>, and -<i>k</i> * <i>j</i> is <i>i</i>, so <code>jij</code> reduces to <i>i</i>.) If this is possible, you will get your point back. Can you find a way to do it?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each consists of one line with two space-separated integers <b>L</b> and <b>X</b>, followed by another line with <b>L</b> characters, all of which are <code>i</code>, <code>j</code>, or <code>k</code>. Note that the string never contains negative signs, <code>1</code>s, or any other characters. The string that you are to evaluate is the given string of <b>L</b> characters repeated <b>X</b> times. For instance, for <b>L</b> = 4, <b>X</b> = 3, and the given string <code>kiij</code>, your input string would be <code>kiijkiijkiij</code>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is either <code>YES</code> or <code>NO</code>, depending on whether the string can be broken into three parts that reduce to <i>i</i>, <i>j</i>, and <i>k</i>, in that order, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>L</b> &le; 10000.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>X</b> &le; 10000.<br/>\n1 &le; <b>L * X</b> &le; 10000.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>X</b> &le; 10<sup>12</sup>.<br/>\n1 &le; <b>L * X</b> &le; 10<sup>16</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U06hmjDs27gbkKrv80nQTa6Z8OHYkxWD6NEy87guCTcqap1vkE7dwpy9gI_eBvioKvVDGGE_gFo13D0Q1vm-oQgS1hMkLhrIQ/dijkstra_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">5\n2 1\nik\n3 1\nijk\n3 1\nkji\n2 6\nji\n1 10000\ni\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2xoCnE64BWaCnH8ub0C7H2C03eyT0KdR9jqWpPCz_Q2tXAwI9UmhY6yWybs45S-7E8PiIYCoae-6PpTxSRtKKH6M7HvqvtG3U/dijkstra_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: NO\nCase #2: YES\nCase #3: NO\nCase #4: YES\nCase #5: NO</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\nIn Case #1, the string is too short to be split into three substrings.<br>\n<br>\nIn Case #2, just split the string into <code>i</code>, <code>j</code>, and <code>k</code>.<br>\n<br>\nIn Case #3, the only way to split the string into three parts is <code>k</code>, <code>j</code>, <code>i</code>, and this does not satisfy the conditions.<br>\n<br>\nIn Case #4, the string is <code>jijijijijiji</code>. It can be split into <code>jij</code> (which reduces to <i>i</i>), <code>iji</code> (which reduces to <i>j</i>), and <code>jijiji</code> (which reduces to <i>k</i>).<br>\n<br>\nIn Case #5, no matter how you choose your substrings, none of them can ever reduce to a <i>j</i> or a <i>k</i>.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Dijkstra","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Introduction</h3>\n<p>\nThere are various aspects to solving this problem. First off, there is one key observation about X-ominoes where X&gt;=7 which we will cover shortly. Beyond that, we describe a brute force solution where we generate all possible X-ominoes, simulate Richard picking one of the X-ominoes, then simulate Gabriel placing that particular X-omino in all possible locations on the grid to determine if a winning configuration can be found. We also present an alternative solution that involves an exhaustive case-by-case analysis of input to determine the winner.\n</p>\n<h3>Trivial case where X&gt;=7</h3>\n<p>\nThere is a key observation for X-ominoes where X&gt;=7. We point out that in such cases, it is impossible for Gabriel to win. How is that?\n</p>\n<pre>\n###  ####\n#.#  #.##\n##.  ###.\n</pre>\n<p>\nWhen X&gt;=7, Richard can always choose a X-omino which has a hole in the middle as shown in the figure above (a 7-omino in the left, and a 10-omino in the right). This means that it is impossible for Gabriel to win using that X-omino at least once, as it is impossible to fill the hole in the middle with another X-omino.\n</p>\n<p>\nTherefore in cases where X&gt;=7, Richard will always win.\n</p>\n<h3>Available cells is a multiple of X</h3>\n<p>\nAnother insight is the following: if R*C is not a multiple of X, then it is impossible for Gabriel to win. Why? The X-omino occupies X cells exactly, so if the total number of cells is not a multiple of X, it is impossible to cover all the cells using only X-ominoes. Therefore, in such cases, Richard will always win.\n</p>\n<p>\nIn fact, we can extend this principle. Let&#39;s imagine that we have already placed one X-omino in the RxC grid, and it results in the RxC grid being separated into two (or more) edge-connected regions. In the figure below, we use a 4-omino in a 2x6.\n</p>\n<pre>\n.##...\n##....\n</pre>\n<p>\nSince the sizes of the connected component (connected components can be found by using <a href=\"http://en.wikipedia.org/wiki/Flood_fill\" target=\"_blank\">flood fill</a>) of the blank areas represented as &#39;.&#39;  are 1 and 7, and 1 is too small to fit while 7 is not a multiple of X, then it is not possible for Gabriel to win that particular configuration. Therefore we can say that if we ever arrive in a grid configuration where any of the remaining connected components size is not a multiple of X then we can say that Richard will win that particular configuration. If a connected blank area of size M is a multiple of X, it can be guaranteed that there is a way to place M/X X-ominoes to fill in the blank area. It can be proven by using exhaustive case-by-case analysis which is described in the next section.\n</p>\n<p>\nNow, armed with the above knowledge, we proceed with describing a brute force solution. First, we describe a way to generate all possible X-ominoes. Then we describe the general brute force strategy to test if Richard can pick a X-omino that will guarantee him a win, and if he is unable to do so then Gabriel will win.\n</p>\n<h3>Generating all possible X-ominoes</h3>\n<p>\nTo generate all possible X-ominoes, we describe a recursive strategy. Let&#39;s start with a 1-omino. Well, for a 1-omino there is trivially only 1 possibility which is the following:\n</p>\n<pre>\n#\n</pre>\n<p>\nSimilarly, we can generate the configurations for a 2-omino as follows:\n</p>\n<pre>\n#   ##\n#\n</pre>\n<p>\nHow can we do this? We can build the X-ominoes recursively. We start with an empty board (let&#39;s say of size 20x20) then place a &#39;#&#39; in middle. Then we can recursively add a &#39;#&#39; adjacent to any of the existing &#39;#&#39; we have already placed, and stop when we have placed X &#39;#&#39; to create a X-omino. But you might have noticed that this recursive process will likely create a lot of duplicate X-omino configurations, e.g. in the 2-omino case, after placing the &#39;#&#39; in the middle, there are 4 possible placements of an adjacent &#39;#&#39; (labeled as 1-4 in the figure below).\n</p>\n<pre>\n.1.\n4#2\n.3.\n</pre>\n<p>\nThis means that this recursive procedure will generate four 2-ominoes! But we know that there are only two 2-ominoes, as &quot;4#&quot; and &quot;#2&quot; are equivalent, and likewise for &quot;1#&quot; and &quot;3#&quot;. Therefore, we can come up with a way to remove duplicate X-omino configurations if needed, which we leave as an exercise.\n</p>\n<p>\nWe can precompute all the X-ominoes for 1&lt;=X&lt;=6. Also note that when generating X-ominoes this way, we will generate all X-ominoes under reflection and rotations which we show with an example below:\n</p>\n<pre>\n#.  .#  .##  ##.\n##  ##  ##.  .##\n.#  #.\n</pre>\n<p>\nFor our solution, it is fine to generate all such X-ominoes. Note that it is also feasible to generate all possible X-ominoes for X&lt;=6 by hand. We cover this in the &quot;Alternative Solution&quot; section below.\n</p>\n<h3>Brute force strategy</h3>\n<p>\nNow, after we have generated all possible X-ominoes, we proceed with describing the brute force strategy. As mentioned earlier, if X&gt;=7, we report that Richard will win, and also if R*C is not a multiple of X, we report that Richard will win.\n</p>\n<p>\nIn the brute force strategy, we simulate Richard picking each of the X-ominoes one-by-one, then simulate if it is possible for Gabriel to win with that particular X-omino. If we can find any X-omino that Richard can pick which results in Gabriel being unable to win, then we report that Richard can win. But if Gabriel wins for all X-ominoes that Richard picks, then we report Gabriel as the winner.\n</p>\n<p>\nSimulating Richard picking a X-omino is straightforward. Richard can pick each of the X-omino one by one. The trickier part is to check if Gabriel can win, we now describe a strategy to perform this check.\n</p>\n<p>\nWe take the RxC grid and we have the X-omino that Richard has required that Gabriel use at least once. We can brute force the placement of this X-omino in the RxC grid (NOTE: We have to try the CxR grid too, we elaborate on the reasons to take the CxR grid in a subsequent paragraph). If it is impossible to place the X-omino (e.g. if the width of the X-omino is bigger than C) in either the RxC grid or the CxR grid then we trivially say that Richard wins for that particular X-omino. If it is possible to place the X-omino in a particular location, we still need to check whether it is possible for Gabriel to win. Let’s see some examples. Suppose that the X-omino Richard chose is the following.\n</p>\n<pre>\n.##\n##.\n</pre>\n<p>\nand we are given a 2x4 grid. In that case, we can place the X-omino in the following two configurations.\n</p>\n<pre>\n.##.\n##..\n</pre>\n<p>\nor\n</p>\n<pre>\n..##\n.##.\n</pre>\n<p>\nWe notice that in both configurations, the X-omino has divided the grid into two connected components of &#39;.&#39; of size 1 and 3. Well, we had mentioned earlier in the section &quot;Available cells is a multiple of X&quot; that such configurations imply Gabriel will always lose.\n</p>\n<p>\nIn fact, after placing a X-omino if it results in connected components of size M where all such M is a multiple of X, then we can say that Gabriel wins with that X-omino placed at that particular location.\n</p>\n<p>\nAs another example, if we use the following 4-omino:\n</p>\n<pre>\n##\n##\n</pre>\n<p>\nand we are given a 2x6 grid, and if we placed the 4-omino as follows:\n</p>\n<pre>\n.##...\n.##...\n</pre>\n<p>\nthen it is not possible for Gabriel to win (there are two connected regions of size 2 and 6, and 2 and 6 are not multiples of 4). But if we placed the 4-omino as follows:\n</p>\n<pre>\n##....\n##....\n</pre>\n<p>\nor \n</p>\n<pre>\n..##..\n..##..\n</pre>\n<p>\nThen in both configurations we say that Gabriel wins (in the first case, there is one connected component of size 8, and 8  is multiple of 4; in the second case, there are two connected components of size 4 each, and 4 is a multiple of 4).\n</p>\n<p>\nAs mentioned in an earlier paragraph, we try the CxR grid too. The reason is because we have to check for a 90 degree rotation of the X-omino that Richard selected. Remember, Gabriel can rotate or reflect the X-omino when initially placing it on the grid. Instead of rotating the X-omino, we can instead just rotate the grid! Therefore it suffices to check if we can fill a RxC grid, or a CxR grid with that X-omino. Note that we don&#39;t need to consider all possible reflections and rotations of the X-omino because because in grid space, things are symmetric therefore it suffices to check for both the RxC and CxR grid.\n</p>\n<p>\nTherefore to generalize it, after placing the selected X-omino at a particular place, we can check the sizes of the edge-connected &#39;.&#39; components, and if all such components have size M is a multiple of X, then it means that we can always fill the M space with M/X X-ominoes. In such a case, we say that that particular grid configuration is one for which Gabriel can win. An explanation of this winning condition for our brute force solution is based off the conclusion that we arrive at from the &quot;Alternative solution&quot; presented below.\n<p>\n<h3>Alternative solution</h3>\n<p>\nThe alternative solution involves careful analysis of various cases. Let <b>S</b> = min(R, C) and <b>L</b> = max(R, C) so that S&lt;=L. Suppose that the grid dimensions are SxL (if the dimensions are LxS, the grid can be rotated without affecting the win conditions).\n</p>\n<p>\nRichard can force a win if any of the following conditions hold; otherwise Gabriel will win.\n</p>\n<ol>\n    <li>X does not divide S*L,</li>\n    <li>X=3 and S=1,</li>\n    <li>X=4 and S&lt;=2,</li>\n    <li>X =5 and either (i) S&lt;=2 or (ii) (S, L) = (3, 5),</li>\n    <li>X=6 and S&lt;=3,</li>\n    <li>X&gt;=7.</li>\n</ol>\n<p>\nWe have already explained (1) and (6) in the previous paragraphs. For (2), (3), (4i), (4ii) and (5), Richard can choose the following pieces and always guarantee a win:\n</p>\n<p>\n(2)\n</p>\n<pre>\n#.\n##\n</pre>\n<p>\nIt is impossible for Gabriel to fit the above piece in a grid with S=1. Similar explanation follows for the following two cases.\n</p>\n<p>\n(3)\n</p>\n<pre>\n###\n.#.\n</pre>\n<p>\nFor the above piece, when the grid has S=2 notice that it will divide the &#39;.&#39; cells into two connected regions and that it is impossible for these regions to have a size which is a multiple of 4. It is impossible for Gabriel to fit the above piece in a grid with S=1.\n</p>\n<p>\n(4i)\n</p>\n<pre>\n#..\n##.\n.##\n</pre>\n<p>\nSimilar to the above cases, it is impossible for Gabriel to fit the above piece in a grid with S&lt;=2.\n</p>\n<p>\n(4ii) For this case, Richard can use the same piece as used in (4i). By trying all possibilities, one can see that it is impossible for Gabriel to win with X=5 and a 3x5 grid.\n</p>\n<pre>\n#....  .#...  ..#..\n##...  .##..  ..##.\n.##..  ..##.  ...##\n</pre>\n<p>\n(5)\n</p>\n<pre>\n.#..\n####\n.#..\n</pre>\n<p>\nA similar explanation follows for the above piece as the explanation for (3).\n</p>\n<p>\nFor all combinations of X, S and L not satisfied by the above condition, Gabriel will win. We provide here an explanation for the X=6 case, and leave the other cases as an exercise. Let&#39;s consider the 4x6 grid, which is the smallest grid for which S&gt;3 and S*L is a multiple of X. We show below Gabriel&#39;s strategy for filling the 4x6 grid, and then generalize for cases where the grid is bigger than 4x6.\n</p>\n<p>\nFirst off, we point out that for a 6-omino, there are only &lt;a href=\"http://en.wikipedia.org/wiki/Hexomino\" &gt;35 choices</a>. In fact, listed below are the number of choices for each X-omino:\n<ul>\n    <li>1-omino, 1 choice,</li>\n    <li>2-omino, 1 choice,</li>\n    <li>3-omino, 2 choices,</li>\n    <li>4-omino, <a href=\"http://en.wikipedia.org/wiki/Tetromino\" target=\"_blank\">5 choices</a>,</li>\n    <li>5-omino, <a href=\"http://en.wikipedia.org/wiki/Pentomino\" target=\"_blank\">12 choices</a>.</li>\n</ul>\n</p>\n<p>\nSince the 6-omino only has 35 choices, we list out below a case-by-case analysis of the 35 choices that Richard can make, and Gabriel&#39;s strategy for filling up the rest of the cells to guarantee a win for himself. &#39;#&#39; denotes the original piece that Richard chooses while &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; are 6-ominoes that Gabriel chooses.\n</p>\n<pre>\n######   a#####   a#####   a#####   ####cc   ##abbb   ##abbb\naaaaaa   aaaaa#   aaaa#c   abb#cc   aab##c   ##abbb   #aabbb\nbbbbbb   bbbbbb   abbbbc   aabbcc   aabbcc   #aaccc   ##accc\ncccccc   cccccc   bbcccc   aabbcc   aabbbc   #aaccc   #aaccc\n\n##abbb   #aabbb   ###bbb   #aaaaa   #aaaaa   aaa#bb   aa#bbb\n#aabbb   ##abbb   #aabbb   ###cca   ####ca   a####b   a####b\n#aaccc   ##accc   #aaccc   #ccccb   #ccccc   aacc#b   aaac#b\n##accc   #aaccc   #aaccc   #bbbbb   bbbbbb   ccccbb   cccccb\n\na#bbbb   aa#bbb   aa#bbb   a###bb   ###bbb   ###bbb   ###bbb\na####b   a####b   a####b   aaa##b   #a##bb   aa###b   a###bb\naacc#b   aaa#bb   aa#ccb   acc#bb   aaaccb   aacccb   aaaccb\naacccc   cccccc   accccb   accccb   aacccc   aacccb   aacccc\n\n###aaa   aaa#bb   aaa###   aa#bbb   ###bbb   ###bbb   aaaaaa\n###aaa   a###bb   aaab##   a###bb   aa#bbb   aa##bb   ###bbb\ncccbbb   aac##b   bbbb#c   aaa##b   aa##cc   aaa#cb   #c#bbb\ncccbbb   cccccb   bccccc   cccccc   aacccc   accccc   #ccccc\n\naaaaab   aabbbb   ##bbbb   aaaaaa   aaaaab   aaaabb   ##aaaa\n#a#cbb   a#b#bc   a###bb   #bbbbc   a#bbbb   aa#cbb   c##aab\n###cbb   a###cc   aaa#cc   ##bbcc   ###ccb   ###cbb   cc##bb\n#ccccb   aa#ccc   aacccc   ###ccc   ##cccc   ##cccc   cccbbb\n\n</pre>\n<p>\nWhew, that was a lot of cases! Clearly, Gabriel will always win with a 4x6 grid and any 6-omino that Richard chooses.\n</p>\n<p>\nWe now explore the case when the grid is bigger for X=6. Let&#39;s pick the 6x8 grid. To win in such cases, Gabriel can use the following strategy. Gabriel can use the top-left corner of the board to place the piece that Richard chooses so that he can complete a 4x6 portion similar to the manner described in the 35 cases above. Then Gabriel can label the remaining cells using a <a href=\"http://en.wikipedia.org/wiki/Hamiltonian_path\" target=\"_blank\">Hamiltonian path</a> (with cells as vertices, and adjacent cells as neighbors). &#39;Z&#39; denotes the 4x6 portion on the top-left corner of the grid, and the rest is filled with a sequence of &#39;a&#39;-&#39;x&#39; which denotes the Hamiltonian path. In this case, Gabriel can start the path from the top-right corner and &#39;snake&#39; back and forth. In general, depending on the parity of the number of rows of the &#39;Z&#39; region (let&#39;s call the number of these rows T), Gabriel can start from the top-right (when T is even), or from the cell adjacent to the top-right corner of the Z-region (when T is odd) then &#39;snake&#39; back and forth to fill the rest of the cells.\n</p>\n<pre>\nZZZZZZba\nZZZZZZcd\nZZZZZZfe\nZZZZZZgh\nponmlkji\nqrstuvwx\n</pre>\n<p>\nObserve that the cells &#39;a&#39;-&#39;x&#39; forms a chain. We can simply chop off this chain into sizes of 6 each (i.e. a 6-omino!). This way, Gabriel can win for X=6 and grids that are bigger than 4x6.\n</p>\n<p>\nSimilar to above, we can list out cases for the other X-ominoes, which we leave as an exercise.\n</p>\n\n<p>Here is a sample implementation in Python:\n\n<pre>\ndef richard_wins(X, R, C):\n  S = min(R, C)\n  L = max(R, C)\n  if (S * L) % X != 0: return True\n  if X == 3 and S == 1: return True\n  if X == 4 and S &lt;= 2: return True\n  if X == 5 and (S &lt;= 2 or (S, L) == (3, 5)): return True\n  if X == 6 and S &lt;= 3: return True\n  if X &gt;= 7: return True\n  return False\n\nfor tc in range(input()):\n  X, R, C = map(int, raw_input().split())\n  print \"Case #%d: %s\" % (tc + 1,\n    \"RICHARD\" if richard_wins(X, R, C) else \"GABRIEL\")\n</pre>","id":"0000000000433c83","statement":"<h3>Problem</h3>\n<p>\nAn <i>N</i>-omino is a two-dimensional shape formed by joining <i>N</i> unit cells fully along their edges in some way. More formally, a 1-omino is a 1x1 unit square, and an <i>N</i>-omino is an (<i>N</i>-1)omino with one or more of its edges joined to an adjacent 1x1 unit square. For the purpose of this problem, we consider two <i>N</i>-ominoes to be the same if one can be transformed into the other via reflection and/or rotation. For example, these are the five possible 4-ominoes:<br>\n<br>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U10HDqsNAOiogDRU4Erxkr0e-Sk-Y-61uihhTjaESzo6PuWZkrJ1f5y3QWvdQa51iGAb54gpFQ/4ominoes.png\"><br>\n<br>\nAnd here are some of the 108 possible 7-ominoes:<br>\n<br>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1ig7vFSJeJptrIy6-0NCnBeh__lVx17Adn9aHg9y1Gg6laqEgRoDGcFCCzB7s7ddMoIdNn0Z1z/7ominoes2.png\"><br>\n<br>\nRichard and Gabriel are going to play a game with the following rules, for some predetermined values of <b>X</b>, <b>R</b>, and <b>C</b>:<br>\n<br>\n1. Richard will choose any one of the possible <b>X</b>-ominoes.<br>\n2. Gabriel must use at least one copy of that <b>X</b>-omino, along with arbitrarily many copies of any <b>X</b>-ominoes (which can include the one Richard chose), to completely fill in an <nobr><b>R</b>-by-<b>C</b></nobr> grid, with no overlaps and no spillover. That is, every cell must be covered by exactly one of the <b>X</b> cells making up an <b>X</b>-omino, and no <b>X</b>-omino can extend outside the grid. Gabriel is allowed to rotate or reflect as many of the <b>X</b>-ominoes as he wants, including the one Richard chose. If Gabriel can completely fill in the grid, he wins; otherwise, Richard wins.<br>\n<br>\nGiven particular values <b>X</b>, <b>R</b>, and <b>C</b>, can Richard choose an <b>X</b>-omino that will ensure that he wins, or is Gabriel guaranteed to win no matter what Richard chooses?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> lines follow. Each contains three space-separated integers: <b>X</b>, <b>R</b>, and <b>C</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is either RICHARD (if there is at least one choice that ensures victory for Richard) or GABRIEL (if Gabriel will win no matter what Richard chooses).<br>\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n<b>T</b> = 64.<br/>\n1 &le; <b>X, R, C</b> &le; 4.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>X, R, C</b> &le; 20.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2 2 2\n2 1 3\n4 4 1\n3 2 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: GABRIEL\nCase #2: RICHARD\nCase #3: RICHARD\nCase #4: GABRIEL\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn case #1, Richard only has one 2-omino available to choose -- the 1x2 block formed by joining two unit cells together. No matter how Gabriel places this block in the 2x2 grid, he will leave a hole that can be exactly filled with another 1x2 block. So Gabriel wins.<br>\n<br>\nIn case #2, Richard has to choose the 1x2 block, but no matter where Gabriel puts it, he will be left with a single 1x1 hole that he cannot fill using only 2-ominoes. So Richard wins.<br>\n<br>\nIn case #3, one winning strategy for Richard is to choose the 2x2 square 4-omino. There is no way for Gabriel to fit that square into the 4x1 grid such that it is completely contained within the grid, so Richard wins.<br>\n<br>\nIn case #4, Richard can either pick the straight 3-omino or the L-shaped 3-omino. In either case, Gabriel can fit it into the grid and then use another copy of the same 3-omino to fill in the remaining hole.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":26}],"title":"Ominous Omino","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433515","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2015"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
