{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1565393400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000051708","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  The 2019 Finals presented a full complement of six challenges.\n  <i>Board Meeting</i> was our now-customary interactive Finals problem; it\n  was not as tough as\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000007766/000000000004da2d\">last year's</a>\n  , but it still required some careful thought about which board positions to\n  check. <i>Sorting Permutation Unit</i> presented another design challenge\n  &mdash; which permutations would work most efficiently and most generally?\n  &mdash; but in a non-interactive format. <i>Won't Sum? Must Now</i> entailed\n  building numbers out of a small number of palindromes, thanks to a\n  mathematically beautiful guarantee.\n</p><p>\n  Moving on to the back half of the set, the two Juggle Struggle problems were\n  a pair like the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051679/0000000000146183\">New Elements problems</a>\n  from this year's Round 2, and these two were even more closely related! Part\n  2 in particular featured a test set 1 that was quite straightforward, but\n  just getting below O(<b>N</b><sup>2</sup>) to O(<b>N</b> log <b>N</b>) proved\n  to be one of the toughest hurdles in this year's problem set! Finally,\n  <i>Go To Considered Helpful</i> required our contestants to find the shortest\n  program to get through a maze; it was not too hard to see that breadth-first\n  searches were needed, but the details were as treacherous as the obstacles\n  that our fish friend had to avoid.\n</p><p>\n  At first, our solvers fanned out and worked on different problems.\n  <b>ecnerwala</b> went right for the most valuable problem, and solved it just\n  over an hour into the contest. Other contestants chipped away at the\n  (relatively) easier 27-point problems. At the halfway point, every problem\n  except for Juggle Struggle: Part 2 had been fully solved by someone, but\n  the judges knew that only <b>ecnerwala</b> and <b>Radewoosh</b> had two full\n  solves; <b>xiaowuc1</b> had an impressive four test set 1 solves, but not\n  the 124 points displayed on the optimistic scoreboard.\n</p><p>\n  By the final hour, every problem had been solved (always a goal of the Code\n  Jam problem setters!), and several contestants vied fiercely for the top\n  triple-digit score, struggling with the age-old Code Jam dilemma: solve more\n  test set 1s to rack up potentially tiebreaking points, or go for a big step\n  with a test set 2? The lead changed several times, and by the end of the\n  contest, we had some huge numbetrs on the board, but how many of those test\n  set 2 solves were real?\n</p><p>\n  When the true results were laid bare, the various ultra-high scores melted\n  away, but there were some impressive results underneath! The judges' room\n  was hanging on every scoreboard change in the last 15 minutes. For a while,\n  it looked as if <b>Gennady.Korotkevich</b> didn't have enough time to solve\n  a full problem to reclaim the lead, but he pulled it off, sealing his win\n  with 143 points. <b>rng..58</b> and <b>ecnerwala</b> were behind by a test\n  set 2 (and time), at 121 points. <b>mnbvmar</b> took a close fourth with\n  118, and <b>Radewoosh</b> had the other triple-digit score at 103.\n</p><p>\n  Goodbye for now, San Francisco! That's one more Code Jam season in the books,\n  and we already can't wait for the next one! (And one more gold medal for\n  <b>Gennady.Korotkevich</b>!) Congratulations to all of our finalists and\n  T-shirt winners, and to everyone who had just the right flash of insight\n  needed to solve that tricky problem that had seemed intractable only a few\n  minutes earlier. We hope to see all of you &mdash; and more &mdash; back here\n  in 2020!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Sorting Permutation Unit: Written by Kevin Tran. Prepared by Jonathan Irvin\n  Gunawan and Trung Thanh Nguyen.\n</p><p>\n  Board Meeting: Written and prepared by Petr Mitrichev.\n</p><p>\n  Won't Sum? Must Now: Written by Igor Naverniouk. Prepared by Darcy Best, Igor\n  Naverniouk, and Ian Tullis.\n</p><p>\n  Go To Considered Helpful: Written by David Arthur. Prepared by John Dethridge.\n</p><p>\n  Juggle Struggle (Parts 1 & 2): Written by Pablo Heiber. Prepared by Timothy\n  Buzzelli and Pablo Heiber.\n</p><p>\n  Solutions and other problem preparation and review by Darcy Best, Timothy\n  Buzzelli, Shane Carr, John Dethridge, Natalia Giraud, Jonathan Irvin Gunawan,\n  Md Mahbubul Hasan, Yuta Kitamura, Petr Mitrichev, Igor Naverniouk, Trung Thanh\n  Nguyen, Ray Robinson, Pi-Hsun Shih, Kevin Wang, and Peter Whalan.\n</p>\n\n<p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Board Meeting: John Dethridge and Ian Tullis</li>\n  <li>Sorting Permutation Unit: John Dethridge, Jonathan Irvin Gunawan,\n    and Trung Thanh Nguyen</li>\n  <li>Won't Sum? Must Now: Darcy Best and Igor Naverniouk</li>\n  <li>Go To Considered Helpful: John Dethridge</li>\n  <li>Juggle Struggle (Parts 1 & 2): Pablo Heiber</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1565379000000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  In the first test set, there is only one king. There are various ways for us\n  to deduce its position; we will describe one that requires three queries and\n  is relatively easy to understand.\n</p><p>\n  First, we query (-1000000, 1000000), which is the upper left corner of the\n  board; let A<sub>1</sub> be the result. It tells us which J-shaped region\n  of the board the king is in, illustrated as follows starting from the upper\n  left corner:\n</p><p>\n  <pre>\n    0123...\n    1123\n    2223\n    3333\n    .   .\n    .    .\n    .     .\n  </pre>\n</p><p>\n  Next, if we did not happen to get lucky and find the king, we query\n  (-1000000 + A<sub>1</sub>, 1000000 - A<sub>1</sub>). That is, we query the\n  corner of that J-shaped region. Call the result A<sub>2</sub>; it tells us\n  how far away from the corner the king is, within that region. However, we do\n  not know whether the king is to the left of or above the corner.\n</p><p>\n  Finally, if we have still not found the king, we query\n  (-1000000 + A<sub>1</sub> - A<sub>2</sub>, 1000000 - A<sub>1</sub>). That is,\n  we guess that the king is to the left of the corner. If the result is 0, then\n  we have found the king; otherwise, we know the king is above the corner, at\n  (-1000000 + A<sub>1</sub>, 1000000 - A<sub>1</sub> + A<sub>2</sub>).\n</p>\n<h3>Test set 2</h3>\n<p>\n  With more than one king, we find that it is not possible to determine the\n  exact location of each king. For example, we cannot distinguish between a\n  case with kings at (+1, 0) and (-1, 0) and a case with kings at (0, +1) and\n  (0, -1). So it must be possible to answer queries with less complete\n  information about the kings' locations.\n</p><p>\n  The \"L<sup>&infin;</sup>\" metric in the problem, for which we take the\n  maximum of the absolute differences of two coordinates, is a little\n  inconvenient to work with directly, which results in the fairly ad-hoc\n  nature of the test set 1 solution above.\n</p><p>\n  Converting to diagonal coordinates makes things simpler.  If a point is at\n  (x, y) in the original coordinates, let (u, v) = (x + y, x - y) / 2 be its\n  diagonal coordinates. Then if the diagonal coordinates of two points are\n  (u1, v1) and (u2, v2), the distance between them is |u1 - v1| + |u2 - v2|. So\n  if the kings are located at diagonal coordinates (ui, vi) for i= 1, ..., N,\n  then the result of a query for the point (u, v) is\n  &Sigma;<sub>i</sub> (|u - ui| + |v - vi|) =\n  (&Sigma;<sub>i</sub> |u - ui|) + (&Sigma;<sub>i</sub> |v - vi|)\n</p><p>\n  We can handle these two sums separately.  To compute the first one, we need\n  to know which \"downright-sloping\" diagonal lines the kings lie on, and to\n  compute the second one, we need to know which \"upleft-sloping\" diagonal lines\n  the kings lie on.\n</p><p>\n  Now we need a method to compute these diagonals. Consider the point (-2M, 0).\n  This point is far enough to the left that, if we propose this point, the\n  total distance we get will be the sum of the differences in x coordinates.\n  If we propose (-2M, 1), we will get the same answer, unless there is a king at\n  (-M, -M), in which case we will get an answer one higher.\n</p><p>\n  More generally, for a positive integer K, let d(K) for a positive integer K\n  be the difference in the results of proposals of (-2M, K) and (-2M, K-1).\n  d(K) will be equal to the number of kings below the diagonal x + y = -2M + K.\n  We can use binary searches to find the places where d(k) changes value, and\n  the magnitudes of those changes, to find out which diagonals of the form\n  x + y = c contain kings, and how many they contain.\n</p><p>\n  Similarly, by proposing points (-2M, -K), we can find out how many kings lie\n  on the diagonals that go in the other direction. Once we have this data, we\n  are able to compute the sums above and respond to queries from the judge.\n</p>\n","id":"000000000016c77c","statement":"<h3>Problem</h3>\n<p>\n  <i>Note that it is not necessary to know anything about the rules of chess to\n    solve this problem.</i>\n</p>\n<p>\n  There are N kings on an infinite chessboard (two-dimensional grid), located\n  in cells with coordinates (X<sub>1</sub>, Y<sub>1</sub>),\n  (X<sub>2</sub>, Y<sub>2</sub>), ..., (X<sub>N</sub>, Y<sub>N</sub>). Both\n  N and the kings' coordinates are unknown to you. However, you do know the\n  following things:\n</p>\n<ul>\n  <li>N is at least 1 and at most <b>N<sub>max</sub></b>.</li>\n  <li>No king's coordinates (X or Y) have an absolute value exceeding\n    <b>M</b>.</li>\n  <li>The N kings are located in N different cells.</li>\n</ul>\n<p>\n  The kings want to meet in a single cell of the board. If some cell (X, Y)\n  were to be chosen as the meeting cell, then in order to get there, the i-th\n  king would use a number of moves equal to the maximum of the absolute values\n  of the differences of coordinates between its cell and the meeting cell:\n  max(|X-X<sub>i</sub>|,|Y-Y<sub>i</sub>|). The total number of moves used by\n  all kings is thus equal to the sum of those maximums over all values of i.\n  Note that it is not relevant to this problem exactly how the kings move on\n  the board &mdash; only the source and destination cells matter, and the\n  number of moves can always be computed using the above formula.\n</p><p>\n  This problem has two phases. In the first phase, you may repeatedly do the\n  following: propose a meeting location (A, B) (with each of A and B between\n  -10&times;<b>M</b> and 10&times;<b>M</b>, inclusive), and have the judge tell\n  you the total number of moves the kings would use to get there &mdash; the\n  sum (over all i) of max(|X<sub>i</sub>-A|,|Y<sub>i</sub>-B|). You can have at\n  most <b>R</b> such exchanges with the judge, choosing your values of A and\n  B each time. Note that the kings do not actually move, so their locations\n  (X<sub>i</sub>, Y<sub>i</sub>) stay the same for all requests within one test\n  case.\n</p><p>\n  In the second phase, the roles are swapped: the judge gives you a meeting\n  cell location (C, D) (with each of C and D between -10&times;<b>M</b> and\n  10&times;<b>M</b>, inclusive), and you must respond with the total number of\n  moves the kings would use to get there, assuming that the kings are in the\n  same locations as in the first phase. There are at most <b>R</b> such\n  exchanges, and you must correctly respond to all of the judge's requests.\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the\n  information in the Interactive Problems section of our\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\">FAQ</a>.\n</p>\n<p>\n  Initially, your program should read a single line containing four integers\n  <b>T</b>, <b>N<sub>max</sub></b>, <b>M</b> and <b>R</b>: the number of test\n  cases, the maximum number of kings, the maximum absolute value for any\n  coordinate for any king, and the maximum number of requests per phase,\n  respectively. (Note that the values of <b>M</b> and <b>R</b> are fixed,\n  and are provided as input only for convenience; see the Limits section for\n  more details.) Then, you need to process <b>T</b> test cases.\n</p><p>\n  In each test case, there are two phases. In the first phase, the i-th exchange\n  is as follows:\n</p>\n<ul>\n  <li>Your program sends one line containing two integers A<sub>i</sub> and\n    B<sub>i</sub>, representing the x and y coordinates of a cell.\n    <ul>\n      <li>Both A<sub>i</sub> and B<sub>i</sub> must be between\n        -10&times;<b>M</b> and 10&times;<b>M</b>, inclusive.</li>\n    </ul>\n  </li>\n  <li>The judge responds with one line containing a single integer: the total\n    number of moves the kings need to use to get from their unknown locations to\n    your cell.</li>\n</ul>\n<p>\n  You may initiate at most <b>R</b> such exchanges in this phase. If you make\n  more than <b>R</b> exchanges, or send a request that the judge can not parse\n  or is out of bounds, the judge responds with one line with a single string\n  <code>ERROR</code>.\n</p><p>\n  To end the first phase and switch to the second phase, you must send one line\n  with the string <code>READY</code> (the case does not matter), to which the\n  judge responds with the first request of the second phase.\n</p><p>\n  In the second phase, the i-th exchange is as follows:\n</p>\n<ul>\n  <li>The judge sends one line containing two integers <b>C<sub>i</sub></b> and\n    <b>D<sub>i</sub></b>, representing the x and y coordinates of a cell.\n    <ul>\n      <li>Each of C<sub>i</sub> and D<sub>i</sub> will be between\n        -10&times;<b>M</b> and 10&times;<b>M</b>, inclusive.</li>\n    </ul>\n  </li>\n  <li>Your program must respond with one line containing a single integer: the\n    total number of moves the kings would need to use to get to the given\n    cell.</li>\n</ul>\n<p>\n  The judge is guaranteed to send at least 1 and at most <b>R</b> such\n  requests. If you send an answer that is incorrect or unparseable, the judge\n  responds with <code>ERROR</code> as described above. If you answer all of the\n  requests correctly, the judge sends one line with a single string\n  <code>DONE</code>, at which point your program should initiate the next\n  test case, or terminate with no error if all <b>T</b> test cases have been\n  handled.\n</p><p>\n  After the judge sends a line with <code>ERROR</code>, it does not send any\n  other output. If your program continues to wait for the judge after receiving\n  <code>ERROR</code>, your program will time out, resulting in a Time Limit\n  Exceeded error. Notice that it is your responsibility to have your program\n  exit in time to receive a Wrong Answer judgment instead of a Time Limit\n  Exceeded error. As usual, if the memory limit is exceeded, or your program\n  gets a runtime error, you will receive the appropriate judgment.\n</p><p>\n  The number and location of the kings, as well as the number and positions of\n  the requests that the judge sends during the second phases, are chosen before\n  any exchanges occur.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 60 seconds per test set.<br/>\n  <i>Note that a program that just makes valid exchanges with the judge (and\n    does no other processing) takes the following time in our environment:\n    ~13 seconds for C++, ~24 seconds for Java, ~19 seconds\n    for Python and Go.</i><br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 15.<br/>\n  <b>M</b> = 10<sup>6</sup>.<br/>\n  -<b>M</b> &le; X<sub>i</sub> &le; <b>M</b>, for all i.<br/>\n  -<b>M</b> &le; Y<sub>i</sub> &le; <b>M</b>, for all i.<br/>\n  The pairs (X<sub>i</sub>, Y<sub>i</sub>) are distinct.<br/>\n  -10&times;<b>M</b> &le; <b>C<sub>i</sub></b> &le; 10&times;<b>M</b>,\n    for all i.<br/>\n  -10&times;<b>M</b> &le; <b>D<sub>i</sub></b> &le; 10&times;<b>M</b>,\n    for all i.<br/>\n  <b>R</b> = 1000.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>N<sub>max</sub></b> = 1.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>N<sub>max</sub></b> = 10.<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1J9p8AXfKXrFGBjyJNAMZClkZs4d9-oOBf5r2Ui1y5xmJygW26Ew2BmDEJJzCKP-0Xiyia9y8T93e3JlH2/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n<p>\n  Note that the following sample interaction is for test set 1, in which there\n  is always exactly one king.\n</p>\n<pre>\n  // Suppose that the judge has decided that in the first test case, the king\n  // is at the coordinates (1, -2), and the requests will be (5, -1) and\n  // (7, 7).\n  t, nmax, m, r = readline_int_list()   // Reads 10 1 1000000 1000\n  // Our solution decides (for whatever reason) to check (3, 3) first.\n  printline 3 3 to stdout\n  flush stdout\n  result = readline_int()               // Reads 5\n  // Our solution now decides (for whatever reason) to check (2, 0).\n  printline 2 0 to stdout\n  flush stdout\n  result = readline_int()               // Reads 2\n  // Our solution concludes that the king is at (3, -2), which is consistent\n  // with the observed information so far, but unfortunately not correct.\n  // Our solution moves on to the request phase.\n  printline READY to stdout\n  request_line = readline()             // Reads 5 -1\n  printline 2 to stdout                 // Wrong answer!\n  request_line = readline()             // Reads ERROR\n  exit                                  // exits to avoid an ambiguous TLE error\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Board Meeting","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<h3>A rotation-based solution</h3>\n\n<p>\n  For simplicity, let's assume that none of the arrays we want to sort contain\n  any repeated entries. If there are repeatred entries, we can arbitrarily\n  choose a correct sorted order for them.\n</p><p>\n  To illustrate the sorting algorithm, let's first ignore the constraint on\n  the number of permutations, and use <b>N</b>-1 permutations: the i-th\n  permutation (1 &le; i &le; <b>N</b>-1) swaps the i-th element with the\n  <b>N</b>-th element.\n</p>\n\n<p>\n  For example, when <b>N</b> = 5, we use the following 4 permutations:\n  <ul>\n    <li><u>5</u> 2 3 4 <u>1</u></li>\n    <li>1 <u>5</u> 3 4 <u>2</u></li>\n    <li>1 2 <u>5</u> 4 <u>3</u></li>\n    <li>1 2 3 <u>5</u> <u>4</u></li>\n  </ul>\n</p>\n\n<p>\n  With this setup, we can use the <b>N</b>-th element as a \"buffer\" to sort\n  the first <b>N</b>-1 elements. The algorithm is as follows:\n  <ol>\n    <li>\n      If the element at position <b>N</b> is not the largest one, swap it to\n      the correct position.\n    </li>\n    <li>\n      Otherwise, there are 2 cases:\n      <ul>\n        <li>The array is sorted, and we are done.</li>\n        <li>The array is not sorted, so we swap the <b>N</b>-th element with\n          any element that is at an incorrect position (so that we can\n          continue using it as buffer).</li>\n      </ul>\n    </li>\n    <li>Repeat from step 1.</li>\n  </ol>\n</p>\n\n<p>\n  For example, let's consider the array [30, 50, 40, 10, 20]. We can:\n  <ul>\n    <li>Swap 20 to the correct position: [30, 20, 40, 10, 50].</li>\n    <li>\n      Now 50 is at the last position, but the array is not sorted, so we swap\n      it with any element that is at an incorrect position, for instance, 30:\n      [50, 20, 40, 10, 30].\n    </li>\n    <li>Swap 30 to the correct position: [50, 20, 30, 10, 40].</li>\n    <li>Swap 40 to the correct position: [50, 20, 30, 40, 10].</li>\n    <li>Swap 10 to the correct position: [10, 20, 30, 40, 50].</li>\n    <li>The array is now sorted.</li>\n  </ul>\n</p>\n\n<p>\n  Note that this solution uses <b>N</b>-1 permutations and 1.5<b>N</b>\n  operations:\n  <ul>\n    <li><b>N</b> operations to swap <b>N</b> elements to their correct positions,</li>\n    <li>\n      At most <b>N</b>/2 to swap the <b>N</b>-th element in case it is the largest. This is because\n      after we swap the largest element with an element at the wrong position, we won't need to do\n      so again on the next step.\n    </li>\n  </ul>\n</p>\n\n<h3>Reducing the number of permutations</h3>\n\n<p>\n  To fit within the limit on the number of allowed permutations, we can\n  instead use the following 5 operations:\n  <ul>\n    <li>One permutation that swaps elements <b>N</b>-1 and <b>N</b> &mdash;\n      the next-to-last and last elements.</li>\n    <li>\n      4 permutations that rotate each of the elements from 1 to <b>N</b>-1 by\n      1, 3, 9 and 27, respectively. (Notice that element <b>N</b> remains the\n      same.)\n    </li>\n  </ul>\n\n  With these 4 permutations, when <b>N</b> &le; 50, we can rotate the first\n  <b>N</b>-1 elements by any amount (from 1 to <b>N</b>-2) in at most 6\n  operations. For example, to rotate by 26 = 9 + 9 + 3 + 3 + 1 + 1, we\n  rotate by 9 two times, rotate by 3 two times, and then rotate by 1 two\n  times. To rotate by 47, we use 27 + 9 + 9 + 1 + 1. (Equivalently, we can\n  express any number less than 50 using a base three string with trinary\n  digits summing to 6 or less. The smallest number that would take 7 or\n  more is 53.)\n</p><p>\n  Our new algorithm is similar to the one above.\n  <ol>\n    <li>\n      If the element E at position <b>N</b> is not the largest one, swap it to\n      the correct position as follows:\n      <ul>\n        <li>Apply rotations to the first <b>N</b>-1 elements until the\n          (<b>N</b>-1)-th position is the slot where E should go.</li>\n        <li>Swap the (<b>N</b>-1)-th and <b>N</b>th positions, moving E\n          into place (and some other element into the <b>N</b>-th position.)\n        </li>\n      </ul>\n    </li>\n    <li>\n      Otherwise, E is the largest element. We need to temporarily move it out\n      of the <b>N</b>-th position. We can swap in some element that is not\n      already in its correct relative position among the first <b>N</b>-1\n      positions. We can use the same strategy as above to rotate to that\n      element. If there is more than one element in the wrong relative position,\n      we choose the element such that the amount we need to rotate to get it in\n      place is minimized.\n    </li>\n    <li>\n      We repeat the above until all of the elements in the first <b>N</b>-1\n      positions are in the correct relative order. Then, we may need to do some\n      final rotations to put them in the correct absolute positions.\n    </li>\n  </ol>\n</p><p>\n  For example, let's consider the array [30, 50, 40, 10, 20]. We will use 3 permutations:\n  <ul>\n    <li>Swap the last 2 elements: 1 2 3 <u>5</u> <u>4</u></li>\n    <li>Rotate the first <b>N</b>-1 elements by 1: 4 1 2 3 5</li>\n    <li>Rotate the first <b>N</b>-1 elements by 3: 2 3 4 1 5</li>\n  </ul>\n</p><p>\n  The algorithm works as follows:\n  <ul>\n    <li>\n      We first want to swap 20 to the relative position after 10:\n      <ul>\n        <li>Rotate the first <b>N</b>-1 elements by 3: [50, 40, 10, 30, 20]</li>\n        <li>Swap the last 2 elements: [50, 40, 10, 20, 30]</li>\n      </ul>\n    </li>\n    <li>\n      Now we want to swap 30 to the relative position after 20:\n      <ul>\n        <li>Rotate the first <b>N</b>-1 elements by 3: [40, 10, 20, 50, 30]</li>\n        <li>Swap the last 2 elements: [40, 10, 20, 30, 50]</li>\n      </ul>\n    </li>\n    <li>\n      The largest element, 50, is now at the last position. We need to swap it with some element\n      at the wrong position. In this case, there is exactly one such element: 40.\n      <ul>\n        <li>Rotate the first <b>N</b>-1 elements by 3: [10, 20, 30, 40, 50]</li>\n        <li>Swap the last 2 elements: [10, 20, 30, 50, 40]</li>\n      </ul>\n    </li>\n    <li>\n      Finally, we want to move 40 to its correct position:\n      <ul>\n        <li>Swap the last 2 elements: [10, 20, 30, 40, 50].</li>\n      </ul>\n    </li>\n</ul>\n</p><p>\n  The number of operations we use are:\n  <ul>\n    <li>1.5<b>N</b> operations for swapping (as shown in our first algorithm)</li>\n    <li>\n      6<b>N</b> operations for rotating the first <b>N</b>-1 elements, to swap them to correct\n      relative positions.\n    </li>\n    <li>\n      For the case where the largest element is at the <b>N</b>-th position, we\n      need an addition of <b>N</b> operations for rotating. This is because we\n      always rotate the minimum amount, after which the first step will rotate\n      the array until it's back at the same relative position. So in total,\n      the rotations in this step will rotate the array at most one full cycle.\n    </li>\n  </ul>\n  Thus we are using total of 8.5<b>N</b> = 425 operations.\n</p>\n<h3>An even tighter solution</h3>\n<p>\n  For each <b>N</b> &le; 50, there also exists a set of 4 rotations\n  that allows us to rotate the first <b>N</b>-1 elements by any amount\n  (from 1 to <b>N</b>-2) in at most 4 operations, making use of the fact that\n  rotating by <b>k</b> is the same as rotating by <b>k+N-1</b>.\n  As an example, for <b>N</b> = 50, {1, 3, 12, 20} is one such set.\n</p><p>\n  This yields a solution that uses just 325 operations in the worst case.\n</p>\n\n<h3>A randomized variant</h3>\n\n<p>\n  In an alternative solution, instead of four rotations of the other=\n  <b>N</b>-1 elements, we have four random involutions which swap randomly\n  selected pairs of the <b>N</b>-1 elements.\n</p><p>\n  Now we use the same algorithm as in the rotation solution, but instead of\n  rotating elements into place, we use a sequence of the random permutations\n  to move the right element to where it can be swapped with the buffer, and\n  then apply the sequence in reverse to move everything back to where it was.\n</p><p>\n  (We can use a breadth-first search to find the shortest sequence to move any\n  given element into place.)\n</p><p>\n  This process may result in a set of permutations that can't solve the input\n  or can't solve it in few enough permutations, but we can simply retry by\n  choosing a new set of random involutions, as getting a solution with under\n  450 permutations is highly likely.\n</p>\n","id":"000000000016c77d","statement":"<h3>Problem</h3>\n<p>\n  You may have heard of Google's Tensor Processing Units, which are used to\n  build neural networks. However, there is one research area that is even\n  deeper and more important than machine learning: sorting!\n</p><p>\n  We are working on a special new chip called the Sorting Permutation Unit,\n  which is very fast at applying permutations to arrays of integers. Formally,\n  a permutation is an ordering of the first n positive integers\n</p><p>\n  p<sub>1</sub>, p<sub>2</sub>, ..., p<sub>n</sub>\n</p><p>\n  and applying it to an array of n integers\n</p><p>\n  a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>\n</p><p>\n  yields the new array\n</p><p>\n  a<sub>p<sub>1</sub></sub>, a<sub>p<sub>2</sub></sub>, ...,\n  a<sub>p<sub>n</sub></sub>.\n</p><p>\n  For example, applying the permutation 3, 1, 2, 4 to the array\n  99, 234, 45, 800 would yield the new array 45, 99, 234, 800.\n</p><p>\n  However, permutations are expensive to represent in the hardware, so the unit\n  can only have access to at most <b>P</b> distinct permutations. We need your\n  help figuring out what those permutations should be!\n</p><p>\n  Given <b>K</b> arrays of <b>N</b> integers each, you must first specify up to\n  <b>P</b> permutations (of size <b>N</b>) of your choice. Then, for each of\n  those <b>K</b> input arrays, you must provide one sequence of up to <b>S</b>\n  instructions (each of which is a permutation from your specified set). When\n  the instructions in this sequence are applied, in the given order, to the\n  array, they must yield an array sorted in nondecreasing order. In each of\n  your <b>K</b> sequences of instructions, you may use each of your <b>P</b>\n  permutations zero or more times (not necessarily consecutively).\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with four integers\n  <b>P</b>, <b>S</b>, <b>K</b>, and <b>N</b>: the maximum number of\n  permutations allowed, the maximum number of instructions you are allowed to\n  use to sort each array, the number of arrays, and the number of integers in\n  each array. Then, there are <b>K</b> more lines of <b>N</b> integers\n  <b>A<sub>i1</sub></b>, <b>A<sub>i2</sub></b>, .., <b>A<sub>iN</sub></b>\n  each, where the j-th integer on the i-th line, <b>A<sub>ij</sub></b>,\n  represents the j-th value of the i-th array.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, first output the following, in this order:\n</p>\n<ul>\n  <li>One line containing <code>Case #x:</code>, where <code>x</code> is the\n    test case number (starting from 1).</li>\n  <li>One line containing one integer P', where 1 &le; P' &le; <b>P</b>: the\n    number of permutations you have chosen to use.</li>\n  <li>P' lines, the i-th of which contains <b>N</b> integers\n    p<sub>i1</sub> p<sub>i2</sub> ... p<sub>i<b>N</b></sub>, where\n    <code>p<sub>ij</sub></code> is the j-th element of the i-th\n    permutation.</li>\n</ul>\n<p>\n  Then, output <b>K</b> more lines. The i-th of these gives the instructions\n  that you will apply to the i-th array given in the input. Each such line\n  must begin with one integer S', where 0 &le; S' &le; <b>S</b>, and must\n  continue with S' integers X<sub>1</sub>, X<sub>2</sub>, ...,\n  X<sub>S'</sub>, where 1 &le; X<sub>k</sub> &le; P' for all k.\n  Here, X<sub>k</sub> represents that the k-th instruction you apply to the\n  i-th array is the X<sub>k</sub>-th permutation (counting starting from 1) in\n  your list of permutations. These instructions must yield an array with\n  the elements of the i-th input array, sorted in nondecreasing order.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 10.<br/>\n  <b>S</b> = 450.<br/>\n  1 &le; <b>K</b> &le; 30.<br/>\n  2 &le; <b>N</b> &le; 50.<br/>\n  1 &le; <b>A<sub>ij</sub></b> &le; 1000, for all i and j.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>P</b> = 20.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>P</b> = 5.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n20 450 4 3\n10 10 11\n17 4 1000\n999 998 997\n10 10 11\n20 450 5 5\n1 2 3 4 5\n2 3 4 5 1\n3 4 5 1 2\n4 5 1 2 3\n5 1 2 3 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n2\n3 1 2\n2 1 3\n0\n1 2\n2 2 1\n1 2\nCase #2:\n1\n5 1 2 3 4\n0\n1 1\n2 1 1\n3 1 1 1\n4 1 1 1 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, we can define up to <b>P</b> = 20 permutations. One\n  viable strategy uses only these two:\n</p>\n<ol>\n  <li>3 1 2</li>\n  <li>2 1 3</li>\n</ol>\n<p>\n  We can handle the four arrays as follows:\n</p>\n<ul>\n  <li><code>10 10 11</code>: This is already sorted in nondecreasing order, so\n    we do not need to do anything.</li>\n  <li><code>17 4 1000</code>: We can apply permutation #2 to yield\n    4 17 1000.</li>\n  <li><code>999 998 997</code>: One option is to first apply permutation #2 to\n    turn the array into 998 999 997, then apply permutation #1 to turn the array\n    into 997 998 999.</li>\n  <li><code>10 10 11</code>: This is the same as the first array. Applying\n    permutation #2 also yields array sorted in nondecreasing order. (But we\n    could have used the line <code>0</code> as we did before.)</li>\n</ul>\n<p>\n  In Sample Case #2, notice that we can use the same permutation instruction\n  more than once on the same array, if desired.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Sorting Permutation Unit","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  The fact that we never need more than 3 palindromes is not obvious,\n  and it was proved in\n  <a href=\"https://arxiv.org/abs/1602.06208\">a long, complicated paper</a>.\n  Numberphile made a\n  <a href=\"https://www.youtube.com/watch?v=OKhacWQ2fCs\">video</a>\n  that explains the basics of the paper's argument. Knowing this upper bound\n  is useful, but is not necessary to solve the problem.\n</p><p>\n  Even if we haven't read every paper on arXiv for fun, we might also\n  reasonably guess that the number of palindromes required is unlikely to be\n  large because there are approximately sqrt(<b>S</b>) palindromes smaller\n  than <b>S</b>, which means that there are approximately <b>S</b> palindrome\n  pairs, which should result in &Theta;(<b>S</b>) numbers smaller than\n  <b>S</b> that should be representable as sums of palindrome pairs. The number\n  of triples is larger by another factor of sqrt(<b>S</b>), and their sums are\n  all smaller than 3<b>S</b>, which does not leave much space to hide a number\n  that could not be represented by a triple of palindromes, unless many triples\n  add up to the same number.\n</p><p>\n  The first step is to check if <b>S</b> is itself a palindrome. If it is a\n  palindrome, then we are done. In the remaining explanation, we will assume\n  that <b>S</b> is not a palindrome. Checking if a number is a palindrome takes\n  O(log <b>S</b>) steps, one step per digit.\n</p>\n\n<h2>Test set 1</h2>\n<p>\n  Key insight: There are only roughly 2 &times; 10<sup>5</sup> palindromic\n  terms up to 10<sup>10</sup>. In the analysis below, we will call this\n  number P.\n</p><h3>\n  Sum of 2 palindromes?\n</h3><p>\n  To check if <b>S</b> is the sum of 2 palindromes, we simply loop through all\n  palindromes, p, less than <b>S</b> and check if <b>S</b>-p is a palindrome.\n  This takes O(P &times; log <b>S</b>) steps.\n</p><h3>\n  Sum of 3 palindromes!\n</h3><p>\n  We were told that every number is the sum of 3 palindromes, so we must find\n  such a sum! On first glance, it seems that doing the same as above for 3\n  palindromes\n  is too slow since there are O(P<sup>2</sup>) pairs of palindromes to check.\n  However, for all numbers up to 10<sup>10</sup>, one of the 3 palindromic\n  terms is always at most 404 (which is needed for 1086412253, for example).\n  Thus, as long as we search the pairs of palindromes in a way that searches\n  triples containing a small value first, we will be fine.\n</p>\n\n<h2>Test set 2</h2>\n<p>\n  Unfortunately, there are as many as 2 &times; 10<sup>20</sup> palindromes\n  less than 10<sup>40</sup>, so it is hopeless to even iterate through the\n  palindromes. Something quicker will be needed.\n</p><h3>\n  <b>S</b> = X + Y?\n</h3><p>\n  We will assume X &ge; Y. The first step is to fix the numbers of digits\n  in X and Y. Note that the number of digits in X must be either (1) the\n  number of digits in <b>S</b> or (2) one less than the number of digits in\n  <b>S</b> (otherwise, X + Y &lt; <b>S</b>).\n</p><p>\n  Let's assume that X and Y have a different number of digits (we will deal\n  with the same-number-of-digits case below). The trickiest part about this\n  problem is dealing with the pesky carries that occur while adding. For\n  example, if we want to find 2 palindromes that add up to 2718281828 with\n  lengths 10 and 8, then the first digit of X can be either 1 or 2 (depending\n  whether there is a carry on the most significant digit). Because we don't\n  know, let's try both! First, let's assume that we do not need a carry (so\n  the first digit of X is 2). This also means that we can determine the least\n  significant digit of Y by considering the sum modulo 10 (which also fills in\n  the most significant digit of Y since it is a palindrome).\n</p>\n<pre>\n  ..........        2........2        2........2\n+   ........  ->  +   ........  ->  +   6......6\n============      ============      ============\n  2718281828        2718281828        2718281828\n</pre>\n<p>\n  At this point, to fill in the remaining unknown digits, we need a 9 digit\n  palindrome and a 7 digit palindrome that sum to\n  2718281828 - (2000000002 + 60000006) = 658281820. This is a subproblem and\n  we may recurse (with leading zeroes now allowed). The other option is that\n  there is a carry on the most significant digit. In this case, the first digit\n  of X must be 1.\n</p><p>\n  When the numbers of digits in X and Y are different, there is always at least\n  one unknown digit that we can determine. However, if X and Y have the same\n  number of digits, this is not necessarily true. However, we can combine two\n  simple observations to determine viable options for the first (and last)\n  digits of both numbers. First, we consider the sums modulo 10. This narrows\n  the possible values we may choose. Second, the number of digits in <b>S</b>\n  compared to the number of digits in X (and Y) tells us if we want the sum of\n  the most significant digits to be at least 10 (causing a carry). For example,\n  if <b>S</b> has 5 digits, while X and Y only have 4 digits, then we must\n  provide a carry in order for this sum to work. Similarly, if the number of\n  digits in <b>S</b> and X are equal, then we cannot have a carry, so the sum\n  must be at most 9. Even after these constraints, we still have some options\n  (for example, if we need a sum of 8, we can use 0+8, 1+7, ... , 7+1, 8+0).\n  Note that it doesn't matter<sup>*</sup> which of these options we take, since\n  the only way they interact with other digits is with the carry.\n</p><p>\n  <sup>*</sup> - There is one case where it matters: we must avoid creating a\n  leading zero in a number.\n</p><p>\n  Let D be the number of digits in <b>S</b>. There are O(D) possible lengths\n  for X and Y. For each pair of lengths, we must decide if there is a carry on\n  each digit on the left-hand side of <b>S</b>. Depending on implementation,\n  this is O(2<sup>D/2</sup> &times; D) operations. This leads to a total of\n  O(2<sup>D/2</sup> &times; D<sup>2</sup>) operations. Note that instead of\n  just computing one digit at a time, we can determine the whole \"overhang\"\n  values. In the example above, we can determine that the first two digits are\n  either 26 or 27:\n</p>\n<pre>\n  ..........        27......72        27......72\n+   ........  ->  +   ........  ->  +   65....56\n============      ============      ============\n  2718281828        2718281828        2718281828\n</pre>\n<p>\n  This means that we only need to make D/overhang choices for the carries\n  instead of D/2 choices. Thus, when the overhang is large, those computations\n  do not contribute heavily to the complexity. This reduces the total\n  complexity to O(2<sup>D/2</sup> &times; D) operations.\n</p><h3>\n  Sum of 3 palindromes\n</h3><p>\n  In the paper listed above, the authors describe an algorithm to write any\n  number as the sum of 3 palindromes is described. This was obviously not\n  needed to solve this problem, but it does require an algorithm to find the\n  sum of three palindromes.\n</p><p>\n  To solve this problem, we will use the fact that there are\n  O(<b>S</b> sqrt(<b>S</b>)) triples of palindromes less than <b>S</b>, which\n  means that each number can be written with an average of O(sqrt(<b>S</b>))\n  different triples. This allows us to randomly select palindromes as one of\n  our three values, then use the algorithm above to check whether the remaining\n  value can be wrritten as the sum of 2 palindromes.\n</p><p>\n  It is possible that there is a number that can only be represented in one\n  different way as a sum of three palindromes, but we were unable to find any\n  case that was not the sum of triples in many different ways. In fact, we were\n  unable to find an input number such that one of the three numbers was more\n  than 10801 (though, we expect that many such cases exist).\n</p>\n","id":"000000000016c77e","statement":"<h3>Problem</h3>\n<p>\n  In 2016, it was shown that every positive integer can be written as the sum\n  of three or fewer palindromic terms. For the purposes of this problem, a\n  palindromic term is a string of digits (with no leading zeroes) that\n  represents a positive integer and reads the same forward and backward.\n</p><p>\n  Given a positive integer <b>S</b>, find K palindromic terms that sum to\n  <b>S</b>, such that K is minimized.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of test cases, <b>T</b>.\n  <b>T</b> lines follow, each containing a positive integer <b>S</b>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line of the form\n  <code>Case #x: A<sub>1</sub></code> (if only one term is needed),\n  <code>Case #x: A<sub>1</sub> A<sub>2</sub></code>\n  (if only two terms are needed), or\n  <code>Case #x: A<sub>1</sub> A<sub>2</sub> A<sub>3</sub></code>\n  (if three terms are needed), where\n  <code>x</code> is the case number (counting starting from 1), each\n  A<sub>i</sub> is a palindromic term (as described above), and the sum of the\n  A<sub>i</sub>s equals <b>S</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>S</b> &le; 10<sup>10</sup>.\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>S</b> &le; 10<sup>40</sup>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1\n198\n1234567890\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 191 7\nCase #3: 672787276 94449 561686165\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the input is already a palindrome.\n</p><p>\n  In Sample Case #2, note that <code>99 99</code>, for example, would also be\n  an acceptable answer. Even though there are multiple instances of\n  <code>99</code>, they count as separate terms, so this solution uses the same\n  number of terms as <code>191 7</code>.\n</p><p>\n  Also note that <code>191 07</code>, <code>181 8 9</code>,\n  <code>0110 88</code>, <code>101 97</code>, <code>7.0 191.0</code>,\n  and <code>-202 4</code>, for example, would not be acceptable answers.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Won't sum? Must now","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1 (Visible)</h3>\n<p>\nWe are given a set of 2<b>N</b> points that we are to pair into <b>N</b> line segments\nsuch that they all intersect each other. That makes the set of line segments magnificent.\n</p><p>\nWe can extend any line segment S into a full line L that divides the plane in two.\nIn a magnificent set of line segments, since S intersects all other segments, all those other\nsegments have one endpoint on each side of L (no other point can be on L or it would be collinear\nwith the endpoints of S). This means that if we pick a point P in the input, it\nmust be paired with another point Q such that the line that goes through both leaves exactly the\nsame number of other points on each side. This hints at an algorithm: choose a point P, find a Q\naccording to the definition above, pair P and Q, and repeat. However, what if there is more than\none such Q?\n</p><p>\nOne way to deal with the problem is by choosing P intelligently. For example, if we choose a\nleftmost point as P, all candidates for Q end up in the right half of the plane cut by a vertical\nline through P (with at most one other point possibly on the line). Consider a line rotating\nclockwise centered on P, going from vertical to vertical again (rotating 180 degrees).\nAt the starting point, there are no points on the left side of the line, because P is leftmost.\nAs it rotates, it will pass over all points, repeatedly adding one point to one side and removing\none from the other.\nSince there are no collinear triples of points, this shift is always by 1. This means there is\nexactly one such line that has P and one more point on it, with <b>N</b>-1 points on each side.\nMoreover, if we sort all non-P points by the angle they form with P (choosing 0 to coincide\nwith the vertical line), the point that ends up on the line is exactly the median of the sorted\nlist.\n</p><p>\nChoosing P as a leftmost point gives a unique choice of another point Q to pair P with.\nWe can then remove both and continue. The algorithm requires <b>N</b> iterations, and in each of\nthem we must find a leftmost point, and sort\n  O(<b>N</b>) points by angle. Calculating the\n<a href=\"https://en.wikipedia.org/wiki/Angle#Dot_product_and_generalisations\">cosine</a> of the\nangles to compare without loss precision takes constant time.\nPicking the median and removing the pair of points all can be done in O(<b>N</b>) time or better.\nTherefore, the overall algorithm\nrequires O(<b>N</b><sup>2</sup> log <b>N</b>) time, and it is enough to solve Test Set 1.\nIf one uses a <a href=\"https://en.wikipedia.org/wiki/Median_of_medians\">linear algorithm to find\nthe median</a> instead of sorting, it would improve the time complexity to O(<b>N</b><sup>2</sup>).\nHowever, sorting to find the median is likely to be faster in practice due to constant factors.\n</p><p>\nA consequence of the reasoning above is that the solution is actually unique. Another observation\nis that any point in the convex hull of the points has the same property as a leftmost point,\nbecause the definition is invariant through rotations and any point in the convex hull can be made\na leftmost point through a rotation. But a leftmost is one of the easiest to find.\n</p>\n<h3>Test Set 2 (Hidden)</h3>\n<p>\nThere is another approach requiring an additional proof but leading to a slightly simpler\nalgorithm for Test Set 1. Most importantly, it leads us one step closer to solving Test Set 2.\n</p><p>\nThe additional key observation for this approach is\nthat if a set of 2<b>N</b> points admits a magnificent pairing, then for <i>every</i>\npoint P in the set (not just those in the convex hull) there is exactly one Q such that the line\nthrough P and Q leaves half the points on each side. The fact that there is at least one is\nimmediate from the existence of a magnificent arrangement. The argument that there cannot be more\nthan one requires more thought.\n</p><p>\nAssume there is a point P and two other points Q<sub>1</sub> and Q<sub>2</sub> such that both of\nthe lines that go through P and each Q<sub>i</sub> have half of all the other points on each\nside. Moreover, without loss of generality, assume Q<sub>1</sub> is the one that actually pairs\nwith P in the magnificent pairing (we know it is unique). The following picture illustrates the\nsituation.\n</p>\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n   width=\"124.85555mm\"\n   height=\"70.53508mm\"\n   viewBox=\"0 0 124.85555 70.53508\"\n   version=\"1.1\"\n   id=\"svg8\"\n   inkscape:version=\"0.92.3 (2405546, 2018-03-11)\"\n   sodipodi:docname=\"drawing.svg\">\n  <defs\n     id=\"defs2\" />\n  <sodipodi:namedview\n     id=\"base\"\n     pagecolor=\"#ffffff\"\n     bordercolor=\"#666666\"\n     borderopacity=\"1.0\"\n     inkscape:pageopacity=\"0.0\"\n     inkscape:pageshadow=\"2\"\n     inkscape:zoom=\"1\"\n     inkscape:cx=\"183.12353\"\n     inkscape:cy=\"125.66119\"\n     inkscape:document-units=\"mm\"\n     inkscape:current-layer=\"layer1\"\n     showgrid=\"false\"\n     inkscape:snap-text-baseline=\"true\"\n     inkscape:window-width=\"1920\"\n     inkscape:window-height=\"1119\"\n     inkscape:window-x=\"0\"\n     inkscape:window-y=\"0\"\n     inkscape:window-maximized=\"1\"\n     fit-margin-top=\"0\"\n     fit-margin-left=\"0\"\n     fit-margin-right=\"0\"\n     fit-margin-bottom=\"0\" />\n  <metadata\n     id=\"metadata5\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     inkscape:label=\"Layer 1\"\n     inkscape:groupmode=\"layer\"\n     id=\"layer1\"\n     transform=\"translate(-2.2061551,-8.8651215)\">\n    <circle\n       id=\"path3713\"\n       cx=\"58.208351\"\n       cy=\"45.267849\"\n       r=\"3.4017856\"\n       style=\"stroke-width:0.26458332\" />\n    <circle\n       id=\"path3713-3\"\n       cx=\"86.178566\"\n       cy=\"60.31131\"\n       r=\"3.4017856\"\n       style=\"stroke-width:0.26458332\" />\n    <circle\n       id=\"path3713-6\"\n       cx=\"86.556557\"\n       cy=\"30.602375\"\n       r=\"3.4017856\"\n       style=\"stroke-width:0.26458332\" />\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       d=\"M 2.2678571,74.75 C 127,8.9821426 127,8.9821426 127,8.9821426\"\n       id=\"path3738\"\n       inkscape:connector-curvature=\"0\" />\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1\"\n       d=\"M 3.7797618,12.761904 C 118.68453,79.285714 118.68453,79.285714 118.68453,79.285714\"\n       id=\"path3740\"\n       inkscape:connector-curvature=\"0\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:6.74502754px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.16862568\"\n       x=\"90.208954\"\n       y=\"78.284111\"\n       id=\"text3760\"\n       transform=\"scale(1.0297602,0.97109987)\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3758\"\n         x=\"90.208954\"\n         y=\"78.284111\"\n         style=\"stroke-width:0.16862568\">2</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:6.74502754px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.16862568\"\n       x=\"94.168503\"\n       y=\"42.896397\"\n       id=\"text3760-9\"\n       transform=\"scale(1.0297602,0.97109987)\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3758-2\"\n         x=\"94.168503\"\n         y=\"42.896397\"\n         style=\"stroke-width:0.16862568\">1</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n       x=\"52.759003\"\n       y=\"22.353834\"\n       id=\"text3810\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3808\"\n         x=\"52.759003\"\n         y=\"22.353834\"\n         style=\"stroke-width:0.26458332\">B</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n       x=\"12.160764\"\n       y=\"46.48827\"\n       id=\"text3814\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3812\"\n         x=\"12.160764\"\n         y=\"46.48827\"\n         style=\"stroke-width:0.26458332\">A</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n       x=\"110.28877\"\n       y=\"52.942833\"\n       id=\"text3818\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3816\"\n         x=\"110.28877\"\n         y=\"52.942833\"\n         style=\"stroke-width:0.26458332\">C</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n       x=\"53.787991\"\n       y=\"78.106255\"\n       id=\"text3822\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan3820\"\n         x=\"53.787991\"\n         y=\"78.106255\"\n         style=\"stroke-width:0.26458332\">D</tspan></text>\n    <path\n       style=\"fill:none;stroke:#000000;stroke-width:1.16499996;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n       d=\"M 59.307107,45.178651 C 86.060787,31.053457 86.15433,31.147 86.15433,31.147\"\n       id=\"path3843\"\n       inkscape:connector-curvature=\"0\" />\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n       x=\"89.989647\"\n       y=\"38.349915\"\n       id=\"text4654\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan4652\"\n         x=\"89.989647\"\n         y=\"38.349915\"\n         style=\"stroke-width:0.26458332\">Q</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n       x=\"85.356812\"\n       y=\"72.090652\"\n       id=\"text4654-3\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan4652-3\"\n         x=\"85.356812\"\n         y=\"72.090652\"\n         style=\"stroke-width:0.26458332\">Q</tspan></text>\n    <text\n       xml:space=\"preserve\"\n       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n       x=\"58.297821\"\n       y=\"56.64603\"\n       id=\"text4695\"><tspan\n         sodipodi:role=\"line\"\n         id=\"tspan4693\"\n         x=\"58.297821\"\n         y=\"56.64603\"\n         style=\"stroke-width:0.26458332\">P</tspan></text>\n  </g>\n</svg>\n<p>\nIn the picture, we have labeled the four areas into which the two lines divide the plane. Let\nA, B, C and D be the sets of input points contained in each area (not including\nP, Q<sub>1</sub> or Q<sub>2</sub>). Notice that any point in A must be paired with a point in C in\norder for the produced segment to intersect PQ<sub>1</sub>. Similarly, any point in D must be\npaired with a point in B. All points below the line that goes through P and Q<sub>2</sub>\nare in either A or D, which means there are |A| + |D| of them. The number of points\nabove, on the other hand, is |B| + |C| + 1. Since we showed |A| &le; |C| and |B| &le; |D|,\n|B| + |C| + 1 &ge; |A| + |D| + 1 &gt; |A| + |D|.\nThis contradicts the assumption that the line that goes through P and Q<sub>2</sub>\nhas the same number of input points on each side.\n</p><p>\nThis observation by itself only allows us to avoid the \"find a leftmost point\" step of the previous\nalgorithm, which does not change its overall time complexity. The definite improvement is to more\nquickly shrink the set of points that we must consider, so that all steps within the iteration\ntake less time. To do that, consider that after we have paired M pairs of points, the lines through\neach pair divide the plane into 2<sup>M</sup> areas, with only the outside areas (the ones with\nunbounded area) possibly containing leftover points. Moreover, each point is to be paired with\none in the area that is opposite in order to cross all the lines, which is a necessary condition\nto intersect all line segments. When we create a new pair, exactly two of the areas are split in\nhalf. The idea is then: instead of removing the new pair and continuing with the full set, continue\nrecursively with two separate sets. If we consider sets X and Y coming from opposite areas,\nsplit after pairing into X<sub>1</sub> and X<sub>2</sub> and Y<sub>1</sub> and Y<sub>2</sub>,\nrespectively, then we need to solve recursively for X<sub>1</sub> and Y<sub>1</sub> separately\nfrom solving for X<sub>2</sub> and Y<sub>2</sub> (assuming\nthe areas are labeled such that X<sub>1</sub>, X<sub>2</sub>, Y<sub>1</sub>, Y<sub>2</sub>\nappear in that order when going through them in clockwise order).\n</p><p>\nThe last thing to do is to make sure we split X and Y more or less evenly with the new line. Notice\nthat if we restrict ourselves to start with a point P that is part of the convex hull of X or Y\nor X &cup; Y, this might be impossible (i.e., all those pairs may split X and Y, leaving most\nremaining points on one side). Hence the need for the property with which we started this\nsection. However, notice that\nif we sort all pairs to be made between points in X and points in Y by the slope of their produced\nsegments, the first and last will split X and Y into an empty set and a set with |X| - 1 points\n(notice that |X| = |Y|). The second and next-to-last will split them into a set with 1 point and a\nset with |X| - 2 points. The i-th will split them into a set with i - 1 points and a set with\n|X| - i points. Therefore, if we choose randomly, we end up with a recursion similar to\n<a href=\"https://en.wikipedia.org/wiki/Quicksort\">quicksort</a>'s, in which\nthe reduction on the size of the sets is expected to be close enough to always partitioning\nevenly. Since the time it takes for the non-recursive part of a set of size M is O(M log M) &mdash;\nnotice that calculating the partitions is only an additional linear time step &mdash;\nthe overall expected time complexity of this recursive algorithm is\n(<b>N</b> log<sup>2</sup> <b>N</b>).\n</p>\n","id":"000000000016c77f","statement":"<h3>Problem</h3>\n<p><i>\nThe first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 2\"\nare identical. The problems can otherwise be solved independently; you do not need to read\nor solve one in order to read or solve the other.\n</i></p><p>\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show\nup a bit. Instead of having each juggler individually juggle their own chainsaws, you want\nthem to form pairs, with each pair throwing the chainsaws back and forth to each other.\nIn this new performance, 2 &times; <b>N</b> jugglers will be on stage at the same\ntime, arranged into <b>N</b> pairs, with each juggler belonging to exactly one pair.\n</p><p>\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of\njugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight\nline segment in that plane that connects the positions of two jugglers in a pair be called the pair's\njuggling path. When two juggling paths instersect, we say the chainsaws juggled by those pairs are\nat risk of collision. We call the spatial positions and the pairings of the jugglers an\narrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at\nrisk of collision.\n</p><p>\nAfter a lot of thinking and designing, you came up with a magnificent arrangement.\nYou wrote down the positions of the jugglers on the stage and the pairings of the jugglers\non a piece of paper. Unfortunately, a bad chainsaw throw cut the paper in half, and you have\nlost the half with the pairings.\nSince the stage decorations have already been designed based on the positions of the jugglers,\nthose positions cannot be changed. The show's highly anticipated debut is a mere few hours away,\nso you need to find a magnificent arrangement that works! Given every juggler's position on a\ntwo-dimensional stage, find a pairing of them that yields a magnificent arrangement.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\nEach test case starts with one line containing a single integer <b>N</b>, the number of pairs of\njugglers. Then, 2 &times; <b>N</b> lines follow. The i-th of these lines contains two integers\n<b>X<sub>i</sub></b> and <b>Y<sub>i</sub></b>, representing the coordinates of the position of the\ni-th juggler.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing\n<code>Case #x: j<sub>1</sub> j<sub>2</sub> ... j<sub>2 &times; <b>N</b></sub></code>, representing\nthat jugglers i and <code>j<sub>i</sub></code> are to be paired together, for every i.\nNotice that <code>j<sub>j<sub>i</sub></sub></code> = i for every i.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n-10<sup>9</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n-10<sup>9</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\nNo three juggler positions are collinear. (Note that this also implies that no two jugglers are in\n  the same position.)<br/>\nThere exists at least one way to pair the jugglers such that the resulting arrangement\n  is magnificent.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n2 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>T</b> &le; 10.<br/>\n2 &le; <b>N</b> &le; 10<sup>5</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2\n-1 -1\n-1 1\n1 1\n1 -1\n3\n1 2\n2 1\n2 3\n3 1\n3 3\n4 2\n3\n7 1\n1 1\n7 2\n5 5\n3 5\n1 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3 4 1 2\nCase #2: 6 5 4 3 2 1\nCase #3: 5 4 6 2 1 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the jugglers' positions form a square. The only valid\n  solution is to pair up jugglers 1 and 3, and pair up jugglers 2 and 4.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Juggle Struggle: Part 1","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nWe can represent each pair of jugglers from the input as the endpoints of a segment.\nThe problem then asks us to find two of those segments that do not intersect, or report that there\nis no such pair.\n</p>\n<h3>Test Set 1 (Visible)</h3>\n<p>\nTest Set 1 can be solved by checking every possible pair of segments to see if they intersect.\nLet pq be the segment between points p and q, and rs be the segment between points r and s;\nthen these segments intersect if and only if\n<ul>\n<li>(r - p) &times; (q - p) has the same sign as (s - p) &times; (q - p), and</li>\n<li>(p - r) &times; (s - r) has the same sign as (q - r) &times; (s - r),</li>\n</ul>\nwhere &times; stands for the\n<a href=\"https://en.wikipedia.org/wiki/Cross_product\">cross product</a>.\nThis works only when no three of the points are collinear, but that is the case in this problem.\nSince each check takes constant time, this algorithm runs in O(<b>N</b><sup>2</sup>) time.\n</p>\n<h3>Test Set 2 (Hidden)</h3>\n<p>\nLet L<sub>i</sub> be the line that fully contains segment S<sub>i</sub>. Let S<sub>i</sub> and\nS<sub>j</sub> be two segments that do not intersect. If L<sub>i</sub> and L<sub>j</sub> are not\nparallel, at least one of S<sub>i</sub> and S<sub>j</sub>\ndoes not contain the intersection between L<sub>i</sub> and L<sub>j</sub>. We can find for every\ninput segment S<sub>i</sub>, we can find whether its line L<sub>i</sub> intersects\nsome other line at a point outside of S<sub>i</sub> (or not at all). Let F be the set of all such\nsegments. Then, every non-intersecting pair contains at least one segment in F and the size of F\nis at most 25. We can do a linear pass over all other segments to see whether or not they intersect\neach segment in F to find the segments not in F that also participate in non-intersecting pairs.\nWe focus now on finding all segments to put in F.\n</p><p>\nWe now present three algorithms. The first two are ultimately similar: the first one uses less\nadvanced theory, but requires more problem-specific proofs because of it. They both\nrequire somewhat large integers. For C++, <code>__int128</code> is enough to represent all values,\nbut since we need to compare fractions that are the ratio of two <code>__int128</code>s, we'll\nneed special comparison code. For Java, <code>BigInteger</code> will do. The third algorithm is\na separate approach that uses a more advanced data structure, and requires only 64-bit integer\narithmetic.\n</p>\n<h4>A solution using less advanced previous knowledge</h4>\n<p>\nFirst, assume there is a purely vertical segment (that is, its two endpoints have the same x\ncoordinate). If we find more than one of those, we add all of them to F, since they don't\noverlap. If we find a single one, we can check it against all others like in the previous solution\nin linear time. In what follows, we assume no vertical segment is present.\n</p><p>\nConsider the extension of each segment S<sub>i</sub> to a full line L<sub>i</sub>.\nWe will find the x coordinates of the leftmost and rightmost intersection of L<sub>i</sub> with all\nother L<sub>j</sub>s and check that they are inside the range of x coordinates where S<sub>i</sub>\nexists. If one of those intersections is not inside that range, then we found one or two segments\nto put in F. Notice that finding all\nrightmost intersections is equivalent to finding all leftmost intersections in the input symmetric\nto the y axis, so if we have an algorithm that finds the leftmost ones, we can just run it twice\n(and reflecting the input takes linear time). Moreover, suppose we restrict ourselves to the\nleftmost intersection of L<sub>i</sub> such that L<sub>i</sub> is above the other intersecting line\nto the left of the found intersection. Let us call these \"leftmost above intersections\".\nWe can use an algorithm that finds those intersections once on the unchanged input and once on the\ninput reflected across the x axis to find the analogous \"leftmost below intersections\". In summary,\nwe develop an algorithm that finds \"leftmost above intersections\" and then run it 4 times (using\nall combinations of reflecting / not reflecting the input across each axis), to find\nall combinations of \"leftmost/rightmost below/above intersections\".\n</p><p>\nTo find all \"leftmost above intersections\", the key observation is that if two lines L<sub>1</sub>\nand L<sub>2</sub> intersect at x coordinate X, and L<sub>2</sub> is below to the left of the\nintersection, then L<sub>2</sub> cannot participate in any leftmost below intersection at\ncoordinates X' &gt; X. L<sub>2</sub>'s own intersections at coordinates X' &gt; X are not leftmost.\nIf L<sub>2</sub> intersects an L<sub>3</sub> that is below L<sub>2</sub> to the left of their\nintersection at X' &gt; X, then L<sub>3</sub> intersects L<sub>1</sub> to the left of X' because\nof continuity: L<sub>1</sub> is below L<sub>2</sub> to the right of X.\n</p><p>\nThis leads to the following algorithm: let X<sub>0</sub> be the minimum x coordinate among all\nendpoints. Sort the lines by y coordinate at X<sub>0</sub>. Let L<sub>i</sub> be the line\nwith the i-th highest y coordinate. We iterate over the\nlines in that order, while keeping a list or ranges of x coordinates and which previously seen\nline is below all others there, since that is the only one that can produce leftmost below\nintersections in that range. We keep that list as a\n<a href=\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\">stack</a>.\n</p><p>\nAt the beginning, we push (X<sub>1</sub>, 1) onto the stack, where X<sub>1</sub> is the maximum\nx coordinate among all input points. This signifies that L<sub>1</sub> is currently below in the\nentire range of x coordinates.\nThen, we iterate through L<sub>2</sub>, L<sub>3</sub>, ... L<sub><b>N</b></sub>.\nWhen processing L<sub>i</sub>, we\n<a href=\"https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\">\nfind the x coordinate of its intersection</a> with L<sub>j</sub> and call it X, where (j, X') is\nthe top of the stack. We check the intersection to see if it is within the x coordinate range\nof the two corresponding segments. Then, if X &lt; X', we simply push (i, X) onto the stack.\nOtherwise, we pop (j, X') from the stack and repeat, since j was not the line below all others at\nX. Notice that this keeps the stack sorted increasingly by line index and decreasingly by\nintersection coordinate at all times.\n</p><p>\nSince every line is processed, pushed onto the stack and popped from the stack at most once, and\neverything else can be done in constant time, this iteration takes linear time. Other than that,\nthe sorting by y coordinate takes time O(<b>N</b> log <b>N</b>), which is also the overall time\ncomplexity of the entire algorithm, since it dominates all other linear steps.\n</p><p>\nNotice that the way we use the stack in the above algorithm is quite similar to how a stack is used\nin the most widely known <a href=\"https://en.wikipedia.org/wiki/Graham_scan\">algorithm to compute\nthe convex hull</a> of a set of points. As we show in the next section, that is no coincidence.\n</p>\n<h4>Using point-line duality to shortcut to the solution</h4>\n<p>\nIn this solution we change how we find leftmost intersections. Treating vertical lines\nand reflecting to find rightmost intersections, and the way to use leftmost/rightmost\nintersections to find the solution to the problem, are the same as in the solution above.\n</p><p>\nTo find the leftmost intersections, we can apply the point-line duality to the input.\nWith duality between points and lines, a line y=mx+b in the original space can be represented\nas the point (m, -b) in the dual space. Similarly, a point (a, b) in the original space\ncan be represented as a line of the form y=ax-b in the dual space. Notice that the dual space\nof the dual space is the original space. Vertical lines have no corresponding point.\nThis duality has the property that when two lines L<sub>1</sub> and L<sub>2</sub> intersect in the\noriginal, their intersection point P corresponds to the line dual(P) in the dual space goes through\nthe points dual(L<sub>1</sub>) and dual(L<sub>2</sub>).\n</p><p>\nThus, if we take all lines that are extensions of input segments and consider the points that\ncorrespond to them in the dual space, the leftmost intersection for a given line L<sub>1</sub>\noccurs when intersecting L<sub>2</sub> such that the slope of the segment between\ndual(L<sub>1</sub>) and dual(L<sub>2</sub>) is minimal.\n</p><p>\nWe now work on the dual space with an input set of points, and for each point P we want to find\nanother point Q such that the slope of PQ is minimal.\nFor each point in the convex hull of the set, the minimal slope occurs between that point and the\nnext point in the convex hull. For points not in\nthe convex hull, however, the appropriate choice is the temporary \"next\" point of the convex hull\nas calculated by the <a href=\"https://en.wikipedia.org/wiki/Graham_scan\">Graham scan</a>.\nThis leads to similar code as for the solution above, but using the duality saves\nus quite a few hand-made proofs. Just as for the algorithm above, all of the steps of this\nalgorithm take linear time, with the exception of the sorting step needed for the Graham scan,\nyielding an overall O(<b>N</b> log <b>N</b>) algorithm.\n</p>\n<h4>A solution using incremental convex hull</h4>\n<p>\nAnother solution requires more code overall, but some of that code might be present in a\ncontestant's comprehensive library. It uses an incremental convex hull, which is a data structure\nthat maintains a convex hull of a set of points and allows us to efficiently (in logarithmic time)\nadd points to the set while updating the convex hull if necessary.\n</p><p>\nThe algorithm checks for a condition that we mentioned in the analysis for Part 1: each\nsegment has the two endpoints of all other segments on different sides.\nThe algorithm uses a rotating sweep line. Assume the endpoints of all input segments are swapped\nas necessary such that the segments point right (the first endpoint has an x coordinate no greater\nthan the x coordinate of the second endpoint). Then, we sort the segments by slope and consider a\nrotating line that stops at all those slopes &mdash; that is, we iterate through the slopes in\norder. If we number the segments S<sub>1</sub>, S<sub>2</sub>, ..., S<sub><b>N</b></sub> in that\norder, S<sub>1</sub> must have\nall left endpoints on one side, and all right endpoints on the other. S<sub>2</sub> is the same,\nexcept the left endpoint of S<sub>1</sub> goes with the right endpoints of all others, and vice\nversa. In general, for S<sub>i</sub> we need to check for the left endpoint of all segments\nS<sub>1</sub>, S<sub>2</sub>, ..., S<sub>i-1</sub> to be on one side together with the right\nendpoints of all segments S<sub>i+1</sub>, S<sub>i+2</sub>, ..., S<sub><b>N</b></sub>, and\nall other endpoints are on the other side. If we find an endpoint of S<sub>j</sub>\non the wrong side of S<sub>i</sub>, then S<sub>i</sub> and S<sub>j</sub> do not intersect. If we\nfind no such example, the answer is <code>MAGNIFICENT</code>.\n</p><p>\nIf we knew the convex hull of all the points that are supposed to be on each side, we could use\n<a href=\"https://en.wikipedia.org/wiki/Ternary_search\">ternary search</a> on the signed\ndistance between the convex hull and the line to efficiently find\nthe point from that set whose signed distance perpendicular to the current S<sub>i</sub> is smallest\n(for the side where the distances are supposed to be positive) or largest (for the other side).\nIf one of those finds us a point on the wrong side, we are done; otherwise, we know all other\npoints are also on the correct side. Unfortunately, to keep those two convex hulls as we rotate\nwould require us to both add and remove a point from each set. Removing is a lot harder to do,\nbut we can avoid it.\n</p><p>\nWhen considering the slope of S<sub>i</sub>, instead of using the convex hull of the full set\non one side, we can use the convex hull of the left endpoints that are on that side, and separately,\nthe convex hull of the right endpoints on that side. That leaves us one additional candidate to\ncheck for that side, but one of those is the optimal candidate. Since we are calculating\nleft and right endpoints separately, the 4 &times; <b>N - 1</b> convex hulls we need are the ones\nof the set of left endpoints of the segments in a prefix of the list of segments,\nthe left endpoints of the segments in a suffix of the list of segments, and similarly,\nthe right endpoints of the segments in a suffix or prefix of the list of segments.\nWe can calculate all of those convex hulls with a data structure that only provides addition of\na point by calculating the convex hulls for prefixes in increasing order of segment index, and\nthe ones for suffixes in decreasing order of segment index. Notice that this means we will\ncalculate the convex hulls in an order different from the order in the original form of the\nalgorithm.\n</p><p>\nWe are doing O(<b>N</b>) insertions into the convex hull data structure and O(<b>N</b>) ternary\nsearches, and each of these operations takes O(log <b>N</b>) time, making the time complexity\nof this algorithm also O(<b>N</b> log <b>N</b>).\n</p><p>\nFor this particular use, we only need one half of the convex hull: the half that is closer to\nthe line being inspected. In this half convex hull, the points in the hull are sorted by\ny coordinate, so a tree search can yield us the tentative insertion point,\nand we can maintain the convex hull by searching and inserting in a sorted tree. This is simple\nenough that it does not necessarily require prewritten code.\nAdditionally, we can further simplify by using\n<a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">binary search</a> on the angle\nbetween the convex hull and the line instead of the ternary search mentioned above.\n</p>\n","id":"000000000016c933","statement":"<h3>Problem</h3>\n<p><i>\nThe first two paragraphs (not counting this one) of this problem and \"Juggle Struggle: Part 1\"\nare identical. The problems can otherwise be solved independently; you do not need to read\nor solve one in order to read or solve the other.\n</i></p><p>\nAs manager of the Graceful Chainsaw Jugglers group, you have decided to spice the show\nup a bit. Instead of having each juggler individually juggle their own chainsaws, you want\nthem to form pairs, with each pair throwing the chainsaws back and forth to each other.\nIn this new performance, 2 &times; <b>N</b> jugglers will be on stage at the same\ntime, arranged into <b>N</b> pairs, with each juggler belonging to exactly one pair.\n</p><p>\nYou think the show will be more impressive if the chainsaws being juggled by different pairs of\njugglers are at risk of collision. Let the stage be a two-dimensional plane, and let the straight\nline segment in that plane that connects the positions of two jugglers in a pair be called the pair's\njuggling path. When two juggling paths instersect, we say the chainsaws juggled by those pairs are\nat risk of collision. We call the spatial positions and the pairings of the jugglers an\narrangement. An arrangement is magnificent if every two pairs of jugglers' chainsaws are at\nrisk of collision. That is, for the arrangement to be magnificent, each of the <b>N</b> juggling path\nsegments must intersect each of the other <b>N</b>-1 juggling path segments (but these intersections do\nnot necessarily all have to be in the same place).\n</p><p>\nAfter some last minute fixes, you have what you think is a magnificent arrangement.\nGiven the rush to put it together, you want to write a checker that can determine whether it is\nindeed magnificent. If it is not, then at most 25 juggler pairs fail to intersect every other pair.\nYou want your checker to report a list of all those juggler pairs for inspection.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\nEach test case starts with one line containing a single integer <b>N</b>, the number of pairs of\njugglers. Then, <b>N</b> lines follow. The i-th of these lines contains four integers\n<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>, <b>X'<sub>i</sub></b>, <b>Y'<sub>i</sub></b>.\n(<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>) and (<b>X'<sub>i</sub></b>, <b>Y'<sub>i</sub></b>)\nare the coordinates of the positions of the two jugglers comprising the i-th juggler pair.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing\n<code>Case #x: y</code>, where <code>y</code> is uppercase <code>MAGNIFICENT</code> if the input\nrepresents a magnificent arrangement. Otherwise, <code>y</code> should be a strictly increasing\nlist of integers. Integer i should be on that list if and only if the juggling path\nof the i-th juggler pair fails to intersect at least one other juggling path.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n-10<sup>9</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n-10<sup>9</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n-10<sup>9</sup> &le; <b>X'<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n-10<sup>9</sup> &le; <b>Y'<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\nNo three juggler positions are collinear. (Note that this also implies that no two jugglers\n  are in the same position.)<br/>\nFor all but up to 25 pairs of jugglers, their juggling paths intersect all <b>N</b> - 1 other\n  juggling paths.<br/>\n<u>Note:</u> There <i>may or may not</i> exist a way to pair the jugglers such that\nthe resulting arrangement is magnificent.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n2 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\nTime limit: 45 seconds.<br/>\n1 &le; <b>T</b> &le; 13.<br/>\n2 &le; <b>N</b> &le; 10<sup>5</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2\n-1 -1 -1 1\n1 1 1 -1\n2\n-1 -1 1 1\n-1 1 1 -1\n4\n1 2 4 2\n2 1 3 1\n2 4 3 0\n3 3 2 3\n3\n1 1 2 2\n3 7 4 8\n8 3 9 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1 2\nCase #2: MAGNIFICENT\nCase #3: 1 2 4\nCase #4: 1 2 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, there are only two pairs, and their paths do not cross.\n</p><p>\n  In Sample Case #2, the arrangement is magnificent: every pair's path crosses\n  every other pair's path.\n</p><p>\n  In Sample Case #3, only pair 3's path crosses every other pair's path.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Juggle Struggle: Part 2","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThere are two kinds of programs: those that terminate, and those that don't!\n</p><p>\nFor any set of instructions for Marlin that does not loop indefinitely (because it reaches the end\nof the program), there is an equivalent program that has no goto instructions, and this is the\nshortest way to write that program.\n</p><p>\nSimilarly, if a program loops indefinitely, there is an equivalent program that consists only of\nmove instructions with a single goto at the end of the program, and this is the shortest way to\nwrite that program.\n</p><p>\nSo we only need to consider those two cases: programs that consist only of move instructions, and\nprograms with only a single goto, as the last instruction.  Then we take the shortest of all of\nthese.\n</p><p>\nWe can easily find a minimal program of the first type with a breadth-first search (BFS) which\nstarts at <code>M</code> and stops when it reaches <code>N</code>, avoiding <code>#</code>s.\nIf the search terminates without reaching <code>N</code>, then we can output that the case is impossible.\n</p><p>\nFinding a minimal program of the second type is harder.  The program can be split into two sections\nwhich compute two separate paths: an initial path P produced by the instructions which do not\nrepeat, and then a path Q which repeats until <code>N</code> is reached.\n</p><p>\nLet B be the point where P ends.  We can use a BFS, as in the previous case, to find a minimal P for\nall possible points B.\n</p><p>\nOptimizing Q is slightly more involved.\nThe first time through Q, Marlin walks through some set of grid cells.  The second time through,\nMarlin walks through grid cells of the same pattern, but offset by some displacement vector D.\nThis continues for\nsome number of iterations K until Marlin reaches the <code>N</code> cell.\nSo the first iteration of Q takes Marlin from B to B+D, but the path must avoid not only cells with\na <code>#</code>, but also cells which have an equivalent cell in a later iteration which is a <code>#</code>.\nAdditionally, the first iteration of Q must include a cell which, in a later iteration, will be <code>N</code>.\n</p><p>\nIt is not easy to satisfy these constraints unless we already know the displacement D, and the\nnumber of iterations, K.  So, we loop over all possibilities for these.\n</p><p>\nInside this loop, we determine the shortest program for all possibilities for B, for the given\nvalues of D and K.\nWe split Q into two parts, Q<sub>1</sub> and Q<sub>2</sub>.  Q<sub>1</sub> contains the instructions\nwhich repeat K times, and reach\ncell <code>N</code> on the final iteration.\nQ<sub>2</sub> contains the instructions which only repeat K-1 times.  (If we reach <code>N</code> at\nthe end of an iteration, Q<sub>2</sub> is empty.)\n</p><p>\nLet N be the location of the cell containing <code>N</code>.\nQ<sub>1</sub> is a path from B to N-(K-1)&times;D, and Q<sub>2</sub> is a path from N-(K-1)&times;D to B+D.\n</p><p>\nThe path for Q<sub>1</sub> can only touch cells X such that X+i&times;D is empty for 0&lt;i&lt;K.\nWe do a BFS from\nN-(K-1)&times;D, using these cells, to find an optimal Q<sub>1</sub> for all possibilities for B.\n</p><p>\nThe path for Q<sub>2</sub> can only touch cells X such that X+i&times;D is empty for 0&lt;i&lt;K-1.\nWe do a BFS\nfrom N-(K-1)&times;D, using these cells, to find an optimal Q<sub>2</sub> for all possibilties for B.\n</p><p>\nFinally, we loop over all possible cells for B, and sum up the lengths of the shortest P, Q<sub>1</sub> and\nQ<sub>2</sub>, plus one for the goto statement.\n</p>\n<h4>\nRunning time\n</h4>\n<p>\nLet max(<b>R</b>,<b>C</b>)=N.  For the outer loop that iterates over D and K, there are O(N<sup>2</sup>) choices for D and\nO(N) choices for K.  However, not all combinations are possible.  If the number of iterations, K,\nis large, then the displacement D for each iteration must be small; otherwise Marlin's path would\nhave to leave the grid to complete K iterations.  The total number of valid combinations of D and K\nis O(N<sup>2</sup>) &mdash; we leave the proof as an exercise for the reader.\n</p><p>\nInside the loop, setting up the grids for the BFS, running the two BFSs, and trying all values for\nB all take O(N<sup>2</sup>) time.  So the loop takes O(N<sup>4</sup>) time.\n</p><p>\nThe BFS outside the loop that computes all optimal paths P takes O(N<sup>2</sup>) time, and so does the\nsearch for the optimal solution with no goto statements.\nSo the overall solution is O(N<sup>4</sup>), and runs fast enough to solve both test sets.\n</p><p>\nBeing less careful can result in an O(N<sup>5</sup>) solution &mdash; for example, by doing O(K) work to check\nwhether a cell is valid for the two BFSs inside the loop.  This is sufficient to solve test set 1.\n</p><p>\nAn exponential-time solution that naively tries all possibilities for Q is unlikely to work even for\ntest set 1, since the maximum length of Q is too large.\n</p>\n","id":"000000000016c934","statement":"<h3>Problem</h3>\n<p>\nMarlin is a fish who lost his son and is trying to find him. Fortunately, he ran into Cynthia,\na turtle, as she swam around with her brothers, Wally and Seymour. Cynthia knows exactly where\nMarlin needs to go, and she can be very precise in giving directions. While Marlin is smart and\ncan follow them perfectly, keeping track of a long list of directions can be problematic.\nCynthia needs to find a way to make the list of directions short.\n</p><p>\nMarlin lives in a matrix of <b>R</b> rows and <b>C</b> columns. Some cells of the\nmatrix are dangerous and cannot be entered. Marlin and his son are currently in\ndifferent non-dangerous cells. Marlin's son never moves to a different cell.\nCynthia decided to give Marlin directions in the form of a program consisting\nof a list of instructions, each on a single line. Each instruction is of one of\n5 types:\n</p><ul>\n  <li><code>N</code>: move one cell North (up),</li>\n  <li><code>S</code>: move one cell South (down),</li>\n  <li><code>W</code>: move one cell West (left),</li>\n  <li><code>E</code>: move one cell East (right), and</li>\n  <li><code>G(i)</code>: jump to the i-th line of the instruction list\n    (counting starting from 1).</li>\n</ul><p>\nAfter executing a line with any of the first 4 instructions, Marlin jumps to the next\nline on the list if there is one. If there is no next line,\nMarlin just stands still forever.\n</p><p>\nFor example, if Marlin were following the program\n</p><pre>\n1: N\n2: E\n3: G(6)\n4: S\n5: G(1)\n6: W\n7: G(4)\n</pre><p>\nhe would move North (line 1), then East (2),\nthen jump to line 6 without physically moving (3), then move West (6),\nthen jump to line 4 (7), then move South (4), then jump to line 1 (5),\nthen move North (1), etc.\n</p><p>\nIf at any point Marlin and his son are at the same cell, they will be reunited\nand Marlin will no longer follow any instructions. Cynthia the turtle wants to find out the\nsmallest number of lines in a program that would get Marlin to the same cell as his\nson, without him ever going into a dangerous cell or moving outside of the matrix\nboundaries. All <code>G</code> instructions must jump to existing lines in the program.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\nEach test case starts with a line containing <b>R</b> and <b>C</b>, the number of\nrows and columns in the matrix. Then, <b>R</b> lines follow containing a string of\n<b>C</b> characters each. The j-th character of the i-th of these lines <b>A<sub>ij</sub></b>\nrepresents the cell in the i-th row and j-th column of the matrix. The character is <code>#</code>\nif the cell is dangerous, an uppercase <code>M</code> if the cell is the one Marlin is currently\nat, an uppercase <code>N</code> if the cell is the one Marlin's son is currently\nat and <code>.</code> if the cell is an unoccupied non-dangerous cell.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the test case number (starting from 1) and <code>y</code> is\n<code>IMPOSSIBLE</code> if there is no program that would get Marlin to his son\nunder the conditions explained above, or the smallest number of instructions in such a\nprogram.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n<b>A<sub>ij</sub></b> is either <code>#</code>, <code>.</code>, uppercase <code>M</code>\n  or uppercase <code>N</code>, for all i and j.<br/>\n<b>A<sub>ij</sub></b> = <code>M</code> for exactly one pair of i and j.<br/>\n<b>A<sub>ij</sub></b> = <code>N</code> for exactly one pair of i and j.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  Time limit: 30 seconds.<br/>\n  1 &le; <b>R</b> &le; 10.<br/>\n  1 &le; <b>C</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  Time limit: 120 seconds.<br/><br/>\n  For at most 10 test cases:<br/>\n  1 &le; <b>R</b> &le; 100.<br/>\n  1 &le; <b>C</b> &le; 100.<br/><br/>\n  For the remaining test cases:<br/>\n  1 &le; <b>R</b> &le; 50.<br/>\n  1 &le; <b>C</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2 5\nN...#\n....M\n2 5\nN#...\n...#M\n5 5\nN..##\n#.###\n#...#\n##.##\n##..M\n5 5\n..N##\n#.###\n#...#\n##.##\n##..M\n3 3\n#M#\n###\n#N#\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 7\nCase #3: 5\nCase #4: 6\nCase #5: IMPOSSIBLE\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Below are some shortest programs for each of the possible sample case.\n</p>\n<ul>\n  <li>Sample Case #1:\n    <pre>1: W\n2: N\n3: S\n4: G(1)\n    </pre> or\n    <pre>1: W\n2: N\n3: W\n4: G(3)\n    </pre>.\n  </li>\n  <li>Sample Case #2:\n    <pre>1: N\n2: W\n3: W\n4: S\n5: W\n6: W\n7: N\n    </pre>.\n  </li>\n  <li>Sample Case #3:\n    <pre>1: W\n2: W\n3: N\n4: N\n5: G(2)\n    </pre>.\n  </li>\n  <li>Sample Case #4:\n    <pre>1: W\n2: W\n3: N\n4: N\n5: E\n6: G(1)\n    </pre>.\n  </li>\n</ul>\n<p>\n  Notice that even though the program must contain the smallest possible number of lines,\n  it is not required to minimize the number of moves that Marlin makes.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":19},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Go To Considered Helpful","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000051708","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2019"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
