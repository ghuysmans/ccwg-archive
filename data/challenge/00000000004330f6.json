{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1217041200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000004330f6","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  The first sub-round of Google Code Jam 2008 Round 1 featured three little\n  challenges. Each problem required one or two cute ideas to solve.\n</p><p>\n  The first problem is formulated in one of the important concepts connecting\n  algebra and geometry, that of scalar product, also known as inner product.\n  Though the problem itself is an exercise in arrays and numbers.\n</p><p>\n  The second problem, as mundane as the name suggests, has some connection to\n  the propositional logic, especially the satisfiability problem. Unlike the\n  super-hard general satisfiability problem, this one is in a restricted form,\n  and thus allows one to find a simple and cute solution.\n</p><p>\n  The third problem, appears as a numerical problem, actually should be solved\n  with only integer numbers. With ideas from elementary algebra, combinatorics,\n  and number theory, armed with some standard tricks on the computational side,\n  we know at least four different solutions with distinct flavor. \n</p><p>\n  2394 contestants finished the match with a positive score, among them, we\n  have 41 perfect scores.\n</p>\n\n<hr>\n<p>\n  <b>Credits</b>\n</p><p>\n  Problem A. <i>Minimum Scalar Product</i>\n  Written by Michael Levin. Prepared by Frank Chu.\n</p><p>\n  Problem B. <i>Milkshakes</i>\n  Written by John Dethridge. Prepared by Frank Chu and John Dethridge.\n</p><p>\n  Problem C. <i>Numbers</i>\n  Written and prepared by Cosmin Negruseri.\n</p><p>\n  Contest analysis presented by Cosmin Negruseri, Xiaomin Chen, and John\n  Dethridge.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1217034000000,"tasks":[{"analysis":"<p>\n  This problem with a simple statement was in fact one of the hardest in Round\n  1. The input restrictions for the small input were chosen so that\n  straightforward solutions in Java or Python, which have arbitrary-precision\n  numbers, would fail.\n  The trick was calculating &radic;5 to a large enough precision and not using\n  the default double value. It turned out that using the Windows calculator or\n  the UNIX <code>bc</code> tool was enough to solve the small tests as well.\n</p><p>\n  Solving the large tests was a very different problem. The difficulty comes\n  from the fact that &radic;5 is irrational and for n close to 2000000000 you\n  would need a lot of precision and a lot of time if you wanted to use the\n  naive solution.\n</p><p>\n  The key in solving the problem is a mathematical concept called\n  <a href=\"http://en.wikipedia.org/wiki/Conjugate_%28algebra%29\" target=\"_blank\">conjugation</a>.\n  In our problem, we simply note that <nobr>(3 - &radic;5)</nobr> is a nice\n  conjugate for <nobr>(3 + &radic;5)</nobr>.\n  Let us define\n</p>\n<blockquote>\n  (1) &nbsp;&nbsp;&nbsp; &alpha; := 3 + &radic;5,  &nbsp; &beta; := 3 -\n  &radic;5, &nbsp; and X<sub>n</sub> := &alpha;<sup>n</sup> +\n  &beta;<sup>n</sup>.\n</blockquote>\n<p>\n  We first note that X<sub>n</sub> is an integer. This can be proved by using the\n  <a href=\"http://en.wikipedia.org/wiki/Binomial_theorem\" target=\"_blank\">binomial expansion</a>.\n  If you write everything down you'll notice that the irrational terms of the\n  sums cancel each other out.\n</p>\n<blockquote>\n  (2) &nbsp;&nbsp;&nbsp; <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U07JTENPZAV2L23HJhH6kMKmiWZZnoOua2_mz3o9LAIjiSHQPnpvzcDcLWj3qxHJnfT1vT4lz0/numbers2.png\"/>\n</blockquote>\n<p>\n  Another observation is that &beta;<sup>n</sup> &lt; 1, so X<sub>n</sub> is\n  actually the first integer greater than &alpha;<sup>n</sup>. Thus we may just\n  focus on computing the last three digits of X<sub></sub>.\n</p><p>\n  <i>A side note.</i> In fact, &beta;<sup>n</sup> tends to 0 so quickly that\n  that our problem would be trivial if we asked for the three digits\n  <i>after</i> the decimal point. For all large values of n they are always\n  999.\n</p><p>\n  Based on (1) and (2), there are many different solutions for finding the last\n  three digits of X<sub>n</sub>.\n</p>\n\n<h3>Solution A. [the interleave of rational and irrational]</h3>\n<p>\n  One solution goes like this: &alpha;<sup>n</sup> can be written as\n  <nobr>(a<sub>n</sub> + b<sub>n</sub>&radic;5)</nobr>, where a<sub>n</sub> and\n  b<sub>n</sub> are integers. At the same time, &beta;<sup>n</sup> is exactly\n  <nobr>(a<sub>n</sub> - b<sub>n</sub>&radic;5)</nobr> and <nobr>X<sub>n</sub>\n  = 2a<sub>n</sub></nobr>. Observe that\n</p>\n<blockquote>\n  (3) &nbsp;&nbsp;&nbsp; &alpha;<sup>(n + 1)</sup> = (3 +\n  &radic;5)(a<sub>n</sub> + b<sub>n</sub>&radic;5) = (3a<sub>n</sub> +\n  5b<sub>n</sub>) + (3b<sub>n</sub> + a<sub>n</sub>)&radic;5.\n</blockquote> \n<p>\n  So a<sub>n + 1</sub> = 3a<sub>n</sub> + 5b<sub>n</sub> and b<sub>n + 1</sub>\n  = 3b<sub>n</sub> + a<sub>n</sub>. This can be written in matrix form as\n</p>\n<blockquote>\n  (4) &nbsp;&nbsp;&nbsp; <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1msEKZW27Eb0WTELZU7XqNkYS4osLdQX2PYREE_ivN8ZaUQbEeGROi9YxNXr1Z0pG8n2fu8tE/numbers4.png\"/>\n</blockquote>\n<p>\n  Since &alpha;<sup>0</sup> = 1, we have (a<sub>0</sub>, b<sub>0</sub>) = (1, 0).\n</p><p>\n  Now we use the standard\n  <a href=\"http://en.wikipedia.org/wiki/Exponentiation_by_squaring\" target=\"_blank\">fast exponentiation</a>\n  to get A<sup>n</sup> in O(log n) time. Note that we do all operations modulo\n  1000 because we just need to return the last three digits of a<sub>n</sub>.\n</p><p>\n  Here's some Python code that implements this solution:\n</p>\n<pre>\ndef matrix_mult(A, B):\n  C = [[0, 0], [0, 0]]\n  for i in range(2):\n    for j in range(2):\n      for k in range(2):\n        C[i][k] = (C[i][k] + A[i][j] * B[j][k]) % 1000\n  return C\n\ndef fast_exponentiation(A, n):\n  if n == 1:\n    return A\n  else:\n    if n % 2 == 0:\n      A1 = fast_exponentiation(A, n/2)\n      return matrix_mult(A1, A1)\n    else:\n      return matrix_mult(A, fast_exponentiation(A, n - 1))\n\ndef solve(n):\n  A = [[3, 5], [1, 3]]\n  A_n = fast_exponentiation(A, n)\n  return (2 * M_n[0][0] + 999) % 1000\n</pre>\n\n<h3>Solution B. [the quadratic equation and linear recurrence]</h3>\n<p>\n  Experienced contestants may notice there is a linear recurrence on the\n  X<sub>i</sub>'s. Indeed, this is not hard to find -- the conjugation enters\n  the picture again.\n</p><p>\n  Notice that\n</p>\n<blockquote>\n  (5) &nbsp;&nbsp;&nbsp; &alpha; + &beta; = 6, and &alpha; &beta; = 4.\n</blockquote>\n<p>\n  So &alpha; and &beta; are the two roots of the quadratic equation\n  x<sup>2</sup> - 6x + 4 = 0. i.e.,\n</p>\n<blockquote>\n  (6) &nbsp;&nbsp;&nbsp; &alpha;<sup>2</sup> = 6&alpha; - 4,  and\n  &beta;<sup>2</sup> = 6&beta; - 4.\n</blockquote>\n<p>\n  Looking at (1) and (6) together, we happily get\n</p>\n<blockquote>\n  (7) &nbsp;&nbsp;&nbsp; X<sub>n+2</sub> = 6X<sub>n+1</sub> - 4X<sub>n</sub>.\n</blockquote>\n<p>\n  Such recurrence can always be written in matrix form. It is somewhat\n  redundant, but it is useful:\n</p>\n<blockquote>\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0vmOxcRMm1m0K7VgJ_cAUlxpN2XekkVrTqpBXtbttb8dmlXOeH10Tde4TRpal_pXDc5jCirYs/numbers8.png\"/>\n</blockquote>\n<p>\n  From here it is another fast matrix exponentiation. Let us see\n  <b>radeye</b>'s perl code that implements this approach here:\n</p>\n<pre>\nsub mul {\n    my $a = shift ;\n    my $b = shift ;\n    my @a = @{$a} ;\n    my @b = @{$b} ;\n    my @c = ($a[0]*$b[0] + $a[1]*$b[2],\n             $a[0]*$b[1] + $a[1]*$b[3],\n             $a[2]*$b[0] + $a[3]*$b[2],\n             $a[2]*$b[1] + $a[3]*$b[3]) ;\n    @c = map { $_ % 1000 } @c ;\n    return @c ;\n}\nsub f {\n    my $n = shift ;\n    return 2 if $n == 0 ;\n    return 6 if $n == 1 ;\n    return 28 if $n == 2 ;\n    $n -= 2 ;\n    my @mat = (0, 1, 996, 6) ;\n    my @smat = @mat ;\n    while ($n &gt; 0) {\n        if ($n &amp; 1) {\n            @mat = mul([@mat], [@smat]) ;\n        }\n        @smat = mul([@smat], [@smat]) ;\n        $n &gt;&gt;= 1 ;\n    }\n    return ($mat[0] * 6 + $mat[1] * 28) % 1000 ;\n}\nsub ff {\n   my $r = shift ;\n   $r = ($r + 999) % 1000 ;\n   $r = \"0\" . $r while length($r) &lt; 3 ;\n   return $r ;\n}\nfor $c (1..&lt;&gt;) {\n    $n = &lt;&gt; ;\n    print \"Case #$c: \", ff(f($n)), \"\\n\" ;\n}\n</pre>\n\n<h3>Solution C. [the periodicity of 3 digits]</h3>\n<p>\n  For this problem, we have another approach based on the recurrence (7).\n  Notice that we only need to focus on the last 3 digits of X<sub>n</sub>,\n  which only depends on the last 3 digits of the previous two terms. The\n  numbers eventually become periodic as soon as we have (X<sub>i</sub>,\n  X<sub>i+1</sub>) and (X<sub>j</sub>, X<sub>j+1</sub>) with the same last 3\n  digits, where i &lt; j. It is clear that we will enter a cycle no later than\n  10<sup>6</sup> steps.\n  In fact, for this problem, you can write some code and find out that the\n  cycle has the size 100 and starts at the 3rd element in the sequence.\n  So to solve the problem we can just brute force the results for the first 103\n  numbers and if n is bigger than 103 return the result computed for the number\n  (n - 3) % 100 + 3.\n</p>\n\n<h3>Solution D. [the pure quest of numbers and combinatorics]</h3>\n<p>\n  Let us see one more solution of different flavor.\n  Here is a solution not as general as the others, but tailored to this\n  problem, and makes one feel we are almost solving this problem by hand.\n</p><p>\n  Let us look again at (2). We want to know X<sub>n</sub> mod 1000.\n  We know from the\n  <a href=\"http://en.wikipedia.org/wiki/Chinese_remainder_theorem\" target=\"_blank\">chinese remander theorem</a>\n  that if we can find X<sub>n</sub> mod 8 and X<sub>n</sub> mod 125, then\n  X<sub>n</sub> mod 1000 is uniquely determined.<br>\n  <b>(a)</b> For n &gt; 2, X<sub>n</sub> mod 8 is always 0. Since 5<sup>i</sup>\n  &equiv; 1 (mod 4), 3<sup>n-2i</sup> &equiv; 1 or -1 (mod 4) depending on n,\n  so, for n &gt; 2, \n</p>\n<blockquote>\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3LIrQIGmqE6Kwf7KpOpXO0hmLUrz4VB24V7yUg4MuhRIaxeTYhFr_fMbuaQ3li2LuYSohEJ0A/numbersa.png\"/>\n</blockquote>\n<p>\n  <b>(b)</b> To compute X<sub>n</sub> mod 125, we only need to worry about\n  i=0,1,2. All the rest are 0 mod 125. In other words, all we need to compute\n  is\n</p>\n<blockquote>\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2NCted93p8sCVIlHhl3oEW7hLVsp_OCILjBiQlEY6NYe9AutRlOPk1p5yPPEu_gq03BHJulQs/numbersb.png\"/>\n</blockquote> \n<p>\n  There are various ways to compute the elements in the above quantity. The\n  exponents can be computed by fast exponentiation, or using the fact that\n  3<sup>n</sup> mod 125 is periodic with cycle length at most 124. The binomial\n  numbers can be computed using arbitrary precision integers in languages like\n  Java and Python, or with a bit careful programming in languages like C++.\n</p>\n\n<h3>More information:</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=binomial+numbers\" target=\"_blank\">Binomial numbers</a> - \n  <a href=\"http://www.google.com/search?q=linear+recurrence\" target=\"_blank\">Linear recurrence</a> - \n  <a href=\"http://www.google.com/search?q=exponentiation\" target=\"_blank\">Exponentiation</a> - \n  <a href=\"http://www.google.com/search?q=chinese+remainder+theorem\" target=\"_blank\">Chinese remainder theorem</a>\n</p>\n","id":"00000000004329f4","statement":"<h3>Problem</h3>\n<p>\n  In this problem, you have to find the last three digits before the decimal\n  point for the number (3 + &radic;5)<sup><b>n</b></sup>.\n</p><p>\n  For example, when <b>n</b> = 5, (3 + &radic;5)<sup>5</sup> = 3935.73982...\n  The answer is 935.\n</p><p>\n  For <b>n</b> = 2, (3 + &radic;5)<sup>2</sup> = 27.4164079... The answer is\n  027.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>T</b>.\n  <b>T</b> test cases follow, each on a separate line. Each test case contains\n  one positive integer <b>n</b>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each input case, you should output:\n  <pre>Case #<b>X</b>: <b>Y</b></pre>\n  where <b>X</b> is the number of the test case and <b>Y</b> is the last three\n  integer digits of the number (3 + &radic;5)<sup><b>n</b></sup>.\n  In case that number has fewer than three integer digits, add leading zeros so\n  that your output contains exactly three digits.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>T</b> &le; 100\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  2 &le; <b>n</b> &le; 30\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  2 &le; <b>n</b> &le; 2000000000<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 935\nCase #2: 027\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":35}],"title":"Numbers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  In spite of the geometric flavor in the name of this problem, it is truly a\n  story of two arrays.\n</p><p>\n  There are two permutations involved. However, after you fix the permutation\n  for V<sub>1</sub>, you have complete freedom in choosing the permutation for\n  V<sub>2</sub>. It is clear that the first permutation really does not matter.\n  The important thing is which x<sub>i</sub> gets to be matched to which\n  y<sub>j</sub>.\n</p><p>\n  To make thinking easier, we may assume that the first permutation has\n</p>\n<pre>\nx<sub>1</sub> &le; x<sub>2</sub> &le; ... &le; x<sub>n</sub>. (1)\n</pre>\n<p>\n  And our task is to match the y's to the x's so that the scalar product is as\n  small as possible.\n</p><p>\n  At this point, if you need a little exercise in the middle: Think about the\n  case <nobr>n = 2</nobr>, and just use a concrete example. What you will\n  surely discover is that, in order to achieve the minimum scalar product, you\n  always want to match the smaller x<sub>i</sub> with the bigger\n  y<sub>j</sub>.\n</p><p>\n  What we would like to prove is: under condition (1), one of the optimal solutions is of the form\n</p>\n<pre>\n  y<sub>1</sub> &ge; y<sub>2</sub> &ge; ... &ge; y<sub>n</sub>. (2)\n</pre>\n<p>\n  The rigorous proof of (2) is given at the end of this analysis. For an easy\n  reading, we point out that the key step is really the <nobr>n = 2</nobr>\n  case. If x &lt; x' and y &lt; y', then\n</p>\n<pre>\n(xy + x'y') - (xy' + x'y) = (x - x')(y - y') &gt; 0. (*)\n</pre>\n<p>\n  So we prefer to match bigger y's with smaller x's.\n</p><p>\nTherefore, this problem is solved by the following simple algorithm.\n</p>\n<pre>\nsort(v1.begin(), v1.end());\nsort(v2.begin(), v2.end(), greater&lt;int&gt;());\nlong long ret = 0;\nfor (int i = 0; i &lt; n; i++)\n  ret += (long long)(v1[i]) * v2[i];\n</pre>\n<p>\n  <i>Proof of (2).</i> We prove that any permutation that does not satisfy (2)\n  can be transformed into one satisfying (2), and in each step we do not\n  increase the scalar product.<br>\n  Indeed, any unsorted array can be transformed to a sorted one by only\n  interchanging adjacent elements that are out of order. (For more rigorous\n  readers: prove this, maybe by counting the number of flipped pairs in the\n  array.)<br>\n  At each step, some <nobr>x = x<sub>i</sub></nobr> is matched to some <nobr>y,\n  and x' = x<sub>i+1</sub></nobr> is matched to some y' so that <nobr>y &le;\n  y'</nobr>. We interchange y and y' in this step. The inequality similar to\n  (*), with &gt; replaced by &ge;, tells us that the scalar product is not\n  increased in this step. &loz;\n</p>\n\n<h3>More information:</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=scalar+product\" target=\"_blank\">The Scalar product</a>\n</p>\n","id":"0000000000432f33","statement":"<h3>Problem</h3>\n<p>\n  You are given two vectors\n  v<sub>1</sub> = (x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>) and\n  v<sub>2</sub> = (y<sub>1</sub>, y<sub>2</sub>, ..., y<sub>n</sub>). The scalar\n  product of these vectors is a single number, calculated as\n  x<sub>1</sub>y<sub>1</sub> + x<sub>2</sub>y<sub>2</sub> + ... + x<sub>n</sub>y<sub>n</sub>. \n</p><p>\n  Suppose you are allowed to permute the coordinates of each vector as you\n  wish. Choose two permutations such that the scalar product of your two new\n  vectors is the smallest possible, and output that minimum scalar product.\n</p>\n\n<h3>Input</h3>\n  The first line of the input file contains integer number <b>T</b> - the\n  number of test cases. For each test case, the first line contains integer\n  number <b>n</b>. \n  The next two lines contain <b>n</b> integers each, giving the coordinates of\n  v<sub>1</sub> and v<sub>2</sub> respectively.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output a line\n  <pre>Case #<b>X</b>: <b>Y</b></pre>\n  where <b>X</b> is the test case number, starting from 1, and <b>Y</b> is the\n  minimum scalar product of all permutations of the two given vectors.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  <b>T</b> = 1000<br>\n  1 &le; <b>n</b> &le; 8<br>\n  -1000 &le; <b>x</b><sub>i</sub>, <b>y</b><sub>i</sub> &le; 1000\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  <b>T</b> = 10<br>\n  100 &le; <b>n</b> &le; 800<br>\n  -100000 &le; <b>x</b><sub>i</sub>, <b>y</b><sub>i</sub> &le; 100000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\n1 3 -5\n-2 4 1\n5\n1 2 3 4 5\n1 0 1 0 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: -25\nCase #2: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Minimum Scalar Product","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  On the surface, this problem appears to require solving the classic problem\n  \"Satisfiability,\" the canonical example of an NP-complete problem.  The\n  customers represent clauses, the milkshake flavors represent variables, and\n  malted and unmalted flavors represent whether the variable is negated.\n</p><p>\n  We are not evil enough to have chosen a problem that hard!\n  The restriction that makes this problem easier is that the customers can only\n  like at most one malted flavor (or equivalently, the clauses can only have at\n  most one negated variable.)\n</p><p>\n  Using the following steps, we can quickly find whether a solution exists, and\n  if so, what the solution is.\n</p><p>\n  <ol>\n    <li>\n      Start with every flavor unmalted and consider the customers one by one.\n    </li><li>\n      If there is an unsatisfied customer who only likes unmalted flavors, and\n      all those flavors have been made malted, then no solution is possible.\n    </li><li>\n      If there is an unsatisfied customer who has one favorite malted flavor,\n      then we must make that flavor malted.\n      We do this, then go back to step 2.\n    </li><li>\n      If there are no unsatisfied customers, then we already have a valid\n      solution and can leave the remaining flavors unmalted.\n    </li>\n  </ol>\n</p><p>\n  Notice that whenever we made a flavor malted, we were forced to do so.\n  Therefore, the solution we got must have the minimum possible number of\n  malted flavors.\n</p><p>\n  With clever data structures, the above algorithm can be implemented to run in\n  linear time.\n</p>\n\n<h3>More information:</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=Satisfiability+problem\" target=\"_blank\">The Satisfiability problem</a> - \n  <a href=\"http://www.google.com/search?q=Horn+clauses\" target=\"_blank\">Horn clauses</a>\n</p>\n","id":"0000000000433246","statement":"<h3>Problem</h3>\n<p>\n  You own a milkshake shop.\n  There are N different flavors that you can prepare, and each flavor can be\n  prepared \"malted\" or \"unmalted\".\n  So, you can make 2N different types of milkshakes.\n</p><p>\n  Each of your customers has a set of milkshake types that they like, and they\n  will be satisfied if you have at least one of those types prepared.\n  At most one of the types a customer likes will be a \"malted\" flavor.\n</p><p>\n  You want to make N batches of milkshakes, so that:\n</p>\n<ul>\n  <li>\n    There is exactly one batch for each flavor of milkshake, and it is\n    either malted or unmalted.\n  </li><li>\n    For each customer, you make at least one milkshake type that they like.\n  </li><li>\n    The minimum possible number of batches are malted.\n  </li>\n</ul>\n<p>\n  Find whether it is possible to satisfy all your customers given these\n  constraints, and if it is, what milkshake types you should make.\n</p><p>\n  If it is possible to satisfy all your customers, there will be only one\n  answer which minimizes the number of malted batches.\n</p>\n\n<h3>Input</h3>\n<p>\n  One line containing an integer <b>C</b>, the number of test cases in the\n  input file.<br>\n  For each test case, there will be:\n  <ul>\n    <li>\n      One line containing the integer <b>N</b>, the number of milkshake\n      flavors.\n    </li><li>\n      One line containing the integer <b>M</b>, the number of customers.\n    </li><li>\n      <b>M</b> lines, one for each customer, each containing:\n      <ul>\n        <li>\n          An integer <b>T</b> &ge; 1, the number of milkshake types the\n          customer likes, followed by\n        </li><li>\n          <b>T</b> pairs of integers \"<b>X Y</b>\", one for each type the\n          customer likes, where <b>X</b> is the milkshake flavor between\n          <b>1</b> and <b>N</b> inclusive, and <b>Y</b> is either 0 to indicate\n          unmalted, or 1 to indicated malted.\n          Note that:\n          <ul>\n            <li>\n              No pair will occur more than once for a single customer.\n            </li><li>\n              Each customer will have at least one flavor that they like (T\n              &ge; 1).\n            </li><li>\n              Each customer will like at most one malted flavor.\n              (At most one pair for each customer has Y = 1).\n            </li>\n          </ul>\n        </li>\n      </ul>\n      All of these numbers are separated by single spaces.\n    </li>\n  </ul>\n</p>\n\n<h3>Output</h3>\n<p>\n  <b>C</b> lines, one for each test case in the order they occur in the\n  input file, each containing the string \"Case #<b>X</b>: \" where <b>X</b>\n  is the number of the test case, starting from 1, followed by:\n  <ul>\n    <li>\n      The string \"<b>IMPOSSIBLE</b>\", if the customers' preferences cannot\n      be satisfied; <b>OR</b>\n    </li><li>\n      <b>N</b> space-separated integers, one for each flavor from <b>1</b>\n      to <b>N</b>, which are 0 if the corresponding flavor should be\n      prepared unmalted, and 1 if it should be malted.\n    </li>\n  </ul>\n<p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  C = 100<br>\n  1 &le; N &le; 10<br>\n  1 &le; M &le; 100\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  C = 5<br>\n  1 &le; N &le; 2000<br>\n  1 &le; M &le; 2000\n</p><p>\n  The sum of all the <b>T</b> values for the customers in a test case will not\n  exceed 3000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n3\n1 1 1\n2 1 0 2 0\n1 5 0\n1\n2\n1 1 0\n1 1 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1 0 0 0 0\nCase #2: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In the first case, you must make flavor #1 malted, to satisfy the first\n  customer.\n  Every other flavor can be unmalted.\n  The second customer is satisfied by getting flavor #2 unmalted, and the third\n  customer is satisfied by getting flavor #5 unmalted.\n</p><p>\n  In the second case, there is only one flavor.\n  One of your customers wants it malted and one wants it unmalted.\n  You cannot satisfy them both.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Milkshakes","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000004330f6","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
