{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1588419000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000019fef4","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Let's go over the varied set of problems for Round 1C. An <i>Overexcited Fan</i> had\n  to get to an elusive celebrity cat to take a photo before their tour was over.\n  Lovers of unusual problems were over the moon with <i>Overrandomized</i>,\n  which was all about focusing on the right patterns in the data. Finally,\n  <i>Oversized Pancake Choppers</i> was among the more difficult pancake\n  problems we've ever posed; its name is an overt reference to problems in two\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/00000000002017f7\" target=\"_blank\">previous</a>\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000007883\" target=\"_blank\">rounds</a>.\n  With 1C done, the set of Round 1s is over. Hopefully they weren't overly\n  difficult to the point of being overwhelming.\n</p><p>\n  Our first problem had a more straightforward solution than usual, involving\n  simulation. The other two problems were hard enough that only two people solved\n  the full set in under an hour: <b>Rafbill</b> with a penalty time of 35:06, and\n  <b>maroon</b> only four seconds behind that at 35:10. After that, there was a\n  gap until <b>spencercompton</b>, <b>Lutyj</b>, and <b>fedoseev.timofey</b> came\n  in just past the 1 hour mark, with penalty times of 1:00:45, 1:03:37, and\n  1:04:39, respectively. This time, there were just over 50 perfect scores out of\n  over 10000 contestants who submitted. Almost 90% of contestants fully solved the\n  first problem and got their picture with Peppurr!\n</p><p>\n  As usual, we will take some time to review the results, but tentatively, a\n  score of 58, achieved fast enough, is good enough to advance. With so many\n  test sets in this round (9, which was a record for a Round 1), there were\n  many paths to a successful result.\n</p><p>\n  If you are not among the 1500 advancing from Round 1C, or the 3000 who\n  already advanced from Rounds 1A and 1B, your journey is unfortunately over\n  for this year... but we hope that you enjoyed the problems and will continue\n  to <a href=\"https://codingcompetitions.withgoogle.com/codejam/archive\" target=\"_blank\">practice</a>\n  for next year's contest. You can also give\n  <a href=\"http://codingcompetitions.withgoogle.com/kickstart\" target=\"_blank\">Kick Start</a>\n  a try for the rest of this year. For those of you who did advance, we will\n  see you in Round 2 in two weeks for the usual shot at a T-shirt and further\n  Code Jam glory!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Overexcited Fan: Written by the üê± Peppurr Fan Squad üê±: Darcy Best, Timothy\n    Buzzelli, and Max Ward. Prepared by Darcy Best.\n</p><p>\n  Overrandomized: Written by Ian Tullis. Prepared by Pablo Heiber.\n</p><p>\n  Oversized Pancake Choppers: Written by Pablo Heiber. Prepared by Artem\n  Iglikov.\n</p><p>\n  Solutions and other problem preparation and review by Mohamed Yosri Ahmed,\n  Liang Bai, Darcy Best, Timothy Buzzelli, John Dethridge, Md Mahbubul Hasan,\n  Artem Iglikov, Joyce Lee, Archie Pusaka, Pi-Hsun Shih, Sudarsan Srinivasan,\n  and Marten Wiman.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Overexcited Fan: Pablo Heiber.</li>\n  <li>Overrandomized: Pablo Heiber.</li>\n  <li>Oversized Pancake Choppers: Artem Iglikov.</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1588410000000,"tasks":[{"analysis":"<h3>\n  Test set 1\n</h3>\n<p>\n  In the first test set, we are only asked to produce 2 or 3 equal slices. Let us consider these\n  cases separately.\n</p>\n<p>\n  For <b>D</b>=2, if we already have two equal slices, then we don't need any cuts. If no two\n  slices are equal, then we can cut any slice into two equal halves with one cut.\n</p>\n<p>\n  Similarly, for <b>D</b>=3, if we already have three equal slices, then we don't need any cuts.\n  We can also cut any slice into three equal slices with two cuts. The extra case to consider is\n  whether we can do it with a single cut.\n</p>\n<p>\n  If we do only 1 cut we end up with <b>N</b>+1 slices: <b>N</b>-1 original slices and two\n  new slices. Three of them need to be of the same size, so this size has to be equal to the size\n  of at least one uncut slice. We can try all possibilities (up to <b>N</b>) for the target size\n  and all possibilities (up to <b>N</b>) for which slice we cut. If the slice p to be cut is not\n  larger than the target size s, we disregard the case. Otherwise, we cut p into a part of size s\n  and another part of size <b>A<sub>p</sub></b>-s. Then, if there are 3 slices of size s in the set\n  of <b>N</b>+1 slices, it is possible to do it with one cut. If that doesn't happen for any of\n  the considered possibilities, then we definitely need two.\n</p>\n<h3>\n  Test Set 2\n</h3>\n<p>\n  Let's define a <i>fully-usable slice</i> as a slice which we can use fully to produce the slices\n  we need, either by cutting it into 2 to <b>D</b> equal sized slices, or just using it in its\n  entirety as it is. That is, a fully-usable slice is a slice that will leave no further leftovers.\n</p>\n<p>\n  Here is a key observation: for every slice we will produce, we will need to use one cut, except\n  possibly for one slice cut from each fully-usable slice we use. That is, we will need\n  <b>D</b>-K cuts to produce <b>D</b> equal slices, where K is the number of\n  slices used fully.\n</p>\n<p>\n  For example:\n</p>\n<ul>\n  <li>\n    It is always possible to produce <b>D</b> equal slices by cutting any original slice with\n    <b>D</b>-1 cuts (K=1).\n  </li>\n  <li>\n    The best possible case is when we already have <b>D</b> equal original slices, because we make 0\n    cuts (K=<b>D</b>).\n  </li>\n</ul>\n<p>\n  Also notice that we never have to consider K=0, since K=1 is always possible by cutting\n  one original slice into equal pieces, and we want the maximum possible K.\n</p>\n<p>\n  By the observation above, the final size of our produced slices (hereafter the <i>target size</i>)\n  is going to be one of the original sizes (from one of the slices we fully use) divided by an\n  integer between 1 and <b>D</b>. Therefore, we have to check at most <b>N</b>&times;<b>D</b>\n  possible target sizes. With any other size, we would have 0 fully-usable slices.\n</p>\n<p>\n  For each such target slice size, we should do the following:\n</p>\n<ul>\n  <li>\n    First, we ensure that we can actually use it: if the total number of slices of this size\n    that can be produced by cutting all original slices is less than <b>D</b>, then, obviously,\n    this size is not useful for us. A slice of size <b>A<sub>i</sub></b> can be used to produce\n    up to floor(<b>A<sub>i</sub></b>/s) slices of target size s.\n  </li>\n  <li>\n    Then, we need to find all the fully-usable slices: their size is evenly divided by the target\n    slice size, with no remainder.\n  </li>\n  <li>\n    Now, since we need to maximize the number of original slices that are fully-usable, we can\n    use a greedy approach and take those slices one by one in non-decreasing order of size,\n    until we have as many fully-usable original slices as possible (that is, taking the next one\n    would cause us to produce more than <b>D</b> target slices). If we use up all fully-usable\n    original slices, we could use the other non-fully-usable original slices in any order.\n  </li>\n  <li>\n    As per our prior observation, each fully-usable original slice gives us one \"free\"\n    target slice; all other target slices will need a cut each to be produced. That is, the\n    total number of cuts for the current target slice size is <b>D</b> minus K, the number of\n    fully-usable original slices we use.\n  </li>\n</ul>\n<p>\n  The part above can be done in O(<b>N</b>) time if we sort the <b>A<sub>i</sub></b>s once\n  (in non-decreasing order) at the beginning, resulting in an\n  O(<b>D</b>&times;<b>N</b><sup>2</sup>) time complexity for the overall algorithm.\n</p>\n<h3>\n  Test Set 3\n</h3>\n<p>\n  First of all, notice that we can precompute the largest possible target slice size in\n  O(log(max(<b>A<sub>i</sub></b>))&times;<b>N</b>) time with a\n  <a href=\"https://en.wikipedia.org/wiki/Bisection_method\" target=\"_blank\">binary search</a>\n  on the target size. Then, we can save some time by not considering any target slice sizes\n  that are greater than the calculated limit.\n</p>\n<p>\n  Now, as in the solution for Test Set 2, we iterate through the <b>A<sub>i</sub></b>s\n  (in non-decreasing order) and all numbers of cuts c (1 to <b>D</b>). Instead of doing an\n  additional pass through <b>N</b> original slices as in the solution for Test Set 2, we can\n  just mark this original slice as a fully-usable slice for target size <b>A<sub>i</sub></b>/c.\n  To do that efficiently, we use a dictionary (ideally implemented as a hash table)\n  where the keys are valid target sizes, and the values are tuples containing\n  the number of fully-usable slices found so far for that target size, and the number of target\n  slices produced from them. Notice that the keys are fractions; to ensure that we do not\n  represent the same fraction in multiple ways, we can use an algorithm to find\n  <a href=\"https://en.wikipedia.org/wiki/Greatest_common_divisor\" target=\"_blank\">greatest common divisors</a>\n  and ensure that all fractions are reduced.\n</p><p>\n  For each target size <b>A<sub>i</sub></b>/c we add 1 and c to the corresponding dictionary values\n  for key <b>A<sub>i</sub></b>/c (assuming the default value for an unset key is zero). If after\n  this operation the number of produced target slices of size <b>A<sub>i</sub></b>/c would exceed\n  <b>D</b>, we should just not consider that slice as fully-usable for this case.\n</p>\n<p>\n  Then we can choose the maximum possible number M of fully-used slices across all valid target\n  slices, and the result is <b>D</b>-M. This improves the time complexity of the algorithm to\n  O(<b>D</b>&times;<b>N</b>).\n</p>\n","id":"00000000003172d1","statement":"<h3>Problem</h3>\n<p>\n  You just showed up to your job as the head chef of the Infinite House of\n  Pancakes, and as usual, you found a disaster in progress! The other chefs\n  accidentally created some enormous circular pancakes, all of the same size.\n  These pancakes are too large to serve whole, so they have already started to\n  chop them up into <i>slices</i> (which, in this problem, are\n  <a href=\"https://en.wikipedia.org/wiki/Circular_sector\" target=\"_blank\">circular sectors</a>).\n  You currently have <b>N</b> slices, the i-th of which is a sector\n  with an internal (central) angle of <b>A<sub>i</sub></b> nanodegrees\n  (a nanodegree is 10<sup>-9</sup> degrees).\n</p><p>\n  You have <b>D</b> diners waiting for their food. Each diner wants a single\n  slice that is the same size as every other diner's slice, although they do\n  not care what that size is. But it may not be possible to do this using the\n  current slices, so you may need to make one or more radial <i>cuts</i>.\n</p><p>\n  A cut changes an existing slice with internal angle X into two new slices\n  with internal angles Y and X - Y. You can do this for any 0 &lt; Y &lt; X,\n  and these values do not need to be integers. You may apply further cuts to\n  either or both of these new slices, and so on.\n</p><p>\n  It is OK to have one or more leftover slices (of any size) that are not\n  given to the diners; you can eat those later, since this disaster is making\n  you miss your own breakfast!\n</p><p>\n  Determine the smallest total number of cuts you need to make to satisfy the\n  diners.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with one line containing two\n  integers <b>N</b> and <b>D</b>: the number of slices you currently have and\n  the number of diners. Then, there is one more line containing <b>N</b>\n  integers <b>A<sub>1</sub></b>, <b>A<sub>2</sub></b>, ...,\n  <b>A<sub>N</sub></b>; the i-th of these represents the internal angle\n  (in nanodegrees) of the i-th slice.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the smallest number of cuts you need, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>A<sub>i</sub></b> &lt; 360 &times; 10<sup>9</sup>, for all i.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  Time limit: 20 seconds.<br/>\n  1 &le; <b>N</b> &le; 300.<br/>\n  2 &le; <b>D</b> &le; 3.<br/>\n</p>\n\n<h4>Test Set 2 (Visible Verdict)</h4>\n<p>\n  Time limit: 20 seconds.<br/>\n  1 &le; <b>N</b> &le; 300.<br/>\n  2 &le; <b>D</b> &le; 50.<br/>\n</p>\n\n<h4>Test Set 3 (Hidden Verdict)</h4>\n<p>\n  Time limit: 60 seconds.<br/>\n  For exactly 21 cases, 9000 &le; <b>N</b> &le; 10000.<br/>\n  For exactly <b>T</b>-21 cases, 1 &le; <b>N</b> &le; 1000.<br/>\n  2 &le; <b>D</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 3\n1\n5 2\n10 5 359999999999 123456789 10\n2 3\n8 4\n3 2\n1 2 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 0\nCase #3: 1\nCase #4: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, you only have one tiny slice to start with. The optimal\n  solution is to use one cut to change it into two slices with angles of 1/3\n  nanodegree and 2/3 nanodegrees, and then further cut the latter slice into\n  two more slices with angles of 1/3 nanodegree.\n</p><p>\n  In Sample Case #2, you already have two slices of the same size, so you can\n  give those to the two diners, and you do not need to make any cuts.\n</p><p>\n  In Sample Case #3, the optimal solution is to cut the slice with internal\n  angle 8 nanodegrees in half. After that operation, you have exactly 3 slices\n  of internal angle 4 nanodegrees, with no leftovers.\n</p><p>\n  In Sample Case #4, remember that every diner must receive a single slice.\n  You cannot give one diner the \"3\" slice and the other diner the \"1\" and \"2\"\n  slices, even though the total areas are the same. You must make at least one\n  cut in this case to satisfy the requirements.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":1,"type__str":"VISIBLE","value":16},{"type":2,"type__str":"HIDDEN","value":16}],"title":"Oversized Pancake Choppers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\nIn Test Set 1, we can try every possible path we can take. During any given minute we have 5\noptions: walk a block in one of the 4 directions, or stay still. Since Peppurr's tour is at\nmost 8 minutes long, we can only walk for at most 8 minutes.\nThat is at most 5<sup>8</sup> possibilities, which is a pretty small\nnumber for a computer. For each combination, we simulate our own path and Peppurr's path,\nrecording any encounters. After trying all possibilities, the solution is\n<code>IMPOSSIBLE</code> if we did not record any encounters, or the earliest time of those\nif we did.\n</p>\n<h3>Test Set 2</h3>\n<p>\nIn Test Set 2, just as in Test Set 1, Peppurr's tour will remain within a single north-south\nstreet. Notice that if we want to meet Peppurr at an intersection (a, b), the order in which\nwe walk the blocks doesn't matter as long as we walk east a times more than west and north b\ntimes more than south. So we may assume that we can finish all of our eastward walking, for\nexample, before walking in any other direction. This means an optimal strategy can begin with\n<b>X</b> blocks of walking east. After that, we are in the same north-south street as Peppurr,\nso we can walk towards the tour until we meet or we are just 1 block away, in which case we\nneed to stand still for 1 minute to avoid crossing paths with the tour in the middle of a\nblock.\n</p>\n<h3>Test Set 3</h3>\n<p>\nFor Test Set 3, we can simulate Peppurr's tour. If after R minutes it is X<sub>R</sub> blocks to\nthe east of us and Y<sub>R</sub> blocks to the north (X<sub>R</sub> and Y<sub>R</sub> can be\nnegative to represent being west or south), we only need to check whether we can reach that\nintersection in R minutes. Fortunately, this is easy to check: the intersection is reachable in\nR minutes or less if and only if |X<sub>R</sub>| + |Y<sub>R</sub>| &le; R. That is, the\nintersection must be within an\n<a href=\"https://en.wikipedia.org/wiki/Taxicab_geometry\" target=\"_blank\">L1 distance</a>\n(also known as Manhattan Distance) of R.\n</p><p>\nTherefore, we can solve the problem by simulating Peppurr's path, and for the i-th intersection\nvisited, check if it's reachable in i minutes. If it is, then i is the answer; otherwise, we\nneed to keep looking. If none of the intersections is reachable within the required time, we\nanswer <code>IMPOSSIBLE</code>.\n</p>\n","id":"0000000000317409","statement":"<h3>Problem</h3>\n<p>\n  Today <i>will</i> be the day&mdash;today will be the day that you finally\n  get a picture with Peppurr the cat!\n</p><p>\n  It has just been announced that Peppurr will be touring your city. The city has infinitely\n  many infinitely-long streets running north-south and infinitely many infinitely-long streets\n  running east-west. An intersection is any point at which a north-south street and an\n  east-west street meet. From any given intersection, the closest intersection in each of the\n  four directions (north, east, south and west) is exactly one block away.\n</p><p>\n  You know the exact path that Peppurr's tour will take along those streets.\n  Your goal is to be at one of the intersections on Peppurr's tour at the same time that\n  Peppurr is there, and you want to do so as fast as possible. This is how you will\n  get your picture with Peppurr!\n</p><p>\n  Peppurr's tour starts at an intersection that is <b>X</b> blocks east and <b>Y</b>\n  blocks north of the intersection where you are currently located. Both you and Peppurr\n  take exactly one minute to walk one full block, and must finish each minute at an\n  intersection; neither of you can walk partial blocks.\n</p><p>\n  Peppurr moves along a predefined path. Every minute, you can\n  choose to stand still for the minute, or use it to walk a single block in any of\n  the 4 directions (north, east, south or west). Both you and Peppurr only walk along the\n  streets.\n</p><p>\n  If you and Peppurr are at the same intersection at the same time, you can take\n  a picture, even at the last intersection of the tour. However, Peppurr is unavailable\n  for pictures after the tour ends, so arriving at the tour's final intersection\n  even a single minute after the tour finishes means you will not get a picture.\n</p><p>\n  Is it possible to get a picture with Peppurr? If so, how soon can you do it?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case consists of one line containing two\n  integers, <b>X</b> and <b>Y</b>, and a string of characters <b>M</b>.\n  This represents that Peppurr's tour starts exactly <b>X</b> blocks east\n  and <b>Y</b> blocks north of you. The string <b>M</b> is the sequence\n  of moves that Peppurr will make.\n  The i-th character in <b>M</b> is one of <code>N</code>,\n  <code>E</code>, <code>S</code> or <code>W</code>, and corresponds to the\n  direction (north, east, south, or west, respectively) in which Peppurr will\n  walk one block during the tour's i-th minute.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line with <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1). If there is no way\n  to get a picture with Peppurr, <code>y</code> is <code>IMPOSSIBLE</code>. Otherwise,\n  <code>y</code> is the smallest number of minutes from the start of the tour needed\n  to get a picture with Peppurr.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  (<b>X</b>, <b>Y</b>) &ne; (0, 0). (The tour does not start in the same intersection as you.)<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  0 &le; <b>X</b> &le; 10.<br/>\n  0 &le; <b>Y</b> &le; 10.<br/>\n  1 &le; length of <b>M</b> &le; 8.<br/>\n  Each character in <b>M</b> is an uppercase letter &mdash;\n      either <code>N</code> or <code>S</code>.<br/>\n</p>\n\n<h4>Test Set 2 (Visible Verdict)</h4>\n<p>\n  0 &le; <b>X</b> &le; 1000.<br/>\n  0 &le; <b>Y</b> &le; 1000.<br/>\n  1 &le; length of <b>M</b> &le; 1000.<br/>\n  Each character in <b>M</b> is an uppercase letter &mdash;\n      either <code>N</code> or <code>S</code>.<br/>\n</p>\n\n<h4>Test Set 3 (Visible Verdict)</h4>\n<p>\n  0 &le; <b>X</b> &le; 1000.<br/>\n  0 &le; <b>Y</b> &le; 1000.<br/>\n  1 &le; length of <b>M</b> &le; 1000.<br/>\n  Each character in <b>M</b> is an uppercase letter &mdash;\n      either <code>N</code>, <code>E</code>, <code>S</code> or <code>W</code>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n4 4 SSSS\n3 0 SNSS\n2 10 NSNNSN\n0 1 S\n2 7 SSSSSSSS\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: IMPOSSIBLE\nCase #3: IMPOSSIBLE\nCase #4: 1\nCase #5: 5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, you can walk east four blocks and you will be able to take a picture\n  with Peppurr on the tour's last intersection.\n</p><p>\n  In Sample Case #2, the tour starts off exactly three blocks to the east of you. No matter how\n  you move, you cannot get a picture with Peppurr.\n</p><p>\n  In Sample Case #3, the tour is too far north for you to get the picture before the tour ends.\n</p><p>\n  In Sample Case #4, the tour will come to you after one minute, so you don't even have to move!\n  Enjoy the picture with Peppurr! Remember that you can only take pictures in intersections,\n  so if you moved north while the tour moved south, which would cause you to cross paths\n  with Peppurr outside of an intersection, you could not get your picture in 0.5 minutes.\n</p><p>\n  In Sample Case #5, you can move north twice, then east twice. Then, you can stay still\n  and you will be able to take a picture with Peppurr in the next minute. There are other\n  paths you can take which can get you a picture with Peppurr in 5 minutes, but none which\n  can do it sooner than that.\n</p><p>\n  The following two cases could not appear in Test Set 1 or Test Set 2, but could appear in Test\n  Set 3:\n</p>\n<pre>\n2\n3 2 SSSW\n4 0 NESW\n</pre>\n<p>\n  The correct output for these two cases would be:\n</p>\n<pre>\nCase #1: 4\nCase #2: 4\n</pre>\n<p>\n  Note that in Case #1, you can take a picture with Peppurr one block to the south\n  and two blocks to the east of your original starting point.\n</p><p>\n  In Case #2, Peppurr travels in a small square. You can take a picture when Peppurr\n  returns to the starting point of that square.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":4},{"type":1,"type__str":"VISIBLE","value":6},{"type":1,"type__str":"VISIBLE","value":12}],"title":"Overexcited Fan","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\nIn Test Set 1, the range for possible M values is so small compared to the number of records\nthat each combination (M<sub>i</sub>, N<sub>i</sub>) has a somewhat large probability\n1 / (99 &times; M<sub>i</sub>) of appearing as a particular record, and an even larger probability\nof being present as at least one record.\n</p><p>\nSuppose there exists at least one record with M<sub>i</sub> = N<sub>i</sub> = x for each x in\nthe range 1 through 9. From the record with M<sub>i</sub> = N<sub>i</sub> = 1 we know that the\nonly letter in <b>R<sub>i</sub></b> represents 1. Then, from all the records with\nM<sub>i</sub> = 2, we can discard the ones where <b>R<sub>i</sub></b> represents 1. The leftovers\nmust be the ones with M<sub>i</sub> = N<sub>i</sub> = 2, and in those, the only letter in\n<b>R<sub>i</sub></b> represents 2. In general, after we have decoded the letters for 1 through x,\nwe can take the records with M<sub>i</sub> = x + 1 and discard the ones with letters in\n<b>R<sub>i</sub></b> that are already assigned, and the <b>R<sub>i</sub></b> values of the\nremaining records will contain the letter that should be assigned to x + 1. Finally, the only\nremaining unassigned letter should be assigned to 0.\n</p><p>\nThis process works as long as records with M<sub>i</sub> = N<sub>i</sub> = x exist\nfor each x in the range 1 through 9. The probability of that happening is hard to calculate, but\nthe least likely of those combinations is M<sub>i</sub> = N<sub>i</sub> = 9, with a probability of\nonly 1 / (99 &times; 9) per record. The probability of that appearing at least once in 10000\nrecords is greater than 99.999%. The smaller values of x have even higher probability. Of course, the\nprobability of all 9 coexisting is smaller than that, and the probability of that happening in all\n10 cases is even smaller, but still decent enough. In addition, there is a really small probability\nthat the letter representing 0 doesn't appear at all in the input, but if that were the case, no\nalgorithm could find it. Given that this is a Visible Verdict test set, we can give the solution a\ntry, and confirm that it passes.\n</p><p>\nThere are additional heuristics we could add to the algorithm. For example, if we can't find the\nvalue for 9 in this way and we need to distinguish the two remaining letters to assign to 9 and 0,\njust having a record whose <b>R<sub>i</sub></b> starts with one of the letters is enough to know\nthat that one should be a 9, since 0 cannot be a leading digit. This further increases the\nprobability of the method working. We can add more and more heuristics to cover the remaining\ncases, but at some point it's easier to just try something more general.\n</p>\n<h3>Test Set 2</h3>\n<p>\nIn Test Set 2, the probability of M<sub>i</sub> being a single digit is small, and we cannot\nrely on that happening, let alone several times and with extra conditions. However, we can treat\nrecords that have M<sub>i</sub> and <b>R<sub>i</sub></b> of the same length similarly, by simply\nusing their first letters and then using those (digit, letter) pairs as we did in the solution for\nTest Set 1.\n</p>\n<h3>Test Set 3</h3>\n<p>\nAt this point, it seems like we may have to throw all of the above insights away, because they are\nall predicated on knowing M<sub>i</sub>. However, the \"use the leading digit/letter\" insight we\nused to solve Test Set 2 is actually the first step toward solving Test Set 3 as well.\n</p><p>\nIn Test Set 3, each record's information comes from a single integer, not two, so we cannot use\nthe association between the two parts as before. We can start by checking the distribution used\nto generate the only piece of information we have. The probability of any particular N<sub>i</sub>\nbeing equal to x is the sum of 10<sup>-16</sup> / y for y in [x, 10<sup>16</sup> - 1], which\ncan be approximated by 10<sup>-16</sup> (ln 10<sup>16</sup> - ln x). In other words, the\nprobability is decreasing in x. Because of this, leading digits are more likely to be smaller\nthan larger. Moreover, even though the decrease in probability between the actual result being\nx and x + 1 is small, the decrease in probability between the leading digit being d and d + 1 is\nlarge, because it aggregates the differences between the probability of dS being more than\nthe probability of (d+1)S for each possible suffix S.  This is a version of\n<a href=\"https://en.wikipedia.org/wiki/Benford%27s_law\" target=\"_blank\">Benford's law</a>.\n</p><p>\nTherefore, a possible solution is to calculate the frequency with which each letter appears as a\nleading digit, and assign the highest frequency to 1, the second highest to 2, etc. The only letter\nthat never appears as a leading digit, and therefore has the minimum frequency, should be assigned\nto the digit 0.\n</p>\n","id":"00000000003179a1","statement":"<h3>Problem</h3>\n<p>\n<i>Note:</i> Every time this statement says something is randomly chosen, it means\n\"chosen uniformly at random across all valid possibilities, and independently from all other\nchoices\".\n</p><p>\nThe company Banana Rocks Inc. just wrote a premium cloud-based random number generation service\nthat is destined to be the new gold standard of randomness.\n</p><p>\nThe original design was that a group of servers would receive a request in the form of a single\npositive integer M of up to <b>U</b> decimal digits and then respond with an integer\nfrom the range 1 through M, inclusive, chosen at random.\nHowever, instead of simply having the output written with digits 0 through 9 as usual, the\nservers were \"overrandomized\". Each server has a random subset of 10 distinct uppercase English\nletters to use as digits, and a random mapping from those letters to unique values between\n0 and 9.\n</p><p>\nThe formal description of the current situation is as follows: each server has a\n<i>digit string</i> D composed of exactly 10 different uppercase English letters.\nThe digit string defines the mapping between letters and the base 10 digits:\nD's j-th character from the left (counting from 0) is the base 10 digit of value j.\nFor example, if D were <code>CODEJAMFUN</code> then <code>C</code> would represent\ndigit 0, <code>O</code> would represent digit 1 and <code>N</code> would represent\ndigit 9. The number 379009 would be encoded as <code>EFNCCN</code> when using that\ndigit string.\n</p><p>\nWhen receiving the i-th query with an integer parameter M<sub>i</sub>, the server:\n<ul>\n  <li>chooses an integer N<sub>i</sub> at random from\n    the inclusive range 1 through M<sub>i</sub>,</li>\n  <li>writes it as a base 10 string with no leading zeroes using the\nj-th character of D (counting starting from 0) as the digit of value j, and</li>\n  <li>returns the resulting string as the response <b>R<sub>i</sub></b>.</li>\n</ul>\n</p><p>\nWe collected some data that we believe we can use to recover the secret digit string D\nfrom each server. We sent 10<sup>4</sup> queries to each server. For each query, we chose a\nvalue M<sub>i</sub> at random from the range 1 through 10<sup><b>U</b></sup> - 1,\ninclusive, and received the response <b>R<sub>i</sub></b>, a string of up to <b>U</b>\nuppercase English letters.\nWe recorded the pairs (M<sub>i</sub>, <b>R<sub>i</sub></b>).\nAs we were moving these records to a new data storage device, the\nvalues of all the integers M<sub>i</sub> within the records of some servers became\ncorrupted and unreadable.\n</p><p>\nCan you help us find each server's digit string D?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.\n<b>T</b> test cases follow. Each test case contains the records for one server\nand starts with a line containing a single integer <b>U</b>,\nrepresenting that 10<sup><b>U</b></sup> - 1 is the inclusive upper bound for the\nrange in which we chose the integers M<sub>i</sub> to query that server.\nThen, exactly 10<sup>4</sup> lines follow. Each of these\nlines contains an integer <b>Q<sub>i</sub></b> (in base 10 using digits 0 through 9, as usual)\nand a string <b>R<sub>i</sub></b>, representing the i-th query and response, respectively.\nIf <b>Q<sub>i</sub></b> = -1, then the integer M<sub>i</sub> used for the i-th query is unknown.\nOtherwise, <b>Q<sub>i</sub></b> = M<sub>i</sub>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing\n<code>Case #x: y</code>, where <code>x</code>\nis the test case number (starting from 1) and <code>y</code> is the digit string D\nfor the server examined in test case <code>x</code>.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 10.<br/>\nD is a string of exactly 10 different uppercase English letters, chosen independently and\nuniformly at random from the set of all such strings.<br/>\nM<sub>i</sub> is chosen independently and uniformly at random from the range 1 through\n10<sup><b>U</b></sup> - 1, inclusive, for all i.<br/>\nN<sub>i</sub> is chosen independently and uniformly at random from the range 1 through\nM<sub>i</sub>, inclusive, for all i.<br/>\n<b>R<sub>i</sub></b> is the base 10 representation of N<sub>i</sub>, using the j-th digit from\nthe left of D (counting starting from 0) as the digit of value j, for all i.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n<b>Q<sub>i</sub></b> = M<sub>i</sub>, for all i.<br/>\n<b>U</b> = 2.<br/>\n</p>\n\n<h4>Test Set 2 (Visible Verdict)</h4>\n<p>\n<b>Q<sub>i</sub></b> = M<sub>i</sub>, for all i.<br/>\n<b>U</b> = 16.<br/>\n</p>\n\n<h4>Test Set 3 (Visible Verdict)</h4>\n<p>\n<b>Q<sub>i</sub></b> = -1, for all i.<br/>\n<b>U</b> = 16.<br/>\n</p>\n\n<p>\nThe sample input is too big to display inline, so we are providing downloadable files instead\nfor the <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3sgKw-FVCLP0ClFMX1484IHg3-r1ITmCyC1YZEdiANMyy7RXkYb0A9CToG8vuo3kkIYS9okN0/sample.in.txt?dl=1\" target=\"_blank\" download=\"sample.in.txt\">input</a> and\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2gBpYYOcA-6JHJ-hZbvZKIE1hdDbVxBp3mCGnf4FdP3oYH_NdbkZGk3SC81S6YdFyuzBVO6Lro/sample.out.txt?dl=1\" target=\"_blank\" download=\"sample.out.txt\">output</a>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":1,"type__str":"VISIBLE","value":10},{"type":1,"type__str":"VISIBLE","value":17}],"title":"Overrandomized","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000019fef4","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2020"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
