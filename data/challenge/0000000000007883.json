{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1523676600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000007883","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  We must have been hungry when we designed the problems for Round 1A!\n  <i>Waffle Choppers</i> was a slight twist on our usual pancake theme, and it\n  may have looked a bit easier than it really was. <i>Bit Party</i> paid\n  homage to a certain Canadian treat, and could be solved by using binary search\n  in the right way. Finally, <i>Edgy Baking</i> was a problem about cutting\n  cookies, but that didn't mean that contestants had to write a \"cookie-cutter\"\n  solution! A dynamic programming approach was possible, but there were other\n  possible strategies as well; see our analysis for an interesting one.\n</p><p>\n  Some of our contestants gobbled up these problems rather quickly! vepifanov\n  submitted three correct solutions for a perfect score and the lowest penalty\n  time (34 minutes and 36 seconds). Well over 400 contestants achieved perfect\n  scores!\n</p><p>\n  Under the new Code Jam 2018 rules, 1500 contestants advance from each of the\n  round 1s; the cutoff for this round ended up being 50 points plus enough\n  speed. Those top 1500 contestants from this round are (provisionally) on to\n  Round 2! For everyone else, there are still two more chances to advance:\n  Round 1B and Round 1C.\n  Check out our schedule,\n  and mark your calendars!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Waffle Choppers: Written by Pablo Heiber and Ian Tullis. Prepared\n  by Micah Stairs.\n</p><p>\n  Bit Party: Written by Pablo Heiber. Prepared by Jonathan Irvin\n  Gunawan.\n</p><p>\n  Edgy Baking: Written by Kevin Tran. Prepared by Micah Stairs.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Shane Carr,\n  Md Mahbubul Hasan, Roman Obukhivskyi, Ray Robinson, and Regis Schiavi.\n</p>\n<p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Waffle Choppers: Ian Tullis</li>\n  <li>Bit Party: Jonathan Irvin Gunawan</li>\n  <li>Edgy Baking: Ragnar Groot Koerkamp, Kevin Tran, and Ian Tullis</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1523667600000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  We might consider enumerating all the ways of assigning bits to cashiers,\n  but with 20 bits and 5 cashiers, there could be as many as 5<sup>20</sup>\n  ways &mdash; too many to check! We need to take advantage of the fact that the\n  bits are interchangeable, and instead find all the ways to <i>partition</i>\n  <b>B</b> bits among <b>R</b> of the <b>C</b> cashiers (since we will only be\n  able to use as many cashiers as we have robots). Then, we can compute how\n  much time each of those ways takes, and pick the minimum of those values.\n</p><p>\n  We can calculate the number of ways to partition 20 bits among 5 robots using\n  <a href=\"https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)\">this method</a>.\n  It turns out there are only (24 choose 4) = 10,626 ways to check. If we have\n  fewer robots than cashiers, then we need to introduce another multiplicative\n  factor of (<b>C</b> choose <b>R</b>), but this cannot be larger than 10 in\n  test set 1. Each check takes O(<b>R</b>) time, which is very small given that\n  <b>R</b> is at most 5. So, test set 1 should be solvable well within the 15\n  second time limit, regardless of your language choice.\n</p>\n\n<h3>Test set 2</h3>\n<p>\n  To solve this test set, we need to be able to answer the following question:\n  Given a time limit T, is there a possible assignment of bits such that all the\n  robots can finish interacting with their cashiers in no more than T seconds?\n  Let f(T) be the answer to this question.\n</p>\n<p>\n  How can we find f(T)? The maximum number of bits that the i-th cashier can\n  process in not more than T seconds is max(0, min(<b>M</b><sub>i</sub>,\n  floor((T - <b>P</b><sub>i</sub>) / <b>S</b><sub>i</sub>))).\n  Let us call this value Capacity<sub>i</sub>.\n</p>\n<p>\n  Then, we want to know whether a total of <b>B</b> bits can be assigned to\n  <b>R</b> robots, and each of those robot to a cashier, such that the number of\n  bits processed by the i-th cashier is not more than Capacity<sub>i</sub>. To\n  do this, we can greedily sort the Capacity values into nonincreasing order,\n  and then assign the <b>R</b> robots to the first <b>R</b> cashiers. f(T) is\n  true if and only if the total number of bits that can be processed by the\n  first <b>R</b> cashiers is at least <b>B</b>. Therefore, we can compute the\n  value of f(T) for any T in O(<b>C</b> log(<b>C</b>)) time (which is the time\n  it takes to sort the Capacity values). (Aside: We can even avoid the sort,\n  and instead partition in O(<b>C</b>) time, by using introselect, for example.)\n</p>\n<p>\n  Since we want to minimize the time taken for all robots to interact with their\n  cashiers, we want to find the minimum possible value of T such that f(T) is\n  true. That value of T will also satisfy the following:\n  <ul>\n    <li>f(x) is false for all x &lt; T.</li>\n    <li>f(x) is true for all x &ge; T.</li>\n  </ul>\n  Therefore, we can find the value of T using binary search. Since the maximum\n  answer will not be more than\n  O(max(<b>S</b>) &times; <b>B</b> + max(<b>P</b>)), this solution will run in\n  O(<b>C</b> log(<b>C</b>) log(max(<b>S</b>) &times; <b>B</b> + max(<b>P</b>)))\n  time.\n</p>\n","id":"000000000002fff6","statement":"<h3>Problem</h3>\n<p>\n  These days, robots can drive cars, but can they throw a good party? The Code\n  Jam team's research into this topic is still at an early stage. We just\n  deployed <b>R</b> robot shoppers to our local supermarket to buy party\n  supplies for our World Finals in Toronto, but their first-order model of a\n  Canadian party was very simple: they just bought <b>B</b> \"bits\" (a bit being\n  a small donut-like treat found in the area). We will work on improving their\n  AI later, but for now, we want to help them purchase all of those bits as\n  quickly as possible.\n</p><p>\n  The supermarket has <b>C</b> cashiers who can scan customers' purchases. The\n  i-th cashier will:\n</p>\n<ul>\n  <li>accept a maximum of <b>M<sub>i</sub></b> items per customer</li>\n  <li>take <b>S<sub>i</sub></b> seconds to scan each item</li>\n  <li>spend a further <b>P<sub>i</sub></b> seconds handling payment and\n    packaging up the bits.</li>\n</ul>\n<p>\n  That is, a customer who brings N bits to the i-th cashier (where N must be\n  less than or equal to <b>M<sub>i</sub></b>) will spend a total of\n  <b>S<sub>i</sub></b> &times; N + <b>P<sub>i</sub></b> seconds interacting\n  with that cashier.\n</p><p>\n  Before the robots interact with any cashiers, you will distribute the bits\n  among the robots however you want. (Bits must remain intact; you cannot\n  break them up into fractional pieces!) Any robot that gets no bits will not\n  get to interact with a cashier, and will go away disappointed.\n</p><p>\n  Then, for each robot with at least one bit, you will choose a\n  <i>different</i> single cashier. (Two robots cannot use the same cashier, and\n  a robot cannot use more than one cashier.) The robots all start interacting\n  with their cashiers at time 0. Note that once a robot finishes interacting\n  with its cashier, it cannot be given more bits and cannot interact with other\n  cashiers.\n</p><p>\n  If you help the robots make optimal choices, what is the earliest time at\n  which all of the robots can finish interacting with their cashiers?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with three integers\n  <b>R</b>, <b>B</b>, and <b>C</b>: the numbers of robot shoppers, bits, and\n  cashiers. Then, there are <b>C</b> more lines. The i-th of these represents\n  the i-th cashier, and it has three integers <b>M<sub>i</sub></b>,\n  <b>S<sub>i</sub></b>, and <b>P<sub>i</sub></b>: the maximum number of bits,\n  scan time per bit (in seconds), and payment/packaging time (in seconds) for\n  that cashier, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the earliest time (in seconds) at which all robots can finish interacting\n  with their cashiers.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>M<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n  1 &le; <b>S<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n  1 &le; <b>P<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n  The sum of the <b>R</b> largest values of <b>M<sub>i</sub></b> &ge;\n    <b>B</b>. (It is possible for at least one subset of <b>R</b> cashiers to\n    handle all of the bits.)<br/>\n  Time limit: 15 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>R</b> &le; <b>C</b> &le; 5.<br/>\n  1 &le; <b>B</b> &le; 20.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>R</b> &le; <b>C</b> &le; 1000.<br/>\n  1 &le; <b>B</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">3\n2 2 2\n1 2 3\n1 1 2\n2 2 2\n1 2 3\n2 1 2\n3 4 5\n2 3 3\n2 1 5\n2 4 2\n2 2 4\n2 5 1\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: 5\nCase #2: 4\nCase #3: 7\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  In Sample Case #1, there are two robots, two bits, and two cashiers, and\n  each cashier can only handle one item. So, you must give one bit to each\n  robot. Cashier 1 takes 5 seconds, and Cashier 2 takes 3 seconds, so the time\n  required is 5 seconds.\n</p><p>\n  Sample Case #2 is similar to the previous case, except that now Cashier 2\n  can handle up to 2 items. So, it is best to give all the bits to one robot\n  and have that robot use Cashier 2. This takes 1 second per item plus 2\n  seconds = 4 seconds.\n</p><p>\n  In Sample Case #3, the optimal strategy is to send one robot with 2 bits to\n  cashier 2, and two robots with 1 bit each to any of the other cashiers.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Bit Party","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Cookie-cutting</h3>\n<p>\n  A cookie with width W and height H has a perimeter of 2 &times; (W + H). If\n  we make a straight cut of length C that divides the cookie in half, each\n  piece will have one side of length C, and the remaining sides of the pieces\n  will represent the perimeter of the original cookie. So, after cutting, we\n  will have a combined perimeter X = 2 &times; (W + H + C).\n</p><p>\n  Clearly X is smallest when we leave the cookie alone. However, if we want to\n  minimize X given that we are making a cut, we must minimize C; no cut can be\n  smaller than the smallest of W and H, so we should cut through the midpoints\n  of the two larger sides, which gives the cut a size of the smaller of the two\n  sides. Then X = 2 &times; (W + H + min(W, H)). On the other hand, if we want\n  to make a cut that maximizes X, we must maximize C by cutting through two\n  opposite corners of the cookie. Then C = sqrt(W<sup>2</sup> + H<sup>2</sup>),\n  so X = 2 &times; (W + H + sqrt(W<sup>2</sup> + H<sup>2</sup>)). If we start\n  our cut somewhere between one of those larger-side midpoints and a corner, we\n  will get a value of X somewhere between these two extremes; since we can cut\n  anywhere we want in that interval, we can get any intermediate value of X\n  that we want.\n</p><p>\n  So, depending on what we do with our cookie, its contribution to our overall\n  perimeter sum will either be 2 &times; (W + H), or a value in the range\n  2 &times; (W + H) + [2 &times; min(W, H), 2 &times; sqrt(W<sup>2</sup> +\n  H<sup>2</sup>)]. From now on, we will abbreviate the extremes of that range\n  as [L, R]. (We could divide all values in the problem by 2 as well, removing\n  that factor, but we will retain it in this analysis for clarity.)\n</p>\n<h3>Test set 1</h3>\n<p>\n  In test set 1, all of the cookies have the same dimensions; we will call them\n  W and H. Let us define P' as <b>P</b> - 2 &times; (W + H) &mdash; that is, the\n  amount of extra perimeter that we need to add to reach the target <b>P</b>.\n  So, we can reformulate the problem as starting with a total perimeter of 0,\n  and trying to reach P'. For each cookie, we can choose to either not cut it,\n  which leaves our total perimeter unchanged, or cut it, which increases our\n  total perimeter by some value of our choice in the range [L, R]. If we cut K\n  cookies, then our total perimeter can be anywhere in the range [K &times; L,\n  K &times; R], depending on how we make our cuts. We will think in terms of\n  this range and not in terms of the individual cuts.\n</p><p>\n  How many cookies should we cut? Of course, we should never cut so many that\n  K &times; L exceeds P'. However, we might as well keep cutting cookies up\n  until that point, since doing so both moves our range closer to the target and\n  makes the range wider. So, we can solve for X in the equation X &times; L =\n  P', and then choose K to be the floor of X &mdash; that is, floor(P' / L).\n  (Since L is an integer representing one of the original side lengths, and P'\n  is also guaranteed to be an integer, we should use integer-based division\n  here to avoid the usual problems with flooring floating-point numbers!)\n</p><p>\n  Then, we can check whether the range [K &times; L, K &times; R] includes P'.\n  If it does, the answer is 0; otherwise, it is P' minus the right end of the\n  range, i.e., P' - K &times; R. Even though R is generally not an integer, we\n  do not need to worry about floating-point issues; even if P' is very close to\n  K &times; R and we mistakenly conclude that it is not in the range, we will\n  still get an answer that is sufficiently close to 0 under our floating point\n  rules.\n</p>\n<h3>Test set 2</h3>\n<p>\n  In test set 2, different cookies might have different dimensions, so we get\n  different total ranges depending on which ones we cut. We have no a priori\n  basis for deciding which cookies to cut, and we cannot directly check all\n  2<sup>100</sup> possibilities, but we can use\n  <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\" target=\"_blank\">dynamic programming</a>\n  to ensure that we find the best possibility without explicitly checking them\n  all; the problem is very similar to the\n  <a href=\"https://en.wikipedia.org/wiki/Knapsack_problem\" target=\"_blank\">knapsack problem</a>.\n  For each cookie, we are deciding whether to leave it as is, or cut it, which\n  adds L to our total perimeter and gives us up to R - L units of additional\n  \"slack\". Once we have finished deciding which cookies to cut, we can include\n  as much or as little of this \"slack\" as we want. All other things being\n  equal, having more slack is always better for us. The large limit on <b>P</b>\n  may seem daunting, but you can convince yourself that the problem space is\n  actually small enough for methods like this to work.\n</p><p>\n  However, the problem can also be solved in a different way. As in the previous\n  solution, each cookie corresponds to a range [L, R] by which we can increase\n  the total perimeter if we decide to cut that cookie. Let S(K) be the list of\n  intervals we can reach after processing the first K cookies.  We start with\n  S(0) = {[0, 0]}.\n</p><p>\n  When we consider the K'th cookie, we can choose to cut it or not. Suppose\n  that this cookie corresponds to the interval [L, R]. If we do not cut it, we\n  can obtain any perimeter that is already in an interval in S(K - 1). If we do\n  cut it, we can reach any interval in the set S' given by S' =\n  {[l + L, r + R] : [l, r] is an interval in S(K - 1)}.\n</p><p>\n  To get S(K), we first take the union of S(K - 1) and S', followed by merging\n  overlapping intervals. For example, if S(K - 1) = {[0, 0], [3, 6]}, and we\n  add the interval [L, R] = [1, 2], we obtain S' = {[1, 2], [4, 8]} and S(K) =\n  {[0, 0], [1, 2], [3, 8]}. Note that the intervals [3, 6] from S(K - 1) and\n  [4, 8] from S' merge into a single interval [3, 8] here.\n</p><p>\n  We can drop any intervals that start after P', so that after processing all N\n  cookies, the answer to the question will be the distance from P' to the last\n  interval.\n</p><p>\n  Without any further analysis, we might expect the size of S(<b>N</b>) to be\n  2<sup><b>N</b></sup>, as it could double in each step. It turns out that we\n  can provide a much stronger bound of (log(P') / log(sqrt(2))) + 1.\n</p><p>\n  We first need the observation that any interval [L, R] corresponding to a\n  cookie will satisfy R &ge; sqrt(2) &times; L, where equality holds for a\n  square. Using induction, we can infer that every interval [l, r] in each S(K)\n  also satisfies r &ge; sqrt(2) &times; l.\n</p><p>\n  The second observation is that all intervals in S(N) are disjoint. Let us now\n  sort intervals in S(N) and enumerate them starting from [l<sub>0</sub>,\n  r<sub>0</sub>]=[0, 0]. Then the observations together imply that\n  l<sub>{i+1}</sub> &gt; r<sub>i</sub> &ge; sqrt(2) &times; l<sub>i</sub>.\n  Since the lower bound of each interval is an integer, we also have\n  l<sub>1</sub> &ge; 1. Hence we have l<sub>i</sub> &ge; sqrt(2)<sup>i-1</sup>.\n  Since we can discard any intervals starting after P', we may assume that\n  l<sub>i</sub> &le; P'. We conclude that there are at most (log(P') /\n  log(sqrt(2))) + 1 intervals in S(<b>N</b>).\n</p><p>\n  This solution takes O(<b>N</b> log(P')) time: for each of the <b>N</b>\n  cookies, we have to perform one merging step that takes O(|S(K)|) time.\n</p><p>\n  It can also be shown that |S(K)| &le; 2K + 1. We leave this as an exercise to\n  the reader!\n</p>\n","id":"000000000002fff7","statement":"<h3>Problem</h3>\n<p>\n  The baker Mr. Maillard has rolled out some cookie dough and cut it up to\n  create <b>N</b> cookies, each of which is a rectangle. He was just about to\n  put them in the oven when he remembered that the crispy, caramelized edges of\n  cookies taste particularly delicious. Specifically, he thinks he would be\n  happiest if the sum of the perimeters of all the cookies were as close as\n  possible to <b>P</b> millimeters (mm), without going over. (If the batch of\n  cookies is <i>too</i> edgy, it might burn!)\n</p><p>\n  For each cookie, Mr. Maillard can decide whether to leave it as is, or make a\n  single straight cut to separate it into two (not necessarily rectangular)\n  halves with equal area. (Note that such a cut must necessarily go through the\n  center of the cookie.) The two new cookies created in this way cannot\n  themselves be cut again.\n</p><p>\n  If Mr. Maillard makes optimal decisions, what is the closest he can come to\n  <b>P</b> without exceeding it?\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with two integers\n  <b>N</b> and <b>P</b>: the number of cookies, and the desired perimeter sum\n  (in mm), respectively. Then, <b>N</b> lines follow. The i-th of these has two\n  integers <b>W<sub>i</sub></b> and <b>H<sub>i</sub></b>: the width and height\n  (both in mm) of the i-th cookie.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is a real number: the largest possible sum (in mm) of the perimeters of all\n  cookies (after Mr. Maillard is done cutting) that does not exceed <b>P</b>.\n  <code>y</code> will be considered correct if it is within an absolute or\n  relative error of 10<sup>-6</sup> of the correct answer. See the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a>\n  for an explanation of what that means, and what formats of real numbers we\n  accept.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>N</b> &le; 100.<br/>\n  1 &le; <b>W<sub>i</sub></b> &le; 250, for all i.<br/>\n  1 &le; <b>H<sub>i</sub></b> &le; 250, for all i.<br/>\n  <b>P</b> &ge; 2 &times; the sum of (<b>W<sub>i</sub></b> +\n  <b>H<sub>i</sub></b>) over all i. (<b>P</b> is at least as large as the\n  sum of the perimeters of all cookies before any cuts are made.)<br/>\n  <b>P</b> &le; 10<sup>8</sup>.<br/>\n  Time limit: 15 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>W<sub>i</sub></b> = <b>W<sub>j</sub></b>, for all i and j.<br/>\n  <b>H<sub>i</sub></b> = <b>H<sub>j</sub></b>, for all i and j.<br/>\n  (All of the provided cookies have the same dimensions.)<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  No additional limits beyond the general ones. (In particular, the provided\n  cookies do not all necessarily have the same dimensions.)\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 7\n1 1\n2 920\n50 120\n50 120\n1 32\n7 4\n3 240\n10 20\n20 30\n30 10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 6.828427\nCase #2: 920.000000\nCase #3: 32.000000\nCase #4: 240.000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Note that the last sample case would not appear in test set 1.\n</p><p>\n  In Sample Case #1, there is only one cookie, and it is a square with side\n  length 1. Mr. Maillard can cut from one corner to a diagonally opposite\n  corner, which creates two right triangles, each of which has side lengths 1,\n  1, and sqrt(2). Then the perimeter sum is 4 + 2 &times; sqrt(2); this is\n  smaller than <b>P</b> = 7, but it is not possible to get any closer.\n</p><p>\n  In Sample Case #2, Mr. Maillard can cut the first cookie along its longer\n  axis to create two new 25 x 120 rectangles, and leave the second cookie\n  alone. The total perimeter is then 580 + 340 = 920, which is exactly\n  <b>P</b>.\n</p><p>\n  In Sample Case #3, Mr. Maillard can cut the cookie to make two trapezoids,\n  each of which has side lengths of 2, 4, 5, and 5. Then the new perimeter sum\n  is 32, which is exactly <b>P</b>.\n</p><p>\n  In Sample Case #4, the initial perimeter sum is exactly <b>P</b>, so Mr.\n  Maillard should not make any cuts.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":29}],"title":"Edgy Baking","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  In test set 1, we are asked to make only one horizontal cut and only\n  one vertical cut. There are <b>R</b> - 1 possible horizontal cuts and\n  <b>C</b> - 1 possible vertical cuts, so there are a total of (<b>R</b> - 1)\n  &times; (<b>C</b> - 1) different ways to make the two cuts. Since <b>R</b>\n  and <b>C</b> are both at most 10, there are at most 81 ways, and we can\n  try each one of them separately. For each way, we can count up the chocolate\n  chips in each of the four resulting pieces. If we ever find a way in which\n  that number is the same for all four pieces, the answer is\n  <code>POSSIBLE</code>; otherwise, it is <code>IMPOSSIBLE</code>.\n</p>\n<h3>Test set 2</h3>\n<p>\n  In test set 2, we may have to make many horizontal and vertical cuts,\n  and there are too many ways to do this to check. The worst cases occur when\n  <b>H</b> is close to half of (<b>R</b> - 1), and <b>V</b> is close to half of\n  (<b>C</b> - 1); there could be over 10<sup>57</sup> ways of making the cuts!\n  So we need another approach.\n</p><p>\n  Let us consider only the horizontal cuts, ignoring the vertical cuts for the\n  moment. These horizontal cuts break the waffle into two or more horizontal\n  \"slices\". Each of these slices will turn into exactly <b>V</b> + 1 pieces\n  when we make our vertical cuts. Here is the critical observation: if the\n  case is <code>POSSIBLE</code>, all of those pieces must have exactly the\n  same number of chips, and since each horizontal slice will produce exactly\n  the same number of pieces, all of those horizontal slices must have exactly\n  the same number of chips. Moreover, we know exactly what that number is; if\n  there are a total of C chips in the waffle, each of the <b>H</b> + 1\n  horizontal slices must have exactly C / (<b>H</b> + 1) chips, or else the\n  case is <code>IMPOSSIBLE</code>.\n</p><p>\n  This observation is so powerful that it tells us where we have to make the\n  cuts if the case is <code>POSSIBLE</code>! We can make a list of the numbers\n  of chips in each row, then turn that list into a cumulative sum of the total\n  number of chips seen so far. For example, for a waffle with seven rows\n  containing 3, 7, 6, 2, 2, 0, and 10 chips, respectively, the cumulative sum\n  list would be: [3, 10, 16, 18, 20, 20, 30]. In that example, if <b>H</b> = 2,\n  we know we have to make cuts immediately below rows that bring the total sum\n  to 10 and 20, and we can do so by cutting immediately below the second and\n  fifth rows. (Note that we could instead make our second cut below the sixth\n  row, but this would make no difference.) If <b>H</b> = 1, though, we need to\n  make our one cut immediately below a row that brings the total sum to 15, and\n  there is no such row. So, after this step, either we will know that the case\n  is <code>IMPOSSIBLE</code>, or we will know exactly where to make our\n  horizontal cuts.\n</p><p>\n  Then, we can consider only vertical cuts, using a similar method, and either\n  learn where to make them, or learn that the case is <code>IMPOSSIBLE</code>.\n  Even if we know where to make the horizontal and vertical cuts, though, we\n  are not done yet! These cuts might not actually create pieces with the same\n  number of chips. For example, for <b>H</b> = 1, <b>V</b> = 1, and this\n  waffle:\n</p>\n<code>\n  ..@@<br/>\n  ..@@<br/>\n  @@..<br/>\n  @@..<br/>\n</code>\n<p>\n  we will learn that if the case is <code>POSSIBLE</code>, we must make our\n  horizontal cut below the second row, and our vertical cut to the right of\n  the second column. But this creates two pieces with four chips each and two\n  pieces with no chips at all, so the case must be <code>IMPOSSIBLE</code>.\n</p><p>\n  To check that each piece has the same number of chips, we can start by\n  turning the list of horizontal cuts into a list of intervals; for example,\n  if we cut below the second and fifth rows in the [3, 10, 16, 18, 20, 20, 30]\n  example from above, then we have the inclusive intervals [1, 2], [3, 5], and\n  [6, 7]. We can do the same for the vertical cuts, and then perform a double\n  iteration over these two sets of intervals, checking each cell within each\n  pair of intervals. We know that each piece must have exactly (total # of\n  chips) / ((<b>H</b> + 1) &times; (<b>V</b> + 1)) chips if the case is\n  <code>POSSIBLE</code>, so if we ever find a slice in which this is not true,\n  the case is <code>IMPOSSIBLE</code>. Otherwise, we have finally shown that\n  the case really is <code>POSSIBLE</code>. (Once again, note that even if we\n  had a choice of where to make one or more of our cuts, this must have been\n  due to empty rows or columns, which do not influence the number of chips in\n  each piece.)\n</p><p>\n  (There are other ways to check the pieces; for example, we can make one\n  pass through the data, and, for each cell, calculate the number of chocolate\n  chips in the rectangle that has that cell as its lower right corner, and\n  the upper left corner of the waffle as its upper left corner. Then, to find\n  the number of chips in a certain piece, we can add and subtract the\n  appropriate rectangles from this set.)\n</p><p>\n  In summary, this algorithm involves several steps:\n</p>\n<ol>\n  <li>Create the row and column sum arrays. We can either make two separate\n    passes through every cell of the waffle, or make one pass and create both\n    arrays at once.</li>\n  <li>Convert the sum arrays into cumulative sum arrays.</li>\n  <li>Check the cumulative sum arrays to find our places to cut.</li>\n  <li>Use the cumulative sum arrays to create interval arrays.</li>\n  <li>Make one pass through every cell of the waffle in a directed way, using\n    the interval arrays, to check whether every piece has the same number of\n    chips.</li>\n</ol>\n<p>\n  Steps 1 and 5 above involve looking at each of the <b>R</b> &times; <b>C</b>\n  cells of the waffle, whereas steps 2, 3, and 4 only involve looking at\n  <b>R</b> or <b>C</b> values. So steps 1 and 5 dominate the running time,\n  which is O(<b>R</b> &times; <b>C</b>). (We could not have done better than\n  this anyway, since we clearly have to look at each cell of the waffle at\n  least once to solve the problem.)\n</p>\n","id":"000000000003005a","statement":"<h3>Problem</h3>\n<p>\n  The diners at the Infinite House of Pancakes have gotten tired of circular\n  pancakes, so the chefs are about to offer a new menu option: waffles! As a\n  publicity stunt, they have made one large waffle that is a grid of square\n  cells with <b>R</b> rows and <b>C</b> columns. Each cell of the waffle is\n  either empty, or contains a single chocolate chip.\n</p><p>\n  Now it is time for the chefs to divide up the waffle among their hungry\n  diners. A <i>horizontal cut</i> runs along the entire gridline between two\n  of the rows; a <i>vertical cut</i> runs along the entire gridline between\n  two of the columns. For efficiency's sake, one chef will make exactly\n  <b>H</b> different horizontal cuts and another chef will make exactly <b>V</b>\n  different vertical cuts. This will conveniently create one piece for each of\n  the (<b>H</b> + 1) &times; (<b>V</b> + 1) diners. The pieces will not\n  necessarily all be of equal sizes, but that is fine; market research has\n  shown that the diners do not care about that.\n</p><p>\n  What the diners do care about is the number of chocolate chips they get, so\n  each piece must have exactly the same number of chocolate chips. Can you\n  determine whether the chefs can accomplish this goal using the given numbers\n  of horizontal and vertical cuts?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>;\n  <b>T</b> test cases follow. Each begins with one line containing four\n  integers <b>R</b>, <b>C</b>, <b>H</b>, and <b>V</b>: the number of rows and\n  columns in the waffle, and the exact numbers of horizontal and vertical cuts\n  that the chefs must make. Then, there are <b>R</b> more lines of <b>C</b>\n  characters each; the j-th character in the i-th of these lines represents the\n  cell in the i-th row and the j-th column of the waffle. Each character is\n  either <code>@</code>, which means the cell has a chocolate chip, or\n  <code>.</code>, which means the cell is empty.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1) and\n  <code>y</code> is <code>POSSIBLE</code> if the chefs can accomplish the goal\n  as described above, or <code>IMPOSSIBLE</code> if they cannot.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 6 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  2 &le; <b>R</b> &le; 10.<br/>\n  2 &le; <b>C</b> &le; 10.<br/>\n  <b>H</b> = 1.<br/>\n  <b>V</b> = 1.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  2 &le; <b>R</b> &le; 100.<br/>\n  2 &le; <b>C</b> &le; 100.<br/>\n  1 &le; <b>H</b> &lt; <b>R</b>.<br/>\n  1 &le; <b>V</b> &lt; <b>C</b>.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">6\n3 6 1 1\n.@@..@\n.....@\n@.@.@@\n4 3 1 1\n@@@\n@.@\n@.@\n@@@\n4 5 1 1\n.....\n.....\n.....\n.....\n4 4 1 1\n..@@\n..@@\n@@..\n@@..\n3 4 2 2\n@.@@\n@@.@\n@.@@\n3 4 1 2\n.@.@\n@.@.\n.@.@\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: POSSIBLE\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\nCase #4: IMPOSSIBLE\nCase #5: POSSIBLE\nCase #6: IMPOSSIBLE\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  Note that the last two sample cases would not appear in test set 1.\n</p><p>\n  In Sample Case #1, one possible strategy is to make the horizontal cut between\n  the second and third rows from the top, and make the vertical cut between the\n  fourth and fifth columns from the left. That creates the following pieces,\n  each of which has exactly two chocolate chips:\n<p><code>\n    .@@. .@<br/>\n    .... .@<br/>\n    <br/>\n    @.@. @@<br/>\n</code></p>\n<p>\n  In Sample Case #2, no matter where you make the horizontal cut and the\n  vertical cut, you will create pieces with unequal numbers of chocolate chips,\n  so the case is impossible.\n</p><p>\n  In Sample Case #3, there are no chocolate chips in the waffle. Any cutting\n  strategy creates pieces which have the same number of chocolate chips (zero),\n  so the diners are happy... but maybe not as happy as they would have been if\n  they had gotten chocolate chips!\n</p><p>\n  In Sample Case #4, just as in Sample Case #2, you cannot succeed regardless\n  of where you make your horizontal cut and your vertical cut.\n</p><p>\n  In Sample Case #5, the chefs can make the only two possible horizontal cuts,\n  and make the two vertical cuts to the right of the first and third columns.\n</p><p>\n  Although Sample Case #6 would be possible for other numbers of horizontal and\n  vertical cuts, remember that you must use exactly <b>H</b> horizontal cuts\n  and exactly <b>V</b> vertical cuts. No matter where you make your one\n  horizontal cut and two vertical cuts, you cannot succeed.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":16}],"title":"Waffle Choppers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000007883","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2018"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
