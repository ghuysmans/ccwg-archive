{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1217095200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432bd2","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  The second subround of Google Code Jam 2008 Round 1, consisted of three\n  problems.\n</p><p>\n  The first problem is a combination of geometry and combinatorics principles\n  and was a bit on the hard side for the 15 points it was valued at.\n</p><p>\n  The second problem was a blend between the Sieve of Erastosthenes and data structures.\n</p><p>\n  The third problem was based on a classic solitaire\n  <a href=\"http://mathworld.wolfram.com/Mousetrap.html\" target=\"_blank\">card game</a>.\n  This one occurs to many as a standard exercise in data structures, like\n  interval trees. However, here we will include a clever, simple solution that\n  suits this problem very well.\n</p><p>\n  This time, 39 contestants succeded in solving every input correctly from a\n  total of 1715 who solved at least one dataset. The fastest to solve all tests\n  was bmerry who took less than an hour!\n</p>\n\n<hr>\n<p>\n  <b>Credits</b>\n</p><p>\n  Problem A. <i>Crop Triangles</i>\n  Written and prepared by Cosmin Negruseri.\n</p><p>\n  Problem B. <i>Number Sets</i>\n  Written by John Dethridge. Prepared by Marius Andrei and John Dethridge.\n</p><p>\n  Problem C. <i>Mousetrap</i>\n  Written by Jonathan Wills. Prepared by Frank Chu.\n</p><p>\n  Contest analysis presented by Cosmin Negruseri, Xiaomin Chen, and John\n  Dethridge.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1217088000000,"tasks":[{"analysis":"<p>\n  The small case was easy to solve using brute force. For each combination of\n  three points you needed to test if the center had integer coordinates.\n  One tricky part was generating the sequence of points, since using 32-bit\n  integers would have resulted in overflow when doing multiplications. One way\n  to get around that problem was to use 64-bit integers.\n</p><p>\n  The observation that helps in solving the large case is that we don't care\n  about the range of the coordinates for the points in the input. We only care\n  about the coordinates modulo 3.\n  We have 9 different classes of points. In bucket[i] we will count the number\n  of points for which <nobr>x % 3 = i / 3</nobr> and <nobr>y % 3 = i %\n  3</nobr>. There are three different ways of choosing 3 points out of the 9\n  classes of points: three points from the same class, two points from the same\n  class and one from a different class and three points from three different\n  classes.\n</p><p>\n  If the three points are in the same class then it's obvious that the center\n  will have integer coordinates. It is easy to see that there is no triangle\n  with two points in the same class and one point in a different class.\n</p>\n\n<p>\n  Here is some code that implements this idea:\n</p>\n<pre>\n    for (int i = 0; i &lt; n; i++) {\n      bucket[((int)X0 % 3) * 3 + (int)Y0 % 3]++;\n      X0 = (A * X0 + B) % M;\n      Y0 = (C * Y0 + D) % M;\n    }\n\n    // The first case.\n    for (int i = 0; i &lt; 9; i++)\n      // We use the formula for n choose 3 so that,\n      // we don't use the same point twice or count\n      // the same triangle more than once.\n      ret += bucket[i] * (bucket[i]-1) * (bucket[i]-2) / 6;\n\n    // The third case.\n    for (int i = 0; i &lt; 9; i++)\n      for (int j = i + 1; j &lt; 9; j++)\n        for (int k = j + 1; k &lt; 9; k++)\n          if (((i / 3) + (j / 3) + (k / 3)) % 3 == 0) &amp;&amp;\n              ((i % 3) + (j % 3) + (k % 3)) % 3 == 0)\n            ret += bucket[i] * bucket[j] * bucket[k];\n    cout &lt;&lt; \"Case #\" &lt;&lt; prob++ &lt;&lt; \": \" &lt;&lt; ret &lt;&lt; endl;\n</pre>\n","id":"0000000000432a7e","statement":"<h3>Problem</h3>\n<p>\n  Some pranksters have watched too much Discovery Channel and now they want to\n  build a crop triangle during the night. They want to build it inside a large\n  crop that looks like an evenly spaced grid from above. There are some trees\n  planted on the field.\n  Each tree is situated on an intersection of two grid lines (a grid point).\n  The pranksters want the vertices of their crop triangle to be located at\n  these trees.\n  Also, for their crop triangle to be more interesting they want the\n  <i>center</i> of that triangle to be located at some grid point as well.\n  We remind you that if a triangle has the vertices (x<sub>1</sub>,\n  y<sub>1</sub>), (x<sub>2</sub>, y<sub>2</sub>) and (x<sub>3</sub>,\n  y<sub>3</sub>), then the center for this triangle will have the coordinates\n  ((x<sub>1</sub> + x<sub>2</sub> + x<sub>3</sub>) / 3, (y<sub>1</sub> +\n  y<sub>2</sub> + y<sub>3</sub>) / 3).\n</p><p>\n  You will be given a set of points with integer coordinates giving the\n  location of all the trees on the grid.\n  You are asked to compute how many triangles you can form with <b>distinct</b>\n  vertexes in this set of points so that their center is a grid point as well\n  (i.e. the center has integer coordinates).  \n</p><p>\n  If a triangle has area 0 we will still consider it a valid triangle.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>N</b>.\n  <b>N</b> test cases follow. Each test case consists of one line containing\n  the integers <b>n</b>, <b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>,\n  <b>x<sub>0</sub></b>, <b>y<sub>0</sub></b> and <b>M</b> separated by exactly\n  one space. <b>n</b> will be the number of trees in the input set.\n  Using the numbers <b>n</b>, <b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>,\n  <b>x<sub>0</sub></b>, <b>y<sub>0</sub></b> and <b>M</b> the following\n  pseudocode will print the coordinates of the trees in the input set.\n  <i>mod</i> indicates the remainder operation.\n</p><p>\n  The parameters will be chosen such that the input set of trees will not have\n  duplicates.\n</p>\n<code><pre>\n<b>X</b> = <b>x<sub>0</sub></b>, <b>Y</b> = <b>y<sub>0</sub></b>\nprint <b>X</b>, <b>Y</b>\nfor i = 1 to <b>n</b>-1\n  <b>X</b> = (<b>A</b> * <b>X</b> + <b>B</b>) mod <b>M</b>\n  <b>Y</b> = (<b>C</b> * <b>Y</b> + <b>D</b>) mod <b>M</b>\n  print <b>X</b>, <b>Y</b>\n</pre></code>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>X</b>: \" where\n  <b>X</b> is the test case number (starting from 1).\n  This should be followed by an integer indicating the number of triangles\n  which can be located at 3 distinct trees and has a center that is a grid\n  point.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>N</b> &le; 10,<br>\n  0 &le; <b>A</b>, <b>B</b>, <b>C</b>, <b>D</b>, <b>x<sub>0</sub></b>,\n  <b>y<sub>0</sub></b>&le; 10<sup>9</sup>,<br>\n  1 &le; <b>M</b> &le; 10<sup>9</sup>.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  3 &le; <b>n</b> &le; 100.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  3 &le; <b>n</b> &le; 100000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n4 10 7 1 2 0 1 20\n6 2 0 2 1 1 2 11\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In the first test case, the 4 trees in the generated input set are (0, 1),\n  (7, 3), (17, 5), (17, 7).\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Crop Triangles","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This problem describes a process where integers are grouped into sets, and\n  then we are asked how many sets there are in the final result.\n</p><p>\n  The process described is fairly slow:\n</p>\n<ul>\n  <li>\n    Create singleton sets of integers.\n  </li><li>\n    Take each pair of integers;\n  </li><li>\n    factor the two integers and see if they have a prime factor in common that\n    is greater than or equal to P;\n  </li><li>\n    if so, merge the sets that have these two integers.\n  </li>\n</ul>\n<p>\nWe need to find the result of this process using a faster method.  A few\nobservations help here.\n</p><p>\n  Firstly, we only need to find prime factors less than the size of the\n  interval.\n  If a prime is larger than or equal to the size of the interval, then at most\n  one integer in the interval can have that prime as a factor, so it will never\n  be used to merge sets.\n</p><p>\n  Secondly, we can take a faster approach than finding the prime factors of\n  each integer separately.\n  Instead we consider each prime in turn and find all the integers in the\n  interval which have this prime as a factor, a technique generally called a\n  <i>sieve</i>.\n</p><p>\n  Thirdly, joining sets can be implemented efficiently with a data structure\n  called <i>union-find</i> (or the <i>disjoint sets data structure</i>).\n  As we consider each prime and find all of the integers with that prime as a\n  factor, we join all of the sets containing those integers.  We could also\n  build an undirected graph with nodes for the integers in the interval and the\n  primes, and edges representing which integers are divisible by which primes;\n  then the final sets are the connected components of this graph.\n</p>\n\n<h3>More information:</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=prime+sieving\" target=\"_blank\">Prime sieving</a> -\n  <a href=\"http://www.google.com/search?q=Union-Find\" target=\"_blank\">Union-Find</a> -\n  <a href=\"http://www.google.com/search?q=undirected+graph+connected+components\" target=\"_blank\">Connected components</a>\n</p>\n","id":"0000000000432acf","statement":"<h3>Problem</h3>\n<p>\n  You start with a sequence of consecutive integers. You want to group them\n  into sets.\n</p><p>\n  You are given the interval, and an integer <b>P</b>.\n  Initially, each number in the interval is in its own set.\n</p><p>\n  Then you consider each pair of integers in the interval.\n  If the two integers share a prime factor which is at least <b>P</b>, then you\n  merge the two sets to which the two integers belong.\n</p><p>\n  How many different sets there will be at the end of this process?\n</p>\n\n<h3>Input</h3>\n<p>\n  One line containing an integer <b>C</b>, the number of test cases in the input file.\n</p><p>\n  For each test case, there will be one line containing three\n  single-space-separated integers <b>A</b>, <b>B</b>, and <b>P</b>.\n  <b>A</b> and <b>B</b> are the first and last integers in the interval, and\n  <b>P</b> is the number as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing the string \"Case #X: Y\" where\n  X is the number of the test case, starting from 1, and Y is the number of\n  sets.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>C</b> &le; 10<br>\n  1 &le; <b>A</b> &le; <b>B</b> &le; 1000<br>\n  2 &le; <b>P</b> &le; <b>B</b>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>C</b> &le; 100<br>\n  1 &le; <b>A</b> &le; <b>B</b> &le; 10<sup>12</sup><br>\n  <b>B</b> &le; <b>A</b> + 1000000<br>\n  2 &le; <b>P</b> &le; <b>B</b>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n10 20 5\n10 20 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 9\nCase #2: 7\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Number Sets","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  In this nice problem, there are two viewpoints one can start with.\n</p>\n<ul>\n  <li>\n    The current position is fixed and the array of cards is rotating each time.\n  </li><li>\n    Think of the cards as a fixed ring (represented byan array) and the current\n    position in focus as a pointer moving on the ring.\n  </li>\n</ul>\n<p>\n  For most of us (and our programs), it is more convenient to adopt the second\n  viewpoint.\n</p><p>\n  After reading the story, it is not hard to see that the task is clear: put\n  card 1 in the first position, then for each card i (in the order 2, 3, ...,\n  <b>K</b>), we start from the current position, and find the i-th empty spot\n  to the right, wrap around as many times as necessary, then put card i there.\n</p><p>\n  The problem is to simulate the process described above. What makes it\n  interesting is that <b>K</b> can be as big as 1000000, which makes the naive\n  <nobr>&Theta;(<b>K</b><sup>2</sup>)</nobr> simulation too slow for our\n  8-minute time limit. For each step, we need to compute the next position much\n  faster than <nobr>&Theta;(<b>K</b>)</nobr> as in the naive approach. We\n  describe three solutions below.\n</p>\n\n<h3>Solution A.</h3>\n<p>\n  Let <nobr><b>S</b> = &radic;<b>K</b></nobr>, we partition the <b>K</b>\n  positions into <b>S</b> intervals of roughly equal size (also <b>S</b>). In\n  addition to bookkeeping which positions are occupied (an array of size\n  <b>K</b>, we call the first level counter), we also count for each interval\n  how many positions are occupied (an array of size <b>S</b> that we call the\n  second level counter).\n  With this information, we may skip intervals of length <b>S</b> as many as\n  possible, until we arrive at an interval where we know the card must belong\n  to.  Then in that interval we only need to deal with at most <b>S</b> first\n  level counters.\n</p><p>\n  Once we put down a card, it is a simple matter to update the counters. We\n  only need to update one on the first level and one on the second level.\n</p><p>\n  This solution runs in time <nobr>O(<b>K</b><sup>1.5</sup>)</nobr>.\n</p>\n\n<h3>Solution B.</h3>\n<p>\n  Push the idea in the previous solution further. Why not have more levels of\n  counters?\n  In fact, one nice plan is to organize the levels into a binary tree. On the\n  bottom (first) level of the tree we have each position as a separate\n  interval. Every time we go up one level, we combine every other interval with\n  the next one. Thus we will have log<b>K</b> levels; the top level being a\n  single interval with all the positions. We omit the details, since we will\n  see this again in the analysis of a Round 1C problem.\n  We mention that the total number of counters is <nobr>O(<b>K</b>)</nobr>, and\n  for each card we will need O(log <b>K</b>) time to find the position and\n  another <nobr>O(log <b>K</b>)</nobr> time to update the counters. The running\n  time of this method is <nobr>O(<b>K</b> log <b>K</b>)</nobr>.\n</p><p>\n  For similar ideas in computer science, we refer to the Wiki page for\n  <a href=\"http://en.wikipedia.org/wiki/Interval_tree\" target=\"_blank\">interval trees</a>.\n</p>\n\n<h3>Solution C.</h3>\n<p>\n  Now let us do something different. At each step, after one position is\n  occupied by card number i, we delete the position from the deck.\n</p><p>\n  Notice that <b>n</b>, the number of queries is at most 100. We do not need to\n  relabel all the positions, it is enough to do this for those <b>n</b> that we\n  are interested in.\n</p><p>\n  The solution can be implemented in two flavors, based on which viewpoint in\n  the beginning of the analysis you pick. The short C++ program is, again,\n  based on the second one, where the position (pos) changes as a pointer, and\n  the deck does not move, except we delete one position in each step.\n</p>\n<pre>\nfor (int j = 0; j &lt; n; j++) answers[j] = -1;\nfor (int i = 1, pos = 0; i &lt;= K; i++) {\n  // Compute the next position, after wrap-around.\n  pos = (pos + i - 1) % (K - i + 1);\n  for (int j = 0; j &lt; n; j++)\n  if (answers[j] &lt; 0) {\n    if (queries[j] == pos+1) {\n      queries[j] = -1; answers[j] = i;\n    } else if (queries[j] &gt; pos+1) {\n      // The effect of deleting the next position.\n      queries[j]--; \n    }\n  }\n}\n</pre>\n<p>\n  You can use a trick to combine the two arrays queries[] and answers[] into\n  one. The programs runs in <nobr>&Theta;(<b>n K</b>)</nobr> time.\n</p>\n\n<h3>More information:</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=interval+tree\" target=\"_blank\">Interval trees</a>\n</p>\n","id":"0000000000433082","statement":"<h3>Problem</h3>\n<p>\n  Mousetrap is a simple card game for one player.  It is played with a shuffled\n  deck of cards numbered 1 through <b>K</b>, face down.\n  You play by revealing the top card of the deck and then putting it on the\n  bottom of the deck, keeping count of how many cards you have revealed.  If\n  you reveal a card whose number matches the current count, remove it from the\n  deck and reset the count.\n  If the count ever reaches <b>K</b>+1, you have lost.  If the deck runs out of\n  cards, you win.\n</p><p>\n  Suppose you have a deck of 5 cards, in the order 2, 5, 3, 1, 4.\n  You will reveal the 2 on count 1, the 5 on count 2, then the 3 on count 3.\n  Since the value matches the count, you remove the 3 from the deck, and reset\n  the count.  You now have 4 cards left in the order 1, 4, 2, 5.  You then\n  reveal the 1 on count 1, and remove it as well (you're doing great so far!).\n  Continuing in this way you will remove the 2, then the 4, and then finally\n  the 5 for victory.\n</p><p>\n  You would like to set up a deck of cards in such a way that you will win the\n  game and remove the cards in increasing order.  We'll call a deck organized\n  in this way \"perfect.\"\n  For example, with 4 cards you can organize the deck as 1, 4, 2, 3, and you\n  will win by removing the cards in the order 1, 2, 3, 4.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>T</b>.\n  Each test case starts with a line containing <b>K</b>, the number of cards in\n  a deck.\n  The next line starts with an integer <b>n</b>, which is followed by <b>n</b>\n  integers (<b>d</b><sub>1</sub>,<b>d</b><sub>2</sub>, ...), indices into the\n  deck.\n</p>\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>x</b>: \" followed by\n  <b>n</b> integers (<b>k</b><sub>1</sub>,<b>k</b><sub>2</sub>, ...), where\n  <b>k</b><sub>i</sub> is the value of the card at index <b>d</b><sub>i</sub>\n  of a perfect deck of size <b>K</b>.\n  The numbers in the output should be separated by spaces, and there must be at\n  least one space following the colon in each \"Case #<b>x</b>:\" line.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  Time limit: 60 seconds.<br>\n  <b>T</b> = 100,<br>\n  1 &le; <b>K</b> &le; 5000,<br>\n  1 &le; <b>n</b> &le; 100,<br>\n  1 &le; <b>d</b><sub>i</sub> &le; <b>K</b>.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  Time limit: 180 seconds.<br>\n  <b>T</b> = 10,<br>\n  1 &le; <b>K</b> &le; 1000000,<br>\n  1 &le; <b>n</b> &le; 100,<br>\n  1 &le; <b>d</b><sub>i</sub> &le; <b>K</b>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n5 1 2 3 4 5\n15\n4 3 4 7 10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1 3 2 5 4\nCase #2: 2 8 13 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":35}],"title":"Mousetrap","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432bd2","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
