{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1522605600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000000130","is_practice_available":true,"my_user_type":3,"my_user_type__str":"PARTICIPANT","recap":"<p>\n  We hope that you enjoyed the practice session! We have re-posted our analyses\n  for the three previous Code Jam problems here, and we have also posted an\n  analysis and some sample solutions for the new sample interactive problem,\n  Number Guessing.\n</p><p>\n  Number Guessing and its analysis were prepared by Anqi (Joyce) Yang.\n  Additional solutions and other help came from Liang Bai, Md Mahbubul\n  Hasan, Micah Stairs, and Sasan Tavakkol.\n</p>\n","registration_gives_participant":false,"result_status":20,"result_status__str":"FULLY_VISIBLE","start_ms":1522432800000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\nWith at most three parties and at most nine senators, various brute force\napproaches will work. One exhaustive strategy is to generate all possible\ndifferent evacuation orders, treating senators from the same party as\ninterchangeable, and then try all possible different ways of chopping those\ninto groups of one or two senators.\n</p><p>\nAnother, simpler strategy is to keep randomly choosing and trying one of the\nnine possible evacuations (A, B, C, AA, AB, AC, BB, BC, CC) as long as the\nchosen senator(s) exist and the evacuation will not cause a new absolute\nmajority. You may worry that this strategy could get stuck, but the outcome of\nany legal evacuation will just be another possible test case for the problem,\nand the statement guarantees that every test case has a solution! With more\nparties and senators, though, this strategy might bog down in the details of\nchecking the legality of evacuations, so we should come up with a more\nefficient approach.\n</p>\n<h3>Test set 2</h3>\n<p>\nIntuitively, it is safest to remove one senator at a time, and to always draw\nfrom whichever party has the most remaining senators (or any such largest\nparty, if there is a tie). But this strategy won't always work! For example,\nif we have two senators from party A and two from party B, and no others,\nwhich is a valid test case, then removing one senator from either party will\ngive the other party an absolute majority.\n</p><p>\nHowever, this strategy <i>is</i> always safe whenever there are more than two\nparties present. Suppose that party 1 is currently the largest, or tied for the\nlargest, of at least three parties, and that we remove a single senator from\nparty 1. Clearly, making party 1 smaller cannot give it an absolute majority\nthat it didn't have before. But could some other party acquire an absolute\nmajority as a result? Suppose that the removal of a senator from party 1 were\nto cause party 2, which currently has X senators, to have an absolute majority.\nBut since party 1 was the largest, or tied for the largest, before a senator\nwas removed, party 1 must still have at least X-1 senators. Moreover, since at\nleast one more party is present, there is at least 1 other senator who is not\nfrom party 1 or 2. So there are a total of at least X remaining senators who\nare not from party 2, which means the X senators of party 2 are not enough to\ngive it an absolute majority, so we have a contradiction.\n</p><p>\nIf we start with three or more parties and keep evacuating a single senator\nfrom the largest party in this way, then at some point, we must reach a step\nin which we go from three parties to two parties. These two remaining parties\nmust have only one senator each. Since we just removed the one remaining\nsenator from the third party, it must have been a largest party, so the other\ntwo can be no larger. So we can remove this last pair of senators in a single\nevacuation as a final step.\n</p><p>\nWhat if we start with two parties? Since the problem statement guarantees that\nno party begins with a majority, these parties must have equal numbers of\nsenators. So, we can evacuate them in pairs, one from each party, until the\nevacuation is complete.\n</p><p>\nThis approach takes more steps than are needed &mdash; most of those single\nevacuations can be paired up &mdash; but it gets the job done.\n</p>\n","id":"00000000000004c0","statement":"<h3>Welcome to the Practice Session!</h3>\n<p>\n  If you experience any technical issues interfering with your ability to\n  participate in the Practice Session, please email us immediately at\n  <a href=\"mailto:codejam@google.com\">codejam@google.com</a>. We will have limited support\n  during the session, but will get back to you as soon as possible. For all\n  other feedback, we invite you to submit your thoughts and suggestions via this\n  <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSfE09X8Zdotkf8FYe-YczYs2eUBZtOC1yoxObpJrQiMAo0Qqg/viewform\">feedback form</a>\n  after the Practice Session.\n\n<h3>Problem</h3>\n<p>\nA small fire started in the senate room, and it needs to be evacuated!\n</p><p>\nThere are some senators in the senate room, each of whom belongs to of one of\n<b>N</b> political parties. Those parties are named after the first <b>N</b>\n(uppercase) letters of the English alphabet.\n</p><p>\nThe emergency door is wide enough for up to two senators, so in each step of\nthe evacuation, you may choose to remove either one or two senators from the\nroom.\n</p><p>\nThe senate rules indicate the senators in the room may vote on any bill at any\ntime, even in the middle of an evacuation! So, the senators must be evacuated\nin a way that ensures that no party ever has an absolute majority. That is, it\ncan never be the case after any evacuation step that more than half of the\nsenators in the senate room belong to the same party.\n</p><p>\nCan you construct an evacuation plan? The senate is counting on you!\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow.  Each test case consists of two lines. The first line\ncontains a single integer <b>N</b>, the number of parties. The second line\ncontains <b>N</b> integers, <b>P<sub>1</sub></b>, <b>P<sub>2</sub></b>, ...,\n<b>P<sub>N</sub></b>, where <b>P<sub>i</sub></b> represents the number of\nsenators of the party named after the i-th letter of the alphabet.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe evacuation plan. The plan must be a space-separated list of instructions,\nin the order in which they are to be carried out, where each instruction is\neither one or two characters, representing the parties of the senators to\nevacuate in each step.\n</p><p>\nIt is guaranteed that at least one valid evacuation plan will exist. If\nmultiple evacuation plans are valid, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 50.<br/>\nNo party will have an absolute majority before the start of the evacuation.<br/>\n1 &le; <b>P<sub>i</sub></b> &le; 1000, for all i.<br/>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 3.<br/>\nsum of all <b>P<sub>i</sub></b> &le; 9.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 26.<br/>\nsum of all <b>P<sub>i</sub></b> &le; 1000.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">4\n2\n2 2\n3\n3 2 2\n3\n1 1 2\n3\n2 3 1\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: AB BA\nCase #2: AA BC C BA\nCase #3: C C AB\nCase #4: BA BB CA\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\nThe sample output displays one set of answers to the sample cases. Other\nanswers may be possible.\n</p><p>\nIn Case #1, there are two senators from each of the parties A and B. If we\nremove one from each party every time, the perfect balance is maintained until\nevacuation is complete.\n</p><p>\nCase #2 proceeds as follows:\n</p><p>\nInitially in the room: 3 A, 2 B, 2 C.<br>\nEvacuate AA. Still in the room: 1 A, 2 B, 2 C.<br>\nEvacuate BC. Still in the room: 1 A, 1 B, 1 C.<br>\nEvacuate C. Still in the room: 1 A, 1 B.<br>\nEvacuate AB. Evacuation complete!<br>\n</p><p>\nNote that it would not be valid to begin the evacuation with BC, which would\nleave 3 A, 1 B, and 1 C in the room; party A would have an absolute majority (3\nout of 5 = 60%).\n</p><p>\nFor Case #3, note that <code>CC AB</code> would also be a valid answer, and\n<code>C C AB</code> is also valid even though it requires three evacuation\nsteps instead of two.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Senate Evacuation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  Since <b>A</b> = 0 and <b>B</b> = 30 in this test set, and since we get <b>N</b> = 30 tries per\n  test case, we can simply guess every number from 1 to 30 until the judge sends back\n  <code>CORRECT</code>.\n</p>\n<h3>Test set 2</h3>\n<p>\n  In test set 2, since the answer could be anywhere in the range (0, 10<sup>9</sup>] and we still\n  have only 30 guesses, we will use binary search.\n</p>\n<p>\n  Initially, we know the answer P is in [1, 10<sup>9</sup>], which is a big range! To cut that range\n  by half, our first guess will be (1 + 10<sup>9</sup>) / 2 = 5&times;10<sup>8</sup>. If the judge\n  sends back <code>TOO_SMALL</code>, we will know that P is in [1, 5&times;10<sup>8</sup>).\n  Similarly, if the judge sends back <code>TOO_BIG</code>, P is in\n  (5&times;10<sup>8</sup>, 10<sup>9</sup>]. Otherwise, P is 5&times;10<sup>8</sup> and we are done.\n</p>\n<p>\n  We will cut that range further by making our next guess the middle number in that range.\n  Again, based on the judge response that we get, we will know that either we have guessed P\n  correctly, or P is in the upper or lower half of the range. We will do this repeatedly, until\n  <code>CORRECT</code> is received.\n</p>\n<p>\n  Each time we make a wrong guess, the range that we must examine next will always be at most half\n  the size of our previous range. So, it will take at most log<sub>2</sub>10<sup>9</sup> = 29.897353\n  &lt; 30 tries to guess P correctly.\n</p>\n\n<h3>Sample Solutions</h3>\n<p>\n  This problem was intended as an opportunity to get used to our interactive judges. Here are\n  some example solutions in all languages that we support so far:\n</p>\n<h4><b>Bash:</b></h4>\n<pre><code>read t\nfor p in $(seq 1 $t); do\n  read -a line\n  a=${line[0]}\n  b=${line[1]}\n  read n\n  head=$(( a+1 ))\n  tail=$b\n  while true; do\n    mid=$(( (head+tail)/2 ))\n    echo $mid\n    read s\n    if [[ \"$s\" == \"CORRECT\" ]]; then\n      break\n    elif [[ \"$s\" == \"TOO_BIG\" ]]; then\n      tail=$(( mid - 1 ))\n    elif [[ \"$s\" == \"TOO_SMALL\" ]]; then\n      head=$(( mid + 1 ))\n    else\n      # Wrong answer; exit to receive Wrong Answer judgment\n      exit 0\n    fi\n  done\ndone\n\n</code></pre>\n<h4><b>C:</b></h4>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n  int T; scanf(\"%d\", &T);\n\n  for (int id = 1; id <= T; ++id) {\n    int A, B, N, done = 0;\n    scanf(\"%d %d %d\", &A, &B, &N);\n    for (++A; !done;) {\n      int mid = A + B >> 1;\n      char result[32];\n      printf(\"%d\\n\", mid);\n      fflush(stdout);\n      scanf(\"%s\", result);\n      if (!strcmp(result, \"CORRECT\")) done = 1;\n      else if (!strcmp(result, \"TOO_SMALL\")) A = mid + 1;\n      else B = mid - 1;\n    }\n  }\n  return 0;\n}\n\n</code></pre>\n<h4><b>C#:</b></h4>\n<pre><code>using System;\n\npublic class Solution\n{\n  static public void Main ()\n  {\n    int num_test_cases = Convert.ToInt32(Console.ReadLine());\n    for (int i = 0; i < num_test_cases; ++i) {\n      string[] lo_hi_s = Console.ReadLine().Split(' ');\n      int[] lo_hi = Array.ConvertAll(lo_hi_s, int.Parse);\n      int num_tries = Convert.ToInt32(Console.ReadLine());\n      int head = lo_hi[0] + 1, tail = lo_hi[1];\n      while (true) {\n        int m = (head + tail) / 2;\n        Console.WriteLine (m);\n        string s = Console.ReadLine();\n        if (s == \"CORRECT\") break;\n        if (s == \"TOO_SMALL\")\n        {\n          head = m + 1;\n        }\n        else\n        {\n          tail = m - 1;\n        }\n      }\n    }\n  }\n}\n\n</code></pre>\n<h4><b>C++:</b></h4>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n  int num_test_cases;\n  std::cin >> num_test_cases;\n  for (int i = 0; i < num_test_cases; ++i) {\n    int lo, hi;\n    std::cin >> lo >> hi;\n    int num_tries;\n    std::cin >> num_tries;\n    int head = lo + 1, tail = hi;\n    while (true) {\n      int m = (head + tail) / 2;\n      std::cout << m << std::endl;\n      std::string s;\n      std::cin >> s;\n      if (s == \"CORRECT\") break;\n      if (s == \"TOO_SMALL\")\n        head = m + 1;\n      else\n        tail = m - 1;\n    }\n  }\n  return 0;\n}\n\n</code></pre>\n<h4><b>Go:</b></h4>\n<pre><code>package main\n\nimport (\n  \"fmt\"\n  \"strings\"\n)\n\nfunc main() {\n  var t int\n  fmt.Scanf(\"%d\", &t)\n  for i := 1; i <= t; i++ {\n    var a, b, n int\n    fmt.Scanf(\"%d %d\", &a, &b)\n    a = a + 1\n    fmt.Scanf(\"%d\", &n)\n    for {\n      m := (a + b) / 2\n      fmt.Println(m)\n      var str string\n      fmt.Scanf(\"%s\", &str)\n      if strings.EqualFold(str, \"CORRECT\") {\n        break\n      } else if strings.EqualFold(str, \"TOO_SMALL\") {\n        a = m + 1\n      } else if strings.EqualFold(str, \"TOO_BIG\") {\n        b = m - 1\n      }\n    }\n  }\n}\n\n</code></pre>\n<h4><b>Haskell:</b></h4>\n<pre><code>import System.IO\n\ngetNum :: IO Int\ngetNum = do\n    x <- getLine\n    let n = read x :: Int\n    return n\n\nbisect :: Int -> Int -> Int -> String -> IO ()\nbisect a b m \"CORRECT\" = return ()\nbisect a b m \"TOO_SMALL\" = singleCase (m+1) b\nbisect a b m \"TOO_BIG\" = singleCase a (m-1)\n\nquery :: Int -> IO String\nquery m = do\n    putStrLn ( show m )\n    hFlush stdout\n    x <- getLine\n    return x\n\nsingleCase :: Int -> Int -> IO ()\nsingleCase a b = do\n    let m = (a+b) `div` 2\n    response <- query m\n    bisect a b m response\n    return ()\n\nsolve :: Int -> IO ()\nsolve 0 = return ()\nsolve n = do\n    [a, b] <- fmap(map read.words)getLine\n    _ <- getNum\n    singleCase (a+1) b\n    solve (n-1)\n\nmain = do\n    hSetBuffering stdout NoBuffering\n    t <- getNum\n    solve t\n\n</code></pre>\n<h4><b>Java:</b></h4>\n<pre><code>import java.util.Scanner;\n\npublic class Solution {\n  public static void solve(Scanner input, int a, int b) {\n    int m = (a + b) / 2;\n    System.out.println(m);\n    String s = input.next();\n    if (s.equals(\"CORRECT\")) {\n      return;\n    } else if (s.equals(\"TOO_SMALL\")) {\n      solve(input, m + 1, b);\n    } else {\n      solve(input, a, m - 1);\n    }\n  }\n\n  public static void main(String args[]) {\n    Scanner input = new Scanner(System.in);\n    int T = input.nextInt();\n    for (int ks = 1; ks <= T; ks++) {\n      int a = input.nextInt();\n      int b = input.nextInt();\n      int n = input.nextInt();\n      solve(input, a + 1, b);\n    }\n  }\n}\n\n</code></pre>\n<h4><b>JavaScript:</b></h4>\n<pre><code>var readline = require('readline');\nvar rl = readline.createInterface(process.stdin, process.stdout);\n\nexpect = 'begin';\nrl.on('line', function(line) {\n  if (expect === 'begin') {\n    num_test_cases = parseInt(line);\n    expect = 'lo_hi';\n    case_counter = 0;\n  } else if (expect === 'lo_hi') {\n    lo_hi = line.split(' ');\n    head = parseInt(lo_hi[0]) + 1;\n    tail = parseInt(lo_hi[1]);\n    expect = 'num_tries';\n  } else if (expect === 'num_tries') {\n    num_tries = line; // not used.\n    expect = 'solve';\n    mid = parseInt((head + tail) / 2);\n    console.log(mid);\n  } else if (expect === 'solve') {\n    if (line === 'CORRECT') {\n      ++case_counter === num_test_cases ? rl.close() : 0;\n      expect = 'lo_hi';\n    } else {\n      line === 'TOO_SMALL' ? head = mid + 1 : tail = mid - 1;\n      mid = parseInt((head + tail) / 2);\n      console.log(mid);\n    }\n  }\n}).on('close',function(){\n    process.exit(0);\n});\n\n</code></pre>\n<h4><b>PHP:</b></h4>\n<pre><code>&lt;?php\n\nfunction solve($a, $b) {\n  $m = ($a + $b) / 2;\n  printf(\"%d\\n\", $m);\n  fscanf(STDIN, \"%s\", $s);\n  if (strcmp($s, \"CORRECT\") == 0) {\n    return;\n  } else if (strcmp($s, \"TOO_SMALL\") == 0) {\n    $a = $m + 1;\n  } else {\n    $b = $m - 1;\n  }\n  solve($a, $b);\n}\n\nfscanf(STDIN, \"%d\", $t);\nfor ($ks = 0; $ks < $t; $ks++) {\n  fscanf(STDIN, \"%d %d\", $a, $b);\n  fscanf(STDIN, \"%d\", $n);\n  solve($a + 1, $b);\n}\n?>\n\n</code></pre>\n<h4><b>Python2:</b></h4>\n<pre><code>import sys\n\ndef solve(a, b):\n  m = (a + b) / 2\n  print m\n  sys.stdout.flush()\n  s = raw_input()\n  if s == \"CORRECT\":\n    return\n  elif s == \"TOO_SMALL\":\n    a = m + 1\n  else:\n    b = m - 1\n  solve(a, b)\n\nT = input()\nfor _ in xrange(T):\n  a, b = map(int, raw_input().split())\n  _ = input()\n  solve(a + 1, b)\n\n</code></pre>\n<h4><b>Python3:</b></h4>\n<pre><code>import sys\n\ndef solve(a, b):\n  m = (a + b) // 2\n  print(m)\n  sys.stdout.flush()\n  s = input()\n  if s == \"CORRECT\":\n    return\n  elif s == \"TOO_SMALL\":\n    a = m + 1\n  else:\n    b = m - 1\n  solve(a, b)\n\nT = int(input())\nfor _ in range(T):\n  a, b = map(int, input().split())\n  _ = int(input())\n  solve(a + 1, b)\n\n</code></pre>\n<h4><b>Ruby:</b></h4>\n<pre><code>$stdout.sync = true\n\ndef solve(a, b)\n  m = (a + b) / 2\n  puts m\n  $stdout.flush\n  s = STDIN.gets.chomp\n  if s.eql? \"CORRECT\"\n    return\n  elsif s.eql? \"TOO_SMALL\"\n    solve(m + 1, b)\n  else\n    solve(a, m - 1)\n  end\nend\n\nt = STDIN.gets.chomp.to_i\nks = 1\nwhile ks <= t\n  a, b = STDIN.gets.split.map &:to_i;\n  n = STDIN.gets.chomp.to_i\n  solve(a + 1, b)\n  ks = ks + 1\nend\n</code></pre>\n","id":"0000000000000523","statement":"<h3>Welcome to the Practice Session!</h3>\n<p>\n  If you experience any technical issues interfering with your ability to\n  participate in the Practice Session, please email us immediately at\n  <a href=\"mailto:codejam@google.com\">codejam@google.com</a>. We will have limited support\n  during the session, but will get back to you as soon as possible. For all\n  other feedback, we invite you to submit your thoughts and suggestions via this\n  <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSfE09X8Zdotkf8FYe-YczYs2eUBZtOC1yoxObpJrQiMAo0Qqg/viewform\">feedback form</a>\n  after the Practice Session.\n\n<h3>Problem</h3>\n<p>\n  This problem is a well-known classic; we present it primarily as an opportunity\n  for you to try out the interactive judging system.\n</p><p>\n  We are thinking of an integer P within the range (<b>A</b>,<b>B</b>] &mdash;\n  that is, <b>A</b> &lt; P &le; <b>B</b>. You have <b>N</b> tries to guess our\n  number. After each guess that is not correct, we will tell you whether P is\n  higher or lower than your guess.\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This problem is\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\">\n  interactive</a>, which means that the concepts of input and output are different\n  than in standard Code Jam problems. You will interact with a separate process\n  that both provides you with information and evaluates your responses.\n  All information comes into your program via standard input; anything that you\n  need to communicate should be sent via standard output.\n  Remember that many programming languages buffer the output by default, so\n  make sure your output actually goes out (for instance, by flushing the\n  buffer) before blocking to wait for a response. See the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a>\n  for an explanation of what it means to flush the buffer.\n  Anything your program sends through standard error is ignored, but it might\n  consume some memory and be counted against your memory limit, so do not\n  overflow it. To help you debug, a local testing tool script (in Python) is\n  provided at the very end of the problem statement.\n</p><p>\n  Initially, your program should read a single line containing a single integer\n  <b>T</b> indicating the number of test cases. Then, you need to process\n  <b>T</b> test cases.\n</p><p>\n  For each test case, your program will read a single line with two integers\n  <b>A</b> and <b>B</b>, representing the exclusive lower bound and inclusive\n  upper bound, as described above. In the next line, you will read a single\n  integer <b>N</b>, representing the maximum number of guesses you can make.\n  Your program will process up to <b>N</b> exchanges with our judge.\n</p><p>\n  For each exchange, your program needs to use standard output to send a single\n  line with one integer Q: your guess. In response to your guess, the judge\n  will print a single line with one word to your input stream, which your\n  program must read through standard input. The word will be\n  <code>CORRECT</code> if your guess is correct, <code>TOO_SMALL</code> if your\n  guess is less than the correct answer, and <code>TOO_BIG</code> if your guess\n  is greater than the correct answer. Then, you can start another exchange.\n</p><p>\n  If your program gets something wrong (e.g., wrong output format, or\n  out-of-bounds values), the judge will send <code>WRONG_ANSWER</code> to your input\n  stream and it will not send any other output after that. If your program\n  continues to wait for the judge after receiving <code>WRONG_ANSWER</code>,\n  your program will time out, resulting in a Time Limit Exceeded error. Notice\n  that it is your responsibility to have your program exit in time to receive\n  the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time\n  Limit Exceeded error. As usual, if the total time or memory is exceeded, or\n  your program gets a runtime error, you will receive the appropriate verdict.\n</p><p>\n  If your test case is solved within <b>N</b> tries, you will receive the\n  <code>CORRECT</code> message from the judge, as mentioned above, and then\n  continue to get input (a new line with two integers <b>A</b> and <b>B</b>,\n  etc.) for the next test case. After <b>N</b> tries, if the test case is not\n  solved, the judge will print <code>WRONG_ANSWER</code> and then stop sending output\n  to your input stream.\n</p><p>\n  You should not send additional information to the judge after solving all test\n  cases. In other words, if your program keeps printing to standard output after\n  receiving <code>CORRECT</code> for the last test case, you will get a Wrong Answer judgment.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 20.<br/>\n  <b>A</b> = 0.\n  <b>N</b> = 30.<br/>\n  Time limit: 10 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>B</b> = 30.\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>B</b> = 10<sup>9</sup>.\n</p>\n\n<h3>Sample interaction</h3>\n<p>\n  Here is a piece of pseudocode that demonstrates an interaction for one test set.\n  Suppose there are three test cases in this test set. The pseudocode first reads an\n  integer t, representing the number of test cases. Then the first test case begins.\n  Suppose the correct answer P is 9 for the first test case. The pseudocode first\n  reads three integers a, b, and n, representing the guessing range and maximum\n  number of tries, respectively, and then outputs a guess 30. Since 30 is greater\n  than 9, the string <code>TOO_BIG</code> is received through stdin from the judge.\n  Then the pseudocode guesses 5 and receives <code>TOO_SMALL</code> in response.\n  The guess 10 is subsequently printed to stdout which is again too big. Finally\n  the pseudocode guesses 9, and receives <code>CORRECT</code> because 9 is the\n  correct answer.\n</p>\n<pre>\n  t = readline_int()         // reads 3 into t\n  a, b = readline_two_int()  // reads 0 into a and 30 into b; note that 0 30 is one line\n  n = readline_int()         // reads 30 into n\n  printline 30 to stdout     // guesses 30\n  flush stdout\n  string s = readline()      // because 30 &gt; 9, reads TOO_BIG into s\n  printline 5 to stdout      // guesses 5\n  flush stdout\n  s = readline()             // reads TOO_SMALL into s since 5 &lt; 9\n  printline 10 to stdout     // guesses 10\n  flush stdout\n  s = readline()             // reads TOO_BIG into s since 10 &gt; 9\n  printline 9 to stdout      // guesses 9\n  flush stdout\n  s = readline()             // reads CORRECT into s\n</pre>\n<p>\n  The second test case shows what happens if the code continues to read from stdin\n  after the judge stops sending info. In this example, the contestant guesses 31,\n  which is outside the range (0, 30]. As a result, the judging system sends <code>WRONG_ANSWER</code>\n  to the input stream of the pseudocode and stops sending anything after that.\n  However, after reading <code>WRONG_ANSWER</code> into string s, the code continues to read for\n  the next test case. Since there is nothing in the input stream (judge has stopped\n  sending info), the code hangs and will eventually receive a Time Limit Exceeded Error.\n</p>\n<pre>\n  a, b = readline_two_int()  // reads 0 into a and 30 into b; note that 0 30 is one line\n  n = readline_int()         // reads 30 into n\n  printline 31 to stdout     // guesses 31\n  flush stdout\n  string s = readline()      // reads WRONG_ANSWER\n  a, b = readline_two_int()  // tries to read for the third test case but hangs since\n                             // judge has stopped sending info to stdin\n</pre>\n<p>\n  If the code in the example above exits immediately after reading <code>WRONG_ANSWER</code>,\n  it will receive a Wrong Answer judgment instead.\n</p>\n<pre>\n  a, b = readline_two_int()  // reads 0 into a and 30 into b; note that 0 30 is one line\n  n = readline_int()         // reads 30 into n\n  printline 31 to stdout     // guesses 31\n  flush stdout\n  string s = readline()      // reads WRONG_ANSWER\n  exit                       // receives a Wrong Answer judgment\n</pre>\n\n\n<h3>Local Testing Tool</h3>\n<p>\n  To better facilitate local testing, we provide you the following script.\n  Instructions are included inside. You are encouraged to add more test cases\n  for better testing. Please be advised that although the testing tool is\n  intended to simulate the judging system, it is <b>NOT</b> the real judging\n  system and might behave differently.\n</p><p>\n  If your code passes the testing tool but fails the real judge, please check\n  the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#coding\">\n  Coding section</a> of our FAQ to make sure that you are using the same\n  compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U11Pjlg-6FabJ7FzquxtnnZD6RvSFAk4BMZTIQtKELvI0t3jRYfxTOhMG2UlPfCPXZXlyc0PMakGthITg/local_testing_tool.py?dl=1\" download=\"local_testing_tool.py\">Download local testing tool</a>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Number Guessing","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<p>\n  Pop quiz, hotshots! This problem seems pretty complicated at first glance.\n  What do you do?\n</p><p>\n  One natural strategy is to try binary searching on Annie's speed, but it is\n  difficult to directly determine whether a given speed avoids passing another\n  horse; the input data alone does not tell us where each horse is at any given\n  time, because horses might slow other horses down. In theory, we could figure\n  out when faster horses catch up to slower horses and slow down, determine the\n  exact path of each horse, and check whether our chosen speed crosses any of\n  those paths. With only up to two horses in test set 1, this sort of\n  calculation is feasible, but it would be laborious for test set 2.\n</p><p>\n  However, we can avoid all of that work via some observations. To maximize\n  cruising speed, Annie's horse should reach the destination at exactly the\n  same time as the horse ahead of her (let's call it Horse A); there is no\n  reason to leave a gap. Either Horse A will reach the destination without\n  having to slow down (and so it will be the one that directly limits Annie's\n  speed), or it will be slowed down at some point by the horse ahead of it\n  (let's call it Horse B). The same is true for Horse B: either it will never\n  have to slow down (and so it will be the one that ultimately limits Annie's\n  speed), or it will be slowed down by the horse ahead of <i>it</i>, and so on.\n  So there will be a single \"limiting horse\" on the road that ultimately\n  determines how fast Annie's horse can reach the destination. We claim that\n  this \"limiting horse\" is the only horse that matters, and we can disregard\n  all of the others!\n</p><p>\n  It is easy to see that we can ignore the horses to the east of the limiting\n  horse; they will reach and pass the destination before the limiting horse\n  gets there. What about the \"intermediate horses\" between Annie and the\n  limiting horse? We know from the way we have defined the limiting horse that\n  every intermediate horse will catch up to the limiting horse before reaching\n  the destination. (If one did not, then <i>it</i> would be the limiting\n  horse.) Suppose that Annie chooses a cruising speed that gets her to the\n  destination at exactly the same time as the limiting horse. We certainly\n  cannot go faster than this. Moreover, this speed is safe: it cannot possibly\n  cause Annie to pass any of the intermediate horses. If she were going fast\n  enough to overtake an intermediate horse, then she would definitely be\n  going fast enough to pass the limiting horse, since every intermediate\n  horse will catch up to the limiting horse. This would cause a contradiction.\n  Therefore, we do not need to worry about the intermediate horses or their\n  interactions with each other.\n</p><p>\n  So, once we have identified the limiting horse, the strategy is simple: go at\n  the exact speed that will cause Annie to reach the destination at the same\n  time as the limiting horse. This speed can be found in constant time. We could\n  identify the limiting horse directly via the argument in our third paragraph\n  above, but even this would be unnecessary work. Instead, for each horse in\n  turn, we can pretend that it is the limiting horse and calculate the cruising\n  speed that it would force. Then the smallest of those speeds is our answer.\n  (If any horse allows a faster cruising speed than another, it cannot be the\n  limiting horse, because that cruising speed would cause Annie to pass the\n  true limiting horse.) This takes O(<b>N</b>) time.\n</p>\n","id":"0000000000000524","statement":"<h3>Welcome to the Practice Session!</h3>\n<p>\n  If you experience any technical issues interfering with your ability to\n  participate in the Practice Session, please email us immediately at\n  <a href=\"mailto:codejam@google.com\">codejam@google.com</a>. We will have limited support\n  during the session, but will get back to you as soon as possible. For all\n  other feedback, we invite you to submit your thoughts and suggestions via this\n  <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSfE09X8Zdotkf8FYe-YczYs2eUBZtOC1yoxObpJrQiMAo0Qqg/viewform\">feedback form</a>\n  after the Practice Session.\n\n<h3>Problem</h3>\n<p>\n  Annie is a bus driver with a high-stress job. She tried to unwind by going on\n  a Caribbean cruise, but that also turned out to be stressful, so she has\n  recently taken up horseback riding.\n</p><p>\n  Today, Annie is riding her horse to the east along a long and narrow one-way\n  road that runs west to east. She is currently at kilometer 0 of the road, and\n  her destination is at kilometer <b>D</b>; kilometers along the road are\n  numbered from west to east.\n</p><p>\n  There are <b>N</b> other horses traveling east on the same road; all of them\n  will go on traveling forever, and all of them are currently between Annie's\n  horse and her destination. The i-th of these horses is initially at kilometer\n  <b>K<sub>i</sub></b> and is traveling at its maximum speed of\n  <b>S<sub>i</sub></b> kilometers per hour.\n</p><p>\n  Horses are very polite, and a horse H<sub>1</sub> will not pass (move ahead\n  of) another horse H<sub>2</sub> that started off ahead of H<sub>1</sub>. (Two\n  or more horses can share the same position for any amount of time; you may\n  consider the horses to be single points.) Horses (other than Annie's) travel\n  at their maximum speeds, except that whenever a horse H<sub>1</sub> catches\n  up to another slower horse H<sub>2</sub>, H<sub>1</sub> reduces its speed to\n  match the speed of H<sub>2</sub>.\n</p><p>\n  Annie's horse, on the other hand, does not have a maximum speed and can\n  travel at any speed that Annie chooses, as long as it does not pass another\n  horse. To ensure a smooth ride for her and her horse, Annie wants to choose\n  a single constant \"cruise control\" speed for her horse for the entire trip,\n  from her current position to the destination, such that her horse will not\n  pass any other horses. What is the maximum such speed that she can choose?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>;\n  <b>T</b> test cases follow. Each test case begins with two integers <b>D</b>\n  and <b>N</b>: the destination position of all of the horses (in kilometers)\n  and the number of other horses on the road. Then, <b>N</b> lines follow. The\n  i-th of those lines has two integers <b>K<sub>i</sub></b> and\n  <b>S<sub>i</sub></b>: the initial position (in kilometers) and maximum speed\n  (in kilometers per hour) of the i-th of the other horses on the road.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the maximum constant speed (in kilometers per hour) that Annie can use\n  without colliding with other horses. <code>y</code> will be considered\n  correct if it is within an absolute or relative error of 10<sup>-6</sup> of\n  the correct answer. See the\n  <a href=\"https://codejam.withgoogle.com/codejam/resources/faq#real-number-behavior\">FAQ</a> for an explanation of what\n  that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  0 &lt; <b>K<sub>i</sub></b> &lt; <b>D</b> &le; 10<sup>9</sup>, for all i.<br/>\n  <b>K<sub>i</sub></b> &ne; <b>K<sub>j</sub></b>, for all i &ne; j. (No two\n    horses start in the same position.)<br/>\n  1 &le; <b>S<sub>i</sub></b> &le; 10000.<br/>\n  Time limit: 10 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 2.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">3\n2525 1\n2400 5\n300 2\n120 60\n60 90\n100 2\n80 100\n70 10\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: 101.000000\nCase #2: 100.000000\nCase #3: 33.333333\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  In Sample Case #1, there is one other (very slow!) horse on the road; it will\n  reach Annie's destination after 25 hours. Anything faster than 101 kilometers\n  per hour would cause Annie to pass the horse before reaching the destination.\n</p><p>\n  In Sample Case #2, there are two other horses on the road. The faster horse\n  will catch up to the slower horse at kilometer 240 after 2 hours. Both horses\n  will then go at the slower horse's speed for 1 more hour, until the horses\n  reach Annie's destination at kilometer 300. The maximum speed that Annie can\n  choose without passing another horse is 100 kilometers per hour.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Steed 2: Cruise Control","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n\n<p>\n  For test set 1, the limits are small enough that you can just simulate\n  the rules outlined in the statement. Most implementations of a simulation\n  will run in O(<b>N</b><b>K</b>) time and thus finish immediately, but even a\n  slow O(<b>N</b><sup>2</sup><b>K</b>) implementation like \"try every possible\n  stall for the next person, and for each empty stall run a loop for each side\n  to check for the closest neighbors\" will most likely finish in time.\n</p><p>\n  For test sets 2 and 3, however, something quadratic in the number of stalls\n  won't cut it, so we have to do better.\n</p>\n\n<h3>Test set 2</h3>\n\n<p>\n  The critical observation to jump from test set 1 to test set 2 is\n  that only the number of consecutive runs of empty stalls matters at any given\n  time. The next person always chooses the middle stall or the left of the two\n  middle stalls of a longest subsequence of consecutive empty stalls. Moreover,\n  the output format already hints at this: even if you were to choose the\n  rightmost of a set of two middle stalls, or a longest run of stalls other\n  than the leftmost one, the answer would not change. Thus, we can rewrite the\n  algorithm in this equivalent (for the required output) form:\n</p><ol>\n  <li>Find any longest subsequence of consecutive empty stalls.</li>\n  <li>Choose the middle or one of the two middle stalls.</li>\n</ol><p>\n  Notice that even though there are still ties to be broken, the output is\n  equivalent for all of them. Since the output is equivalent, so is the\n  multiset of lengths of consecutive runs of empty stalls left behind, so the\n  whole process only depends on that multiset. (As a reminder, a multiset is a\n  set in which the same element can appear more than once.) We can write an\n  optimized simulation that solves test set 2 following this pseudocode:\n</p><pre>\n  S = {<b>N</b>}  - This is a multiset!\n  repeat <b>K</b> times:\n    X = max(S)\n    X0 = ceil((X - 1) / 2)\n    X1 = floor((X - 1) / 2)\n    if this is the last step:\n      we are done; answer is X0 and X1\n    else:\n      remove one instance of X from S\n      insert X0 and X1 into S\n</pre><p>\n  If the operations over <code>S</code> are efficient, this will run in\n  quasilinear time. There are many data structures that support insertion,\n  finding the maximum, and removal of the maximum in logarithmic time,\n  including AVL trees, red-black trees, and heaps. Many languages have one such\n  structure in their standard libraries (e.g., the <code>multiset</code> or\n  <code>priority_queue</code> in C++, <code>TreeSet</code> in Java, and\n  <code>heapq</code> module in Python). Since we take O(log <b>K</b>) time for\n  each of K steps, the algorithm takes only O(<b>K</b> log <b>K</b>) time,\n  which is fast enough to solve test set 2. However, for test set 3, even\n  quasilinear time on K is not enough.\n</p>\n\n<h3>Test set 3</h3>\n\n<p>\n  The observation required to solve test set 3 is that we are simulating\n  similar steps over and over again. The first time a bathroom user arrives, we\n  partition <b>N</b> into ceil((<b>N</b> - 1) / 2) and\n  floor((<b>N</b> - 1) / 2), which means that numbers between\n  ceil((<b>N</b> - 1) / 2) and <b>N</b> will never appear in S. This hints at a\n  logarithmic number of simulation steps.\n</p><p>\n  Let's divide the work in stages. The first stage processes only <b>N</b>.\n  Then, stage <i>i</i>+1 processes all of the values spawned by stage <i>i</i>.\n  So, stage 2 processes up to 2 values: ceil((<i>i</i> - 1) / 2) and\n  floor((<i>i</i> - 1) / 2). What about the other stages? It is not hard to\n  prove by induction that they also process at most two consecutive values:\n  since stage i processes two consecutive values, they are either 2x and 2x+1 or\n  2x and 2x-1, for some x (that is, one even and one odd number). Thus, the spawned\n  values for stage i+1 can only be x and/or x-1.\n  Since the largest value in each stage is at most half the largest\n  value of the previous stage, there are a logarithmic number of stages. This all\n  means that there are at most O(log <b>N</b>) different values\n  that go into S at any point. Of course, some of them appear in S many, many\n  times. So, the optimization to get the running time low enough for test\n  set 3 is to process all repetitions of a given value at the same time,\n  since all of them yield the same X0 and X1 values. We can do that by using a\n  regular set with a separate count for the number of repetitions.\n</p><pre>\n  S = {<b>N</b>}  - This is a set, not a multiset!\n  C(N) = 1\n  P = 0\n  repeat:\n    X = max(S)\n    X0 = ceil((X - 1) / 2)\n    X1 = floor((X - 1) / 2)\n    P = P + C(X)\n    if P &ge; <b>K</b>:\n      we are done; the answer is X0 and X1.\n    else:\n      remove X from S\n      insert X0 and X1 into S\n      add C(X) to the counts of X0 and X1 in C\n</pre><p>\n  Once again, we have structures that implement all the required operations in\n  logarithmic time, yielding an O(log<sup>2</sup> <b>N</b>) running time\n  overall. In general, adding any good dictionary implementation to the\n  structure of choice from the test set 2 solution would work, either by\n  plugging the dictionary functionality into the structure (like\n  <code>map</code> in C++ or <code>TreeMap</code> in Java) or having a separate\n  hash-table for the dictionary (which is the easiest implementation in Python).\n</p><p>\n  Moreover, since we proved the population of S is at most 4 at any given time\n  (only values from two consecutive stages can coexist in S), any implementation\n  of set and dictionary will provide all operations in constant time, because the\n  size of the whole structure is bounded by a constant! This makes the overall\n  time complexity just O(log <b>N</b>).\n</p><p>\n  This was a nice problem to put experimentation to work if your intuition was not\n  enough. After solving test set 1, if you print the succession of values for a\n  fixed <b>N</b>, you may spot the pattern of few values occurring\n  in the set S, and from there, you can find the mathematical arguments to support\n  the needed generalization. In harder problems in later rounds, this can become an\n  even more important asset to tackle problems. As you can see in many parts of last\n  year's finals <a href=\"https://www.youtube.com/watch?v=4diQ6JXY4cI\">live stream</a>,\n  finalists use experimentation a lot to inspire themselves and/or validate their ideas\n  before committing to them.\n</p>\n","id":"0000000000000652","statement":"<h3>Welcome to the Practice Session!</h3>\n<p>\n  If you experience any technical issues interfering with your ability to\n  participate in the Practice Session, please email us immediately at\n  <a href=\"mailto:codejam@google.com\">codejam@google.com</a>. We will have limited support\n  during the session, but will get back to you as soon as possible. For all\n  other feedback, we invite you to submit your thoughts and suggestions via this\n  <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSfE09X8Zdotkf8FYe-YczYs2eUBZtOC1yoxObpJrQiMAo0Qqg/viewform\">feedback form</a>\n  after the Practice Session.\n\n<h3>Problem</h3>\n<p>\n  A certain bathroom has <b>N</b> + 2 stalls in a single row; the stalls on the\n  left and right ends are permanently occupied by the bathroom guards. The\n  other <b>N</b> stalls are for users.\n</p><p>\n  Whenever someone enters the bathroom, they try to choose a stall that is as far\n  from other people as possible. To avoid confusion, they follow deterministic\n  rules: For each empty stall S, they compute two\n  values L<sub>S</sub> and R<sub>S</sub>, each of which is the number of empty\n  stalls between S and the closest occupied stall to the left or right,\n  respectively. Then they consider the set of stalls with the farthest closest\n  neighbor, that is, those S for which min(L<sub>S</sub>, R<sub>S</sub>) is\n  maximal. If there is only one such stall, they choose it; otherwise, they choose\n  the one among those where max(L<sub>S</sub>, R<sub>S</sub>) is maximal. If there\n  are still multiple tied stalls, they choose the leftmost stall among those.\n</p><p>\n  <b>K</b> people are about to enter the bathroom; each one will choose their\n  stall before the next arrives. Nobody will ever leave.\n</p><p>\n  When the last person chooses their stall S, what will the values of\n  max(L<sub>S</sub>, R<sub>S</sub>) and min(L<sub>S</sub>, R<sub>S</sub>)\n  be?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> lines follow. Each line describes a test case with two integers\n  <b>N</b> and <b>K</b>, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y z</code>,\n  where <code>x</code> is the test case number (starting from 1),\n  <code>y</code> is max(L<sub>S</sub>, R<sub>S</sub>), and <code>z</code>\n  is min(L<sub>S</sub>, R<sub>S</sub>) as calculated by the last person to\n  enter the bathroom for their chosen stall S.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>K</b> &le; <b>N</b>.<br/>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n<h4>Test set 2 (Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n<h4>Test set 3 (Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 10<sup>18</sup>.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">5\n4 2\n5 2\n6 2\n1000 1000\n1000 1\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: 1 0\nCase #2: 1 0\nCase #3: 1 1\nCase #4: 0 0\nCase #5: 500 499\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  In Sample Case #1, the first person occupies the leftmost of the middle two\n  stalls, leaving the following configuration (<code>O</code> stands for an\n  occupied stall and <code>.</code> for an empty one): <code>O.O..O</code>.\n  Then, the second and last person occupies the stall immediately to the right,\n  leaving 1 empty stall on one side and none on the other.\n</p><p>\n  In Sample Case #2, the first person occupies the middle stall, getting to\n  <code>O..O..O</code>. Then, the second and last person occupies the leftmost\n  stall.\n</p><p>\n  In Sample Case #3, the first person occupies the leftmost of the two middle\n  stalls, leaving <code>O..O...O</code>. The second person then occupies the\n  middle of the three consecutive empty stalls.\n</p><p>\n  In Sample Case #4, every stall is occupied at the end, no matter what the\n  stall choices are.\n</p><p>\n  In Sample Case #5, the first and only person chooses the leftmost middle\n  stall.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Bathroom Stalls","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000000130","type":3,"type__str":"PARTICIPANT"},"title":"Practice Session 2018"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
