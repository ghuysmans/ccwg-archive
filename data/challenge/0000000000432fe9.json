{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1338049800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432fe9","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 2 whittled down our field from 3000 to 500 contestants with a combination of very challenging problems.  A theme in this round was the freedom to choose one of several ways to solve most of the problems we posed.\n</p>\n<p>\nWe began the round with a graph traversal problem that required one of a few possible insights to make it fast enough for the large input. This didn't stop 1630 of our contestants, though.\n</p>\n<p>\nAerobics is one of the problems that can be solved in very many ways, from rather grueling circle geometry to a nifty randomized solution requiring very little code.  Next came Mountain View, an ad-hoc problem which required contestants to re-create an input that would match the provided output.\n</p>\n<p>\nFinally came Descending in the Dark, a very challenging problem in which many contestants succumbed to the temptation of trying a randomized or heuristic solution.  No one managed to solve the Large version of it, which was a very challenging DP!\n</p>\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>\nProblem A. <i>Swinging Wild</i> Written by Onufry Wojtaszczyk.  Prepared by Luka Kalinovcic and Onufry Wojtaszczyk.\n</p>\n\n<p>\nProblem B. <i>Aerobics</i> Written by Onufry Wojtaszczyk.  Prepared by Dustin Tseng and Onufry Wojtaszczyk.\n</p>\n\n<p>\nProblem C. <i>Mountain View</i> Written by Onufry Wojtaszczyk.  Prepared by Onufry Wojtaszczyk and Andrei Missine.\n</p>\n\n<p>\nProblem D. <i>Descending in the Dark</i> Written by David Arthur.  Prepared by Onufry Wojtaszczyk and David Arthur.\n</p>\n\n<p>\nContest analysis presented by Onufry Wojtaszczyk, Onufry Wojtaszczyk, Onufry Wojtaszczyk and David Arthur.\n</p>\n\n<p>\nSolutions and other problem preparation by \nIgor Naverniouk,\nAdam Polak,\nAndrii Sydorchuk,\nPedro Bello,\nDave Walker,\nBartholomew Furrow,\nGary Sivek,\nLucas Hosseini,\nJohn Dethridge,\nPetr Mitrichev,\nSean Henderson,\nTomek Czajka,\nWitek Jarnicki\nand Raymond Ho.  It's possible Onufry Wojtaszczyk contributed somehow too.\n</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1338040800000,"tasks":[{"analysis":"<h3>Translating to a graph problem</h3>\n<p>\nTo analyse the problem, let us begin with describing the state we can be in at any particular point during traversing the swamp. It is easy to see that we need two items of information to describe this state - which vine are we currently holding on to, and how far away from the root are we holding it.\n</p>\n\n<p>\nOnce we have such a description, we can frame the problem as a path-finding problem in a graph. We start in the state (0, <b>d</b><sub>0</sub>), and we want to any state (<b>i</b>, <b>p</b>) with <b>p</b> + <b>d<sub>i</sub></b> &ge; <b>D</b> (to simplify, we can also add an artificial <b>N</b>+1st vine where our true love stands and demand that we reach the state (<b>N</b>, <b>p</b>) for any <b>p</b>).\n</p>\n\n<p>\nThe transitions between states (or, in other words, edges in the graph) are allowed swings we can make. If we currently hold vine <b>i</b>, at <b>p</b> units away from the root, we can swing to any vine <b>j</b> rooted between <b>d<sub>i</sub></b> - <b>p</b> and <b>d<sub>i</sub></b> + <b>p</b>, and the new length will be the minimum of |<b>d<sub>i</sub></b> - <b>d<sub>j</sub></b>| and <b>l<sub>j</sub></b>. Note that the only use of climbing up a vine is to catch a vine that would be too short to be within our swing path - so we implicitly include it in the transitions described above (and thus do not need extra transitions from (<b>i</b>, <b>p</b>) to (<b>i</b>, <b>p</b>-1)).\n</p>\n\n<h3>Limiting the number of nodes</h3>\n<p>\nAs described, we could have a large number of states (as there are very many possible vine lengths. A crucial fact to notice is that the second part of the state (the length away from root) is uniquely determined by the previous vine we got here from; and it is independent of where did we hold it (assuming we held it far enough to actually reach this state). This means that there are at most <b>N</b><sup>2</sup> states we will ever consider, as each is determined by a pair of vine indices.\n</p>\n\n<p>\nWe can now solve the small input. We have a graph with <b>N</b><sup>2</sup> nodes and at most <b>N</b> edges from each node, and we want to verify whether a path between some two nodes exists (we can merge all the target nodes into one node for simplicity). As we have at most <b>N</b><sup>3</sup> edges in total, any standard graph traversal algorithm (like BFS or DFS) will allow us to solve the problem.\n</p>\n\n<h3>Limiting the number of edges</h3>\n<p>\nFor the large input, a O(<b>N</b><sup>3</sup>) solution will be unsatisfactory, and we need a bit more subtlety. There is a number of tricks one can use to beat down the complexity. One is to make use again of the fact that the target node depends only on the vine we start from, and not on the position at which we hold it. This means that there are in fact at most <b>N</b> edges from a given vine - if we manage to reach some vine <b>j</b> from a given vine <b>i</b> when holding it at position <b>A</b>, we do not need to check this edge when considering moves from vine <b>i</b> held at position <b>B</b> (because even if we reach vine <b>j</b>, we will arrive in a state that we have already analysed). Thus, we need to make at most <b>N</b><sup>2</sup> edge traversals to visit all reachable nodes. There are various techniques to actually code this (for instance, for each vine, we could order the other vines by distance from this vine, and each time process this list from the closest vine and remove all traversed edges), we encourage you to explore the options.\n</p>\n\n<h3>An alternative for the large problem</h3>\n<p>\nAn alternative is to notice another fact - the position part of the state (that is, the distance away from the root that you hold the vine at) never increases. This is because if you swing from vine <b>i</b> to vine <b>j</b>, it means you were holding <b>i</b> at least |<b>d</b><sub>i</sub> - <b>d</b><sub>j</sub>| away from the root, while this quantity is at the same time an upper bound on the position you will hold vine <b>j</b> at.\n</p>\n\n<p>\nThis means that we can use Dijkstra's algorithm to find, for each vine, the maximum position we can hold this vine at - we treat the decreasing vine position as increasing time, and in each step we analyse what lengths could we obtain for each vine by moving from the current vine, and then choose the vine with the largest length to analyse. This will give us a O(<b>N</b><sup>2</sup>log<b>N</b>) solution, which should be fast enough.\n</p>\n\n<h3>Going even faster</h3>\n<p>\nA fun fact is that this problem can be solved faster than O(<b>N</b><sup>2</sup>), although you didn't need to notice this to solve our data sets. The key fact here is that if you can pass the swamp at all, you can always do it without going backwards (that is, you always catch a vine that's in front of you, you never swing back). An easy way to use this observation is to modify the Dijkstra's algorithm mentioned above to process the vines from first to last, which will turn O(<b>N</b><sup>2</sup>log<b>N</b>) into O(<b>N</b><sup>2</sup>).\n</p>\n<p>To go down to O(<b>N</b>), we need one more trick. Notice that if we can reach a vine, we will get the largest (meaning best) position if we swing to it from a vine that is as far away as possible. As we move only forward, this means that as soon as we can reach any particular vine, we should note the position achieved and we never need to check any other way of reaching it. This means we can get an O(<b>N</b>) solution by keeping track of the vine we are currently processing and farthest we have reached so far, and from each vine trying to update only vines that we have not reached as yet. As each vine will be updated at most once, and read at most once, we will do O(<b>N</b>) operations.\n</p>\n<p>We encourage you to flesh out the details and try to prove the \"never go back\" lemma - it's not trivial!\n</p>","id":"0000000000432b88","statement":"<h3>Problem</h3>\n<p>\nYou are standing on a ledge in the jungle, and your one true love is standing on a similar ledge at the other side of a swamp infested with snakes, crocodiles and a variety of other unpleasant denizens. Fortunately, there is a number of vines hanging from the canopy of the jungle over the swamp, even more fortunately, you somehow managed to get hold of the first of these vines (see figures below).  The canopy of the jungle is at a constant height, and both the ledges are at the same height as the canopy. The vines are simply lines hanging from the canopy at certain points, with differing lengths.\n</p>\n\n<p>\nIf you happened to be a fictional hero, you would just go swinging wildly and yelling, at some point let go of the vine you hold, fly in the air for some time, catch another vine, swing again, and after a few repetitions you would be holding your one true love in your arms. Unfortunately, you are not a fictional hero, and if you tried that, probably yelling would be the only part you would manage well.\n</p>\n\n<p>\nYour plan is a bit more cautious. You will swing on the vine you hold, but instead of letting go, you will catch hold of another vine. Then you will slowly and carefully climb up your original vine, so that the new vine you are holding will become horizontal - either to its full length, or up to the distance between the two vines, whichever is smaller. Then you will rest for a bit, and swing again, to repeat the process. Note that you do not have to catch the first vine you come up against while swinging, you might prefer to swing a bit further and catch some further-off vine instead. You can also climb up the vine you're currently swinging back and forth on to reduce the distance between you and the root of the vine.  In effect, this means that you can catch any vine that your vine crosses while swinging.  Note that you will not climb down a vine while swinging.\n</p>\n\n<p>\nOne other thing that sets you apart from any fictional hero is that before you start the whole rather risky procedure you would like to know whether it is actually possible to reach the other side of the jungle this way. And this is the question you have to answer in this problem.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  The first line of each test case contains the number <b>N</b> of vines. <b>N</b> lines describing the vines follow, each with a pair of integers <b>d</b><sub>i</sub> and <b>l</b><sub>i</sub> - the distance of the vine from your ledge, and the length of the vine, respectively. The last line of the test case contains the distance <b>D</b> to the ledge with your one true love. You start by holding the first vine in hand.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is a YES or a NO.  Indicating whether it is possible for you to reach your one true love, given the rules above.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 40 seconds per test set.<br/>\n0 &lt; <b>d</b><sub>i</sub>, <b>l</b><sub>i</sub>, <b>D</b> &le; 10<sup>9</sup>.<br/>\n<b>T</b> &le; 30. <br/>\n<b>d</b><sub>i</sub> &lt; <b>d</b><sub>i+1</sub>.<br/>\nAs you hold the first vine, <b>d</b><sub>0</sub> &le; <b>l</b><sub>0</sub>.<br/>\n<b>d</b><sub><b>N</b>-1</sub> &lt; <b>D</b>.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 10000</sup>.<br/>\nThere will be at most 60000 vines in all the test cases in total.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3\n3 4\n4 10\n6 10\n9\n3\n3 4\n4 10\n7 10\n9\n2\n6 6\n10 3\n13\n2\n6 6\n10 3\n14\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: YES\nCase #2: NO\nCase #3: YES\nCase #4: NO\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first case, you hold the first vine 3 units away from where it is attached. You swing wildly, bypass the second vine and just barely catch the third. The picture below depicts the starting situation, and you are able to reach any vine that is rooted anywhere within the red interval:</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1QXQOPiufbwmDOvBSpVogkxNpnKnWz5ia5A610ZNpnb20vh0un0aiRbmBQ6YYQj4oGoOc5WIwkYvM7xw/CaseOneBefore.png\"/>\n<p>\nAfter resting, you climb down the third one and up the first, to find yourself three units from the start, touching the canopy and holding the first and third vines. Now you let go of the first vine, swing again and again just barely reach the ledge, where your one true love awaits. The picture below depicts the situation after you caught the third vine and climbed over to the root of the first one. Again, you could reach any vine rooted within the red interval:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U14xB_5oTe9en2mNxSw5aeorA2d39XbVodqcQobB2XSaAex4W1mXVlSsU3c2g6PLrc1l9UqpKkVW8PZ/CaseOneAfter.png\">\n\n<p>\nIn the second case, you will not reach the third vine in the first swing, so your only choice is to catch the second. However, as it is attached four units from the start, you can (by going up the first vine) give yourself only one unit of swing - clearly too little to reach the third vine. Thus, you can't even reach the third vine, not to mention the other side of the swamp. Better go looking for some way around (or for a new true love).\n</p>\n\n<p>\nIn the third case, note that if you just swing on the first vine you hold, your path will not intersect the second vine - you have to climb up a bit while swinging (fortunately, you can) to reach the second vine. Remember, you can only climb up while swinging, you cannot climb down (because the vine going up is taut and you can put your weight on it, while the vine going down is swinging freely). In the fourth case, even though you can reach the second vine, it is too short to reach the final ledge.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":9}],"title":"Swinging Wild","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe main challenge in this problem is determining whether a cave is lucky. The set of all possible states is huge, so a complete search over all plans is simply not going to work. Fortunately, there is one observation we can use to greatly simplify the task.</p>\n\n<br/>\n<b>Eliminating Backtracking</b>\n\n<p>\nFix a cave <b>C</b>, and recall that <b>S<sub>C</sub></b> denotes the set of squares from which <b>C</b> can be reached. We will build up our plan one instruction at a time.\n</p>\n\n<p>\nLet <b>X</b> be the set of squares that you can be in if you start in <b>S<sub>C</sub></b> and follow the plan so far. If <b>X</b> contains a square not in <b>S<sub>C</sub></b>, we know the plan cannot work for every starting position. Otherwise, we can be 100% sure that the plan so far is fine! This is because the set of possible squares we are in has either stayed the same or gotten strictly smaller. In particular, if there was a plan that worked from the starting position, we can append it to what we have done so far, and it will still work.\n</p>\n\n<p>\nSo what does this mean? As long as we don't do a move that adds a square not in <b>S<sub>C</sub></b> to the set of possible squares <b>X</b>, we can go ahead and do that move, and it will still be possible to finish. In particular, we can always move left and right whenever we want, since moving left or right can never move you out of <b>S<sub>C</sub></b>.\n</p>\n\n<br/>\n<b>All You Need Is Down!</b>\n\n<p>\nEven with the previous observation, we still have work to do. We now know all the moves that can be done safely, but the state space is still huge. We can't find just any move; we need one that makes progress.\n</p>\n\n<p>\nHere is where it is important that you cannot go up the mountain. Suppose you can add a Down move to the plan, satisfying the following two properties:\n<ul>\n<li> There is at least one position in <b>X</b> from which you can actually move down. (Without this, the Down move will never do anything, and so is useless!)\n<li> There is no position in <b>X</b> from which a down move will take you outside of <b>X<sub>C</sub></b>.\n</ul>\nIf you add this Down move to the plan, then the sum of the heights over all squares in <b>X</b> will have gone down, and it can never go up again, because you can never climb the mountain!\n</p>\n\n<p>\nSince the sum of the heights is a positive integer, you will eventually have to stop making Down moves. At that point, you are stuck in one or more horizontal intervals. If there is just one interval and it contains the cave, the plan can be finished successfully. Otherwise, you're screwed! And remember, since this set of squares is a subset of what you started with, you were in fact screwed from the start.\n</p>\n\n<br/>\n<b>Can You Go Down?</b>\n\n<p>\nOnly one question remains: given a set of positions <b>X</b> reachable from the start, can you come up with a valid plan that includes at least one Down move?\n</p>\n\n<p>\n<b>X</b> must be contained in a set of horizontal intervals, bounded by impassable squares to the left and right. Since it is always safe to move left and right, we can keep moving left until <b>X</b> is actually just the leftmost square in each of these intervals. If we cannot make progress from that situation, we have already shown we are lost.\n</p>\n\n<p>\nAs we perform left and right moves from there, our position within each interval might change. However, note that if two intervals have the same length, our relative horizontal positions within them will always be the same. Therefore, let's define x<sub>j</sub> to be our relative horizontal position within all intervals of length j. (In particular, x<sub>j</sub> = 0 if we are in the leftmost position, and x<sub>j</sub> = j - 1 if we are in the rightmost position.)\n\n<p><b>Lemma:</b> It is possible to reach position (x<sub>1</sub>, x<sub>2</sub>, ...) using left and right moves if and only if x<sub>i</sub> &le; x<sub>j</sub> &le; x<sub>i</sub> + j - i for all i &lt; j.\n\n<p><b>Proof:</b> First we show x<sub>i</sub> &le; x<sub>j</sub>. This is true initially. If it ever failed after some sequence of moves, it would be because x<sub>i</sub> and x<sub>j</sub> were equal, and then either:\n<ul>\n<li> We moved left, and only x<sub>j</sub> was able to move.\n<li> We moved right, and only x<sub>i</sub> was able to move.\n</ul>\nHowever, both of these scenarios are impossible. Therefore, x<sub>i</sub> is indeed at most x<sub>j</sub>, or in other words, the distance from x<sub>i</sub> to the left wall is no larger than the distance from x<sub>j</sub> to the left wall. The same argument can be applied for the right wall, which gives us the other half of the inequality: x<sub>j</sub> &le; x<sub>i</sub> + j - i.\n</p>\n\n<p>Conversely, any set of positions with x<sub>i</sub> &le; x<sub>j</sub> &le; x<sub>i</sub> + j - i really can be reached via the following algorithm:\n<ul>\n<li>Start with each x<sub>i</sub> = 0.\n<li>Loop from i = largest interval length down to 2.\n<li>Move i-2 + x<sub>i</sub> - x<sub>i-1</sub> times to the right, and then i-2 times to the left.\n</ul>\nTry it yourself and you will see why it works!\n</p>\n<br/>\n\n<p>\nWe are now essentially done. We need to determine if there is set of positions {x<sub>i</sub>} that can be reached for which it is safe to move down. Once you have gotten this far, you can finish it off with <a href=\"https://www.google.com/search?q=dynamic+programming\" target=\"_blank\">dynamic programming</a>. Here is some pseudo-code that determines whether there is a set of positions from which it is possible to move down and make progress:\n<pre>\nold_safety = [SAFE] * (n+1)\nfor length in {n, n-1, ..., 1}:\n  for i in [0, length-1]:\n    pos_safety[i] = best(old_safety[i], old_safety[i+1])\n    if moving down leaves <b>S<sub>C</sub></b>:\n      pos_safety[i] = UNSAFE\n    elif moving down is legal and pos_safety[i] == SAFE:\n      pos_safety[i] = SAFE_WITH_PROGRESS\n  old_safety = pos_safety\nreturn (pos_safety[0] == SAFE_WITH_PROGRESS)\n</pre>\nThis is a good starting point, but you would still have to tweak it to actually record what the right x<sub>i</sub> is for all i.\n</p>\n\n<p>Putting it all together, we repeatedly use the above algorithm to see if it is possible to make a down move. If so, we do it and repeat. Otherwise, we stop. If the only remaining interval is the one containing the cave, then that cave is lucky. Otherwise, it is not!\n</p>\n\n<p>Since there are no correct submissions for the large input during the contest, we provide here a full java solution (by <a href=\"https://www.google.com/search?q=Petr+Mitrichev\" target=\"_blank\">Petr Mitrichev</a>) so everyone can use it to generate correct outputs for various inputs.\n</p>\n\n<pre>\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Dark {\n static class Segment {\n  int len;\n  long goodExitMask;\n  long badExitMask;\n }\n\n public static void main(String[] args) throws IOException {\n  BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n  int numTests = Integer.parseInt(reader.readLine());\n  for (int testId = 0; testId &lt; numTests; ++testId) {\n   String[] parts = reader.readLine().split(\" \", -1);\n   if (parts.length != 2) throw new RuntimeException();\n   int rows = Integer.parseInt(parts[0]);\n   int cols = Integer.parseInt(parts[1]);\n   String[] field = new String[rows];\n   for (int r = 0; r &lt; rows; ++r) {\n    field[r] = reader.readLine();\n    if (field[r].length() != cols) throw new RuntimeException();\n   }\n   System.out.println(\"Case #\" + (testId + 1) + \":\");\n   for (char caveId = '0'; caveId &lt;= '9'; ++caveId) {\n    int cr = -1;\n    int cc = -1;\n    for (int r = 0; r &lt; rows; ++r)\n     for (int c = 0; c &lt; cols; ++c)\n      if (field[r].charAt(c) == caveId) {\n       cr = r;\n       cc = c;\n      }\n    if (cr &lt; 0) continue;\n    boolean[][] reach = new boolean[rows][cols];\n    reach[cr][cc] = true;\n    int nc = 1;\n    while (true) {\n     boolean updated = false;\n     for (int r = 0; r &lt; rows; ++r)\n      for (int c = 0; c &lt; cols; ++c)\n       if (reach[r][c]) {\n        if (r &gt; 0 &amp;&amp; field[r - 1].charAt(c) != '#' &amp;&amp; !reach[r - 1][c]) {\n         reach[r - 1][c] = true;\n         ++nc;\n         updated = true;\n        }\n        if (c &gt; 0 &amp;&amp; field[r].charAt(c - 1) != '#' &amp;&amp; !reach[r][c - 1]) {\n         reach[r][c - 1] = true;\n         ++nc;\n         updated = true;\n        }\n        if (c + 1 &lt; cols &amp;&amp; field[r].charAt(c + 1) != '#' &amp;&amp; !reach[r][c + 1]) {\n         reach[r][c + 1] = true;\n         ++nc;\n         updated = true;\n        }\n       }\n     if (!updated) break;\n    }\n    List&lt;Segment&gt; segments = new ArrayList&lt;Segment&gt;();\n    for (int r = 0; r &lt;= cr; ++r)\n     for (int c = 0; c &lt; cols; ++c)\n      if (reach[r][c] &amp;&amp; (c == 0 || !reach[r][c - 1])) {\n       int c1 = c;\n       while (reach[r][c1 + 1]) ++c1;\n       Segment s = new Segment();\n       s.len = c1 - c + 1;\n       for (int pos = c; pos &lt;= c1; ++pos) {\n        if (r + 1 &lt; rows &amp;&amp; field[r + 1].charAt(pos) != '#') {\n         if (reach[r + 1][pos])\n          s.goodExitMask |= 1L &lt;&lt; (pos - c);\n         else\n          s.badExitMask |= 1L &lt;&lt; (pos - c);\n        }\n       }\n       segments.add(s);\n      }\n    while (true) {\n     int maxLen = 0;\n     for (Segment s : segments)\n      maxLen = Math.max(maxLen, s.len);\n     long[] badByLen = new long[maxLen + 1];\n     for (Segment s : segments) {\n      badByLen[s.len] |= s.badExitMask;\n     }\n     long[] possible = new long[maxLen + 1];\n     possible[1] = 1;\n     for (int len = 1; len &lt;= maxLen; ++len) {\n      possible[len] &amp;= ~badByLen[len];\n      if (len &lt; maxLen) {\n       possible[len + 1] = possible[len] | (possible[len] &lt;&lt; 1);\n      }\n     }\n     for (int len = maxLen; len &gt; 1; --len) {\n      possible[len - 1] &amp;= possible[len] | (possible[len] &gt;&gt; 1);\n     }\n     List&lt;Segment&gt; remaining = new ArrayList&lt;Segment&gt;();\n     for (Segment s : segments)\n      if ((s.goodExitMask &amp; possible[s.len]) == 0) {\n       remaining.add(s);\n      }\n     if (remaining.size() == segments.size()) break;\n     segments = remaining;\n    }\n    System.out.println(caveId + \": \" + nc + \" \" + (segments.size() == 1 ? \"Lucky\" : \"Unlucky\"));\n\n   }\n  }\n }\n}\n\n</pre>","id":"0000000000432f3f","statement":"<h3>Problem</h3>\n<p>\nYou are on the face of Mount Everest. You need to find shelter before you freeze, and it's dark! What do you do?\n</p>\n\n<p>\nThe good news is you have already memorized the layout of the mountain. It is a grid with certain squares impassable and other squares containing caves where you can rest for the night. The bad news is you don't know where you are, and it's too steep to climb up. All you can do is move left, right, or down.\n</p>\n\n<p>\nHere is an example layout, with '.' representing a passable square, '#' representing an impassable square, and numbers representing caves.\n</p>\n\n<pre>\n######\n##...#\n#..#.#\n#...##\n#0#..#\n####1#\n######\n</pre>\n\n<p>\nSince it is so dark, you will move around by following a <i>plan</i>, which is a series of instructions, each telling you to move one square left, right, or down. If an instruction would take you to a passable square or to a cave, you will follow it. If it would take you to an impassable square, you will have to ignore it. Either way, you will continue on to the next step, and so on, until you have gone through the whole plan.\n</p>\n\n<p>\nTo help with your descent, you want to find out two things for each cave <b>C</b>:\n\n<ul>\n<li> What squares is it possible to reach <b>C</b> from? We will label the set of these squares by <b>S<sub>C</sub></b>, and the number of them by <b>n<sub>C</sub></b>.\n\n<li> Is there a single plan that, if followed from any square in <b>S<sub>C</sub></b>, will finish with you at cave <b>C</b>? If so, we say the cave is <i>lucky</i>.\n</ul>\n\n<p> Note that you might pass by several caves while following a plan. All that matters is what square you <i>finish</i> on after executing all the steps, not what caves you visit along the way.</p>\n\n<p>For example, in the layout above, cave 0 is lucky. There are 9 squares that it can be reached from (including itself), and the plan \"left-left-down-down-left-down\" will finish with you at the cave from any of those squares.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, beginning with a line containing integers <b>R</b> and <b>C</b>, representing the number of rows and columns in the mountain layout.</p>\n\n<p>This is followed by <b>R</b> lines, each containing <b>C</b> characters, describing a mountain layout. As in the example above, a '#' character represents an impassable square, a '.' character represents a passable square, and the digits '0'-'9' represent caves (which are also passable squares).</p>\n\n<h3>Output</h3>\n\n<p>\nFor each test case, first output one line containing \"Case #x:\", where x is the case number (starting from 1). For each cave <b>C</b>, starting with 0 and counting up from there, write a line \"<b>C</b>: <b>n<sub>C</sub></b> <b>L<sub>C</sub></b>\". Here, <b>C</b> is the cave number, <b>n<sub>C</sub></b> is the number of squares you can reach the cave from, and <b>L<sub>C</sub></b> is either the string \"Lucky\" or the string \"Unlucky\", as defined above.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 40 seconds per test set.<br/>\nThere will be between 1 and 10 caves inclusive.<br/>\nIf there are <i>d</i> caves, they will be labeled with the digits {0, 1, ..., <i>d</i> - 1}, and no two caves will have the same label.<br/>\nAll squares on the boundary of the mountain layout will be impassable.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n3 &le; <b>R, C</b> &le; 10.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n3 &le; <b>R, C</b> &le; 60.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n7 5\n#####\n##0##\n##1.#\n##2##\n#3..#\n#.#.#\n#####\n7 6\n######\n##...#\n#..#.#\n#...##\n#0#..#\n####1#\n######\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n0: 1 Lucky\n1: 3 Lucky\n2: 4 Unlucky\n3: 7 Lucky\nCase #2:\n0: 9 Lucky\n1: 11 Unlucky\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn the first case, here are some valid plans you could use for the lucky caves:\n<ul>\n<li>For cave 0, you can use the empty plan. If you can reach the cave at all, you are already in the right place!\n<li>For cave 1, you can use the plan right-down-left.\n<li>For cave 3, you can use the plan right-right-left-down-down-down-left.\n</ul>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Descending in the Dark","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>This problem gives you a lot of freedom in how you approach it, as it is OK to output any sequence of peak heights matching the input data. What follows is one of the possible solutions, but others are possible.</p>\n\n<p>First notice that if from peak 3 we perceive peak 7 as highest, then from peaks 4, 5 and 6 I can surely see no farther than 7, as the peaks have to lie below the line connecting peaks 3 and 7, and no peak after 7 lies above that line (or it would appear higher from peak 3). If this condition is not satisfied, we can safely return \"impossible\".</p>\n\n<p>So, begin with peak 1, then go to the one appearing to be highest from it, then the apparent highest from it, and so on. Give all these peaks height of 10<sup>9</sup>. Note this sequence necessarily ends on peak <b>N</b> (as it is strictly increasing).</p>\n\n<p>Now sequentially take the first peak <b>A</b> that we haven't assigned a height to yet. As it's the first non-assigned, the previous peak (<b>A</b>-1) has necessarily been assigned, and we can look at the peak that appears highest from <b>A</b>-1. Suppose it's <b>B</b>. We know that when we start a sequence of apparently highest peaks from <b>A</b>, it has to contain at <b>B</b> - it cannot skip <b>B</b>, because the whole sequence has to lie below the [(<b>A</b>-1), <b>B</b>] line), and it is strictly increasing. If the sequence jumps over <b>B</b>, we return \"impossible\".</p>\n\n<p>Assume the line [(<b>A</b>-1), <b>B</b>] has slope <b>T</b>; our construction will guarantee that <b>T</b> is an integer (notice the slope of the first line is zero). We will want all the peaks on the sequence starting at <b>A</b> to lie on a line passing through peak <b>B</b> and with slope <b>T</b>+1; this determines the line uniquely. If we do it this way, we will not spoil visibilities built before (because the whole line is below the line connecting <b>A</b>-1 and <b>B</b>), and in the sequence for each peak the apparently highest peak will be the next peak in the sequence (as they are all in one line, no peaks with constructed heights lie between <b>A</b> and <b>B</b>, and all the peaks after <b>B</b> are invisible, because they lie below the line connecting (<b>A</b>-1) and <b>B</b>, and thus, even more so, below the line connecting <b>A</b> and B (which has larger slope).</p>\n\n<p> We continue in this fashion. We can check that at any moment of our construction:\n<ul>\n<li> If we assume the peaks that we have not constructed yet do not stand in the way (have, say, a height of zero), then for each peak we already constructed the peak appearing to be the highest is the one we expect to appear highest. </li>\n<li> For any constructed peak <b>A</b>, either <b>A</b>+1 is constructed as well, or no peak between <b>A</b> and the peak visible from <b>A</b> has its height constructed.</li>\n<li> Adding a new sequence upholds these invariants, which proves that when we end, the visibilities are all OK.</li>\n</ul>\nThus, the construction works.\n</p>\n\n<p>\nNotice that we increase the slope by one for each sequence, so it is at most <b>N</b> at the end, and so the lowest we can get is 10<sup>9</sup> - <b>N</b><sup>2</sup>; thus the heights are all positive.\n</p>","id":"0000000000433104","statement":"<h3>Problem</h3>\n<p>\nYou are walking through the mountains. It turns out that in this mountain range there is a peak every kilometer, and there are no intermediate peaks. On every peak, you lie down for a rest, look forward, and perceive one of the peaks in front of you to be the highest one. The peak that looks like it's the highest might not <b>really</b> be the highest, for two reasons: there could be a higher peak that is obscured by another peak that's closer to you, and not as high; or you could be looking down, and a faraway peak could look higher than a nearby one.</p>\n\n<p>To be precise, when we say that <i>peak <b>B</b> looks like it's the highest from peak <b>A</b></i> we mean that <b>B</b> is further down the road than <b>A</b>; all peaks between <b>A</b> and <b>B</b> are below the line connecting the peaks <b>A</b> and <b>B</b>; and all the peaks that are further than <b>B</b> are below or on this line.</p>\n\n<p>\nYou don't know how high each peak is, but you have a very good memory; you've been on all the peaks; and you remember which peak looks like it's the highest from each of them.  You would like to invent a set of heights for the peaks that is consistent with that information.  Note that you were lying down when looking, so we assume you always looked from the ground level on each peak.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1OFavoDciUoNg_R2ctJvLtrkMX9woZ55kpX9vW-zbO5MUdYQcwRcvClEk4fGIEd5HPJBJ81fsY/mountains.png\"><br/>\nIn this example, the fourth peak looks like it's the highest from the first and third peaks.  When you're lying on the second peak, you can't see the fourth peak; the third one obscures it, and looks like it's the highest.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of two lines. The first contains one number, <b>N</b>, the number of peaks in the range. You began your trip on peak 1 and went forward to peak <b>N</b>. The next line contains <b>N-1</b> numbers <b>x</b><sub>i</sub>. The i-th number denotes the index of the peak that appeared to be the highest from peak <i>i</i> (note that peak <b>N</b> is the last peak, so there are no other peaks to see from there).\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #n: y<sub>1</sub> y<sub>2</sub> ... y<sub><b>N</b></sub>\", where n is the case number (starting from 1) and y<sub>i</sub> is the height of the i-th peak. You can output any solution agreeing with the input data, except that all the heights you output have to be integers between 0 and 10<sup>9</sup>, inclusive.\n</p>\n<p>\nIf no solution is possible, output \"Case #n: Impossible\" instead.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 20 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 30.<br/>\ni &lt; <b>x<sub>i</sub></b> &le; <b>N</b>.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n2 &le; <b>N</b> &le; 10.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n2 &le; <b>N</b> &le; 2000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n6\n2 3 4 5 6\n4\n4 4 4\n4\n3 4 4\n4\n4 3 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 10 10 10 10 10 2\nCase #2: 10 20 40 80\nCase #3: Impossible\nCase #4: 5 3 6 8\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Mountain View","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe key to this problem lies in realizing that there really is a lot of space on the mat to take advantage of, and a number of different approaches will work.\n</p>\n\n<p>\nFor the small input, putting the circles along one of the longer edge, and - if it runs out - along the opposite edge will work. The precise analysis of why they fit is somewhat tedious, so we will skip it in favor of describing two solutions that can also deal with the large input.\n</p>\n\n<h3>A randomized solution</h3>\n<p>\nThe large input is a more interesting case. We will describe two solutions that allow one to solve this problem. The first one will be randomized. (If you solved the Equal Sums problem in Round 1B, you should already realize how helpful randomized algorithms can be!).\n</p>\n\n<p>\nWe will order the circles by decreasing radius. We will then take the circles one by one, and for each circle try to place it on the mat at a random point (that is, put the center of the circle at a random point on the mat). We then check whether it collides with any circle we have placed previously (by directly checking all of them). If it does collide, we try a different random point and repeat until we find one that works. When we succeed in placing all the circles, we're done.\n</p>\n\n<p>\nOf course, if we manage to place all the circles, we have found a correct solution. The tricky part is why we will always find a good place to put the new circle in a reasonable time. To see this, let's consider the set of \"bad points\" - the points where we cannot put the center of a new circle because it would cause a collision. If we are now placing circle <b>j</b> with radius <b>r<sub>j</sub></b>, then it will collide with a previously placed circle <b>i</b> if and only if the distance from the new center to the center of circle <b>i</b> is less than <b>r<sub>i</sub></b> + <b>r<sub>j</sub></b>. This means that the \"bad points\" are simply a set of circles with radii <b>r<sub>i</sub></b> + <b>r<sub>j</sub></b>.\n</p>\n\n<p>\nWhat is the total area of the set of bad points? Well, since the set is a group of circles, the area is at most the sum of the areas of the circles. (It can be less because the circles can overlap, but it cannot be more). As we are placing the circles ordered by decreasing radius, we know <b>r<sub>j</sub></b> &le; <b>r<sub>i</sub></b>, so the area of the <b>i</b><sup>th</sup> \"bad\" circle is at most &pi; * (2<b>r<sub>i</sub></b>)<sup>2</sup> = 4&pi; <b>r<sub>i</sub></b><sup>2</sup>. Here is where we will use that the mat is so large - we see that the total bad area is always at most 80 percent of the mat. Therefore, we have at least a 1 in 5 chance of choosing a good center on every attempt. In particular, it is always possible to find a good center, and it will take us only a few tries.\n</p>\n\n<p>\nFor each attempt, we have to make O(<b>N</b>) simple checks, and we expect to make at most 5<b>N</b> attempts, so the expected time complexity of this algorithm is O(<b>N</b><sup>2</sup>) - easily fast enough.\n</p>\n\n<h3> A deterministic solution </h3>\nAs usual, if we are willing to deal with a bit more complexity in the code, we can get rid of randomness in the solution, taking advantage of all the extra space we have in a different way. One sample way to do this follows.\n</p>\n\n<p>\nTo each circle of radius <b>R</b> we attach a 4<b>R</b> * 2<b>R</b> rectangle as illustrated below:</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U29-5QKYgMa19ockxVLLh56jk2u9hCItOGPZ8lUYRduh8AYkDRViNFZqiwBNL84EKDyKGNn/circle.png\">\n\n<p>\nThe top edge of the rectangle passes through the center of the circle. The bottom edge, the left edge, and the right edge are all at a distance of 2<b>R</b> from the center of the circle.\n</p>\n\n<p>\nWe now place circles one at a time, starting from the ones with the larger radius. We always place each circle in the topmost (and if we have a choice, leftmost) point not covered by any of the rectangles we have already drawn.\n</p>\n\n<p>\nAn argument similar to the one used in the randomized solution proves that if we place a circle like that, it does not collide with any of the previously placed circles. As we place each point in the topmost available point, the centers of the previously placed circles are necessarily above the last one placed, and so if our new circle would collide with one of the previous ones, it would have to be in the rectangle we associated with it.\n</p>\n\n<p>\nNow notice that the areas of all the rectangles we place is the sum of 8<b>R</b><sup>2</sup> = 8 / &pi; times the total area of the circles - which is easily less than the area of the mat. This means we always can place the next circle within the mat.\n</p>\n\n<p>\nThis solution is somewhat more tricky to code than the previous one (because we have to find the topmost free point, instead of just choosing a random one), but still easier than if we tried to actually stack circles (instead of replacing them by rectangles).\n</p>","id":"0000000000433338","statement":"<h3>Problem</h3>\n<p>\nThe aerobics class begins. The trainer says, \"Please position yourselves on the training mat so that each one of you has enough space to move your arms around freely, and not hit anybody else.\" People start milling around on the mat, trying to position themselves properly. Minutes pass, and finally the trainer is so annoyed that he asks you to write a program that will position all the people correctly, hoping it will be quicker than letting them figure it out for themselves!\n</p>\n\n<p>\nYou are given the dimensions (width and length) of the mat on which the class takes place. For every student, there is a circular area she has to have for herself, with radius equal to the reach of her arms.  These circles can not intersect, though they can touch; and the center of each circle (where the student stands) has to be on the mat.  Note that the arms <b>can</b> reach outside the mat. You know that there's plenty of space on the mat &mdash; the area of the mat is at least five times larger than the total area of the circles required by all the people in the class.  It will always be possible for all the people to position themselves as required.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of two lines. The first line contains three integers: <b>N</b>, <b>W</b> and <b>L</b>, denoting the number of students, the width of the mat, and the length of the mat, respectively. The second line contains <b>N</b> integers <b>r</b><sub>i</sub>, denoting the reach of the arms of the i<sup>th</sup> student.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #n: y\", where n is the case number (starting from 1) and y is a string containing 2<b>N</b> numbers, each of which can be an integer or a real number: <b>x</b><sub>1</sub>, <b>y</b><sub>1</sub>, <b>x</b><sub>2</sub>, <b>y</b><sub>2</sub>, etc., where the pair (<b>x</b><sub>i</sub>, <b>y</b><sub>i</sub>) is the position where the i<sup>th</sup> student should stand (with 0 &le; <b>x</b><sub>i</sub> &le; <b>W</b> and 0 &le; <b>y</b><sub>i</sub> &le; L).\n</p>\n<p>\nAs there will likely be multiple ways to position the students on the mat, you may output any correct positioning; but remember that you may not submit an output file more than 200kB in size.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 40 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n1 &le; <b>W, L</b> &le; 10<sup>9</sup>.<br/>\n1 &le; <b>r</b><sub>i</sub> &le; 10<sup>5</sup>.<br/>\nThe area of the mat is at least 5 times larger than the total area of the circles: <br/>5*&pi;*(<b>r<sub>1</sub><sup>2</sup></b> + ... + <b>r<sub>N</sub><sup>2</sup></b>) &le; <b>W*L</b>.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 10<sup>3</sup>.<br/>\nThe total number of circles in all test cases will be &le; 6000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2 6 6\n1 1\n3 320 2\n4 3 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.0 0.0 6.0 6.0\nCase #2: 0.0 0.0 7.0 0.0 12.0 0.0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Aerobics","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432fe9","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2012"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
