{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1581787800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000019ff03","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  This year's Code Jam to I/O for Women contest was the first to feature a\n  multi-part problem: <i>Interleaved Output</i>. In Part 1, the natural greedy\n  algorithm did work; however, in Part 2, a small change to the setup forced a\n  more complex solution. We hope that you won't see <code>I</code>s and\n  <code>O</code>s and <code>i</code>s and <code>o</code>s floating by in your\n  dreams! An earlier internal version of the problem had <code>1</code>s\n  and <code>0</code>s instead of the lowercase letters, so at least you didn't\n  have to parse strings like <code>I1O0</code>...\n</p><p>\n  The first two test sets of <i>Imbalance Obviation</i> were perhaps more\n  approachable than Interleaved Output: Part 2 &mdash; indeed, the whole\n  problem could be solved without prior algorithmic knowledge. (Depending on\n  your strategy, though, it might have been tricky to handle the odd-length\n  cases in Test Set 3!) Finally, <i>Impromptu Outdoor Gallery</i> was a very\n  difficult geometry problem about the whims of the art world. Those tickets to\n  I/O weren't going to come easily this year!\n</p><p>\n  Many contestants plowed through Interleaved Output: Part 1; our first\n  correct solutions rolled in after only a few minutes. However, the remaining\n  problems didn't give up their points without a fight! Even picking off\n  Visible test sets took some work. Every test set did get solved at least\n  once, but there were no perfect scores. <b>rediska0123</b> came closest (93\n  points, 1:41:21), missing only the third test set of Imbalance Obviation.\n  <b>kobus</b> (76 points, 1:04:13) came in second, with everything but the\n  last test set of Impromptu Outdoor Gallery. <b>tap_tapii</b> (76 points,\n  1:09:48), the winner of Code Jam to I/O for Women 2019, was not far behind in\n  third. Just over 2500 contestants submitted something, and about half of\n  those solved at least one test set.\n</p><p>\n  We hope you had a great time thinking about the problems, and for those of\n  you in the top 150, we'll look forward to seeing you at I/O 2020! To make the\n  top 150, you had to earn at least 41 points (generally by completely solving\n  the first two problems), or earn 39 points with a sufficiently small penalty\n  time. (As usual, we will need a bit of time to finalize the results, so the\n  initial rankings are provisional.)\n</p><p>\n  Thank you, and we'll see you next year with another set of Intriguing\n  Offerings!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  <i>Interleaved Output: Part 1</i>: Written by Sherry Wu and Pablo Heiber.\n  Prepared by Jonathan Irvin Gunawan. Analysis by Swetha Srinivasan.\n</p><p>\n  <i>Imbalance Obviation</i>: Written by Hsin-Yi Wang. Prepared by Sadia Atique\n  and Jonathan Irvin Gunawan. Analysis by Sadia Atique.\n</p><p>\n  <i>Interleaved Output: Part 2</i>: Written by Sherry Wu and Pablo Heiber.\n  Prepared by Swetha Srinivasan. Analysis by Swetha Srinivasan.\n</p><p>\n  <i>Impromptu Outdoor Gallery</i>: Written by Lin Jin. Prepared by\n  Timothy Buzzelli and Lin Jin. Analysis by Timothy Buzzelli.\n</p><p>\n  Solutions and other problem preparation and review by Shantam Agarwal, \n  Lena Anyusheva, Bakhodir Ashirmatov, Sadia Atique, Liang Bai, Darcy Best,\n  Timothy Buzzelli, Mingyuan Gao, Divanshu Garg, Jonathan Irvin Gunawan,\n  Md Mahbubul Hasan, Pablo Heiber, Joyce Lee, Lizzie Sapiro, Pi-Hsun Shih,\n  Swetha Srinivasan, Mary Streetzel, Ian Tullis, Hsin-Yi Wang, Sherry Wu, and\n  Diego Gutiérrez Yépiz.\n</p>\n","registration_gives_participant":true,"result_status":30,"result_status__str":"FINALIZED","start_ms":1581778800000,"tasks":[{"analysis":"<p>\n  An important difference between this problem and the Part 1 version is that\n  in this version, for each of the events, there is only a single computer that\n  can print it. That is, there are only four computers printing simultaneously\n  for the four events, <code>IO</code>, <code>io</code>, <code>Io</code> and\n  <code>iO</code>. Our optimal greedy strategy from the Part 1 analysis is not\n  compatible with this constraint.\n</p><p>\n  For example, consider the sample input <code>IiOioIoO</code>. Our\n  Part 1 strategy would find an interpretation in which <code>IO</code>\n  was advertised twice. But this interpretation requires two separate computers\n  to have printed <code>io</code>, since one computer cannot print an\n  <code>i</code> followed by another <code>i</code>... and in Part 2, we only\n  have one <code>io</code> computer.\n</p><p>\n  Let us find a way to turn this new constraint into an advantage. Regardless\n  of how many times each computer ends up advertising its event, each computer\n  can be in only one of two states at any given time: either it is about to\n  print its first character, or about to print its second character. So, at any\n  point, the system of 4 computers is in one of 2<sup>4</sup> = 16 states. This\n  situation, in which we have only a limited number of states to consider,\n  is ideal for a\n  <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\" target=\"_blank\">dynamic programming</a>\n  approach in which we step through the string and keep track of the best\n  option seen so far for each of those states.\n</p><p>\n  Let us describe our 16 states in terms of which computers are about to print\n  their <i>second</i> characters. For example, the state\n  {<code>IO</code>, <code>iO</code>} means that the <code>IO</code> and\n  <code>iO</code> computers need to print their second character\n  (<code>O</code>) next, and the <code>io</code> and <code>Io</code> computers\n  need to print their first character (<code>I</code> or <code>i</code>)\n  next.\n</p><p>\n  We will also define the \"score\" of a prefix of the input string p and a state\n  s as the number of completed <code>IO</code> events designated after\n  processing p ending in state s. Since scores only increase, we only\n  care about the maximum score for each combination. The final answer to the\n  problem is the score for p = <b>S</b> and s = {}, that is, when we have\n  processed the entire string and no computer has printing pending.\n  We will also define the \"score\" of a partial string as the number of\n  completed <code>IO</code> events designated so far in that string.\n</p><p>\n  Consider the input string <code>IiOioIoO</code>. When we process the first\n  <code>I</code>, we must decide which computer printed that character &mdash;\n  that is, after that choice, we can either be in the state {<code>IO</code>}\n  or the state {<code>Io</code>}. With dynamic programming, we simultaneously\n  keep track of all of these possible worlds; we are not actually committing to\n  a particular choice. After we process the next character, depending on our\n  interpretation, we can be in one of four states: {<code>IO, iO</code>},\n  {<code>IO, io</code>}, {<code>Io, iO</code>}, or {<code>Io, io</code>}.\n  Then, moving on to the next <code>O</code>, we find that\n  {<code>Io, io</code>} is inconsistent, and the possible states become\n  {<code>IO</code>} (with a score of 0 so far), {<code>iO</code>} (with a score\n  of 1), {<code>io</code>} (with a score of 0), or {<code>Io</code>} (with a\n  score of 0). We continue this until we have finished processing the string,\n  and then we have our answer.\n</p><p>\n  Our dynamic programming approach has O(L) stages (where L is the input string\n  length), and each stage has a constant processing time since there are\n  no more than 16 states to consider. This results in an overall time\n  complexity of O(L), but notice that we have only been able to wave away a\n  constant factor because the number of events/computers was small. With E\n  possible events, the complexity would be O(L &times; 2<sup>E</sup>.)\n</p>\n","id":"00000000001b5cd7","statement":"<h3>Problem</h3>\n<p>\n  <i>\n    You do not need to read the <b>Interleaved Output: Part 1</b> problem to\n    be able to solve this problem. Both Part 1 and Part 2 have the same first\n    two paragraphs (not including this informational text). We have underlined\n    the critical difference between the two parts.\n  </i>\n</p><p>\n  On a distant moon of Jupiter, some developer conference events are about to\n  happen! They are called <code>IO</code> (uppercase I, uppercase O),\n  <code>Io</code> (uppercase I, lowercase o), <code>iO</code> (lowercase I,\n  uppercase O), and <code>io</code> (lowercase I, lowercase O).\n</p><p>\n  The best way to advertise an event is by using special computers that print\n  the event's name one character at a time, with the output appearing on a\n  digital display. Each such computer only knows the name of one event, and is\n  programmed to print its event's name zero or more times. For example, a\n  computer programmed to print <code>IO</code> twice prints an <code>I</code>,\n  followed by an <code>O</code>, followed by an <code>I</code>,\n  followed by an <code>O</code>, for a final string of <code>IOIO</code>.\n</p><p>\n  You know that the conference organizers are using\n  <u>exactly one computer to advertise each event</u>. Each printer may print\n  its event name zero or more times. Moreover, the computers are not\n  necessarily all programmed to print the same number of times.\n</p><p>\n  The computers have all finished printing, but unfortunately, they all\n  printed to the same display! Because the computers printed concurrently,\n  event names in the final output string may be interleaved. You are\n  considering the possible ways in which that string could have been produced.\n</p><p>\n  For example, the string <code>IiOioIoO</code> could have been produced\n  as follows:\n  <pre>\n    index:  1 2 3 4 5 6 7 8\n    IO:     . . . . . . . .\n    Io:     I . . . o I o .\n    iO:     . i O i . . . O\n    io:     . . . . . . . .\n    string: I i O i o I o O\n  </pre>\n</p><p>\n  In this interpretation, the <code>Io</code> event was advertised twice, the\n  <code>iO</code> event was advertised twice, and the other two events were\n  not advertised at all.\n</p><p>\n  Notice that there is no valid interpretation of this string in which the\n  <code>IO</code> computer advertised its event twice. In that case, the\n  remaining output, <code>iioo</code>, would have had to have come from the\n  <code>io</code> computer, but that is impossible &mdash; that computer would\n  have had to have printed <code>i</code> twice in a row, which is not allowed.\n</p><p>\n  However, it is possible that the <code>IO</code> computer advertised its\n  event once, as in the following interpretation:\n  <pre>\n    index:  1 2 3 4 5 6 7 8\n    IO:     . . . . . I . O\n    Io:     I . . . o . . .\n    iO:     . i O . . . . .\n    io:     . . . i . . o .\n    string: I i O i o I o O\n  </pre>\n</p><p>\n  Given a final output string, what is the maximum possible number of times\n  that the event <code>IO</code> could have been advertised?\n</p><p>\n  It is guaranteed that the string has at least one valid interpretation.\n  For example, <code>oI</code>, <code>IOI</code>, and <code>IIOO</code> are not\n  valid inputs.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> lines follow; each represents a single test case. Each case\n  consists of a string <b>S</b> containing only the characters from the set\n  <code>I</code>, <code>O</code>, <code>i</code>, and <code>o</code>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the maximum number of times <code>IO</code> could have been advertised, as\n  described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  The length of <b>S</b> is even.<br/>\n  There is at least one interpretation of the string that is consistent with\n  the rules above. (That is, there is some way to assign each character to one\n  of the four computers, such that the substring corresponding to each computer\n  consists of zero or more repeats of that computer's event's name.)<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  2 &le; the length of <b>S</b> &le; 8.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n  2 &le; the length of <b>S</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\nIiOioIoO\nIIOiOo\nIoiOiO\nio\nIiOIOIoO\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 1\nCase #3: 0\nCase #4: 0\nCase #5: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  Sample Case #1 is the one described in the problem statement. (If you have\n  read Interleaved Output: Part 1, notice that it is the same input as in the\n  first sample case in that problem, but the output is different.)\n</p><p>\n  In Sample Case #2, it is not possible that <code>IO</code> was advertised\n  twice, because then the <code>IO</code> computer would have had to print\n  two <code>I</code>s in a row. However, it is possible that <code>IO</code>\n  was advertised once, e.g.:\n  <pre>\n    index:  1 2 3 4 5 6\n    IO:     I . O . . .\n    Io:     . I . . . o\n    iO:     . . . i O .\n    io:     . . . . . .\n    string: I I O i O o\n  </pre>\n</p><p>\n  In Sample Case #3, notice that it is not possible that <code>IO</code> was\n  advertised. The second character, <code>o</code>, must have been printed by\n  the same computer that printed the first character <code>I</code>.\n</p><p>\n  In Sample Case #4, notice that it is possible that <code>I</code> and/or\n  <code>O</code> might not even show up in the string.\n</p><p>\n  In Sample Case #5, it is possible that <code>IO</code> was advertised as\n  many as three times (and in that case, <code>io</code> was advertised once).\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Interleaved Output: Part 2","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  For Test Set 1, we can enumerate all 2<sup>N</sup> possible strings of\n  length <b>N</b> composed only of <code>L</code>s and/or <code>R</code>s, and\n  check whether each one would break the scale, by simulating the process\n  explained in the problem statement. We can then output any one string that\n  works; the statement guarantees that at least one exists.\n</p><p>\n  This process has a time complexity of O(<b>N</b>&times;2<sup><b>N</b></sup>)\n  for each test case, which is fast enough for this test set.\n</p>\n<h3>Test Set 2</h3>\n<p>\n  Suppose we've placed our first marble on one of the pans. Then the second\n  marble must go on the other pan. Now we are effectively back in the same\n  situation &mdash; the scale is balanced and we have our choice of pan again,\n  but then that choice forces the next choice, and so on.\n</p><p>\n  Similarly, if the number of marbles is even (as is always the case in this\n  test set), the scale is balanced before we start to remove marbles. This\n  means we can remove the first marble from either pan, but the second marble\n  we remove must come from the other one. The third marble can be removed from\n  either one again, but the fourth must be removed from the other one, and so\n  on.\n</p><p>\n  We can formalize the first observation by saying that marbles 2i and 2i-1\n  must go on different pans, for every i &ge; 1. We can formalize the second\n  observation by saying that marbles <b>A</b><sub>2i-1</sub> and\n  <b>A</b><sub>2i</sub> must go on different pans, for every i &ge; 1.\n</p><p>\n  The rules above help to reduce this problem to\n  <a href=\"https://en.wikipedia.org/wiki/Graph_coloring#Vertex_coloring\" target=\"_blank\">graph coloring</a>\n  . In our graph, each node represents a marble, and each pair of marbles that\n  are required to be on different pans is connected by an edge. The resulting\n  graph has <b>N</b> nodes and at most <b>N</b> edges, and each of the nodes is\n  connected to at most 2 other nodes. If we can 2-color the graph, we can use\n  one of the colors (it doesn't matter which one) to represent the left pan and\n  the other to represent the right pan, and then we will have our desired\n  assignment of marbles to pans. Better yet, 2-coloring takes at most linear\n  time!\n</p><p>\n  How can be sure that a 2-coloring is possible, apart from the assurances in\n  the problem statement that a solution always exists? Well, this is possible\n  if and only if there are no cycles of odd length &mdash; can we show that?\n</p><p>\n  The constraints from the marble-adding phase pair up nodes 1 and 2, 3 and 4,\n  etc. Call these the \"original pairs\". Any additional constraint from the\n  marble-removing phase (that is, from the input permutation <b>A</b>) can do\n  one of the following: match an original pair's edge, in which case that pair\n  cannot have other connections to the rest of the graph and is not a cycle, or\n  add an edge that connects two of the original pairs. Then, any path that does\n  not repeat edges alternates between edges connecting original pairs and edges\n  from the marble-removing phase that do not connect original pairs. Therefore,\n  any cycle formed is of even length, or else it would have two edges of the\n  same type one after the other.\n</p><p>\n  So, the resulting graph is\n  <a href=\"https://en.wikipedia.org/wiki/Bipartite_graph\" target=\"_blank\">bipartite</a>\n  and our strategy will always find a solution.\n</p>\n<h3>Test Set 3</h3>\n<p>\n  Let's reconsider the above strategy and see if we can make it work for odd\n  <b>N</b>:\n  <ul>\n    <li>The first rule (\"marbles 2i and 2i-1 must go on different pans, for\n      every i &ge; 1\") is still fine &mdash; the pans will be balanced right\n      before we place marble <b>N</b>, so it does not matter where we put that\n      marble.</li>\n    <li>After we remove the marble <b>A<sub>1</sub></b> (more on that in a\n      moment), the pans will be balanced again, so we need our second and third\n      marbles to be removed from opposite sides, and then our fourth and fifth,\n      and so on. We can replace the second rule above (\"marbles\n      <b>A</b><sub>2i-1</sub> and <b>A</b><sub>2i</sub> must go on different\n      pans, for every i &ge; 1\") with: marbles <b>A</b><sub>2i</sub> and\n      <b>A</b><sub>2i+1</sub> must go on different pans, for every i\n      &ge; 1. (If we write this as \"marbles <b>A</b><sub><b>N</b>-2i+2</sub> and\n      <b>A</b><sub><b>N</b>-2i+1</sub> must go on different pans, for every i\n      &ge; 1\", then the condition is the same as in the even-<b>N</b> case.)\n    </li>\n    <li>Finally, the first marble removed, <b>A<sub>1</sub></b>, must come from\n      the heaviest pan. We know that marble <b>N</b> is in the heaviest pan, so\n      one way to represent this constraint is to replace both\n      <b>A<sub>1</sub></b> and <b>N</b> in the graph with a new \"node\" that\n      represents them both. We can do this because we know that marble <b>N</b>\n      has no constraints arising from the marble-adding phase, and marble\n      <b>A<sub>1</sub></b> has no constraints arising from the marble-removing\n      phase. So the argument from earlier about no odd cycles still holds;\n      this new \"node\" can only be entered via one type of constraint and exited\n      via another.\n  </ul>\n</p><p>\n  A less complex version of the above idea is: we can introduce an imaginary\n  extra marble that we add last and remove first, making the total number of\n  marbles even again. We can add <b>N</b> + 1 to the end of the identity\n  permutation, and to the beginning of the input permutation (since it was the\n  last marble added, it's always safe to remove it first, restoring a previous\n  valid state). Then we can solve the problem as in the even version above, and\n  finally chop off the last character of the sequence. This gives us the same\n  O(<b>N</b>) time complexity as in Test Set 2.\n</p>\n<h3>A note on 2-SAT</h3>\n<p>\n  A more abstract view of the same solution is to represent each marble as a\n  Boolean variable (where true corresponds to assignment to one pan and false\n  to assignment to the other pan), and then encode the requirements explained\n  above as two implications of literals, which are in turn disjunctions of\n  literals. The conjunction of all those requirements is a valid input to\n  <a href=\"https://en.wikipedia.org/wiki/2-satisfiability\" target=\"_blank\">2-satisfiability</a>\n  (2-SAT). Notice that the graph created in the typical 2-SAT algorithm is\n  exactly 2 copies of the graph mentioned for the solution above, so the\n  algorithm ends up being the same in both cases.\n</p>\n","id":"00000000001b5e24","statement":"<h3>Problem</h3>\n<p> You have a special balance scale, with two pans (left and right) that are\n  both initially empty. You also have a box of identical 1-gram marbles. There\n  are <b>N</b> of these marbles, and the marbles are numbered from 1 to\n  <b>N</b>.\n</p><p>\n  Your scale is very sensitive, and you know that if the total weight on the\n  left pan and the total weight on the right pan ever differ by strictly more\n  than 1 gram, the scale will break. For example, if at some point there are 4\n  marbles in one of the pans, there must be either 3, 4, or 5 marbles in the\n  other pan.\n</p><p>\n  Your friend Libra has challenged you to do the following, without breaking\n  the scale at any point:\n  <ul>\n    <li>First, put all of the marbles on the scale one at a time, in numerical\n      order: marble 1, then marble 2, and so on up to marble <b>N</b>. For each\n      marble, you choose whether to place it on the left pan or on the right\n      pan.</li>\n    <li>Then, remove all of the marbles from the scale one at a time, in an\n      order <b>A<sub>1</sub></b>, <b>A<sub>2</sub></b>, ...,\n      <b>A<sub>N</sub></b> specified by your friend. This order is a\n      permutation of 1, 2, ..., <b>N</b>. The i-th marble you remove must be\n      the marble numbered <b>A<sub>i</sub></b>.\n  </ul>\n</p><p>\n  Can you find a way to do this?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case begins with one line with an\n  integer <b>N</b>: the number of marbles. Then, there is one more line with\n  <b>N</b> integers\n  <b>A<sub>1</sub></b>, <b>A<sub>2</sub></b>, ..., <b>A<sub>N</sub></b>,\n  which constitute a permutation of the first <b>N</b> natural numbers.\n  The marble numbered <b>A<sub>i</sub></b> must be the i-th marble that you\n  remove in the removal phase.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1) and\n  <code>y</code> is a string of <b>N</b> characters. The i-th of these\n  characters (counting starting from 1) should be uppercase <code>L</code> if\n  the i-th numbered marble should be put on the left pan, or uppercase\n  <code>R</code> if it should be put on the right pan.\n</p><p>\n  It is guaranteed that at least one answer exists. If there are multiple valid\n  answers, you may output any one of them.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>A<sub>i</sub></b> &le; <b>N</b>, for all i.<br/>\n  <b>A<sub>i</sub></b> &ne; <b>A<sub>j</sub></b> for all i &ne; j.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  2 &le; <b>N</b> &le; 16.<br/>\n  <b>N</b> is even.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n  2 &le; <b>N</b> &le; 1000.<br/>\n  <b>N</b> is even.<br/>\n</p>\n\n<h4>Test set 3 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n4\n3 1 2 4\n4\n1 2 3 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: LRRL\nCase #2: LRLR\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, we will put marble 1 on the left pan, then put marble 2 on\n  the right pan, then put marble 3 on the right pan, then put marble 4 on the\n  left pan. Notice that the total weights on the left and right pans &mdash;\n  (1, 0), (1, 1), (1, 2), and (2, 2) &mdash; never differ by more than 1\n  throughout this process.\n</p><p>\n  Then, we must remove the marbles in the order 3, 1, 2, 4. Again, the total\n  weights on the left and right pans &mdash; (2, 1), (1, 1), (1, 0), (0, 0)\n  &mdash; never differ by more than 1 at any point. We have succeeded!\n</p><p>\n  Also notice that <code>RLLR</code> would be a valid answer for this case, per\n  the same reasoning above (but with the two pans swapped).\n</p><p>\n  Notice that the following are examples of invalid answers for this case:\n  <ul>\n    <li><code>LLRR</code>: breaks the scale when placing marble 2</li>\n    <li><code>LRLR</code>: breaks the scale when removing marble 1 (which is\n      the second marble to be removed)</li>\n  </ul>\n</p><p>\n  Although there are no samples with odd <b>N</b> (since that is only possible\n  in Test Set 3), here are some examples:\n  <ul>\n    <li><code>1</code>: Either <code>L</code> or <code>R</code> would be\n      acceptable.</li>\n    <li><code>2 3 1</code>: <code>LRR</code> and <code>RLL</code> are the only\n      acceptable answers. <code>LLL</code>, <code>LLR</code>, <code>RRL</code>,\n      and <code>RRR</code> would break the scale during the placement phase.\n      <code>LRL</code> and <code>RLR</code> would break the scale during the\n      removal phase.</li>\n  </ul>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":13},{"type":2,"type__str":"HIDDEN","value":7}],"title":"Imbalance Obviation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  One way of approaching this test set is to try all ways of assigning pairs of\n  characters in the string (an uppercase <code>I</code> or lowercase\n  <code>i</code> followed by an uppercase <code>O</code> or lowercase\n  <code>o</code>) to particular computers, and in each case, recursively check\n  whether the remaining string could have been produced. If, at any point during\n  our check, our string starts with an uppercase <code>O</code> or lowercase\n  <code>o</code>, then the string is invalid and we can abandon that branch\n  of the search.\n</p><p>\n  For example, if we have <code>IoiO</code>, we can try assigning the\n  uppercase <code>I</code> and the uppercase <code>O</code> to an\n  <code>IO</code> computer, then recursively check the remaining\n  <code>oi</code> and find that it's invalid, then try instead assigning the\n  uppercase <code>I</code> and lowercase <code>o</code> to an <code>Io</code>\n  computer, and so on. Finally, find the largest possible number of\n  advertisements of <code>IO</code>, across all valid assignments.\n</p>\n<h3>Test Set 2</h3>\n<p>\n  The above strategy is too slow for Test Set 2 because there are too many\n  possible pairs to check. Let's look for a simpler strategy.\n</p><p>\n  As we scan through a string, whenever we encounter an uppercase or lowercase\n  O, we must find a previous unused uppercase or lowercase I to pair it with\n  (implicitly claiming that a particular computer printed both of those\n  characters). Intuitively, to find an interpretation that maximizes the number\n  of times <code>IO</code> is advertised, we would like to do the following as\n  much as possible:\n  <ul>\n    <li>Preferentially pair an uppercase <code>O</code> with an uppercase\n      <code>I</code>, rather than with a lowercase <code>i</code></li>\n    <li>Preferentially pair a lowercase <code>o</code> with a lowercase\n      <code>i</code>, rather than with an uppercase <code>I</code></li>\n  </ul>\n</p><p>\n  However, we may not always be able to get what we want! For example, suppose\n  we are scanning through the input <code>IoiO</code>. When we reach the\n  lowercase <code>o</code>, we have no choice but to pair it with the preceding\n  <code>I</code>.\n</p><p>\n  We can prove, though, that if we adhere to the above preferences whenever we\n  have a choice, we will find the correct answer. Suppose we are carrying out\n  this method, and we reach an uppercase <code>O</code> &mdash; call it\n  O<sub>1</sub> &mdash; that we can match to either some previous unmatched\n  uppercase <code>I</code> &mdash; call it I<sub>prev</sub> &mdash; or some\n  previous unmatched lowercase <code>i</code> &mdash; call it i<sub>prev</sub>.   Suppose we choose to match O<sub>1</sub> with i<sub>prev</sub>. Then we must\n  eventually match I<sub>prev</sub> with some later uppercase or lowercase O.\n  (It is guaranteed that at least one of these exists because the input\n  satisfies a balanced parentheses constraint, as outlined in the Limits\n  section.) Call that later O O<sub>2</sub>. We will obtain 1 \"point\" (i.e. we\n  will be able to claim that an <code>IO</code> computer advertised its event\n  once) if O<sub>2</sub> is uppercase, and 0 points if O<sub>2</sub> is\n  lowercase.\n</p><p>\n  But then observe that we could have instead matched the uppercase\n  <code>O</code><sub>1</sub> with I<sub>prev</sub> (scoring 1 point\n  <i>for sure</i>), and matched the lowercase i<sub>prev</sub> with the same\n  O<sub>2</sub>. This argument holds true no matter which O<sub>2</sub> we\n  picked. So preferentially matching with the I<sub>prev</sub> is no worse, and\n  may be better.\n</p><p>\n  A similar argument holds for the situation in which we reach a lowercase\n  <code>o</code> that we can match to either a previous uppercase\n  <code>I</code> or a previous lowercase <code>i</code>, and it tells us to\n  preferentially match with the i<sub>prev</sub>.\n</p><p>\n  We have covered the only two cases in which we can make a decision. Since no\n  other strategy is better in either case, our strategy is an optimal one. It\n  is possible that we may have a choice of e.g. two previous uppercase\n  <code>I</code>s and one previous lowercase <code>i</code>, but then it does\n  not matter which of the uppercase <code>I</code>s we pick, since whichever\n  one we don't use will still be \"previous\" for the purposes of later\n  decisions.\n</p><p>\n  A simpler way to frame this strategy is as follows: scan through the string\n  from left to right, keeping two counts: C<sub>I</sub>, the number of\n  unmatched uppercase <code>I</code>s seen so far, and C<sub>i</sub>, the\n  number of unmatched lowercase <code>i</code>s seen so far. When we encounter\n  an uppercase <code>O</code>, score one point and decrement C<sub>I</sub> if\n  C<sub>I</sub> is positive, or otherwise decrement C<sub>i</sub>. When we\n  encounter a lowercase <code>o</code>, decrement C<sub>i</sub> if\n  C<sub>i</sub> is positive, or otherwise decrement C<sub>I</sub>. Notice that\n  the rules of the problem guarantee that these counts will never\n  simultaneously become zero at the time we encounter an uppercase\n  <code>O</code> or lowercase <code>o</code>.\n</p>\n","id":"00000000001b5e88","statement":"<h3>Problem</h3>\n<p>\n  <i>\n    You do not need to read the <b>Interleaved Output: Part 2</b> problem to\n    be able to solve this problem. Both Part 1 and Part 2 have the same first\n    two paragraphs (not including this informational text). We have underlined\n    the critical difference between the two parts.\n  </i>\n</p><p>\n  On a distant moon of Jupiter, some developer conference events are about to\n  happen! They are called <code>IO</code> (uppercase I, uppercase O),\n  <code>Io</code> (uppercase I, lowercase o), <code>iO</code> (lowercase I,\n  uppercase O), and <code>io</code> (lowercase I, lowercase O).\n</p><p>\n  The best way to advertise an event is by using special computers that print\n  the event's name one character at a time, with the output appearing on a\n  digital display. Each such computer only knows the name of one event, and is\n  programmed to print its event's name zero or more times. For example, a\n  computer programmed to print <code>IO</code> twice prints an <code>I</code>,\n  followed by an <code>O</code>, followed by an <code>I</code>,\n  followed by an <code>O</code>, for a final string of <code>IOIO</code>.\n</p><p>\n  You know that the conference organizers are using these computers, but you do\n  not know how many computers are advertising each event. <u>For each event,\n  there may be any number of computers (including zero) programmed to print the\n  event's name.</u> Moreover, the computers are not necessarily all programmed\n  to print the same number of times. For example, it is possible that there are\n  three computers programmed to print <code>Io</code> once each, and one\n  computer programmed to print <code>Io</code> twice.\n</p><p>\n  The computers have all finished printing, but unfortunately, they all\n  printed to the same display! Because the computers printed concurrently,\n  event names in the final output string may be interleaved. You are\n  considering the possible ways in which that string could have been produced.\n</p><p>\n  For example, the string <code>IiOioIoO</code> could have been produced by\n  two computers, as follows:\n  <ul>\n    <li>A: programmed to print <code>Io</code> twice</li>\n    <li>B: programmed to print <code>iO</code> twice</li>\n  </ul>\n  <pre>\n    index:  1 2 3 4 5 6 7 8\n    A:      I . . . o I o .\n    B:      . i O i . . . O\n    string: I i O i o I o O\n  </pre>\n</p><p>\n  In this interpretation, the <code>Io</code> event was advertised twice, the\n  <code>iO</code> event was advertised twice, and the other two events were\n  not advertised at all.\n</p><p>\n  But the string could have also been produced by three computers:\n  <ul>\n    <li>A: programmed to print <code>IO</code> twice</li>\n    <li>B: programmed to print <code>io</code> once</li>\n    <li>C: programmed to print <code>io</code> once</li>\n  </ul>\n  <pre>\n    index:  1 2 3 4 5 6 7 8\n    A:      I . O . . I . O\n    B:      . i . . o . . .\n    C:      . . . i . . o .\n    string: I i O i o I o O\n  </pre>\n</p><p>\n  In this interpretation, the <code>IO</code> event was advertised twice, the\n  <code>io</code> event was advertised twice, and the other two events were not\n  advertised at all. Notice that this interpretation required two computers\n  printing <code>io</code>; there could not have been just one computer\n  printing <code>io</code> twice, because it would have had to print\n  <code>i</code> twice in a row, which is not allowed.\n</p><p>\n  Given a final output string, what is the maximum possible number of times\n  that the event <code>IO</code> could have been advertised?\n</p><p>\n  It is guaranteed that the string has at least one valid interpretation.\n  For example, <code>oI</code> and <code>IOI</code> are not valid inputs.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> lines follow; each represents a single test case. Each case\n  consists of a string <b>S</b> containing only the characters from the set\n  <code>I</code>, <code>O</code>, <code>i</code>, and <code>o</code>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the maximum number of times <code>IO</code> could have been advertised, as\n  described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  The length of <b>S</b> is even.<br/>\n  For each prefix S' of <b>S</b>, the number of <code>i</code>\n  characters plus the number of <code>I</code> characters in S' is not less\n  than the number of <code>o</code> characters plus the number of\n  <code>O</code> characters in S'.<br/>\n  The number of <code>i</code>s plus the number of <code>I</code>s in <b>S</b>\n  is equal to the number of <code>o</code>s plus the number of <code>O</code>s\n  in <b>S</b>.<br/>\n  (Notice that the above three conditions guarantee that there is at least one\n  interpretation of <b>S</b> that is consistent with the rules in the problem\n  statement.)<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  2 &le; the length of <b>S</b> &le; 8.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n  2 &le; the length of <b>S</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\nIiOioIoO\nIiOOIo\nIoiOiO\nio\nIIIIOOOO\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 1\nCase #3: 0\nCase #4: 0\nCase #5: 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  Sample Case #1 is the one described in the problem statement. We saw that\n  there is an interpretation in which <code>IO</code> was advertised twice.\n  There are only two <code>I</code>s and two <code>O</code>s in the string,\n  so the answer cannot be larger than this.\n</p><p>\n  In Sample Case #2, notice that it is not possible that <code>IO</code> was\n  advertised twice. The only possible interpretations are as follows:\n  <ul>\n    <li>A: programmed to print <code>IO</code> once</li>\n    <li>B: programmed to print <code>iO</code> once</li>\n    <li>C: programmed to print <code>Io</code> once</li>\n  </ul>\n  <pre>\n    index:  1 2 3 4 5 6\n    A:      I . . O . .\n    B:      . i O . . .\n    C:      . . . . I o\n    string: I i O O I o\n  </pre>\n</p><p>\n  or the same but with\n  <pre>\n    index:  1 2 3 4 5 6\n    A:      I . O . . .\n    B:      . i . O . .\n    C:      . . . . I o\n    string: I i O O I o\n  </pre>\n</p><p>\n  In either of these interpretations, <code>IO</code> was advertised only\n  once.\n</p><p>\n  In Sample Case #3, there is no possible interpretation in which\n  <code>IO</code> was advertised. There must have been one computer programmed\n  to print <code>Io</code> once, and either one computer printing\n  <code>iO</code> twice, or two computers printing <code>iO</code> once each.\n</p><p>\n  In Sample Case #4, notice that it is possible that <code>I</code> and/or\n  <code>O</code> might not even show up in the string.\n</p><p>\n  In Sample Case #5, an interpretation in which <code>IO</code> was advertised\n  four times requires four computers, each of which was programmed to\n  print <code>IO</code> once.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":11}],"title":"Interleaved Output: Part 1","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  We can start by making the observation that for every valid quadrilateral,\n  p<sub>1</sub>p<sub>2</sub>p<sub>3</sub>p<sub>4</sub>, at least one of the\n  two diagonals divides the quadrilateral into two triangles. We can order\n  the points in the quadrilateral such that the diagonal formed by points\n  p<sub>1</sub> and p<sub>3</sub> splits the quadrilateral into two triangles.\n  This means that points p<sub>2</sub> and p<sub>4</sub> are on opposite sides\n  of the infinite line through p<sub>1</sub> and p<sub>3</sub> or vice versa.\n  Without loss of generality, we can assume the former, since it is just a renaming\n  of the same set of points in the same order.\n  The area of p<sub>1</sub>p<sub>2</sub>p<sub>3</sub>p<sub>4</sub> is equal to\n  the sum of the areas of the two triangles\n  p<sub>1</sub>p<sub>3</sub>p<sub>2</sub> and\n  p<sub>1</sub>p<sub>3</sub>p<sub>4</sub>.\n  These areas are equal to half of the product of the distance between\n  p<sub>1</sub> and p<sub>3</sub> and the distance between p<sub>2</sub>\n  (or p<sub>4</sub>) and the line through p<sub>1</sub> and p<sub>3</sub>.\n  Therefore, if we choose two points to be p<sub>1</sub> and p<sub>3</sub> in\n  our quadrilateral, we can find the minimum area using those two points by\n  getting the closest point to the line through p<sub>1</sub> and p<sub>3</sub>\n  on each side of the line.\n</p>\n\n<h3>Test set 1</h3>\n<p>\n  With only 25 points, we can test every set of 4 points in every order. To\n  make sure a specific order defines a simple polygon, it suffices to check\n  the sign of the signed area of both triangles is positive. This can be done by\n  checking the sign of the\n  <a href=\"https://en.wikipedia.org/wiki/Cross_product\" target=\"_blank\">cross product</a>\n  when computing the area of the two triangles that make up the quadrilateral.\n</p><p>\n  We could also can loop over all possible pairs of points to use as p<sub>1</sub>\n  and p<sub>3</sub>, and then, for each pair, loop through the remaining points\n  to find the closest on each side.\n  There are O(<b>N</b><sup>2</sup>) unique pairs of points and for each pair, we\n  check O(<b>N</b>) other points to find the closest on each side. This gives\n  an overall time complexity of O(<b>N</b><sup>3</sup>).\n</p>\n\n<h3>Test set 2</h3>\n<p>\n  In test set 2 we have significantly more points to choose from that a time\n  complexity of O(<b>N</b><sup>3</sup>) will not work for the given time limit.\n  We can, however, precompute all lines formed by unique pairs of points\n  and do a circular\n  <a href=\"https://en.wikipedia.org/wiki/Sweep_line_algorithm\" target=\"_blank\">sweep line</a>,\n  processing those lines in order of their slopes; this will make it much faster to\n  find the closest points to the lines. As we rotate, we keep the points in a list sorted\n  by their distance to the line.\n</p><p>\n  We can add the horizontal line to the set of stop points, and use it as the starting angle\n  for the sweep line. This simplifies initialization because sorting the points by distance\n  to this line is simply sorting by y-coordinate.\n  Then, for any p<sub>1</sub> and p<sub>3</sub>, the closest points to the line\n  p<sub>1</sub>p<sub>3</sub> must be ones which are adjacent to either\n  p<sub>1</sub> or p<sub>3</sub> in the sorted list (because p<sub>1</sub> and p<sub>3</sub>\n  have a distance of 0). There is a constant number of candidates, so we can check them\n  all in constant time to find the best p<sub>2</sub> and p<sub>4</sub>.\n</p><p>\n  As we rotate our orientation to line up with the next\n  smallest sloped line, we can see that the only points that change their\n  ordering in the sorted list are the two points of the line segment being\n  looked at. Taking advantage of this, we can maintain our sorted list of points\n  by just swapping the adjacent pairs of each line after we consider them in\n  order of slope.\n</p><p>\n  Because we still have O(<b>N</b><sup>2</sup>) unique lines and we need to sort\n  them by their slopes, the initial time complexity to generate the sorted list\n  of lines and the initial ordering of the points is\n  O(<b>N</b><sup>2</sup> log <b>N</b>). After we have all the line segments\n  sorted, we can maintain the sorted list and go through each line in order and\n  find the closest points in O(1) per line. This results in an overall time\n  complexity of O(<b>N</b><sup>2</sup> log <b>N</b>).\n</p>\n","id":"00000000001b5e89","statement":"<h3>Problem</h3>\n<p>\n  The artist Cody-Jamal recently decided to out-hip all of his hipster friends\n  by showing his latest paintings in an impromptu outdoor gallery. He is going\n  to show up in a field, put up some paintings, and display them.\n</p><p>\n  The field has <b>N</b> posts in it, with no subset of 3 of them being\n  collinear (which also implies that no two posts are in the same place).\n  Cody-Jamal is going to choose four of them &mdash; call them p<sub>1</sub>,\n  p<sub>2</sub>, p<sub>3</sub>, and p<sub>4</sub>. He will then string velvet\n  ropes between p<sub>1</sub> and p<sub>2</sub>, p<sub>2</sub> and\n  p<sub>3</sub>, p<sub>3</sub> and p<sub>4</sub>, and finally, p<sub>4</sub>\n  and p<sub>1</sub>. He must choose the four ordered posts such that no two\n  ropes cross, effectively forming a\n  <a href=\"https://en.wikipedia.org/wiki/Quadrilateral#Simple_quadrilaterals\" target=\"_blank\">simple quadrilateral</a>\n  p<sub>1</sub>p<sub>2</sub>p<sub>3</sub>p<sub>4</sub>. The quadrilateral may be\n  convex or concave.\n  He will then hang his paintings inside the perimeter delimited by the ropes.\n</p><p>\n  To attract wealthy art lovers that might purchase his paintings, Cody-Jamal\n  is hiring waitstaff to go around and serve refreshments to visitors. The cost\n  of the refreshments is fixed, but the cost of the waitstaff is proportional\n  to the area they will have to walk. Specifically, they charge 2 artcoins per\n  square meter. Therefore, Cody-Jamal wants to choose\n  p<sub>1</sub>, p<sub>2</sub>, p<sub>3</sub> and p<sub>4</sub> to minimize the\n  area of the quadrilateral\n  p<sub>1</sub>p<sub>2</sub>p<sub>3</sub>p<sub>4</sub>, and thus minimize the\n  cost (in artcoins) of the refreshments service. What is the minimum such cost?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case begins with a line containing a\n  single integer <b>N</b>: the number of posts in the field. <b>N</b> more\n  lines follow, each containing two integers <b>X<sub>i</sub></b> and\n  <b>Y<sub>i</sub></b>, representing the coordinates, in meters from an\n  arbitrary origin, of the i-th post.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the minimum number of artcoins Cody-Jamal will have to pay &mdash; or, in\n  other words, twice the area (in square meters) of a smallest simple\n  quadrilateral that has four of the input points as vertices.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.<br/>\n  -10<sup>9</sup> &le; <b><b>X<sub>i</sub></b></b> &le; 10<sup>9</sup>,\n  for all i.<br/>\n  -10<sup>9</sup> &le; <b><b>Y<sub>i</sub></b></b> &le; 10<sup>9</sup>,\n  for all i.<br/>\n  No three points in the input are collinear.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  Time limit: 20 seconds.<br/>\n  1 &le; <b>T</b> &le; 50.<br/>\n  4 &le; <b>N</b> &le; 25.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n  Time limit: 60 seconds.<br/>\n  1 &le; <b>T</b> &le; 30.<br/>\n  4 &le; <b>N</b> &le; 1200.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n4\n-5 5\n-5 -5\n5 5\n5 -5\n5\n-5 5\n-5 -5\n5 5\n5 -5\n4 2\n5\n-5 5\n-5 -4\n5 5\n5 -5\n4 2\n4\n-1000000000 -1000000000\n-1000000000 1000000000\n1000000000 -1000000000\n1000000000 1000000000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 200\nCase #2: 30\nCase #3: 31\nCase #4: 8000000000000000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Case #1, there are only 4 points in the input, and the only orderings that\n  can be chosen to form a simple quadrilateral yield a square of side length 10.\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2sKgYbwBndf4hyawvypE7hoNpe0ATFUXh1K76i9sgLBaYWoglsBcQCYEANZ0Ck69liRL8g3BfmbCHH4hjNi1Fa/sample_case_1.svg\" />\n</p>\n<p>\n  In Cases #2 and #3, an optimal choice is to leave the first point out and\n  use the last four, in the order given in the input.\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U34-kms_jpZjjCUA3AufomWrcgl7l4Zb2AkdtlChqlp8jqTmloWVHo1DNBRza1BgmXYyVirM-6bJwtANeBajctZ/sample_case_2.svg\" />\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3dS6ybC5VrpLx0-jcyrp1of8pbNnq5nCll22_8JtKiqoQ9QkTcZkfOMTcReW8k8Tr7bH0Z6Jf4yc7ys6vgqQ5l/sample_case_3.svg\" />\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Impromptu Outdoor Gallery","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000019ff03","type":1,"type__str":"SPECTATOR"},"title":"Code Jam to I/O for Women 2020"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
