{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1462041000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201b6c","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"</p><p>\nRound 1B featured two problems with possible greedy approaches, <i>Getting\nthe Digits</i> and <i>Close Match</i>; the latter was much trickier to wrestle\nwith! <i>Technobabble</i> required bipartite matching for the Large; more\nadvanced techniques like this tend to show up as the contest goes on.\n</p><p>\nTwo of our competitors in Round 1B, ikatanic and rng..58, accomplished a feat\nthat we've never seen before in Code Jam: by submitting their final correct\ndatasets at exactly the same time (37 minutes and 32 seconds into the contest,\nwith no penalties for wrong Smalls), they tied for first place! Congratulations\nto our co-winners of this round.\n</p><p>\nAlmost 8,000 contestants submitted at least one correct dataset, and there\nwere 324 perfect scores. To be in the top 1000, you needed at least 56 points\n(which usually meant at least two Larges) plus some speed.\n</p><p>\nThe top 1000 contestants in this round advance to Round 2 and Distributed\nRound 1, joining the 1000 advancers from Round 1A. We will email official\nresults early next week. If you weren't in the top 1000 in Rounds 1A or 1B,\nRound 1C will give you one more chance to advance; see the\nschedule.\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>Getting the Digits</i>): Written by Ian Tullis. Prepared by Steve\nThomas and Ian Tullis.\n</p><p>\nProblem B (<i>Close Match</i>): Written by Pablo Heiber. Prepared by Karol\nPokorski and Ian Tullis.\n</p><p>\nProblem C (<i>Technobabble</i>): Written by Ian Tullis. Prepared by John\nDethridge and Karol Pokorski.\n</p><p>\nSolutions and other problem preparation and review by Shane Carr, John\nDethridge, Minh Doan, Jackson Gatenby, Taman (Muhammed) Islam, Timothy Loh,\nKarol Pokorski, Steve Thomas, and Yerzhan Utkelbayev.\n</p><p>\nAnalysis authors:\n</p>\n<ul>\n<li>Getting the Digits: Ian Tullis</li>\n<li>Close Match: Ian Tullis</li>\n<li>Technobabble: Shane Carr</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1462032000000,"tasks":[{"analysis":"<h2>Getting the Digits: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nSince the string can be no longer than 20 letters in the Small dataset, the\nphone number can be no longer than six digits (since the digits with the\nshortest spelled-out length, <code>ONE</code> and <code>TWO</code>, have three\nletters, and 7 * 3 > 20). A key observation is that this means there are no\nmore than a million possible answers; in fact, there are far fewer than that,\nsince only phone numbers with digits in nondecreasing order are valid.\n</p><p>\nSo, you can look at all possible phone numbers from <code>0</code> to\n<code>9</code>, <code>00</code> to <code>99</code> (note that <code>00</code>\nis different from <code>0</code>), and so on, up to <code>000000</code> through\n<code>999999</code>, and save the numbers that have their digits in\nnondecreasing order. (In fact, for that last range, you only need to go up to\n<code>222222</code>.) Then, turn each of those into letters. There are\nmultiple possible orderings for those letters &mdash; <code>1</code> could be\ngiven as <code>EON</code>, <code>ENO</code>, or <code>NEO</code>, among others\n&mdash; but you can just take the alphabetically ordered version. <code>0</code>\nbecomes <code>EORZ</code>, <code>1</code> becomes <code>ENO</code>, ...,\n<code>01</code> becomes <code>EENOORZ</code>, and so on.\n</p><p>\nThen you can make a dictionary (hash table) with these strings as keys\nand the phone numbers as values. (It turns out that each of those keys maps to\nonly one phone number &mdash; more on that later.) To solve a test case, take\nthe string your friend gave you, sort it alphabetically, and then look that up\nin the dictionary. (Your friend could have given you the same string in any\norder, so you can permute it however you want without changing the identity of\nthe underlying phone number.)\n</p><p>\nThere's no need to generate this dictionary every time you solve a test case;\nyou can do it just once, before your program starts processing test cases. You\ncan even produce the entire dictionary before you download an input file and\nstore it in your source code or in a separate file that your source code reads,\nas long as this does not cause your source code to exceed the standard limit of\n100kB.\n</p>\n<h3>Large dataset</h3>\n<p>\nThe dictionary for all 1000-digit phone numbers would be too huge to generate\nand store beforehand, let alone produce on the fly.\n</p><p>\nOne tempting approach is to greedily remove spelled-out digits: for instance,\nkeep taking the letter set <code>NINE</code> (one <code>E</code>, one\n<code>I</code>, and two <code>N</code>s) away until you no longer can, then\nkeep taking the letter set <code>EIGHT</code> away, and so on. But this won't\nnecessarily work &mdash; what if there are no <code>9</code>s in the actual\nphone number, and the first <code>NINE</code> you try to take away is really\nthe <code>N</code> from a <code>SEVEN</code>, the <code>I</code> from a\n<code>SIX</code>, and the <code>NE</code> from a <code>ONE</code>? This will\neventually leave you with a mess of letters from which no digit's letters can\nbe removed!\n</p><p>\nIt turns out that you can make this method work... as long as you pick the\nright order in which to remove the digits! For instance, <code>FOUR</code> is\nthe only digit out of the ten that contains a <code>U</code>. So, if you see\nthree <code>U</code>s in the string, there must be three instances of\n<code>FOUR</code>. You can safely remove three <code>F</code>s, three\n<code>O</code>s, three <code>U</code>s, and three <code>R</code>s, and record\nthat the phone number has three <code>4</code>s. Once all the\n<code>FOUR</code>s are gone, <code>FIVE</code> is the only remaining digit with\nan <code>F</code>, so you can remove as many <code>FIVE</code>s as there are\n<code>F</code>s, and so on. If you had tried to do this in the other order,\nstarting by removing as many <code>FIVE</code>s as there were <code>F</code>s,\nit might not have worked, depending on how many <code>FOUR</code>s,\n<code>SIX</code>es, <code>SEVEN</code>s, etc. were in the number!\n</p><p>\nHere is one safe order in which to remove digits, based on their letters that\nare unique at the time of removal: <code><b>Z</b>ERO</code>,\n<code>SI<b>X</b></code>, <code>EI<b>G</b>HT</code>, <code>T<b>W</b>O</code>,\n<code>FO<b>U</b>R</code>, <code><b>F</b>IVE</code>, <code>SE<b>V</b>EN</code>,\n<code><b>T</b>HREE</code>, <code>N<b>I</b>NE</code>, <code><b>O</b>NE</code>.\nNote, for example, that even though all of the letters in <code>ONE</code>\nappear in other digits besides <code>ONE</code>, by the time we get to removing\n<code>ONE</code>s, there are only <code>ONE</code>s left.\n</p><p>\nThe existence of an ordering like this also explains why we didn't have to\nworry about two different phone numbers having the same alphabetized string in\nour dictionary for the Small solution. Two different phone numbers cannot\nproduce the same string because no subset of digit words is a linear\ncombination of other digit words. This would <i>not</i> necessarily hold for\narbitrary sets of words, though. For example, in a language in which the digit\nwords are <code>AB</code>, <code>AC</code>, <code>BD</code>, and\n<code>CD</code>, given the string <code>ABCD</code>, it is impossible to know\nwhether it was formed from one <code>AB</code> and one <code>CD</code>, or from\none <code>AC</code> and one <code>BD</code>.\n</p>\n","id":"0000000000201bf0","statement":"<h3>Problem</h3>\n<p>\nYou just made a new friend at an international puzzle conference, and you\nasked for a way to keep in touch. You found the following note slipped under\nyour hotel room door the next day:\n</p><p>\n\"Salutations, new friend! I have replaced every digit of my phone number with\nits spelled-out uppercase English representation (\"ZERO\", \"ONE\", \"TWO\",\n\"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\" for the digits 0\nthrough 9, in that order), and then reordered all of those letters in some way\nto produce a string <b>S</b>. It's up to you to use <b>S</b> to figure out how\nmany digits are in my phone number and what those digits are, but I will tell\nyou that my phone number consists of those digits in nondecreasing order. Give\nme a call... if you can!\"\n</p><p>\nYou would to like to call your friend to tell him that this is an obnoxious way\nto give someone a phone number, but you need the phone number to do that! What\nis it?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each consists of one line with a string <b>S</b> of\nuppercase English letters.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\na string of digits: the phone number.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\nA unique answer is guaranteed to exist.<br>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n3 &le; length of <b>S</b> &le; 20.\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n3 &le; length of <b>S</b> &le; 2000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\nOZONETOWER\nWEIGHFOXTOURIST\nOURNEONFOE\nETHER\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 012\nCase #2: 2468\nCase #3: 114\nCase #4: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Getting the Digits","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Close Match: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nA brute force algorithm will work just fine for the Small. For each case, we\ncan try all possible ways to fill in the <code>?</code>s and see which way\nproduces the smallest absolute difference. It is important to break any ties\nfirst by the first score, or, if necessary, by the second score. Even in the\nworst case for brute force, <code>??? ???</code>, there are only 10<sup>6</sup>\n= one million different possibilities to check.\n</p>\n<h3>Large dataset</h3>\n<p>\nMany Code Jam problems look complex and challenging, but have a surprisingly\nsimple solution. But sometimes we throw in just the opposite sort of problem!\nIn this case, it's easy to come up with a tantalizing greedy approach that will\nsometimes fail. We'll present an approach that gets greedy only when it's safe\nto do so.\n</p><p>\nWe will investigate various different ways to fill in the <code>?</code>s, and\nwe will constantly keep track of the best set of scores (using tiebreaker\nrules) seen so far. We will look at the pair of characters in the first\nposition of each string, then the pair of characters in the second position of\neach string, and so on.\n</p><p>\nWhen we look at a pair of characters, we must decide how to fill in any\n<code>?</code>s. We may be able to make those two digits of the final scores be\nthe same, either by filling in <code>?</code>s appropriately, or because the\ntwo characters are already the same digit and we have no choice. If we're\nlucky, and we never encounter a position where the two strings have different\ndigits, we can make every pair of digits in the final scores the same! This is\nas good as it gets; our difference will be 0.\n</p><p>\nFor example, for the case <code>?1? 2??</code>, we can make all the digits\nequal to get <code>210 210</code>. We choose <code>0</code>s for any pair of\n<code>?</code>s to satisfy the tiebreaker rules.\n</p><p>\nHowever, we won't have this option in every test case. If the strings have\ndifferent digits at some position, then there's no way the score difference\ncan be 0. Moreover, we may even need to introduce our own difference before\nthat first existing point of difference! For instance, in the case <code>??0\n?99</code>, we don't want to just make the digits equal until we get to the\nfirst point of difference, because that would leave us with\n<code>090 099</code>, whereas we can do better with <code>100 099</code>.\n</p><p>\nSo, if we have two different digits at any position in the strings, then either\nwe can make everything equal up to that first existing point of difference, or\nwe can introduce a first point of difference earlier. That is, we will start\nfrom the left, and for some number of positions (possibly zero), we will make\nthe digits in the final scores equal. Then we will encounter (or make) our\nfirst point of difference.\n</p><p>\nOnce we've reached our first point of difference, we know something crucial:\n<i>which of the two final scores is larger</i>. Because the scores have been\nequal up until the first point of difference, the score with the larger digit\nin this position is guaranteed to be larger, no matter how we fill in any\n<code>?</code>s beyond this point.\n</p><p>\nMoreover, we know exactly how to fill in those <code>?</code>s to minimize the\ndifference between the two scores! We have no reason to make the larger number\nany larger, so all of its <code>?</code>s should become <code>0</code>s. And we\nwant to make the smaller number as large as possible, so all of its\n<code>?</code>s should become <code>9</code>s.\n</p><p>\nSo, as we step through our strings from left to right, for every position of\nthe strings, we'll do the following:\n<ol>\n<li>If we encounter two identical digits, move on.</li>\n<li>If we encounter two different digits, fill in all remaining\n<code>?</code>s, compare those scores with the best we've seen so far, and\nstop. We're done!</li>\n<li>If we encounter a digit and a <code>?</code>:\n<ul>\n<li>If the digit is not <code>9</code>: try changing the <code>?</code> to\n1 more than that digit. This would introduce a first point of difference, so we\nknow how we would fill in all remaining <code>?</code>s. Compare those scores\nwith the best we've seen so far. Then...</li>\n<li>If the digit is not <code>0</code>: try changing the <code>?</code> to\n1 less than that digit. This would introduce a first point of difference, so we\nknow how we would fill in all remaining <code>?</code>s. Compare those scores\nwith the best we've seen so far. Then...</li>\n<li>Change the <code>?</code> to that digit and move on. (Why didn't we try\nchanging the <code>?</code> to all possible digits? We can get away with doing\nthis, but it's not necessary. If we have control over the digits at the first\npoint of difference, there's no reason to make them differ by more than 1; this\nwould just make the overall difference larger, regardless of what we do with\nthe rest of the strings.)</li>\n</ul></li>\n<li>If we encounter two <code>?</code>s:\n<ul>\n<li>Try changing the first <code>?</code> to a <code>0</code> and the\nsecond <code>?</code> to a <code>1</code>. Figure out the scores and compare.\nThen...</li>\n<li>Try changing the first <code>?</code> to a <code>1</code> and the\nsecond <code>?</code> to a <code>0</code>. Figure out the scores and compare.\nThen...</li>\n<li>Change both <code>?</code>s to 0s and move on. (Again, there is no reason\nto make the <code>?</code>s differ by more than <code>1</code>.)</li>\n</ul></li>\n</ol>\n<p>\nWe must make sure our implementation also checks the case in which there is no\npoint of difference. Once we're done, the best scores will be our answer.\n</p><p>\nThis approach has some room for improvement, but it solves the Large very\nquickly. It makes one full pass through the strings, and at each position, it\nmight make up to 2 additional partial passes, so the worst case running time is\nO(<b>N</b><sup>2</sup>), where <b>N</b> is the length of <b>C</b> (and\n<b>J</b>). We leave an O(<b>N</b>) approach as an exercise!\n</p>\n","id":"0000000000201c8c","statement":"<h3>Problem</h3>\n<p>\nYou are attending the most important game in sports history. The Oceania Coders\nare playing the Eurasia Jammers in the Centrifugal Bumble-Puppy world finals.\nUnfortunately, you were sleep deprived from all the anticipation, so you fell\nasleep during the game!\n</p><p>\nThe scoreboard is currently displaying both scores, perhaps with one or more\nleading zeroes (because the scoreboard displays a fixed number of digits).\nWhile you were asleep, some of the lights on the scoreboard were damaged by\nstrong ball hits, so one or more of the digits in one or both scores are not\nbeing displayed.\n</p><p>\nYou think close games are more exciting, and you would like to imagine that the\nscores are as close as possible. Can you fill in all of the missing digits in a\nway that minimizes the absolute difference between the scores? If there is more\nthan one way to attain the minimum absolute difference, choose the way that\nminimizes the Coders' score. If there is more than one way to attain the\nminimum absolute difference while also minimizing the Coders' score, choose\nthe way that minimizes the Jammers' score.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ncases follow. Each case consists of one line with two non-empty strings\n<b>C</b> and <b>J</b> of the same length, composed only of decimal digits and\nquestion marks, representing the score as you see it for the Coders and the\nJammers, respectively. There will be at least one question mark in each test\ncase.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: c j</code>, where\n<code>x</code> is the test case number (starting from 1), <code>c</code> is\n<b>C</b> with the question marks replaced by digits, and <code>j</code> is\n<b>J</b> with the question marks replaced by digits, such that the absolute\ndifference between the integers represented by <code>c</code> and\n<code>j</code> is minimized. If there are multiple solutions with the same\nabsolute difference, use the one in which <code>c</code> is minimized; if there\nare multiple solutions with the same absolute difference and the same value of\n<code>c</code>, use the one in which <code>j</code> is minimized.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 200.<br/>\n<b>C</b> and <b>J</b> have the same length.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n1 &le; the length of <b>C</b> and <b>J</b> &le; 3.\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n1 &le; the length of <b>C</b> and <b>J</b> &le; 18.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1? 2?\n?2? ??3\n? ?\n?5 ?0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 19 20\nCase #2: 023 023\nCase #3: 0 0\nCase #4: 05 00\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn sample case #4, note that the answer cannot be <code>15 10</code>; that\nminimizes the absolute difference, but does not minimize the Coders' score.\nNor can the answer be <code>05 10</code>; that minimizes the absolute\ndifference and the Coders' score, but does not minimize the Jammers' score.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Close Match","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Technobabble: Analysis</h2>\n\n<h3>Small dataset</h3>\n\n<p>Each topic on the list could be \"faked\" or \"un-faked.\" One natural brute\nforce solution is to enumerate all possible orderings of the topics, and pick\nthe one that has the most faked topics.\n</p><p>\nIt's easy to check whether a topic could have been faked: simply check\nwhether the first word of the topic appears as a first word earlier in the\nlist, and the second word of the topic appears as a second word earlier in the\nlist. Note that marking a topic as faked does not change whether or not topics\nlater in the list can be marked as faked, so using this strategy, it is\noptimal to always count a topic as faked if possible.\n</p><p>\nHowever, there are <b>N</b>! possible orderings, which is too large to\nenumerate even for the small dataset where <b>N</b> &le; 16 (16! is on the\norder of 21 trillion). We need a better approach. Rather than trying to\nmaximize the number of faked topics, let's think about the reverse problem:\ntrying to minimize the number of un-faked topics.\n</p><p>\nThe key observation is that any possible set of un-faked topics must\ncontain every first word at least once and every second word at least once\n&mdash; otherwise, there would be a faked topic that contained a word that\nwas not available for the faker to use. Conversely, any set containing every\nfirst word at least once and every second word at least once could be a\npossible set of un-faked topics &mdash; simply put all the topics from the un-\nfaked set at the top of the list. So, the question we need to answer is this:\n<em>What is the smallest set of topics that contains every first word at least\nonce and every second word at least once?</em>\n</p><p>\nA brute-force approach, which works for the Small dataset, is to enumerate\nall subsets of topics and pick the subset with the fewest topics that covers\nevery first word at least once and every second word at least once. Since\nthere are 2<sup><strong>N</strong></sup> subsets, this solution runs in\nexponential time, which is fine for the Small dataset (2<sup>16</sup> =\n65,536).\n</p>\n<h3>Large dataset</h3>\n<p>\nFor the large dataset, the exponential time solution will not work. It\nturns out that there is a polynomial time solution to the problem. We will\nillustrate the solution using graph theory.\n</p><p>\nLet each word be a vertex in a\n<a href=\"https://en.wikipedia.org/wiki/Bipartite_graph\">\nbipartite graph</a> in which each topic is an edge connecting two vertices.\nThe sample input below corresponds to the following graph (we'll explain the\ncolors of the edges in a moment).\n</p>\n<code>\nHYDROCARBON COMBUSTION<br/>\nBIOMASS COMBUSTION<br/>\nQUAIL COMBUSTION<br/>\nQUAIL BEHAVIOR<br/>\nQUAIL CONTAMINATION<br/>\nGROUNDWATER CONTAMINATION<br/>\nGROUNDWATER HYDROLOGY<br/>\n</code>\n<p>\n<img alt=\"Bipartite graph in which each node is a word and each edge is a topic.\" src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3RzROHtBXu9qykJ2f_6saLOEkx1zFbJZVqH19aucM7t2PEijX0LJs3lfhTIiMy89L9gWwGMHZ-6ysSMHizxz9SG9sd/technobabblebipartite.png\"/>\n</p><p>\nThe problem we're trying to solve on this graph is the <em>minimum edge\ncover</em>; that is, finding the smallest set of edges such that each vertex\nis connected to at least one edge. This corresponds to the smallest set of\ntopics containing every first word at least once and every second word at\nleast once.\n</p><p>\nThe minimum edge cover problem is related to finding a <em>maximum\nmatching</em> of a graph (the largest set of edges without any common\nvertices): the two will always have the same number of connected components.\nIf it's not immediately obvious why this is the case, convince yourself by\ndrawing some graphs on paper\nand trying to come up with a counter-example. We can additionally observe that\nevery vertex left out of a maximum matching must be connected to a vertex in\nthe maximum matching; otherwise, we could have added that pair to the maximum\nmatching. With these facts, we can use\n<a href=\"https://en.wikipedia.org/wiki/Edge_cover#Algorithms\">a two-step\nalgorithm</a> to compute a minimum edge cover on our bipartite graph:</p>\n<ol>\n<li>Find a maximum cardinality bipartite matching of the graph, which can be\ndone in\n<a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)#In_unweighted_bipartite_graphs\">\npolynomial time</a> using an approach such as the\n<a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\">\nFord-Fulkerson algorithm</a> or the\n<a href=\"https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\">\nHopcroft&ndash;Karp algorithm</a>. One such matching\nis shown above in <span style=\"color:red\">red</span>.</li>\n<li>Iterate over the remaining edges, and greedily add edges that connect to\nan unused vertex. The edges added by this step are shown above in\n<span style=\"color:blue\">blue</span>.</li>\n</ol>\n<p>\nIn fact, all we really need to know is the <em>size</em> of a minimum\nedge cover: the number of edges in a maximum matching plus the number of\nvertices not included in a maximum matching. The solution to the problem is\nthen simply the total number of edges (topics) minus the size of a minimum edge\ncover.\n</p>\n","id":"0000000000201d19","statement":"<h3>Problem</h3>\n<p>\nEvery year, your professor posts a blank sign-up sheet for a prestigious\nscientific research conference on her door. If a student wants to give a\nlecture at the conference, they choose a two-word topic that is not already on\nthe sheet and write it on the sheet. Once the deadline has passed, the\nprofessor has one of her grad students put the topics in a random order, to\navoid biasing for or against students who signed up earlier. Then she presents\nthe topics to you for review.\n</p><p>\nSince the snacks at the conference are excellent, some students try to fake\ntheir way into the conference. They choose the first word of some topic\nalready on the sheet and the second word of some topic already on the sheet,\nand combine them (putting the first word first, and the second word second) to\ncreate a new \"topic\" (as long as it isn't already on the sheet). Since your\nprofessor is open-minded, sometimes this strategy actually works!\n</p><p>\nThe fakers are completely unoriginal and can't come up with any new first or\nsecond words on their own; they must use existing ones from the sheet.\nMoreover, they won't try to use an existing first word as their own second word\n(unless the word also already exists on the sheet as a second word), or vice\nversa.\n</p><p>\nYou have a list of all <b>N</b> of the submitted topics, in some arbitrary\norder; you don't know the order in which they were actually written on the\nsheet. What's the largest number of them that could have been faked?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each consists of one line with an integer <b>N</b>, followed\nby <b>N</b> lines, each of which represents a different topic and has two\nstrings of uppercase English letters: the two words of the topic, in order.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nan integer: the largest number of topics that could have possibly been faked.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; length of each word &le; 20.<br/>\nNo topic is repeated within a case.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 16.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\nHYDROCARBON COMBUSTION\nQUAIL BEHAVIOR\nQUAIL COMBUSTION\n3\nCODE JAM\nSPACE JAM\nPEARL JAM\n2\nINTERGALACTIC PLANETARY\nPLANETARY INTERGALACTIC\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 0\nCase #3: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn sample case #1, one possibility is that the topics were added to the sheet\nin this order:\n</p><p>\n<code>QUAIL BEHAVIOR</code> (real)<br>\n<code>HYDROCARBON COMBUSTION</code> (real)<br>\n<code>QUAIL COMBUSTION</code> (fake)<br>\n</p><p>\nThere is no scenario in which more than one of the topics can be fake.\n</p><p>\nIn sample case #2, all of the topics must be real. Whatever order they were\nwritten in, at no point would it have been possible to use existing words to\ncreate a new topic that was not already on the list.\n</p><p>\nIn sample case #3, neither topic can be fake. For example, if\n<code>INTERGALACTIC PLANETARY</code> had been the first and only topic written\non the sheet, a faker could only have used <code>INTERGALACTIC</code> as the\nfirst word of a new topic and could only have used <code>PLANETARY</code> as\nthe second word of a new topic... but the only topic that the faker could have\nformed would have been <code>INTERGALACTIC PLANETARY</code>, which would have\nbeen off limits since it was already on the sheet. So\n<code>PLANETARY INTERGALACTIC</code> must have also been a real topic.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Technobabble","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201b6c","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2016"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
