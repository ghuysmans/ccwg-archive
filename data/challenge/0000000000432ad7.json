{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1274553000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432ad7","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nIn this second sub-round of Round 1, the problems ranged from parse-and-simulate to standard dynamic programming.\n</p>\n\n<p>\nContestants found Round 1B easier than 1A. The winner, Gluk, was finished 26 minutes into the contest, with yuhch123 and Gennady.Korotkevic solving all 3 problems correctly just a few minutes later.\n</p>\n\n<h3>Cast</h3>\n<p>Problem A. <i>File Fix-it</i> Written and prepared by David Arthur.</p>\n<p>Problem B. <i>Picking Up Chicks</i> Written by Igor Naverniouk. Prepared by David Arthur and Igor Naverniouk.</p>\n<p>Problem C. <i>Your Rank is Pure</i> Written by Xiaomin Chen. Prepared by Ante Derek and Xiaomin Chen.</p>\n<p>Contest analysis presented by Xiaomin Chen and Petr Mitrichev.</p>\n<p>Solutions and other problem preparation provided by John Dethridge, Petr Mitrichev, and Cosmin Negruseri.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1274544000000,"tasks":[{"analysis":"<h3>Foreword</h3>\n<p>This is a very &quot;mathematical&quot; problem, and solving it required thinking in very formal terms. So please bear with a lot of formulas and little text in the below explanation.</p>\n<h3>Initial approach</h3>\n<p>Let's study the process described in the problem statement. Suppose the rank of number <b>N</b> with respect to set <b>S</b> is <b>K</b>. Since <b>N</b> is the largest number in <b>S</b>, that just means the number of elements in <b>S</b> is <b>K</b>.</p>\n<p>Then let's consider the set <b>S'</b> = <b>S</b> &cap; {1, 2, ..., <b>K</b>}. From the definition of a pure number, <b>K</b> is now pure with respect to <b>S'</b>.</p>\n<h3>Have we got a Dynamic Programming solution yet?</h3>\n<p>Does that mean that we've managed to reduce the problem for <b>N</b> to a smaller problem for <b>K</b>? Not yet: suppose we know the number of possible sets <b>S'</b> for which <b>K</b> is pure. How do we find the number of sets <b>S</b> that contain this set (and for which <b>N</b> is pure and that have <b>K</b> elements)?</p>\n<p>In order to do that, we need to know how many numbers are there in <b>S'</b>. Suppose there are <b>K'</b> numbers in <b>S'</b>. Then the number of ways to extend this set <b>S'</b> back to <b>S</b> is the number of ways to choose <b>K</b>-<b>K'</b>-1 numbers from the set {<b>K+1</b>, <b>K+2</b>, ..., <b>N-1</b>}.\n<h3>Now we have a Dynamic Programming solution!</h3>\n<p>Let's define <i><b>Count</b>[<b>N</b>, <b>K</b>]</i> to be the number of sets <b>S</b> that are subsets of {2, 3, ..., <b>N</b>}, have <b>K</b> elements, contain number <b>N</b> and for which number <b>N</b> is pure.</p>\n<p>The above discussion proves that <b>Count</b>[<b>N</b>, <b>K</b>] is equal to the sum over all <b>K'</b> of <b>Count</b>[<b>K</b>, <b>K'</b>] times <b>C</b>[<b>N</b>-<b>K</b>-1, <b>K</b>-<b>K'</b>-1], where <i><b>C</b>[<b>A</b>, <b>B</b>]</i> is the number of ways to choose <b>B</b> items out of <b>A</b> (so-called <a href=\"http://www.google.com/search?q=combination+number\" target=\"_blank\">combination number</a>).</p>\n<p>We can calculate <b>Count</b> values in increasing order of <b>N</b>. That will give us O(<b>N</b><sup>2</sup>) values to calculate, each requiring O(<b>N</b>) operations, for the total running time of O(<b>N</b><sup>3</sup>). That seems to be too slow for <b>N</b>=500 and 100 testcases.</p>\n<h3>Final observation</h3>\n<p>However, one can notice that the above algorithm calculates the answer for smaller values of <b>N</b> as well. That means we can run it just once for <b>N</b>=500, and get the answers for all testcases at once, so the total runtime will be just O(<b>N</b><sup>3</sup>), which is okay.</p>\n","id":"0000000000432df8","statement":"<h3>Problem</h3>\n<p>\n<blockquote>\n<i>Pontius</i>: You know, I like this number 127, I don't know why.<br/>\n<i>Woland</i>: Well, that is an object so pure. You know the <i>prime numbers</i>.<br/>\n<i>Pontius</i>: Surely I do. Those are the objects possessed by our ancient masters hundreds of years ago. Oh, yes, why then? 127 is indeed a prime number as I was told.<br/>\n<i>Woland</i>: Not... only... that. 127 is the 31st prime number; then, 31 is itself a prime, it is the 11th; and 11 is the 5th; 5 is the 3rd; 3, you know, is the second; and finally 2 is the 1st.<br/>\n<i>Pontius</i>: Heh, that is indeed... purely prime.<br/>\n</blockquote>\n</p>\n<p>\nThe game can be played on any subset <code>S</code> of positive integers. A number in <code>S</code> is considered pure with respect to <code>S</code> if, starting from it, you can continue taking its rank in <code>S</code>, and get a number that is also in <code>S</code>, until in finite steps you hit the number 1, which is not in <code>S</code>.\n</p>\n<p>\nWhen <b>n</b> is given, in how many ways you can pick <code>S</code>, a subset of {2, 3, ..., n}, so that <b>n</b> is pure, with respect to <code>S</code>? The answer might be a big number, you need to output it modulo 100003.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each contains a single integer <b>n</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the answer as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n<b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n2 &le; <b>n</b> &le; 25.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>n</b> &le; 500.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n6\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5\nCase #2: 8\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Your Rank is Pure","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis is an easy problem. Especially when efficiency is not a big issue here.\n</p>\n<p>\nFor each directory you want to create, we get all the directories you <i>need</i>. Those are all the ancestors of that directory. For example, if one items in the input of wanted directories is\n<pre>\n/home/gcj/round1b/problema/input\n</pre>\nWe need all the following\n<pre>\n/home\n/home/gcj\n/home/gcj/round1b\n/home/gcj/round1b/problema\n/home/gcj/round1b/problema/input\n</pre>\n</p>\n<p>\nLet <code>A</code> be the collection of all the directories we need, and <code>B</code> be the collection of all the directories that are already exist. Simply count how many elements are from <code>A</code> but not <code>B</code>. You need to use one <code>mkdir</code> for each of them.\n</p>\n","id":"0000000000433086","statement":"<h3>Problem</h3>\n\n<p>\nOn Unix computers, data is stored in <i>directories</i>. There is one <i>root directory</i>, and this might have several directories contained inside of it, each with different names. These directories might have even more directories contained inside of them, and so on.\n</p>\n\n<p>\nA directory is uniquely identified by its name and its parent directory (the directory it is directly contained in). This is usually encoded in a <i>path</i>, which consists of several parts each preceded by a forward slash ('/'). The final part is the name of the directory, and everything else gives the path of its parent directory. For example, consider the path:\n<pre>\n/home/gcj/finals\n</pre>\nThis refers to the directory with name \"finals\" in the directory described by \"/home/gcj\", which in turn refers to the directory with name \"gcj\" in the directory described by the path \"/home\". In this path, there is only one part, which means it refers to the directory with the name \"home\" in the root directory.\n</p>\n\n<p>\nTo create a directory, you can use the <i>mkdir</i> command. You specify a path, and then <i>mkdir</i> will create the directory described by that path, but <i>only if</i> the parent directory already exists.  For example, if you wanted to create the \"/home/gcj/finals\" and \"/home/gcj/quals\" directories from scratch, you would need four commands:\n<pre>\nmkdir /home\nmkdir /home/gcj\nmkdir /home/gcj/finals\nmkdir /home/gcj/quals\n</pre>\n</p>\n\n<p>\nGiven the full set of directories already existing on your computer, and a set of new directories you want to create if they do not already exist, how many <i>mkdir</i> commands do you need to use?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each case begins with a line containing two integers <b>N</b> and <b>M</b>, separated by a space.\n</p>\n\n<p>\nThe next <b>N</b> lines each give the path of one directory that already exists on your computer. This list will include every directory already on your computer other than the root directory. (The root directory is on every computer, so there is no need to list it explicitly.)\n</p>\n\n<p>\nThe next <b>M</b> lines each give the path of one directory that you want to create.\n</p>\n\n<p>\nEach of the paths in the input is formatted as in the problem statement above. Specifically, a path consists of one or more lower-case alpha-numeric strings (i.e., strings containing only the symbols 'a'-'z' and '0'-'9'), each preceded by a single forward slash. These alpha-numeric strings are never empty.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of <i>mkdir</i> you need.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\nNo path will have more than 100 characters in it.<br/>\nNo path will appear twice in the list of directories already on your computer, or in the list of directories you wish to create. A path may appear once in both lists however. (See example case #2 below).<br/>\nIf a directory is listed as being on your computer, then its parent directory will also be listed, unless the parent is the root directory.<br/>\nThe input file will be no longer than 100,000 bytes in total.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n0 &le; <b>N</b> &le; 10.<br/>\n1 &le; <b>M</b> &le; 10.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n0 &le; <b>N</b> &le; 100.<br/>\n1 &le; <b>M</b> &le; 100.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n0 2\n/home/gcj/finals\n/home/gcj/quals\n2 1\n/chicken\n/chicken/egg\n/chicken\n1 3\n/a\n/a/b\n/a/c\n/b/b\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 0\nCase #3: 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":14}],"title":"File Fix-it","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>The solution for this problem consists of several steps, each making the problem a bit easier until it becomes simple.</p>\n<h3>Step 1. Do swaps as fast as possible (or don't do them at all)</h3>\n<p>Suppose a chick catches another one in front of it. We have the following options: \n<ol>\n<li>lift the slow one immediately to let the fast one pass;</li>\n<li>let them run together for some time, and then lift the small one;</li>\n<li>let them run together all remaining time and not let the fast one pass at all.</li>\n</ol></p>\n<p>The first observation that we need to solve this problem is that option 2 is never necessary. Intuitively:  what's the point of holding the fast one if we will still do the same work on swapping them later? Formally: suppose we have a sequence of swaps that forms the solution for the problem, and that swaps chicks <b>P</b> and <b>Q</b> at time <b>T<sub>1</sub></b>, while they first meet at time <b>T<sub>0</sub></b>, <b>T<sub>0</sub></b>&lt;<b>T<sub>1</sub></b>. Let's move this swap to time <b>T<sub>0</sub></b>. Note that for each particular chick and each particular moment, the position of this chick at this moment will either stay unchanged, or move closer to the barn. Because of this, the changed solution is also valid.</p>\n<h3>Step 2. Never swap two chicks that will make it to the barn in time</h3>\n<p>Suppose that we swap two chicks that would both make it to the barn in time in the end. Then we can avoid this swap and still have both chicks arrive at the barn in time. We will need to do the same number of swaps for the fast chick during the rest of the way than we had to previously (or even fewer, since some chicks might get out of our way), so we'll save at least one swap by keeping the two chicks together until the end.</p>\n<h3>Step 3. If a chick can't make it to the barn in time, all chicks behind it will have to swap with it</h3>\n<p>Suppose a chick can't theoretically make it to the barn in time: <b>X<sub>i</sub></b>+<b>T</b>*<b>V<sub>i</sub></b>&lt;<b>B</b>. Then all chicks that start behind it will need to be swapped with this check or else they won't make it to the barn in time either.</p>\n<h3>Step 4. Split the chicks into two classes to get a lower limit on the number of swaps</h3>\n<p>Let's paint the chicks that can theoretically make it to the barn in time with <i>red</i> color, and the ones that can't do that with <i>blue</i> color.</p>\n<p>For every red chick, the amount of swaps needed to get to the barn on time is at least the number of blue chicks that start closer to the barn. This gives us a lower bound on our answer: if we count this number for each red chick, then the answer is at least the sum of <b>K</b> smallest such numbers.</p>\n<h3>Step 5. The lower bound that we've found is actually the correct answer</h3><p>At the previous step, we've found some swaps that are necessary in order to solve this problem. Now we note that we don't need any more swaps. More precisely, let's take <b>K</b> red chicks that are closest to the barn initially, and swap them with the blue chicks as soon as they reach any. Since we took <b>K</b> red chicks that are closest to the barn, the number of blue chicks that will get in their way is minimum possible (remember that we never need to swap two red chicks!).</p>\n<h3>Step 6. Code!</h3>\n<p>After making all of the above observations, the actual solution becomes very simple:\n<pre>  num_red = 0\n  num_blue = 0\n  answer = 0\n  for i = N - 1 .. 0:\n    if num_red == K:\n      break\n    if X[i] + T * V[i] &lt; B:\n      num_blue += 1\n    else:\n      num_red += 1\n      answer += num_blue\n  if num_red &gt;= K:\n    output answer\n  else\n    output \"IMPOSSIBLE\"\n</pre></p>\n","id":"0000000000433197","statement":"<h3>Problem</h3>\n<p>\nA flock of chickens are running east along a straight, narrow road. Each one is running with its own constant speed. Whenever a chick catches up to the one in front of it, it has to slow down and follow at the speed of the other chick. You are in a mobile crane behind the flock, chasing the chicks towards the barn at the end of the road. The arm of the crane allows you to pick up any chick momentarily, let the chick behind it pass underneath and place the picked up chick back down. This operation takes no time and can only be performed on a pair of chicks that are immediately next to each other, even if 3 or more chicks are in a row, one after the other.\n</p>\n\n<p>\nGiven the initial locations (<b>X<sub>i</sub></b>) at time 0 and natural speeds (<b>V<sub>i</sub></b>) of the chicks, as well as the location of the barn (<b>B</b>), what is the minimum number of swaps you need to perform with your crane in order to have at least <b>K</b> of the <b>N</b> chicks arrive at the barn no later than time <b>T</b>?\n</p>\n\n<p>\nYou may think of the chicks as points moving along a line. Even if 3 or more chicks are at the same location, next to each other, picking up one of them will only let one of the other two pass through. Any swap is instantaneous, which means that you may perform multiple swaps at the same time, but each one will count as a separate swap.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>C</b>.  <b>C</b> test cases follow.  Each test case starts with 4 integers on a line -- <b>N</b>, <b>K</b>, <b>B</b> and <b>T</b>. The next line contains the <b>N</b> different integers <b>X<sub>i</sub></b>, in increasing order. The line after that contains the <b>N</b> integers <b>V<sub>i</sub></b>. All distances are in meters; all speeds are in meters per second; all times are in seconds.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: <b>S</b>\", where x is the case number (starting from 1) and <b>S</b> is the smallest number of required swaps, or the word \"IMPOSSIBLE\".\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>C</b> &le; 100;<br>\n1 &le; <b>B</b> &le; 1,000,000,000;<br>\n1 &le; <b>T</b> &le; 1,000;<br>\n0 &le; <b>X<sub>i</sub></b> &lt; <b>B</b>;<br>\n1 &le; <b>V<sub>i</sub></b> &le; 100;<br>\nAll the <b>X<sub>i</sub></b>'s will be distinct and in increasing order.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 10;<br>\n0 &le; <b>K</b> &le; min(3, <b>N</b>);\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 50;<br>\n0 &le; <b>K</b> &le; <b>N</b>;\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n5 3 10 5\n0 2 5 6 7\n1 1 1 1 4\n5 3 10 5\n0 2 3 5 7\n2 1 1 1 4\n5 3 10 5\n0 2 3 4 7\n2 1 1 1 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 2\nCase #3: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Picking Up Chicks","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432ad7","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2010"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
