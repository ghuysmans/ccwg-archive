{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1464453000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201c91","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 2 turned up the heat with some tougher problems. Even the easiest one,\n<i>Rather Perplexing Showdown</i>, can be tough depending on how you approach\nit. <i>Red Tape Committee</i> requires some standard dynamic programming\ntechniques and a perhaps counterintuitive insight about probability.\n<i>The Gardener of Seville</i> is an unusual construction problem that is not\ntrivial to implement even when you know what to do, and <i>Freeform Factory</i>\nis a tricky graph/matching problem.\n</p><p>\nThe first hour of the contest saw many solves of A and B, and some correct answers to the\ntougher larges trickled in. SnapDragon was the first to crack C-large, at 44:09. austrin\nsnagged the first D-large solution at 55:45, and had the only one until reigning champion Gennady.Korotkevich solved it at 1:11:07, jumping to the top of the scoreboard. For a while,\nmany contestants were one problem away from 100, but EgorKulikov reached it first with\na penalty time of 1:55:43. EgorKulikov had two wrong tries on one problem, so a tense 8\nminutes passed in which another contestant could have jumped into first place, but this did\nnot happen and victory was secured. Ahyangyi, eatmore, and betaveros followed up with our\nother three perfect scores.\n</p><p>\nAlthough the results are provisional until confirmation emails are sent, the top 500 required\nat least 46 points (often all of A and B plus one other Small) plus some speed, and the top\n1000 required 29 points (at least one Large, usually A) plus some speed.\nCongratulations to the top 1000... wear your 2016 Code Jam T-shirt with pride!\nThe top 500 will join us in Round 3 to compete for one of 25 tickets to the\nWorld Finals in New York in August! Even if you didn't advance or win a T-shirt\nin this round, remember that DCJ Round 1 offers another chance at a T-shirt and\na trip to New York; it will take place on\nMay 29.\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>Rather Perplexing Showdown</i>): Written by Ian Tullis. Prepared\nby Taman (Muhammed) Islam and Ian Tullis.\n</p><p>\nProblem B (<i>Red Tape Committee</i>): Written by Ian Tullis. Prepared by Karol\nPokorski.\n</p><p>\nProblem C (<i>The Gardener of Seville</i>): Written and prepared by Petr\nMitrichev and Ian Tullis.\n</p><p>\nProblem D (<i>Freeform Factory</i>): Written by Petr Mitrichev. Prepared by\nPablo Heiber and Petr Mitrichev.\n</p>\nSolutions and other problem preparation and review by David Arthur, Shane Carr,\nJohn Dethridge, Minh Doan, Taman (Muhammed) Islam, Chieu Nguyen, Nathan\nPinsker, Karol Pokorski, Yerzhan Utkelbayev, Jonathan Wills,\nand Josef Ziegler.\n</p><p>\nAnalysis authors:\n</p>\n<ul>\n<li>Rather Perplexing Showdown: Ian Tullis</li>\n<li>Red Tape Committee: David Arthur and Ian Tullis</li>\n<li>The Gardener of Seville: Timothy Loh</li>\n<li>Freeform Factory: Pablo Heiber, Petr Mitrichev and Amit Weinstein</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1464444000000,"tasks":[{"analysis":"<h2>Red Tape Committee: Analysis</h2>\n<p>\nThis problem poses two challenges: figuring out which sets of members to\nconsider as possible committees, and calculating the tie probability for each\ncommittee. In the Small dataset, brute force will suffice for both of these\nsubproblems. However, in the Large dataset, we will need more efficient methods\nfor both of them.\n</p>\n<h3>Who should we choose?</h3>\n<p>\nOne might think that in order to create ties, we should choose from among the\nmost \"moderate\" department members &mdash; that is, the ones with Yes\nprobabilities closest to 0.5. In fact, the opposite is true! The best way to\ncreate a tie is to choose department members from one or both <i>extremes</i>.\nThat is, we should choose the <i>M</i> (possibly zero) of the department\nmembers with the lowest Yes probabilities, and the <b>K</b> - <i>M</i> of the\ndepartment members with the highest Yes probabilities. This makes sense\nintuitively; to take an extreme case, a committee of two members with Yes\nprobabilities of 0.00 and 1.00 will always tie, whereas a committee of two\nmembers with Yes probabilities of 0.50 and 0.50 will tie only half the time.\nExperimentation bears this idea out. But how can we prove it?\n</p><p>\nWithout loss of generality, let's sort the members in increasing order of Yes\nprobability. Suppose that we have chosen a committee of these members that\nmaximizes the tie probability. If there are multiple such committees, suppose\nthat we have chosen the one that also minimizes the sum of the members' indexes\nin that sorted list.\n</p><p>\nWe'll show that this set consists of the <i>M</i> (possibly zero) leftmost\nmembers and the <b>K</b> - <i>M</i> rightmost members, as described above.\nSuppose that there exist the following: a member X, who is in our set, and\nmembers Y and Z, who are not in our set, and that they are in the left to right\norder Y, X, Z. Fix all the other members and consider the tie probability as a\nfunction of member X's Yes probability. This is a linear function. If it has\nslope 0, then we can get an equally good set with a smaller sum of member\nindices by replacing X with Y. If it has slope > 0, we can get a better set by\nreplacing X with Z. If it has slope < 0, we can get a better set by replacing X\nwith Y. So X must not exist!\n</p><p>\nTherefore, we can try all values of <i>M</i> and consider only those\ncommittees. This linear search adds a multiplier of O(<b>K</b>) to the running\ntime of the calculation of tie probabilities. The one-time sort also adds a\nsingle O(<b>N</b> log <b>N</b>) term.\n</p>\n<h3>How likely is a tie?</h3>\n<p>\nFor a large committee, we cannot explicitly consider all 2<sup><b>N</b></sup>\npossible voting outcomes. Many of these outcomes are very similar, and we would\ndo a lot of redundant work. This is an ideal situation for dynamic programming.\n</p><p>\nLet's build a table in which the columns represent the committee members, the\nrows represent the total number of Yes votes so far, and the numbers in the\ncells measure the probability of being in the situation represented by that\nrow and column. We start with a 1.00 in the upper left cell, which represents\nthe situation before anyone has voted; there is a 100% chance that there will\nbe no \"Yes\" votes at this stage. Let's consider a committee with Yes\nprobabilities of 0.10, 0.20, 0.50, and 1.00. We will label the columns in that\norder (although the order does not matter).\n</p>\n<code>\n<b>- init 0.10 0.20 0.50 1.00</b><br>\n<b>0</b> 1.00 ---- ---- ---- ----<br>\n<b>1</b> ---- ---- ---- ---- ----<br>\n<b>2</b> ---- ---- ---- ---- ----<br>\n<b>3</b> ---- ---- ---- ---- ----<br>\n<b>4</b> ---- ---- ---- ---- ----<br>\n</code>\n<p>\nWhen the first member votes, either the vote will be \"Yes\" with 10% probability\n(and we will have one Yes vote), or \"No\" with 90% probability (and we will have\nzero Yes votes). So the 1.00 value gets split up among two cells in the next\ncolumn: the \"0 Yes votes after 1 member has voted\" and \"1 Yes vote after 1\nmember has voted\" cells.\n</p>\n<code>\n<b>- init 0.10 0.20 0.50 1.00</b><br>\n<b>0</b> 1.00 0.90 ---- ---- ----<br>\n<b>1</b> ---- 0.10 ---- ---- ----<br>\n<b>2</b> ---- ---- ---- ---- ----<br>\n<b>3</b> ---- ---- ---- ---- ----<br>\n<b>4</b> ---- ---- ---- ---- ----<br>\n</code>\n<p>\nLet's look at the \"0 Yes votes after 1 member has voted\" cell, which represents\n90% of all possible situations after the first member has voted. That\nprobability will feed into two of the cells in the next column: the one just to\nthe right, and the one just below that. Since the second member has an 80%\nprobability of voting No, 80% of that 90% possibility space branches off to the\n\"0 Yes votes after 2 members have voted\" cell. The other 20% of that 90%\nbranches off to the \"1 Yes vote after 2 members have voted\" cell.\n</p>\n<code>\n<b>- init 0.10 0.20 0.50 1.00</b><br>\n<b>0</b> 1.00 0.90 0.72 ---- ----<br>\n<b>1</b> ---- 0.10 0.18 ---- ----<br>\n<b>2</b> ---- ---- ---- ---- ----<br>\n<b>3</b> ---- ---- ---- ---- ----<br>\n<b>4</b> ---- ---- ---- ---- ----<br>\n</code>\n<p>\nAnd now for the \"1 Yes vote after 1 member has voted\" cell, which represents\n10% of all possible situations after the first member has voted. Again, that\nprobability will feed into the right and down-and-right neighboring cells in the\nnext column. Note that we add 0.08 to the existing value of 0.18 in the \"1 Yes\nvote after 2 members have voted\" cell; there are multiple ways of getting to\nthat cell. The power of dynamic programming is that it merges separate\npossibilities like this and lets us consider them together going forward; this\nprevents an exponential increase in the number of possibilities.\n</p>\n<code>\n<b>- init 0.10 0.20 0.50 1.00</b><br>\n<b>0</b> 1.00 0.90 0.72 ---- ----<br>\n<b>1</b> ---- 0.10 0.26 ---- ----<br>\n<b>2</b> ---- ---- 0.02 ---- ----<br>\n<b>3</b> ---- ---- ---- ---- ----<br>\n<b>4</b> ---- ---- ---- ---- ----<br>\n</code>\n<p>\nContinuing in this way, we can fill in the whole table. Note that every column\nsums to 1, as expected.\n</p>\n<code>\n<b>- init 0.10 0.20 0.50 1.00</b><br>\n<b>0</b> 1.00 0.90 0.72 0.36 0.00<br>\n<b>1</b> ---- 0.10 0.26 0.49 0.36<br>\n<b>2</b> ---- ---- 0.02 0.14 0.49<br>\n<b>3</b> ---- ---- ---- 0.01 0.14<br>\n<b>4</b> ---- ---- ---- ---- 0.01<br>\n</code>\n<p>\nThe tie probability is the value in the \"2 Yes votes after 4 members have\nvoted\" cell: 0.49. We could have optimized this further by not considering any\nrows below the number of Yes votes needed for a tie. In practice, in problems\nlike this, one should store the logarithms of probabilities instead of the\nactual values, which can become small enough for floating-point precision\nerrors to matter.\n</p><p>\nThe number of calculations in this method is proportional to the dimensions of\nthe table, each of which is proportional to <b>K</b>, so the running time of\nthis part is O(<b>K</b><sup>2</sup>). Combining that with the O(<b>K</b>)\nmethod of selecting committees, the overall running time of our approach is\nO(<b>K</b><sup>3</sup>) + O(<b>N</b> log <b>N</b>). Since <b>K</b> cannot\nexceed <b>N</b>, and <b>N</b> cannot exceed 200 for the Large, this is fast\nenough, albeit not optimal. (For example, we could do a ternary search on the\nvalue of <i>M</i> mentioned above, instead of a linear search.)\n</p>\n","id":"0000000000201b71","statement":"<h3>Problem</h3>\n<p>\nYou are the head of the Department of Redundancy Reduction and Superfluity\nShrinkage. Currently, the department cannot agree on whether there is too much\n\"red tape\" (inefficiency) in the department itself. They have asked you to form\na Red Tape Committee to vote on the issue.\n</p><p>\nThe department has <b>N</b> members. For each member, you know the probability\n<b>P<sub>i</sub></b> that that member will vote \"Yes\". If a member does not\nvote \"Yes\", they necessarily vote \"No\"; nobody abstains.\n</p><p>\nYou must choose exactly <b>K</b> members to be on the committee. The department\nrules dictate that <b>K</b> must be an even number to allow for ties, which\nare seen as part of a healthy bureaucracy.\n</p><p>\nIf you choose committee members to <i>maximize</i> the probability of a tie,\nwhat is that probability?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow; each consists of two lines. The first line of a test case\nconsists of two integers <b>N</b> and <b>K</b>, the sizes of the department and\nthe committee. The second line of a test case consists of <b>N</b> decimal\nvalues <b>P<sub><i>i</i></sub></b>; each has exactly two decimal places of\nprecision and represents the probability that the <i>i</i>-th department member\nwill vote \"Yes\".\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\na floating-point number: the maximum possible probability of a tie.\n<code>y</code> will be considered correct if it is within an absolute or\nrelative error of 10<sup>-6</sup> of the correct answer. See the\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an\nexplanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n2 &le; <b>K</b> &le; <b>N</b>.<br/>\n<b>K</b> is even.<br/>\n0.00 &le; each <b>P<sub>i</sub></b> &le; 1.00.<br/>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>N</b> &le; 16.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n2 &le; <b>N</b> &le; 200.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 2\n0.50 0.50\n4 2\n0.00 0.00 1.00 1.00\n3 2\n0.75 1.00 0.50\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.5\nCase #2: 1.0\nCase #3: 0.5\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn sample case #1, you must use the only two available department members to\nform the committee. That committee will tie only if the two committee members\nvote differently, which will happen half the time. (Without loss of generality,\nchoose the vote of the first. Then the probability that the second will vote\nthe other way is 0.5.)\n</p><p>\nIn sample case #2, the best strategy is to pick one of the members with \"Yes\"\nprobability 0.00 and one of the members with \"Yes\" probability 1.00. This\nguarantees a tie.\n</p><p>\nIn sample case #3, suppose that we pick the two members with \"Yes\"\nprobabilities of 0.50 and 0.75. A tie will happen if the first one votes \"Yes\"\nand the second one votes \"No\" (probability 0.5 * 0.25 = 0.125), or if the\nfirst one votes \"No\" and the second one votes \"Yes\" (probability 0.5 * 0.75 =\n0.375). So the total probability of a tie is 0.125 + 0.375 = 0.5. Choosing the\ntwo members with \"Yes\" probabilities of 0.50 and 1.00 would also make the tie\nprobability 0.5, since the 1.00 member will vote \"Yes\" and the 0.50 member must\nvote \"No\". Choosing the two members with \"Yes\" probabilities of 0.75 and 1.00\nwould make the tie probability only 0.25, since the 1.00 member will vote \"Yes\"\nand the 0.75 member must vote \"No\". So 0.5 is the best we can do.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Red Tape Committee","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>The Gardener of Seville: Analysis<h2>\n<h3>Small dataset</h3>\n<p>\nFor the Small dataset, there are at most 16 cells in the courtyard that we must\nassign hedge directions to, a total of at most 65536 different hedge mazes.\nNote that because every cell must have a diagonal hedge, any maze creates a\nbijection between courtiers; it is impossible for the paths used by two\ndifferent pairs of lovers to intersect, so we don't need to worry about that.\nWe can use brute force to generate and check all possible hedge mazes, as long as\nwe can efficiently work out which outer cells are paired up through the hedge\nmaze. This can be done in various ways, including:\n<ul><li>Consider hedges to be mirrors, and imagine shining a beam of light into\nthe maze from an outer cell, perpendicular to the edge it's on. At each cell\nthe light will reflect off the cell's mirror at a 90 degree angle and continue\nto the next cell in its new direction. It repeatedly bounces off mirrors until\nit exits the maze at the cell it's paired with.</li>\n<li>Imagine drawing both hedges in each cell, splitting each cell into four\nquadrants. We can represent the maze as a graph in which the nodes are these\nquadrants, and there are edges between adjacent quadrants that are not blocked\nby part of a hedge. We can find which courtiers are paired by starting at the\nnode corresponding to that courtier's starting edge of the maze, and traversing\nthe graph until we reach another edge. Equivalently, we can find the connected\ncomponents of the graph.</li></ul>\n</p>\n<h3>Large dataset</h3>\n<p>\nThe Large dataset has test cases with up to 100 cells, which is too large for our\nbrute force approach. A more fruitful approach is to take the given pairs\nand install hedges so that those pairs are connected. The easiest cases would be\nconnecting two cells which are adjacent (either along an edge or around a\ncorner). For example, to connect the two outer cells adjacent to the upper left\ncorner, a single <code>/</code> hedge is sufficient. Does it ever make sense to\nconnect them any other way? The illustration for test case 3 from the sample input\nconnects the two outer cells adjacent to the upper right corner via a longer\nwinding path, but it would also work to make this connection direct and leave the\ncenter of the garden unreachable. The direct\nconnection covers just two triangular quadrants (as defined in the Small dataset\nsection) in the corner, and it is easy to see that any other possible path\nbetween the two cells also covers these two quadrants. Thus there is no reason\nnot to use this direct path if we need to connect the cells at a corner.\n</p><p>\nHow about outer cells next to each other along an edge? These can be easily\nconnected using two hedges, which covers four triangular quadrants. All possible\nconnections will necessarily cover the two quadrants at the edge of the board,\nbut we can construct paths which do not cover the other two quadrants. However,\nany path that does not use those two quadrants is guaranteed to block them off\nand make them inaccessible from other edges. Thus, any path between the two cells\nwill either cover the four quadrants forming the simplest path, or render some of\nthem unusable; there is no reason to use anything more complex than the simplest path.\n</p><p>\nIf every pair to connect has a similarly optimal path which we can easily\ndetermine, then we can solve the problem by installing hedges so each pair is\nconnected via its respective optimal path, and if any of the paths intersect\nthen there is no solution. Consider, however, a pair between outer cells on the left\nand right sides of the garden. Depending on the other connections we need to\nmake, we may be able to freely choose between (for example) having the path go\nthrough the top half of the garden and the bottom half of the garden. As such,\nthere isn't a clear single optimal path for connecting this pair. However, we\ncan consider uppermost and lowermost paths, which leave the most space for\npaths below and above them, respectively. For an uppermost path, for example, we want to take\nthe least space possible to connect the pair, and all the pairs above it.\nturns out there is a optimal way to connect such pairs.\n</p><p>\nFor the rest of the analysis, we will assume that there is a solution to the\nproblem. If there is a solution, then our strategy will provide a way to find\nit. If there is no solution, our strategy may not be correct but we can easily\ndetect that it fails by checking the hedge maze as we did in the Small solution.\n</p><p>\nDefine a 'group of pairs' as a non-zero number of pairs where all the outer cells used\nform a fully contiguous section around the perimeter (but not the full perimeter).\nFor a pair connecting the left and right sides of the garden, we can consider\nthe group of pairs above the path connecting this pair, and the group of pairs\nabove and including this pair. Every group of pairs has an optimal set of\ntriangular quadrants to join all pairs in that section. Similar to before,\noptimality here means that we can install hedges to connect each pair in the\ngroup without covering quadrants outside the optimal set (this property is\nsufficiency), and if all pairs in the group are connected, no paths from other\npairs can ever cover quadrants inside the set (this property is necessity).\n</p><p>\nWe already know the optimal sets for the groups with a single pair of adjacent\nouter cells. If we have two groups of pairs, which together would form a larger\ngroup of pairs, the optimal set will be the union of the optimal sets for the\ntwo smaller groups. We can prove that this meets both the sufficiency and\nnecessity properties (as stated before, this requires the assumption that there\nis a solution).\n</p><p>\nConsider again the case of a pair connecting the left and right sides of the\ngarden. If we have the optimal set for the group of pairs above this pair, then\nwe can try and extend this to the optimal set for the group of pairs above and\nincluding this pair. It makes sense to try and make the path for this pair as\nhigh up as possible, staying as close as possible to the paths above it. It can\nbe proven that including this path makes a new optimal set. In general, this\nworks for any non-adjacent pair. If we have the optimal set of quadrants for\nthe group of pairs on one side of a pair, we can extend it by adding a path\nthat stays as close to those quadrants as possible. This means we can\ninductively find optimal sets of quadrants until we cover all the pairs (note\nthat we did not define all pairs as a valid group of pairs, as the definition\nof optimality doesn't work for that case).\n</p><p>\nThese ideas give us the following algorithm:\n<ul>\n<li>Start with no hedges in the garden</li>\n<li>Iterate over pairs, in increasing order of distance (along the perimeter)\nbetween the two cells. Ties can be broken arbitrarily.\n<ul><li>Let the two outer cells be A and B, such that A&rarr;B clockwise around\nthe edge is shorter than counterclockwise. Due to the chosen iteration order,\nwe've already built paths for all points on the left side of the A&rarr;B path\nwe're going to construct.</li>\n<li>Walk through maze starting at A (the mirror analogy is useful here). We want\nto stay to the left as much as possible, so if we get to a cell without a hedge\ninstalled we pick one so that we turn left. Once we exit the maze, check if we\nactually made it to B. (If there is no solution we might end up somewhere else.)\n</li></ul>\n<li>Fill in remaining cells arbitrarily</li>\n</ul>\n</p><p>\nA sample implementation of this in Python is provided below. We encode\ndirections with integers, which allows us to rotate direction and calculation\nmovement easily using bitwise operations and array lookups.\n</p><pre><code>def position(v, R, C):\n    # Map from outer cell number to a direction facing into the maze\n    # and the position of the outer cell\n    # 0->downwards, 1->leftwards, 2->upwards, 3->rightwards\n    if v &lt;= C: return 0, v-1, -1\n    v -= C\n    if v &lt;= R: return 1, C, v-1\n    v -= R\n    if v &lt;= C: return 2, C-v, R\n    v -= C\n    return 3, -1, R-v\n\ndef move(x, y, direction):\n    return x + [0,-1,0,1][direction], y + [1,0,-1,0][direction]\n\ndef solve(R, C, permutation):\n    board = [[None] * C for _ in range(R)]\n    size = 2*(R+C)\n    permutation = zip(permutation[::2], permutation[1::2])\n    permutation.sort(key=lambda(a,b): min((b-a)%size, (a-b)%size))\n    for start, end in permutation:\n        if (start-end) % size > R+C:\n            start, end = end, start\n        direction, x, y = position(start, R, C)\n        x, y = move(x, y, direction)\n        while 0&lt;=x&lt;C and 0&lt;=y&lt;R:\n            if board[y][x] is None:\n                board[y][x] = \"/\\\\\"[direction &amp; 1]\n            direction ^= {\"/\": 1, \"\\\\\": 3}[board[y][x]]\n            x, y = move(x, y, direction)\n        if (x, y) != position(end, R, C)[1:]:\n            return \"IMPOSSIBLE\"\n    return \"\\n\".join(\"\".join(c or \"/\" for c in row) for row in board)\n\nif __name__ == \"__main__\":\n    for t in range(1, input() + 1):\n        R, C = map(int, raw_input().split())\n        permutation = map(int, raw_input().split())\n        print \"Case #%d:\" % t\n        print solve(R, C, permutation)</code></pre>\n","id":"0000000000201bf5","statement":"<h3>Problem</h3>\n<p>\nYou are the Gardener of Seville, a minor character in an opera. The setting for\nthe opera is a courtyard which is a rectangle of unit cells, with <b>R</b> rows\nand <b>C</b> columns. You have been asked to install a maze of hedges in the\ncourtyard: every cell must contain a hedge that runs diagonally from one corner\nto another. For any cell, there are two possible kinds of hedge: lower left to\nupper right, which we represent with <code>/</code>, and upper left to lower\nright, which we represent with <code>\\</code>. Wherever two hedges touch, they\nform a continuous wall.\n</p><p>\nAround the courtyard is an outer ring of unit cells, one cell wide, with the\nfour corners missing. Each of these outer cells is the home of a courtier.\nThe courtiers in these outer cells are numbered clockwise, starting with 1 for\nthe leftmost of the cells in the top row, and ending with\n2 * (<b>R</b> + <b>C</b>) for the topmost cell in the left column. For example,\nfor <b>R</b> = 2, <b>C</b> = 2, the numbering in the outer ring looks like this.\n(Note that no hedges have been added yet.)\n</p><p>\n<code>\n&nbsp;12&nbsp;<br>\n8&nbsp;&nbsp;3<br>\n7&nbsp;&nbsp;4<br>\n&nbsp;65&nbsp;<br>\n</code>\n</p><p>\nIn this unusual opera, love is mutual and exclusive: each courtier loves\nexactly one other courtier, who reciprocally loves only them. Each courtier\nwants to be able to sneak through the hedge maze to his or her lover without\nencountering any other courtiers. That is, any two courtiers in love with each\nother must be connected by a path through the maze that is separated from every\nother path by hedge walls. It is fine if there are parts of the maze that are\nnot part of any courtier's path, as long as all of the pairs of lovers are\nconnected.\n</p><p>\nGiven a list of who loves who, can you construct the hedge maze so that every\npair of lovers is connected, or determine that this is <code>IMPOSSIBLE</code>?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.\n<b>T</b> test cases follow. Each consists of one line with two integers\n<b>R</b> and <b>C</b>, followed by another line with a permutation of all of\nthe integers from 1 to 2 * (<b>R</b> + <b>C</b>), inclusive. Each integer is\nthe number of a courtier; the first and second courtiers in the list are in\nlove and must be connected, the third and fourth courtiers in the list are in\nlove and must be connected, and so on.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <i>only</i>\n<code>Case #x:</code>, where <code>x</code> is the test case number (starting\nfrom 1). Then, if it is impossible to satisfy the conditions, output one more\nline with the text <code>IMPOSSIBLE</code>. Otherwise, output <b>R</b> more\nlines of <b>C</b> characters each, representing a hedge maze that satisfies the\nconditions, where every character is <code>/</code> or <code>\\</code>. You may\nnot leave any cells in the maze blank. If multiple mazes are possible, you may\noutput any one of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 40 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>R * C</b> &le; 16.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 500.<br/>\n1 &le; <b>R * C</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 1\n1 4 3 2\n1 3\n1 8 2 7 3 4 5 6\n2 2\n8 1 4 5 2 3 7 6\n1 1\n1 3 2 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n/\nCase #2:\n//\\\nCase #3:\n//\n\\/\nCase #4:\nIMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn Case #3, the following pairs of courtiers are lovers: (8, 1), (4, 5),\n(2, 3), (7, 6). Here is an illustration of our sample output:\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0h65SObJ-GX6043gUDKw_dAJNWY8fVbdhlDXllNNui5ynEx6wZ6YR1rQg8Kj-ZOeG3aUq37B0/gardener.png\"/>\n<p>\nFor Case #3, note that this would also be a valid maze:\n</p>\n<p>\n<code>/\\<br>\n\\/</code>\n</p><p>\nIn Case #4, the courtyard consists of only one cell, so the courtiers living\naround it, starting from the top and reading clockwise, are 1, 2, 3, and 4.\nThere are only two possible options to put in the one cell: <code>/</code> or\n<code>\\</code>. The first of these choices would form paths from 1 to 4, and\nfrom 2 to 3. The second of these choices would form paths from 1 to 2, and from\n3 to 4. However, neither of these helps our lovesick courtiers, since in this\ncase, 1 loves 3 and 2 loves 4. So this case is <code>IMPOSSIBLE</code>, and\nthe opera will be full of unhappy arias!\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":23}],"title":"The Gardener of Seville","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>As the first step in solving this problem, we will move it from worker/factory terms to graph\n  terms: we are given a bipartite graph with <b>N</b> vertices in each part, and need to add\n  the smallest amount of edges to this graph to guarantee that every\n  <a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)#Definition\">maximal matching</a>\n  (one where it is impossible to add more edges) is a perfect matching (one which covers all vertices).\n\n</p><p>In order to determine that, we need to understand which bipartite graphs have the property that\n  every maximal matching is perfect. One can tackle this part by drawing a few\n  graphs on paper and trying to add edges one by one to find a maximal matching.\n\n</p><p>\n  After a few experiments, we can form a hypothesis: every maximal matching is perfect if and\n  only if each connected component of the bipartite graph is a\n  <a href=\"https://en.wikipedia.org/wiki/Complete_bipartite_graph\">complete bipartite graph</a>\n  with same number of\n  vertices in each part. The \"if\" part is somewhat clear, but the \"only if\" part\n  looks surprising at first and definitely needs a formal proof, which you can find at the end of\n  this editorial. Here's an example of such graph:<br/>\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1-c08BdwUsKgl8eMakHi6gk7ksyiLSNB5v4t8pJTpzV_S8CibQb1xzsAxFWU7IN5yhvvXZng/ff_pic1.png\">\n\n</p><p>Now we can return to solving our problem. As the first step, we need to find the number\n  of vertices in each half for each connected components of the graph. Let us put those\n  numbers into a list of pairs, one pair per connected component:\n  (<i>p</i><sub>1</sub>, <i>q</i><sub>1</sub>),\n  (<i>p</i><sub>2</sub>, <i>q</i><sub>2</sub>), ...\n  The above hypothesis tells us that we need to split this list into groups such\n  that in each group the sum <i>r</i> of all <i>p</i>s equals the sum of all <i>q</i>s, those groups\n  corresponding to the connected components of the graph after adding more edges.\n  The number of added edges is the total number of edges in the resulting graph minus\n  the number edges we have initially, and the number of edges in the resulting graph\n  is equal to the sum of squares of <i>r</i>s. Thus we need to minimize the sum of squares of\n  <i>r</i>s.\n\n</p><p>Since <b>N</b> is quite small&nbsp;&mdash; up to 25&nbsp;&mdash; there are quite a few\n  approaches that work, almost all revolving around dynamic programming/memoization.\n\n</p><p>Here is one possibility:\n  for each subset <i>Y</i> of the (multi-)set <i>X</i> of pairs we have,\n  and each number <i>t</i> between 0 and <b>N</b>, we will check if it is possible to group\n  all components in <i>Y</i> into groups in such a way that there are several balanced\n  groups with total size <i>t</i>, and possibly one unbalanced group with all remaining\n  components. In case it is possible, we will find the smallest possible sum of squares\n  of sizes of the balanced groups, denoted as <i>dp</i><sub><i>Y</i>,<i>t</i></sub>.\n  Looking at <i>dp</i><sub><i>X</i>,<b>N</b></sub> will give us the answer to the problem.\n\n</p><p>At first sight,\n  it seems that we are considering 2<sup>50</sup> subsets here as we might have up to 50 components\n  in the original graph (if we have no edges at all), but we can note that equal components are\n  interchangeable, so a graph with no edges simply has 25 components of one type and 25 components\n  of the other type, and thus has the total of 26*26=676 different subsets of components.\n  The maximum amount of different subsets of components for N=25 is 43008, formed by the following\n  initial components:\n  6&times;(0,1), 5&times;(1,0), 3&times;(1,1), 1&times;(1,2), 1&times;(1,3), 1&times;(1,4),\n  1&times;(2,1), 1&times;(2,2), 1&times;(3,1), 1&times;(3,2), 1&times;(4,1).\n\n</p><p>The most straightforward way to compute the <i>dp</i><sub><i>Y</i>,<i>t</i></sub> values\n  is to use the so-called <i>forward dynamic programming</i>: after finding\n  <i>dp</i><sub><i>Y</i>,<i>t</i></sub>, we will iterate over all ways to add a new element\n  to the unbalanced group in <i>Y</i>, updating <i>t</i> in case the unbalanced group\n  becomes balanced.\n</p><p>All that is left is to prove the hypothesis. We will prove by contradiction: assume that\n  the hypothesis is false&nbsp;&mdash; in other words, that there exists a bipartite graph\n  where every maximal matching is perfect, but one of its connected components is not a complete\n  bipartite graph with same number of vertices in each part.\n\n</p><p>Consider such counterexample <i>G</i> with the smallest number of vertices (note that\n  looking at the smallest counterexample is essentially the same as proving by induction). First of all,\n  <i>G</i> is connected&nbsp;&mdash; otherwise any of its connected components would form a smaller\n  counterexample. It is also clear that both its parts have the same number of vertices, as otherwise\n  no perfect matching exists at all, while at least one maximal matching always exists, so we would have\n  a contradiction. Since <i>G</i> is a counterexample, it is missing at least one edge. Let us\n  say that the missing edge connects vertices <i>a</i> and <i>b</i>.\n\n</p><p>\n  Consider any edge (<i>a</i>, <i>c</i>) that exists from <i>a</i>\n  (there is one since <i>G</i> is connected). Consider the graph <i>G</i>' obtained by\n  removing <i>a</i>, <i>c</i> and all their incident edges from <i>G</i>. Every maximal matching\n  in this smaller graph is perfect, since it can be extended to a maximal matching in\n  <i>G</i> by adding (<i>a</i>, <i>c</i>). And since <i>G</i>' has fewer vertices\n  than <i>G</i>, it is not a counterexample to our hypothesis, and thus each connected component\n  of <i>G</i>' is a complete bipartite graph with same number of vertices in each part.\n\n</p><p>Let us look at the connected component <i>H</i> of <i>G</i>' containing <i>b</i>. There are three\n  cases, each leading to a contradiction:\n\n</p><ul>\n  <li>There is at least one edge (<i>d</i>, <i>c</i>) in <i>G</i> from <i>H</i> to <i>c</i>.\n    Since all connected components of <i>G</i>' are complete, we can easily build a matching\n    <i>M</i>'\n    in <i>G</i>' that covers all vertices except <i>d</i> and <i>b</i>. By adding the edge\n    (<i>d</i>, <i>c</i>) to this matching we get a matching <i>M</i> in <i>G</i>.\n    Matching <i>M</i> is maximal: its only two uncovered vertices are <i>a</i> and <i>b</i>,\n    and there is no edge between them. <i>M</i> is not perfect, and thus we get a contradiction\n    with the definition of <i>G</i>.\n\n  </li><li>There is no edge from <i>H</i> to <i>c</i>, but there exists an edge (<i>a</i>, <i>e</i>)\n  from <i>a</i> to <i>H</i>. Consider any vertex <i>f</i> from <i>H</i> in a different part from\n  <i>e</i>. Since <i>H</i> and all other connected components of <i>G</i>' are complete,\n  we can now build a matching <i>M</i>' in <i>G</i>' that covers all vertices except\n  <i>e</i> and <i>f</i>. By adding the edge (<i>a</i>, <i>e</i>) to this matching we get a matching\n  <i>M</i> in <i>G</i>. Matching <i>M</i> is maximal: its only two uncovered vertices are\n  <i>f</i> and <i>c</i>, and there is no edge between them since there is no edge between the entire\n  <i>H</i> and <i>c</i>. <i>M</i> is not perfect, and thus we get a contradiction\n    with the definition of <i>G</i>.\n\n  </li><li>Finally, if <i>H</i> is not connected to <i>a</i> and <i>c</i>, then <i>G</i> is\n    disconnected, which is also a contradiction.\n  </li>\n</ul><p>\nThe first two contradiction cases are depicted below:<br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1mfGmM0C2EWMRVxNmX8HnKpi_ggT4HbaMDSUHW-5hLwQBT1qHZLoehjc_LjPru-HHNZkP-KQ/ff_pic2.png\">\n</p>\n<p>\nThere is also a more beautiful argument leading to a contradiction which does not even require\nthe counterexample <i>G</i> to be the smallest,\nbut it can be a bit harder to come up with. Since <i>G</i> is connected, there is a simple path\n<i>P</i> between <i>a</i> and <i>b</i>. Since the graph is bipartite, <i>P</i> has odd length and\ncovers some subset\nof the vertices, the same number from each part. We construct a maximal (therefore perfect) matching\nas follows: we take every odd edge along the path <i>P</i>, and then complete it with arbitrary\nedges. Now, we can change our choice of edges and take the even edges of <i>P</i> instead of the odd\nones. As a result, our matching has one less edge, and vertices <i>a</i> and <i>b</i> are the only\nnon-covered ones. Since a and b are not connected by an edge, we are left with a maximal matching\nwhich is not perfect, in other words a contradiction.\n</p>\n","id":"0000000000201c92","statement":"<h3>Problem</h3>\n<p>\nYou have just built a brand new factory. Your factory\nhas <b>N</b> different machines, and each machine needs to be <i>operated</i> by exactly one\nworker for the factory to function well.\n</p><p>\nYou have also hired <b>N</b> workers to operate those machines. Since you were in a hurry when you\nhired them, you did not check whether they actually know how to operate your machines. Now you have\nfinally asked them, and so you have the information on whether the i-th worker\ncan operate the j-th machine, for each i and j.\n</p><p>\nIn a typical working day, the workers will arrive at the factory in a random order,\nwhich can be different each day.\nAs each worker arrives, they will find all machines that they know how to operate and that do not\nalready have an operator. They will choose one of those at random\nand operate it for the whole working day.\n If all machines they know how to operate already have an operator, they will not work that day.\n Your goal is to make sure that all machines are being operated each working\nday, regardless of what order the workers arrive in and which machines they choose.\n</p><p>\nFor example, suppose there are two workers A and B, and two machines 1 and 2. Suppose\nthat A knows how to operate 1 and 2, and B knows how to operate 1 but not 2.\nIf worker B arrives first, he will pick machine 1, then when worker A arrives she will have\nto choose 2, and the factory will work well. However, if worker A arrives first,\nit might happen that she chooses to operate 1 on that day, and then when worker B arrives\nhe does not have anything to do, leaving machine 2 without an operator, and causing\nyour factory to waste a whole day!\n</p><p>\nAs another example, suppose there are two workers A and B, and two machines 1 and 2,\nand that A knows how to operate 1 but not 2, and B does not know how to operate anything. Then,\nregardless of the order in which the workers arrive, the factory will not be able to function well.\n</p><p>\nBefore you open your factory, in order to guarantee that the factory will\nconstantly function well, you can teach your workers how to operate machines.\nIt costs one dollar to give a single worker a lesson on how to operate a single\nmachine. Each lesson involves only one worker and only one machine, but you can\nteach any number of lessons to any number of workers, and the same worker can\nreceive multiple lessons. You cannot make a worker forget how to operate a\nmachine if they already know how to operate it.\n</p><p>\nFor example, both examples above can be fixed by teaching worker B to operate machine 2.\nIn that case each machine is guaranteed to have an operator every day, regardless of which order the\nworkers arrive in and which machines they choose to operate when they have more than one\npossibility.\n</p><p>\nWhat is the minimum amount of dollars you need to spend on training workers to make sure the factory\nfunctions well every day?\n</p>\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow.  Each test case starts with one line with an integer\n<b>N</b>, the number of workers (and machines). This line is followed by <b>N</b> lines with\na string of <b>N</b> characters each. The j-th character on the i-th of those lines is\n<code>1</code> if the i-th worker knows how to operate the j-th machine, and\n<code>0</code> otherwise.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1), and <code>y</code> is\na non-negative integer: the minimum amount of dollars you need to spend to make sure that\nall <b>N</b> machines will always have an operator.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 4.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 25.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2\n11\n10\n2\n10\n00\n3\n000\n000\n000\n1\n1\n3\n000\n110\n000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 1\nCase #3: 3\nCase #4: 0\nCase #5: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\nSample cases #1 and #2 are the ones described in the problem statement.\n</p><p>\nIn sample case #3, nobody knows how to do anything! One optimal strategy is to\nteach worker A to operate machine 1, worker B to operate machine 2, and worker\nC to operate machine 3.\n</p><p>\nIn sample case #4, no action is necessary. There is only one worker, and the\nworker already knows how to operate the one machine.\n</p><p>\nIn sample case #5, worker B already knows how to operate machines 1 and 2. One\noptimal strategy is to teach worker A to operate machine 3, and make A the only\nworker who can operate that machine. But now we have to consider that B might\noperate either machine 1 or 2 upon arrival, so C needs to be able to operate\nthe one not chosen by B. So C must be taught to operate both 1 and 2.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Freeform Factory","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Rather Perplexing Showdown: Analysis</h2>\n<p>\nThere are multiple ways to attack this problem. We will present two methods for\nbuilding the correct tournament tree, and a method for finding the arrangement\nof that tree that produces the alphabetically earliest lineup. It is possible\nto combine the tree building and tree optimization methods into a single\nalgorithm, but we present the analysis this way for ease of explanation.\n</p>\n<h3>Building the tree: starting from the beginning</h3>\n<p>\nLet's start from the beginning of the tournament and create each new round. At\nany point, you have some number of <code>R</code>s, <code>P</code>s, and\n<code>S</code>s remaining, and you can only create <code>RP</code>,\n<code>RS</code>, and <code>PS</code> matches, because anything else would\nresult in a tie. Call the number of <code>RP</code> matches you will create\n<i>x</i> &mdash; that is, you will make <i>x</i> of the <code>R</code>s match\nup with <code>x</code> of the <code>P</code>s. Then all other <code>R</code>s\nmust face <code>S</code>s, so you will create <b>R</b>-<i>x</i> <code>RS</code>\nmatches. There will be <b>P</b>-<i>x</i> leftover <code>P</code>s and\n<b>S</b>-(<b>R</b>-<i>x</i>) leftover <b>S</b>s, and these numbers must be\nequal to avoid creating tied matches, so <b>P</b>-<i>x</i> =\n<b>S</b>-<b>R</b>+<i>x</i> and <i>x</i> = (<b>R</b>+<b>P</b>-<b>S</b>)/2. If\nthis <i>x</i> causes an impossible situation (e.g, there must be more\n<code>RP</code> matches than there are <code>R</code>s or <code>P</code>s),\nthen the answer is <code>IMPOSSIBLE</code>. Otherwise, match the players\naccordingly, note the winners (all <code>RP</code>s become <code>P</code>s, all\n<code>RS</code>s become <code>R</code>s, and all <code>PS</code>s become\n<code>S</code>s), and then you have a smaller instance of the same problem.\nThis strategy tells you whether the tournament will end, and how to make all\nyour matchups; with that information and some careful bookkeeping along the\nway, you can generate the entire tree.\n</p><p>\n<h3>Building the tree: starting from the end</h3>\n<p>\nLet's start from the end of a tournament instead. Suppose that the winning\nplayer is a <code>P</code>. What do we know about the match that produced\nthat winner? One of the participants must have been that <code>P</code>, and\nthe other must have been the opponent that the <code>P</code> defeated, namely,\nan <code>R</code>. That <code>R</code> must have defeated an <code>S</code>,\nand so on. That is, for any node in the tournament tree, including the bottom\n(winning) node, we can easily regenerate the entire part of the tree that led\nto it!\n</p><p>\nThis also implies that for a given <b>N</b>, there is only one possible\n(<code>R</code>, <code>P</code>, <code>S</code>) triplet that will produce a\nsuccessful tournament ending in <code>R</code>, and likewise for <code>P</code>\nand <code>S</code>. Almost all triplets are doomed to fail! There are only\nthree valid ones for any <b>N</b>, and each of them must produce a different\nwinner.\n</p><p>\nSo, we can try all three possible winners (<code>R</code>, <code>P</code>, and\n<code>S</code>) for every value of <b>N</b> from 1 to 12, and store the\nresulting tournament trees and their numbers of <code>R</code>s,\n<code>P</code>s, and <code>S</code>s. Then, for each test case, either the\ngiven <b>N</b>, <b>R</b>, <b>P</b>, and <b>S</b> values match one of the stored\ntrees, or we know the case is <code>IMPOSSIBLE</code>.\n</p>\n<h3>Finding the alphabetically earliest lineup</h3>\n<p>\nHaving the tournament tree is not enough, because a tree can generate many\npossible lineups. For any internal (non-leaf) node in the tree, you can swap\nthe two branches; this does not change the tree, but it does change the initial\nlineup! For instance, the lineups <code>PSRS</code>, <code>PSSR</code>,\n<code>RSPS</code>, <code>RSSP</code>, <code>SPRS</code>, <code>SPSR</code>,\n<code>SRPS</code>, and <code>SRSP</code> all represent the same tree. There are\n2<sup><b>N</b></sup>-1 internal nodes in the tree, and we can't try all 2 to\nthe (2<sup><b>N</b></sup>-1) ways of flipping or not flipping each of them.\nFortunately, we don't have to.\n</p><p>\nConsider any pair of players who face off in the first round; let's say\nthey're using moves X and Y, where X is alphabetically earlier than Y. These\ntwo players will contribute to two consecutive characters in the lineup;\neither XY or YX, depending on whether we flip their node. Flipping other nodes\nin the tree may move this pair of characters around in the final lineup, but it\ncannot reverse or separate them. So we have nothing to lose by choosing XY;\nthis decision is totally independent of whatever we do with other nodes later.\nMore generally, for any node, we should put the \"alphabetically earlier\" branch\nbefore the \"alphabetically later\" branch. Moreover, we should optimize\nshallower nodes in the tree before optimizing deeper nodes, so that we can be\nsure that we're only making decisions about branches that are already\nthemselves alphabetically optimized.\n</p><p>\nSo we can start with <i>any</i> lineup corresponding to our tree (ideally,\nwhatever came out of our algorithm earlier), and first examine the lineup in\n2<sup><b>N</b>-1</sup> chunks of length 2 and swap the letters in each chunk\nwhenever that would make the chunk alphabetically earlier. Then we can examine\nthe lineup in 2<sup><b>N</b>-2</sup> chunks of length 4, and swap the subchunks\nof length 2 in each chunk whever that would make the chunk alphabetically\nearlier. And so on, until we've examined and possibly swapped the 2 chunks of\nlength 2<sup><b>N</b>-1</sup>; that final lineup will be our alphabetically\nearliest answer.\n</p><p>\n","id":"0000000000201d1e","statement":"<h3>Problem</h3>\n<p>\nYou've been asked to organize a Rock-Paper-Scissors tournament. The tournament\nwill have a single-elimination format and will run for <b>N</b> rounds;\n2<b><sup>N</sup></b> players will participate.\n</p><p>\nInitially, the players will be lined up from left to right in some order that\nyou specify. In each round, the first and second players in the lineup\n(starting from the left) will play a match against each other, and the third\nand fourth players in the lineup (if they exist) will play a match against\neach other, and so on; all of these matches will occur simultaneously. The\nwinners of these matches will remain in the lineup, in the same relative order,\nand the losers will leave the lineup and go home. Then a new round will begin.\nThis will continue until only one player remains in the lineup; that\nplayer will be declared the winner.\n</p><p>\nIn each Rock-Paper-Scissors match, each of the two players secretly chooses\none of <i>Rock</i>, <i>Paper</i>, or <i>Scissors</i>, and then they compare\ntheir choices. Rock beats Scissors, Scissors beats Paper, and Paper beats Rock.\nIf one player's choice beats the other players's choice, then that\nplayer wins and the match is over. However, if the players make the\nsame choice, then it is a tie, and they must choose again and keep playing\nuntil there is a winner.\n</p><p>\nYou know that the players this year are stubborn and not very strategic.\nEach one has a <i>preferred move</i> and will only play that move in every\nmatch, regardless of what the opponent does. Because of this, if two\nplayers with the same move go up against each other, they will keep tying\nand their match will go on forever! If this happens, the tournament will never\nend and you will be a laughingstock.\n</p><p>\nThis year, there are <b>R</b> players who prefer Rock, <b>P</b> players\nwho prefer Paper, and <b>S</b> players who prefer Scissors. Knowing this,\nyou want to create a lineup that guarantees that the tournament will go to\ncompletion and produce a single winner &mdash; that is, no match will ever be a\ntie. Your boss has asked you to produce a list of all such lineups (written\nin left to right order, with <code>R</code>, <code>P</code>, and <code>S</code>\nstanding for players who prefer Rock, Paper, and Scissors, respectively),\nand then put that list in alphabetical order.\n</p><p>\nYou know that the boss will lazily pick the first lineup on the list; what will\nthat be? Or do you have to tell your boss that it is <code>IMPOSSIBLE</code> to\nprevent a tie?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\nlines follow; each represents one test case. Each test case consists of four\nintegers: <b>N</b>, <b>R</b>, <b>P</b>, and <b>S</b>, as described in the\nstatement above.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\neither <code>IMPOSSIBLE</code> or a string of length 2<b><sup>N</sup></b>\nrepresenting the alphabetically earliest starting lineup that solves the\nproblem. Every character in a lineup must be <code>R</code>, <code>P</code>, or\n<code>S</code>, and there must be <b>R</b> <code>R</code>s, <b>P</b>\n<code>P</code>s, and <b>S</b> <code>S</code>s.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n<b>R</b> + <b>P</b> + <b>S</b> = 2<b><sup>N</sup></b>.<br/>\n0 &le; <b>R</b> &le; 2<b><sup>N</sup></b>.<br/>\n0 &le; <b>P</b> &le; 2<b><sup>N</sup></b>.<br/>\n0 &le; <b>S</b> &le; 2<b><sup>N</sup></b>.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 25.<br/>\n1 &le; <b>N</b> &le; 3.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 75.<br/>\n1 &le; <b>N</b> &le; 12.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 1 1 0\n1 2 0 0\n2 1 1 2\n2 2 0 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: PR\nCase #2: IMPOSSIBLE\nCase #3: PSRS\nCase #4: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn sample case #1, there are only two players and the tournament will\nconsist of one round. It doesn't matter what order the two line up in; the\nPaper-using player will defeat the Rock-using player. You will give\nyour boss the alphabetically ordered list <code>PR</code>, <code>RP</code>, and\nthe first element is <code>PR</code>.\n</p><p>\nIn sample case #2, the only two players both play Rock, so a tie is\nunavoidable.<br>\n</p><p>\nIn sample case #3, there are four players and the tournament will go on for two\nrounds. In the first round, the first player (Paper) will lose to the second\nplayer (Scissors), and the third player (Rock) will defeat the fourth player\n(Scissors). The second round lineup will be <code>PR</code>, and the first\nremaining player (Paper) will defeat the other remaining player (Rock), so the\ntournament will end with a winner and no ties.<br>\n</p><p>\nHere is an illustration of the tournament for sample case #3:\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0YeTlStzp7DCqVzvNH4c9xG6LrmSUh8-tuPTtD1R12b8OeIvDze1kSE8ZROBf8VDX3-NhuEydz/rps_case3.png\">\n</p>\nOther lineups such as <code>PSSR</code> will appear on the list you give to\nyour boss, but <code>PSRS</code> is alphabetically first.\n<p>\nIn sample case #4, the only way to organize the first round such that there are\nno ties is to create two matches with one Rock player and one Scissors player.\nBut both of those matches will have a Rock winner, and when these two winners\ngo on to face each other, there will be a tie.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Rather Perplexing Showdown","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201c91","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2016"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
