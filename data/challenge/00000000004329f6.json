{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1226693700000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000004329f6","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<h3>A feast of square boards</h3>\n<p>\n  We present five problems we like very much for the Google Code Jam 2008 world\n  final. Not until the committee selected all the problems did we find out that\n  the rectangular board of unit squares clearly appears in four of the five\n  problems. Only the first problem is an exception. Does that make the contest\n  imperfect in a perfectionist's eyes? Not at all! See the picture in our\n  analysis for that problem.\n</p><p>\n  Yet that is just a nice coincidence. Each of the five problems have its\n  distinct nature under the cover of these beautiful rectangular grids.\n</p>\n\n<h3>Behind the scenes</h3>\n<p>\n  Our last problem is called <i>The Year of Code Jam</i>. So is that another\n  nice coincidence? Maybe.\n</p><p>\n  The original author certainly made the name and the good story intentionally.\n  However, the author did not realize a crucial trick. As a result, two easier\n  version of this problem were created, none exciting enough to be selected as\n  the last problem for the final round. Until one day Tomek Czajka looked at\n  them and said, \"We just need to change it slightly to be a bipartite graph,\n  and here is a nice trick one can use...\"\n</p><p>\n  A bigger story was centered around the problem <i>Bridge Builders</i>. Why is\n  it \"bigger\"? Because (1) it was the first problem the committee selected for\n  the final round, months before the competition, with all the members voting\n  for it. And (2) up until the day before the final round, it was still unclear\n  whether we would use the problem, with debates raging and whiteboards covered\n  in faulty proofs.\n</p><p>\n  So the story goes like this. Yes, the committee liked it very much. One needs\n  good intuition to see that this is a cute version of minimum weighted spanning\n  tree problem. The committee saw that, and proved it, and the problem was\n  sitting there for months.\n</p><p>\n  Months later, a week before the contest, it was time to finalize the problems.\n  The committee found out that the proof was incomplete. It did not look too\n  difficult to fix, but the task turned out to be tricky. As long as the\n  algorithm was correct, we valued the intuition required to come up with the\n  solution. After a series of debates, discussions, refutations, and\n  verifications, we finally got a proof one day before the contest. The proof\n  was mainly due to Derek Kisman and Christopher Hendrie.\n</p>\n\n<h3>At the world finals</h3>\n<p>\n  11,000 of you competed in the first round of Google Code Jam 2008, and on\n  Friday morning the top 100 went head-to-head in Mountain View to vie for the\n  top spot. After 3 hours of grueling competition and a problem set that could\n  make your head spin, we had a winner: ACRush of China, jumping into first\n  place with 6 minutes, 40 seconds to go. Innovative.Cat of China came in\n  second, finishing the same set of problems with 5 minutes, 44 seconds left.\n  And a mere 2 points behind them, the difference between two larges, was bmerry\n  of South Africa; he burned through most of the problem set with 1/3 of the\n  contest to go, but couldn't quite finish it off. Everyone solved our easiest\n  problem, and six people solved the hardest one (which was six more than many\n  of us expected!)\n</p><p>\n  Congratulations to all of Friday's contestants, and to everyone who competed\n  in GCJ 2008!\n</p>\n\n<hr>\n<p>\n  <b>Credits</b>\n</p><p>\n  Problem A. <i>Juice</i>\n  Written by John Dethridge. Prepared by Marius Andrei.\n</p><p>\n  Problem B. <i>Ping Pong Balls</i>\n  Written by William Rucklidge. Prepared by Matthew Chan and Daniel Rocha.\n</p><p>\n  Problem C. <i>Mine Layer</i>\n  Written by Zhen Wang. Prepared by Xiaomin Chen.\n</p><p>\n  Problem D. <i>Bridge Builders</i>\n  Written by Mark Gordon. Prepared by the Code\n  Jam team.\n</p><p>\n  Problem E. <i>The Year of Code Jam</i>\n  Written by Tomek Czajka and Xiaomin Chen. Prepared by Bartholomew Furrow and\n  Xiaomin Chen.\n</p><p>\n  Contest analysis presented by Xiaomin Chen and Derek Kisman.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1226682900000,"tasks":[{"analysis":"<h3>The different appearances of perimeter</h3>\n<p>\n  In spite of the nice story about the calendar and the fancy definition of\n  happiness, we hope that you have discovered the following abstract description\n  of this problem.\n</p>\n<blockquote>\n  On a board of <b>N</b> by <b>M</b> unit squares, some squares are blue, some\n  are white, and some are undecided. For each undecided square, color it either\n  blue or white, so that the total perimeter of blue region is maximized.\n</blockquote>\n<p>\n  We see that the perimeter can be defined in two ways.\n</p>\n<ul>\n  <li>\n    (a) The sum of the contributions from each blue square, as indicated in our\n    problem statement.\n  </li>\n  <li>\n    (b) The sum of the contributions from each unit segment. Count 1 for each\n    unit segment that separates two squares with different colors. (Assume all\n    the squares outside the board are white.)\n  </li>\n</ul>\n<p>\n  The second interpretation is useful for the following analysis.\n</p><p>\n  There are some simple observations that seem useful. For example, for any\n  undecided unit square, if we have already decided that two of its neighbors\n  are blue, then in one optimal solution we can assign it to be white. Yet, as\n  far as we know, no such heuristics give a complete and fast solution to our\n  problem.\n</p>\n\n<h3>A similar problem</h3>\n<p>\n  Let us discuss a problem that at least looks similar to ours. What if we\n  wanted to minimize the perimeter instead of maximizing it?\n</p><p>\n  We rephrase the problem in terms graph theory. Let the set of <b>NM</b> unit\n  squares be our vertices, and let there be an edge between two adjacent\n  squares. Our task is to color each undecided vertex either blue or white, so\n  that the number of edges (in the graph) between the blue vertices and the\n  white vertices is minimized.\n</p><p>\n  This is rather nice, isn't it? If you add a source <b>s</b> and a destination\n  <b>t</b>, add one edge from <b>s</b> to every blue vertex with infinite\n  capacity (4 is enough) and one edge from every white vertex to <b>t</b> with\n  infinite capacity, then the problem is asking for a <i>minimum cut</i> from\n  <b>s</b> to <b>t</b>, which can be solved by your favorite max flow algorithm.\n</p>\n\n<h3>Solving the original problem</h3>\n<p>\n  While minimum cut is polynomial-time solvable by max flow, the max-cut problem\n  is too hard in general graphs. Therefore, our problem still seems much harder\n  than the minimization version of the problem.\n</p><p>\n  However, we have not used an important fact yet. Our graph is far from\n  arbitrary. We play this game on the <b>N</b> by <b>M</b> board; the resulting\n  graph is bipartite (imagine it as a chessboard). Maximizing the number of\n  edges between different colored vertices is the same as minimizing the number\n  of edges between vertices of the same color. In other words, if we flip the\n  colors of one half of the chessboard, the problem reduces to the minimization\n  version we discussed above.\n</p><p>\n  We mark the board in a chessboard fashion, label the unit squares as odd or\n  even. Then we flip the color of all the even squares. Now look at property\n  (b). A contribution becomes a non-contribution and vice versa. The total\n  number of edges is fixed, so the maximization problem reduces to its\n  minimization version.\n</p>\n","id":"0000000000432a81","statement":"<h3>Problem</h3>\n<p>\n  The year 2008 will be known as a year of change and transition, the start of a\n  new era: we're talking, of course, about the new Google Code Jam format. The\n  introduction of this contest has jammed so many great programming competitions\n  together in a single year that people have started calling it\n  <i>The Year of Code Jam</i>.<br>\n  Sphinny, a passionate contestant, is looking at her calendar of the year and\n  discovering that a great number of programming contests has been scheduled.\n  She has marked every day of the year on the calendar in one of the three ways:\n</p>\n<ul>\n  <li>\n    White: She will not participate in a contest on this day. Either no contests\n    are scheduled, or she has more important things to do (surely there are\n    other good things in life!).\n  </li>\n  <li>Blue: She will definitely participate in a contest on this day.</li>\n  <li>\n    Question mark: There is a contest scheduled, but she has not decided yet\n    whether she will participate.\n  </li>\n</ul>\n\n<p>\n  Note: To simplify the problem, we'll assume that there is no concept of\n  qualification: you don't have to participate in one contest to be eligible for\n  another.\n</p><p>\n  Being in a world that is somewhat different from ours, Sphinny's calendar has\n  some features we must mention: It has <b>N</b> months, and each month has\n  exactly <b>M</b> days.\n</p><p>\n  The picture below depicts a calendar with 5 months, 8 days in each month, 15\n  blue days, and 5 question marks.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U33uQ3Fjc1vhveDXrkxrXkc8w3H2yrIEzkXxZf8R07OQ1Xg0X6puKzRcz8iQYIuvgcxczhK/yocj01.png\" />\n<p>\n  Looking at her beautiful calendar, Sphinny has decided that each day has up to\n  4 <b>neighbors</b> in the year: The previous day in the same month, the next\n  day in the same month, the same day in the previous month, and the same day in\n  the next month.\n</p><p>\n  Sphinny wants to maximize her happiness from these contests, and she estimates\n  the effect of the contests on her happiness as a summation of values for all\n  the blue days. For each blue day, the value is computed as follows:\n</p>\n<ul>\n  <li>The initial value is 4.</li>\n  <li>For each blue neighbour the day has, decrease the value by 1.</li>\n</ul>\n<p>\n  You may think that Sphinny likes the contests, but participating on two\n  consecutive days makes her a little tired. And for aesthetic reasons,\n  participating on the same day in two consecutive months is also not so great.\n</p><p>\n  Sphinny wants to plan her year now, and decide for every day with a question\n  mark whether it should be white or blue. Her goal is simply to maximize the\n  happiness value.\n</p><p>\n  The following picture shows a solution for the example above. By changing two\n  question marks to blue days, and the other three to white days, she can\n  achieve a happiness value of 42.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1dEV7nXSBWNAJp7STm2Jmho_6HU_c-NCdAfvPXOAKFv3_emExU5ImVA6uuCi50c3PxhN4f/yocj02.png\" />\n\n<h3>Input</h3>\n<p>\n  The first line in the input file contains the number of cases <b>T</b>. This\n  is followed by <b>T</b> cases in the following format.<br>\n  The first line is of the form \"<b>N M</b>\", where <b>N</b> and <b>M</b> are\n  two numbers giving the number of months and the number of days per month.<br>\n  The next <b>N</b> lines each contain a string of length <b>M</b>. The\n  <b>j</b>-th character in the <b>i</b>-th string is one of {'#', '.', '?'},\n  which gives the status of the j-th day in the i-th month. '#' indicates a blue\n  day, '.' indicates a white day, and '?' indicates a day with a question mark.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each input case, you should output a line in the format:\n</p>\n<pre>\nCase #X: Y\n</pre>\n<p>\n  where <b>X</b> is the 1-based case number, and <b>Y</b> is the maximum\n  happiness value.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.<br>\n  1 &le; <b>T</b> &le; 100.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  Time limit: 30 seconds.<br>\n  1 &le; <b>M</b>, <b>N</b> &le; 15.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  Time limit: 120 seconds.<br>\n  1 &le; <b>M</b>, <b>N</b> &le; 50.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 3\n.?.\n.?.\n.#.\n5 8\n.#...##.\n.##..?..\n.###.#.#\n??#..?..\n###?#...\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 8\nCase #2: 42\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Note that the second sample is our example in the pictures above.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":23}],"title":"The Year of Code Jam","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  In this problem, we need to find the best (A*, B*, C*) such that there is a\n  maximum number of (A, B, C) triplets in the input satisfying:\n</p>\n<blockquote>\n  A &le; A*, B &le; B*, C &le; C*, and A* + B* + C* &le; 10000.\n</blockquote>\n<p>\n  It is easy to see that we can just consider integer A*, B*, C*'s. In fact C*\n  can be one of the C's from the input, so are A* and B* -- otherwise we can\n  just decrease it until it hits some C for a satisfied customer.\n</p><p>\n  So we have at most 5000 possible candidate values for C* (or 10000, if you\n  don't want to use the above observation). We try each of them. And the problem\n  is nicely visualized in 2-dimensional grid.\n</p><p>\n  For a fixed C*, we know A* + B* &le; 10000 - C*. We filter out all the inputs\n  that have\n</p>\n<blockquote>\n  C &le; C* or A + B &ge; 10000 - C*,\n</blockquote>\n<p>\n  and view the remaining as points in the 2-d plane, with their A, B as the\n  coordinates. For the best solution (A*, B*), we can just try all the integer\n  points (10001 - C* of them) on the line A* + B* = 10000 - C*. For each point,\n  we need to know <i>quickly</i> how many input points are dominated by that\n  point, i.e., lying in the axis-parallel rectangle between the origin and that\n  point.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1tNp473GOgtZJkNiajEC3Y75PWaVQLzM5cII7DEFkVmOspbx8T-9-2tQUPsambqp6xOszf_Ulq/juice_sol.png\" />\n<p>\n  The last step must be computed fast enough to meet the time limit of the\n  competition. Assume we move the point (A*, B*) from the top-left to\n  bottom-right. In a certain step, we are at (A', B'), with Q points dominated\n  by it. In the next step, we are at (A' + 1, B' - 1), the number of points\n  dominated by the new point can be computed as\n</p>\n<blockquote>Q' = Q - H<sub>B'</sub> + V<sub>A' + 1</sub>,</blockquote>\n<p>\n  where V<sub>A</sub> is the counter of points on the A-th vertical line, and\n  H<sub>B</sub> is the number of points on the B-th horizontal line. Q' can be\n  computed in constant time if we pre-compute the counters.\n</p><p>\n  Solution from the judges:\n</p>\n<pre>\nint T, n, ans;\nint A[5000], B[5000], C[5000], H[10001], V[10001];\n\nint main() {\n  cin&gt;&gt;T;\n  for (int t=1; t&lt;=T; t++) {\n    cin&gt;&gt;n;\n    for(int i=0; i&lt;n; ++i) cin&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;C[i];\n\n    int ans = 0;\n    for (int CC=0; CC&lt;=10000; ++CC) {\n      memset(H, 0, sizeof(H));\n      memset(V, 0, sizeof(V));\n      for (int i=0; i&lt;n; ++i)\n        if (C[i]&lt;=CC &amp;&amp; A[i]+B[i]+CC&lt;=10000)\n        { V[A[i]]++; H[B[i]]++; }\n      int Q = 0;\n      for (int AA=-1; AA&lt;10000-CC; ++AA) {\n        Q = Q + V[AA+1] - H[10000-CC-AA];\n        ans &gt;?= Q;\n      }\n    }\n\n    cout&lt;&lt;\"Case #\"&lt;&lt;t&lt;&lt;\": \"&lt;&lt;ans&lt;&lt;endl;\n  }\n  return 0;\n}\n</pre>\n","id":"0000000000432b25","statement":"<h3>Problem</h3>\n<p>\n  You are holding a party. In preparation, you are making a drink by mixing\n  together three different types of fruit juice: Apple, Banana, and Carrot.\n  Let's name the juices A, B and C.\n</p><p>\n  You want to decide what fraction of the drink should be made from each type of\n  juice, in such a way that the maximum possible number of people attending the\n  party like it.\n</p><p>\n  Each person has a minimum fraction of each of the 3 juices they would like to\n  have in the drink. They will only like the drink if the fraction of each of\n  the 3 juices in the drink is greater or equal to their minimum fraction for\n  that juice.\n</p><p>\n  Determine the maximum number of people that you can satisfy.\n</p>\n\n<h3>Input</h3>\n\n<ul>\n  <li>\n    One line containing an integer <b>T</b>, the number of test cases in the\n    input file.\n  </li>\n</ul>\n<p>\nFor each test case, there will be:\n</p>\n<ul>\n  <li>\n    One line containing the integer <b>N</b>, the number of people going to the\n    party.\n  </li>\n  <li>\n    <b>N</b> lines, one for each person, each containing three space-separated\n    numbers \"A B C\", indicating the minimum fraction of each juice that would\n    like in the drink. A, B and C are integers between 0 and 10000 inclusive,\n    indicating the fraction in parts-per-ten-thousand. A + B + C &le; 10000.\n  </li>\n</ul>\n\n<h3>Output</h3>\n<ul>\n  <li>\n    <b>T</b> lines, one for each test case in the order they occur in the input\n    file, each containing the string \"Case #X: Y\" where X is the number of the\n    test case, starting from 1, and Y is the maximum number of people who will\n    like your drink.\n  </li>\n</ul>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>T</b> &le; 12\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 5000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n10000 0 0\n0 10000 0\n0 0 10000\n3\n5000 0 0\n0 2000 0\n0 0 4000\n5\n0 1250 0\n3000 0 3000\n1000 1000 1000\n2000 1000 2000\n1000 3000 2000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 2\nCase #3: 5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  In the first case, for each juice, we have one person that wants the drink\n  to be made entirely out of that juice! Clearly we can only satisfy one of\n  them.\n</p><p>\n  In the second case, we can satisfy any two of the three preferences.\n</p><p>\n  In the third case, all five people will like the drink if we make it using\n  equal thirds of each juice.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":3},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Juice","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This problem seems intimidating at first glance. There are many different\n  routes between the islands and the costs are somewhat unintuitive. However,\n  the problem is actually a disguised Minimum Spanning Tree between the forests;\n  and the nice thing about MSTs is that they are very friendly to greedy\n  approaches. Almost any reasonable greedy approach that focuses on connecting\n  up the forests will get the right answer.\n</p><p>\n  It is fairly easy to convince yourself that the correct approach to the Small\n  dataset is to head directly for the other forest; it can't possibly hurt,\n  since all the other islands pay their minimum possible cost (ie, the distance\n  to the nearest forest). In fact, assuming that islands pay their minimum cost\n  is key: you can ignore this \"base\" cost, and then the only time you actually\n  have to pay \"extra\" is when connecting up the two forests.\n</p><p>\n  So for the Large dataset, once again you ignore the \"base\" cost for each\n  island and simply focus on reaching all the forests, at which point you're\n  done. Based on this intuition, you might immediately think of building a MST\n  across the forests. The \"extra\" cost of connecting forests increases with\n  distance, so use Prim's Algorithm: always head towards the forest nearest to\n  the forests you've already visited. After connecting all the forests, you can\n  build minimal-cost bridges to the remaining islands.\n</p><p>\n  This greedy approach always works, and is quite an intuitive answer when you\n  think of the problem in these terms. However, the proof that it works turns\n  out to be quite technical. The problem is that you have to be sure that the\n  forest connections really do form a graph with well-defined, order-independent\n  costs. If your choice of path between one pair of forests could somehow help\n  you save cost later, this would be incorrect (and the specter of\n  NP-Completeness would loom menacingly). It seems reasonable that this can't\n  happen, especially if you try a few examples yourself. But writing a proof in\n  contest time is probably impossible. In fact, it took us several days of\n  collaboration to come up with a proper, correct proof. :) This is what you\n  have to deal with as a competitor in the Finals of the Google Code Jam!\n</p><p>\n  Here's an outline of this proof:\n</p><p>\n  First, suppose that we already have a tree (no cycles) of bridges which\n  connects up every island. We show that the cheapest way we could have built\n  these bridges is given by our MST algorithm (where distances are measured\n  along the given tree). Assume we have some cheapest ordering of the bridges.\n  First, we can reorder at no cost to ensure that it consists of direct\n  sequential paths from a previously-visited island to a forest. Now suppose\n  there is ever an island A from which we build two bridges, A-B and A-C.\n  Further, suppose A-B leads to a closer island than A-C, but we build A-C\n  first. Finally, suppose this is the <i>last</i> such occasion; so we build\n  directly to the closest islands in B's subtree and in C's subtree.\n</p><p>\n  Let w be the distance, when A-C is built, from A to its nearest forest along\n  built bridges. Let x be this distance when A-B is built (so x &lt;= w). Let y\n  be the distance from A to its closest island in B's subtree, and z to the\n  closest island in C's subtree (so y &lt;= z). Then the cost of building these\n  A-C and A-B paths is (w+1 + w+2 + ... + w+z) + (x+1 + x+2 + ... + x+y).\n  Instead, if we do the A-B path <i>first</i> and leave A-C and its subtree\n  until later, we pay at most (w+1 + w+2 + ... + w+y) + (x+1 + x+2 + ... + x+z),\n  and possibly less since intermediate steps may also cost less. The second\n  subtracted from the first is (w+y+1)-(x+y+1) + (w+y+2)-(x+y+2) + ... +\n  (w+z)-(x+z) = (z-y)*(w-x), which is non-negative.\n</p><p>\n  Thus, without increasing the cost, we can rearrange the order of bridges to\n  build A-B first. Repeating this, we determine that one cheapest way to build\n  the tree of bridges is always to head for the nearest forest first, which is\n  what our algorithm does.\n</p><p>\n  Now, for any graph (a set of islands with a set of possible bridges), we prove\n  inductively that our algorithm always gives the cheapest cost. It's true for 1\n  island; assume it's true for k. Suppose we have a minimal plan to connect up\n  k+1 islands. Let A-B be the final bridge built. B could not have been visited\n  already; so consider this plan restricted to the first k islands. Inductively,\n  we know this plan is no cheaper than our algorithm, when run on those k\n  islands; furthermore -- a nice fact about our algorithm, if you have not\n  noticed yet -- after running our algorithm A is as close as possible to a\n  forest. So doing this then building A-B is also a cheapest plan, and,\n  importantly, this forms a tree of bridges. Let's call it T.\n</p><p>\n  Now, from above, we know the cost of building this tree of bridges: it's just\n  the total cost based on running our algorithm on the forest-to-forest\n  distances in T. But these distances are at least as large as the corresponding\n  forest-to-forest distances along <i>all</i> the potential bridges between our\n  k+1 islands. We've paid at least as much as a normal spanning tree on our\n  forests - so at least as much as a MST. But our algorithm achieves this MST\n  cost, which we now know to be minimal.\n</p><p>\n  QED.\n</p><p>\n  Interestingly, this result also holds for any graph of islands and potential\n  bridges, not just a grid or a planar graph. And the distance-to-cost metric\n  can be any nondecreasing function. These facets of the problem are artificial\n  and not essential to the algorithm.\n</p><p>\n  Finally, here is pseudocode for the solution, assuming you know any standard\n  MST algorithm.\n</p>\n\n<pre><code>\nfor each unordered pair of forests (a, b)\n  x = distance(a, b)\n  y = x / 2  // Assume integer division\n  c = x * (x + 1) / 2  // Add cost of connecting forests\n  c -= y * (y + 1)  // Subtract \"base\" cost of islands\n  if x is even\n    c += y // Avoid double-counting middle island\n  add edge (a, b) at cost c to forest_graph\n\nresult = min_cost_spanning_tree(forest_graph)\n\nfor each island x\n  d = INFINITY\n  for each forest y\n    d = min(d, distance(x, y))\n  result += d  // Add \"base\" cost of island x\n</code></pre>\n","id":"0000000000432bd7","statement":"<h3>Problem</h3>\n<p>\n  The king wants bridges built and he wants them built as quickly as possible.\n  The king owns an <b>N</b> by <b>M</b> grid of land with each cell separated\n  from its adjacent cells by a river running between them and he wants you to\n  figure out how many man-hours of work it will take to build enough bridges to\n  connect every island. Some cells are actually lakes and need not have a bridge\n  built to them.\n</p><p>\n  Some of the islands are forests where trees are abundant. Located in the top\n  left corner is the <i>base camp</i>, which is always a forest.\n</p><p>\n  A bridge can only be built between two islands if they are vertically or\n  horizontally adjacent, and one of the islands is accessible from the base camp\n  through the bridges that are already built.\n</p><p>\n  The number of man-hours it takes to build a bridge is the number of bridges\n  the builders have to cross to get from the nearest forest to the island you're\n  building to, including the bridge being built. Builders can only walk between\n  two islands if there is already a bridge between them.\n</p><p>\n  The king has already ensured that there is at least one way to connect all the\n  islands.\n</p><p>\n  Write a program that, given a map of the islands, will output the minimum\n  number of man-hours required to connect all islands.\n</p><p>\n  Consider this example. A green tile indicates a forest, gray indicates an\n  empty island, and blue indicates water.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3DUB8lyB0hM1UODiI8YhFnU_-d0LhHGED89hVSlzkAn7yVNFOKXT6p7WBtR21UwBmWscof/stage0.png\" />\n<p>\n  One optimal solution starts out by building the following bridges from the\n  base camp forest.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2wMgOxnXTg0DZH_3haG0Kp6Dz7FuQe5MkoJ7xJ7oYiTRg0UVmEe5CPrHIyrBzZEPizanv_/stage1.png\" />\n<p>\n  This has a cost of 1 + 2 + 1 + 2 + 3 + 4 = 13\n</p><p>\n  Now since the forest at row 3, column 3 is connected to base camp, we can\n  build bridges from there. One optimal solution connects the rest of the\n  islands with bridges built from this forest.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3CKB4kpTp8MzZHTLQhNkMnaovnynaL9F7uHnA9XzSPlfi6Q1SQZwOIf4g817CI-guQG5OU/stage2.png\" />\n<p>\n  This has a cost of 2 + 1 + 2 + 1 + 2 + 3 = 11. This brings the total cost to\n  24 which is the optimal solution.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input contains an integer <b>T</b>, the number of test\n  cases. <b>T</b> test cases follow. Each test case will begin with <b>N</b>,\n  the number of rows, and <b>M</b>, the number of columns, on one line separated\n  by a space. <b>N</b> rows follow that contain exactly <b>M</b> characters\n  each. A 'T' indicates an island with a forest, a '#' indicates an island, and\n  a '.' indicates water.\n</p>\n\n<h3>Output</h3>\n<p>\n  A single line containing \"Case #X: Y\", where <b>X</b> is the 1-based case\n  number, and <b>Y</b> is the minimum number of man-hours needed to connect all\n  islands.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>T</b> &le; 50<br>\n  2 &le; <b>N</b> &le; 30<br>\n  2 &le; <b>M</b> &le; 30<br>\n  The top left cell will always be a 'T'<br>\n  It will be possible to connect all islands through bridges\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  There will be at most 2 forests in the grid including the base camp.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  There will be no limit on the number of forests in the grid.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 2\nT.\nT#\n4 4\nT##.\n##.#\n.#T#\n####\n5 5\nT#T.#\n..#.#\n#.###\n###.#\nT###T\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 24\nCase #3: 49\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Bridge Builders","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Special Cases</h3>\n<p>\n  The small dataset can be solved by a brute force. With algorithms like breadth\n  first search (BFS), one can find all the points that are triggered.\n</p><p>\n  Another case we can use BFS is when the two displacement vectors are\n  collinear. In this case all the points we need to consider are in a line, and\n  there will be no more than 1000000 points on any line.\n</p>\n\n<h3>General Case</h3>\n<p>\n  Interestingly, for the general case, where the two vectors are not collinear,\n  one can use a shorter program with a simpler data structure. Here we introduce\n  a solution that only involves vector additions. This is not the most efficient\n  solution, but it is good enough for our purposes.\n</p><p>\n  <i>Note</i>: This is not the first time we've encountered a 2-dimensional\n  integer lattice where it is better to change the coordinate system. See the\n  similar picture we have in the analysis for Problem D in online round 3.\n</p><p>\n  Let us use [x, y] to denote the points in the ordinary coordinate system, and\n  (a, b) to denote the points in the new system. Suppose the two displacement\n  vectors are V1 = [&delta;<sub>x1</sub>, &delta;<sub>y1</sub>], V2 =\n  [&delta;<sub>x2</sub>, &delta;<sub>y2</sub>], Suppose that the first ball hits\n  position P = [x<sub>0</sub>, y<sub>0</sub>]. The points in the new system is\n  given by\n</p>\n<blockquote>\n  (a, b) := P + aV<sub>1</sub> + bV<sub>2</sub> =\n  [x<sub>0</sub> + a&delta;<sub>x1</sub> + b&delta;<sub>x2</sub>,\n  y<sub>0</sub> + a&delta;<sub>y1</sub> + b&delta;<sub>y2</sub>]. (*)\n</blockquote>\n<p>\n  The problem is to figure out, from (0, 0), how many points will be hit by\n  repeatedly adding (1, 0) or (0, 1).\n</p><p>\n  It is not hard to prove, using (*) and the fact that the two vectors are not\n  collinear, that for any points (a, b) inside the room, the numbers a and b are\n  bounded by some quantity <b>Q</b>, where <b>Q</b> is the size of the room\n  times the maximum value of the &delta;s. With the limits in our problem,\n  <b>Q</b> &le; 2 &times; 10<sup>7</sup>.\n</p><p>\n  For any fixed <b>a</b>, it is easy to see that there is a contiguous sequence\n  of numbers <b>b</b> such that (a, b) is hit. In other words, there are numbers\n  b<sub>a</sub> and b'<sub>a</sub> such that (a, b) is hit if and only if\n  b<sub>a</sub> &le; b &le; b'<sub>a</sub>. This is because, if we let\n  b<sub>a</sub> and b'<sub>a</sub> be the minimum and maximum <b>b</b> that get\n  hit, respectively, then, by convexity, (a, b) is inside the room for all\n  <b>b</b> between b<sub >a</sub> and b'<sub>a</sub>. Once we hit (a,\n  b<sub>a</sub>), we keep adding (0, 1) and get all the other points. It is\n  clear that (a, b'<sub>a</sub>) is the last point that stays in the room, and\n  (a, b'<sub>a</sub> + 1) is outside the room.\n</p><p>\n  It is good enough if we can iterate over <b>a</b> = 0, 1, 2, ..., (at most\n  <b>Q</b>), and quickly compute b<sub>a</sub> and b'<sub>a</sub> for each\n  <b>a</b>. Notice that, by definition, (a, b<sub>a</sub> - 1) is not hit. In\n  order to hit (a, b<sub>a</sub>), the last step must be from (a - 1,\n  b<sub>a</sub>). So\n</p>\n<blockquote>\n  b<sub>a-1</sub> &le; b<sub>a</sub> &le; b'<sub>a-1</sub>.\n</blockquote>\n<p>\n  To find b<sub>a</sub>, we can simply start from b<sub>a-1</sub> and keep\n  increasing until we hit a point inside the room. Note that for a single\n  <b>a</b> this might take a long time. However, the b<sub>a</sub>'s are\n  monotone, so the cost never exceeds <b>Q</b>.\n</p><p>\n  Once we find b<sub>a</sub>, we can use a binary search to find b'<sub>a</sub>.\n  Although a binary search is simple and quick enough, another approach seems\n  dumber but actually works faster. Similarly to the way we get b<sub>a</sub>\n  from b<sub>a-1</sub>, we may also get b'<sub>a</sub> from b'<sub>a-1</sub>.\n  Here the b'<sub>a</sub> are not monotone, so we need to try both increasing\n  and decreasing. Nevertheless, based on the rectangular shape of the room, the\n  direction will not change more than once. The total cost is still O(Q).\n</p><p>\n  Sample code from the judges for the non-collinear case:\n</p>\n\n<pre>\nint T, W, H;\nint x, y, dx1, dx2, dy1, dy2;\n\nbool inside(int a, int b) {\n  int xx = x + a*dx1 + b*dx2;\n  int yy = y + a*dy1 + b*dy2;\n  if(xx&lt;0 || xx&gt;=W) return false;\n  if(yy&lt;0 || yy&gt;=H) return false;\n  return true;\n}\n\nlong long play() {\n  long long ans=0;\n  int b1=0; int b2=1000001;\n  for(int a=0; ; a++) {\n    while(!inside(a, b1)) {\n      b1++;\n      if(b1&gt;b2) return ans;\n    }\n    if(inside(a, b2)) {\n      while(inside(a, b2)) b2++;\n      b2--;\n    } else {\n      while(!inside(a, b2)) b2--;\n    }\n    ans+=(b2-b1+1);\n  }\n  return 0;\n}\n</pre>\n","id":"0000000000432cc2","statement":"<h3>Problem</h3>\n<p>\n  A large room is filled with mousetraps, arranged in a grid. Each mousetrap is\n  loaded with two ping-pong balls, carefully placed so that when the mousetrap\n  goes off they will be flung, land on other mousetraps and set them off. The\n  walls of the room are sticky, so any balls that hit the walls of the room are\n  effectively absorbed.\n</p><p>\n  Every mousetrap that gets hit sends the two ping-pong balls in the same way:\n  their movement is determined by a X and Y displacement relative to the\n  launching mousetrap. You then decide to launch a single ping-pong ball into\n  the room. It hits a mousetrap, setting it off, and launching its two balls.\n  These two balls then set off two more mousetraps, and now four balls fly\n  off... When the dust settles, many of the mousetraps have been set off, but\n  some have been missed by all the flying balls.\n</p><p>\n  You need to calculate how many mousetraps will be set off.\n</p><p>\n  As an example (see the first sample test case), the picture below illustrates\n  a room with width 5, height 3. The two directions for the ping-pong balls in\n  each room are (-1, 0) and (-1, -1), respectively. The first ball you launch\n  hits the mousetrap at the position (4, 2). In the end, 12 mousetraps are\n  triggered.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1xwV74T0dI1eoNQRuHXwdpTEpSuqb0zXisCpcUn5XOAGBcU0U5cTTjTPAe5G1PFyC6ESVPVe8/pingpong.png\" />\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>C</b>. <b>C</b> test\n  cases follow. Each case contains four lines. The first line is the size of the\n  grid of mousetraps (equal to the size of the room), given as its width\n  <b>W</b> and height <b>H</b>. The next two lines give the destinations of the\n  two ping-pong balls, as an X and Y displacement. For example, if the two lines\n  were <code>0 1</code> and <code>1 1</code>, then triggering a mousetrap would\n  launch two balls; one would hit the mousetrap just up from the triggered\n  mousetrap, and the other would hit the mousetrap that is up and to the right\n  of the triggered mousetrap. The final line has two integers specifying,\n  respectively, the column and row of the mousetrap set off by the original\n  ping-pong ball (where 0 0 would be the bottom left mousetrap).\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>A</b>: <b>B</b>\",\n  where <b>A</b> is 1-based number of the case and <b>B</b> is the number of\n  mousetraps that are triggered (including the first one).\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>C</b> &le; 100<br>\n  -20 &le; any displacement &le; 20<br>\n  Neither vector will have zero length.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  2 &le; <b>W</b>, <b>H</b> &le; 100\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  2 &le; <b>W</b>, <b>H</b> &le; 1000000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n5 3\n-1 0\n-1 -1\n4 2\n50 50\n0 1\n1 1\n10 10\n6 2\n2 0\n3 0\n0 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 12\nCase #2: 820\nCase #3: 5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":11}],"title":"Ping Pong Balls","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>For the convenience of discussion, we denote c<sub>i,j</sub> as the input number at the position (i,j), i.e., the number of mines in the 3 by 3 square centered at (i,j). In the solution below we will see that, any solvable square must have a unique answer for the number of mines in the middle row.\n</p>\n\n<h3>(1) The number of mines in any 3 rows and 3<b>K</b> columns</h3><p>\nIn the picture below, sum up the c<sub>i,j</sub>'s of the starred positions.\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3cho-LxokMVWNRVygb0sjAHBw5IlfxEtKWnIG8shAjk9EdcY3qWKiW9YWM_dLQTVjiDlvWWkOtIg/mine_sol01.png\">\n</p>\n\n<h3>(2) The number of mines in any 3 rows and <b>C</b> columns</h3><p>\nIf <b>C</b> is not a multiple of 3, based on <b>C</b> mod 3, use one or two squares on the boundary.\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3LWjWNKITLDW7tOsFSuCO1tgHYpSs5paKpc-gzueRfFqaR1vluVogxy09Fo3ABzYMoy7r2zkWPXg/mine_sol02.png\">\n</p><p>\nIn summary, to get the number of mines in any three consecutive rows, we look at the middle row, start from either the first or second square, and mark every 3rd square. Let the middle row be the <b>a</b>-th row. We denote this sum by F<sub>a</sub>.\n</p><p>Also note that with exactly the same method, F<sub>0</sub> gives the number of mines in the first two rows, and F<sub>R-1</sub> does the same for the last two rows.</p>\n\n<h3>(3) The number of mines in the whole board</h3><p>Similarly, based on <b>R</b> mod 3, start from <b>a</b> = 0 or 1 and sum up the F<sub>a</sub> for every 3rd number.\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1-g6Xons0Bvve62jOqcvhCG6PxS-xTbSwyl2CiY_RS_NlCBz_3dXxVuJ4VYM5_eqig9RqWQqx3WQ/mine_sol03.png\">\n</p>\n\n<h3>(4) The number of mines in the first 3<b>K</b> or 3<b>K</b>+2 rows</p><p>We omit the picture here. It is similar to the pictures above. We either group the first 2 rows together, or the first 3. By symmetry, we can also get the number of mines in the last 3<b>K</b> or 3<b>K</b>+2 rows.</h3>\n\n<h3>(5) The number of mines in the middle row</h3><p>Let <b>h</b> = (<b>R</b> - 1) / 2. There are <b>h</b> rows above the middle row, as well as <b>h</b> rows below.\n</p><p>\nIf <b>h</b> mod 3 is 0 or 2, we can get the sum of those 2<b>h</b> rows from step (4) and subtract it from the total number of mines from step (3).\n</p><p>\nIf <b>h</b> mod 3 is 1, we can get the sum of the first <b>h</b>+1 rows from step (4), as well as the sum of the last <b>h</b>+1 rows. Only the center row is counted twice, so we can subtract the sum by the total number of mines from step (3).\n</p>\n\n<h3>Solution from the judges</h3>\n\n<pre>\nint T, R, C;\nint c[100][100];\n\nint SumRowsCentered(int a) { // F(a) as in the discussion.\n  int r=0;\n  for(int i=(C%3)?0:1; i&lt;C; i+=3) r+=c[a][i];\n  return r;\n}\n\nint play() {\n  int i;\n  // Get the total.\n  int total=0;\n  for(i=(R%3)?0:1; i&lt;R; i+=3) total+=SumRowsCentered(i);\n  // Get the answer.\n  int h=(R-1)/2; int S=0;\n  if (h%3==1) {\n    for(i=h-1;i&gt;=0;i-=3) S+=SumRowsCentered(i);\n    for(i=h+1;i&lt;R;i+=3) S+=SumRowsCentered(i);\n    return S-total;\n  } else {\n    for(i=h-2;i&gt;=0;i-=3) S+=SumRowsCentered(i);\n    for(i=h+2;i&lt;R;i+=3) S+=SumRowsCentered(i);\n    return total-S;\n  }\n  return 0;\n}\n\nint main() {\n  int i,j,k;\n  cin&gt;&gt;T;\n  for (i=1; i&lt;=T; i++) {\n    cin&gt;&gt;R&gt;&gt;C;\n    for(j=0;j&lt;R;j++) for (k=0;k&lt;C;k++) cin&gt;&gt;c[j][k];\n    cout&lt;&lt;\"Case #\"&lt;&lt;i&lt;&lt;\": \"&lt;&lt;play()&lt;&lt;endl;\n  }\n  return 0;\n}\n</pre>\n","id":"0000000000433150","statement":"<h3>Problem</h3>\n<p>\n  MineLayer is a MineSweeper-like puzzle game played on an <b>R</b> by\n  <b>C</b> grid. Each square in the grid either has one mine or no mines at all.\n  A MineLayer puzzle consists of a grid of numbers, each of which indicates the\n  total number of mines in all adjacent squares and in the square underneath.\n  The numbers will thus range from zero to nine.\n</p><p>\n  The objective of MineLayer is to figure out a layout of the mines in the grid\n  that matches the given clues.\n</p><p>\n  Below is a typical 3 by 4 grid. The original layout is on the left, and the\n  puzzle on the right.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U02Q_7tilJboPASnlvrG-LZbRJk_wc5qUykd4jzWUhNjovfE_b3V303QsNdONoYb-3Ydg/mine.png\" />\n<p>\n  Since there may be many solutions, your task is to write a program that\n  outputs the maximum possible number of mines in the middle row. The number of\n  rows will always be odd, and there will always be at least one solution to the\n  puzzle.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>N</b>. <b>N</b> test\n  cases follow.\n</p><p>\n  The first line of each case contains two space-separated numbers: <b>R</b>,\n  the number of rows, and <b>C</b>, the number of columns. <b>R</b> is always an\n  odd integer. Each of the next <b>R</b> lines contains <b>C</b> space-separated\n  numbers that denote the clues of that row.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #X: Y\", where X is the\n  1-based case number, and Y is the maximum possible number of mines in the\n  middle row of a grid that satisfies the given constraints.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>N</b> &le; 50.<br>\n  Each puzzle is guaranteed to have at least one solution.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  <b>R</b> = 3 or <b>R</b> = 5.<br>\n  3 &le; <b>C</b> &le; 5.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  <b>R</b> is an odd number between 3 and 49, inclusive.<br>\n  3 &le; <b>C</b> &le; 49.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 3\n2 2 1\n3 4 3\n2 3 2\n3 4\n1 2 1 1\n2 3 3 2\n2 2 2 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Mine Layer","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000004329f6","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
