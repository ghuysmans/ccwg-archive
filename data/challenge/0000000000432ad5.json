{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1258146000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432ad5","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nIn this final, onsite round, ACRush got into an early lead and managed to hold on to it until the very end, winning by a large margin of 81 points -- almost double the score of second place finisher, qizichao, with wata in close third.\n</p>\n<p>\nThe problem set was geometry-heavy, with three of the six problems requiring at least some computational geometry. Dynamic programming and probability made notable appearances as well.\n</p>\n<p>\nUnusually, the round started with four different people solving four different problems (A, B, C and D). Most contestants quickly realized that E and F were much more difficult than the first four and left them to the end. ACRush ended up being the only one to solve problem F correctly. Vitaliy and dzhulgakov were the only two contestants to solve problem E and finished in 7th and 5th place respectively.\n</p>\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Year of More Code Jam</i> Written by Xiaomin Chen. Prepared by Ante Derek and Xiaomin Chen.</p>\n<p>Problem B. <i>Min Perimeter</i> Written by Cosmin Negruseri. Prepared by Petr Mitrichev and Cosmin Negruseri.</p>\n<p>Problem C. <i>Doubly-sorted Grid</i> Written by Evgeny Cherepanov. Prepared by Xiaomin Chen.</p>\n<p>Problem D. <i>Wi-fi Towers</i> Written by Xiaomin Chen. Prepared by Xiaomin Chen, Tomek Czajka, and John Dethridge.</p>\n<p>Problem E. <i>Marbles</i> Written by Cosmin Negruseri. Prepared Frank Chu and Ante Derek.</p>\n<p>Problem F. <i>Lights</i> Written and prepared by Tomek Czajka.</p>\n<p>Contest analysis presented by Xiaomin Chen, Tomek Czajka, John Dethridge, Igor Naverniouk, and Cosmin Negruseri.</p>\n<p>Solutions and other problem preparation provided by Marius Andrei, Bartholomew Furrow, Derek Kisman, Fabio Moreira, and Igor Naverniouk.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1258131600000,"tasks":[{"analysis":"<p>There are various ways to solve this problem. The solutions can\nbe split into two kinds of approaches. One way is to solve the problem exactly\n(or, to arbitrary precision), the other is to approximate the answer with\nhigh enough precision. The exact solutions generally try to divide the square\ninto subareas of the same color, compute the area of each subarea separately,\nand add up the totals for each color. We discuss these first.</p>\n\n<h3>Intersection of (mostly) triangles</h3>\n\n<p>First, consider just one light. We want to compute the total area illuminated\nby the light. To do that, compute the tangent lines from the light to each\npillar, and lines from the light to each corner of the room, and consider each \"cone\" between two adjacent lines separately. Each cone will either end up hitting a wall, or hitting a pillar. In the first\ncase we get a triangle, whose area we can easily compute.\nIn the second case we get a \"quasi-triangle\", that is,\na triangle minus a disk segment. Here, we need to subtract the area of the disk\nsegment. We can compute the area of a disk segment by subtracting a triangle\nfrom the area of a disk sector (a \"pie slice\").</p>\n\n<p>Once we have the total area covered by each light, we need one more thing:\nthe area covered by both lights. We can take each pair of triangles or\nquasi-triangles generated in the previous step, and compute the common area\nbetween them. Now we need to compute the area of the\nintersection of two triangles or quasi-triangles.</p>\n\n<p>A simple way to approach this is to first treat quasi-triangles as triangles\n(include the disk segment). Now we compute the intersection between the two\ntriangles, which gives us a polygon (up to six sides). If one or both of the\ntriangles were actual triangles, or when the pillars subtracted from the two\nquasi-triangles were different, the polygon is the correct answer - there is\nno need to account for the subtracted disk segments, because each segment is\noutside the other triangle anyway.</p>\n\n<p>The only nasty case comes up when we have\ntwo quasi-triangles ending at the same pillar. In that case, we first compute\nthe intersection polygon, and then we subtract the pillar from the polygon.\nTo do that, remove those edges and parts of edges of the polygon that fall inside the circle and\nreplace them with one edge. The answer will be the area of the reduced polygon, again minus a disk sector cut off by a line, which we already know how to\ncompute.</p>\n\n<h3>Line sweeping</h3>\n\n<p>\nLine sweeping is a common technique in computational geometry. We sweep a vertical line from the left edge to the right. As in the solution above, the interesting rays are the tangent rays from lights to circles. The interesting moments are when the x-coordinate of the vertical line reaches one of the following. (1) A light. (2) A pillar starts or ends. (3) An interesting ray touches or intersects a circle, or hits the wall. (4) Two interesting rays intersect.\n</p>\n<p>\nNow, let x<sub>1</sub> &lt; x<sub>2</sub> be two adjacent interesting moments. The vertical strip between x<sub>1</sub> and x<sub>2</sub> is divided into pieces. Each piece is bounded above and below by a general segment -- a line segment or an arc. By the definition of the interesting moments, nothing interesting will happen in the middle, and each piece is of one color. So we can sample an arbitrary point from each piece to decide the color. The pieces are not convex, but this is not a problem -- they are convex on any vertical line so we can easily find a point that is inside each piece. The area of each piece is also easy to compute -- it is basically a trapezoid, possibly degenerating into a triangle if the upper and lower boundaries meet at one end, and one needs to subtract a disk segment for each arc-boundary.\n</p>\n<p>\nLine sweeping is often used with nice data structures to achieve good complexity. But that is not our primary concern here. We used it for the simplicity of the implementation -- the only geometric operations needed here are intersections between lines and circles.\n</p>\n\n<h3>Approximations</h3>\n\n<p>The problem requires a relative or absolute error of at most 10<sup>-5</sup>,\nwhile the total room area is 10000. Cases requiring the most care are those when\none of the four colors has an area less than 1, in which case the error we can\nmake relative to the area of the whole room is 10<sup>-9</sup>.</p>\n\n<p>The simplest approach would be to sample a lot of points either randomly, or\nin a regular grid, compute the color of each sample and assume that the sample\nis representative of the\ncorrect answer. The above error estimation suggests though that to get enough\nprecision, we would need to sample on the order of 10<sup>9</sup> points (or\nmore, due to random deviations). This is too much for a solution to run within\nthe time limit. A smarter approach is needed.</p>\n\n<p>Computing the area can be seen as a problem of computing a two-dimensional\nintegral. A hybrid approach is also possible: we can see it as a one-dimensional\nintegral along the <b>x</b> coordinate, and for each <b>x</b> coordinate we sample we can\ncompute the exact answer by looking at which segment of the vertical line\nis in what color. This one-dimensional sub-problem is somewhat simpler to do than solving the full\ntwo-dimenstional problem exactly.</p>\n\n<p>In either case, whether we compute a two-dimensional integral or just a\none-dimensional one for a more complex function, we need a smart way to\napproximate the integral. Uniform or random sampling is not enough.</p>\n\n<p>You can search the web for methods of\n<a href=\"http://www.google.com/search?q=numerical+integration\" target=\"_blank\">numerical integration</a>.\nIn this problem, an adaptive algorithm is needed, which means that we sample\nmore \"interesting\" areas with more samples than the less \"interesting\" ones.\n\"Interesting\" can be defined as \"large changes in values\" (large first\nderivative) or \"wild changes in values\" (large second derivative).</p>\n\n<p>One simple algorithm is to write the integration procedure as a recursive\nfunction. We recursively try splitting the interval into smaller ones, and see\nhow much the answer changes through such increases of precision. We stop the\nrecursion when the answer changes very little, which means the interval is small\nenough or the function is smooth enough in the interval. This will result in\nsampling the more \"interesting\" areas more accurately.</p>\n","id":"0000000000432911","statement":"<h3>Problem</h3>\n<p>\nIn a big, square room there are two point light sources: one is red and\nthe other is green. There are also <b>n</b> circular pillars.\n</p>\n\n<p>Light travels in straight lines and is absorbed by walls and pillars. The pillars therefore cast shadows: they do not let light through. There are places in the room where no light reaches (black), where only\none of the two light sources reaches (red or green), and places where\nboth lights reach (yellow). Compute the total area of each of the four\ncolors in the room. Do not include the area of the pillars.\n\n<h3>Input</h3>\n\n<p>\n<ul>\n  <li> One line containing the number of test cases, <b>T</b>.</li>\n</ul>\nEach test case contains, in order:\n<ul>\n  <li>One line containing the coordinates <b>x</b>, <b>y</b>\n  of the red light source.</li>\n  <li>One line containing the coordinates <b>x</b>, <b>y</b>\n  of the green light source.</li>\n  <li>One line containing the number of pillars <b>n</b>.</li>\n  <li><b>n</b> lines describing the pillars. Each contains 3 numbers\n<b>x</b>, <b>y</b>, <b>r</b>. The pillar is a disk with the center\n(<b>x</b>, <b>y</b>) and radius <b>r</b>.</li>\n</ul>\nThe room is the square described by 0 &le; <b>x</b>, <b>y</b> &le; 100.\nPillars, room walls and light sources are all disjoint, they do not overlap or touch.\n</p>\n\n<h3>Output</h3>\n\n<p>\nFor each test case, output:\n<pre>Case #X:\nblack area\nred area\ngreen area\nyellow area</pre>\nwhere <b>X</b> is the test case number, starting from 1,\nand each area is a real number.</p>\n<p>\nAny answer with absolute or relative error of at most 10<sup>-5</sup>\nwill be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>All input numbers are integers.</p>\n<p>\n1 &le; <b>T</b> &le; 15<br/>\n0 &le; <b>x</b>, <b>y</b> &le; 100<br/>\n1 &le; <b>r</b> &le; 49</b><br/>\n</p>\n\n<h3>Small dataset</h3>\n<p>\nTime limit: 20 seconds.<br/>\n0 &le; <b>n</b> &le; 1<br>\n</p>\n<h3>Large dataset</h3>\n<p>\nTime limit: 90 seconds.<br/>\n0 &le; <b>n</b> &le; 50<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1kAq1Wpf4cjzL82st0LtllhJGW3NhbUvsIX0km8yPb1KSuWV3jz68W321J_tZ6-iB9loSS0HSCY9YQZORNZ8wUdhgRnlo/lights_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">1\n5 50\n95 50\n1\n50 50 10\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0KWlzOwUhfTsNsJhOpe5e-fRMQmL_jgLZ6-iplYKlXonlTk_BjOgA-IlGqrSCtS25LpnUmupMh8T37RQcufFKBdypuvjGl/lights_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1:\n0.7656121\n1437.986\n1437.986\n6809.104\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":21},{"type":2,"type__str":"HIDDEN","value":45}],"title":"Lights","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nLast year we were trying to solve different instances of this problem. It took a long time to converge to this particular shape, and even after we settled on the current requirements, we were still tweaking the input limits at 2am the night before the contest to make the problem a bit more interesting. The problem nicely combines together dynamic programming, greedy and graph related notions like biconnected components and trees.\n</p>\n<p>\nThe first step is deciding if a particular configuration is or isn't solvable. If for two colors their corresponding marbles alternate it means that the two pairs of marbles need to be joined by curves on opposite sides of the horizontal line <i>Y=0</i>. We can build a graph where the nodes represent pairs of same-color marbles and form a graph with edges between pairs of marbles that alternate. We can draw the paths with no intersection if and only if this graph is bipartite.\n</p>\n<p>\nNext, for solvable configurations we compute the minimum height. The pairs graph can have many connected components, and for each such component we can choose two ways of drawing the lines (with the first pair of marbles above the <i>Y=0</i> line or below it), so in total we would have <i>O(2<sup>components</sup>)</i> configurations. This idea can solve the small case but is too time consuming for the large case.\n</p>\n<p>\nSolving the large case requires us to use dynamic programming. Our state will be defined by <i>left, right, height_up</i> and <i>height_down</i>. For each state we compute a boolean value which tells us if the subproblem which uses the set of marbles with indexes from <i>left</i> to <i>right</i> can be solved in the vertical range <i>[-height_down .. height_up]</i>. Computing this value is a bit tricky, what we need to notice is that we can try each of the two ways of drawing the component that starts at index <i>left</i>. Then an important observation is that  we can draw each path with the maximum height possible if the line is above the X axis or maximum depth possible if the line is below the X axis as long as our drawing is within the <i>[-height_down .. height_up]</i> vertical range. Using these ideas we can come up with an <i>O(n<sup>5</sup>)</i> algorithm.\n</p>\n<p>\nWe can improve on this solution by using the state <i>(left, right, height_up)</i> and for each state finding the smallest height_down for which the subproblem <i>[left .. right]</i> is solvable. Now we notice that we should use dynamic programming on pairs of <i>left</i> and <i>right</i> where connected components of marbles start and finish.  This will make <i>right</i> uniquely defined by <i>left</i>. Thus we have reduced the state space to <i>O(n<sup>2</sup>)</i> states. We also notice that the connected components form a tree-like structure where we need to solve the innermost components first and then solve outer components, much like visiting the leaves of a tree first and getting closer and closer to the root. Now each connected component will be analyzed just once at an upper component level so the overall algorithm will take <i>O(n<sup>2</sup>)</i> time. \n</p>\nHere's Tomek Czajka's solution:\n<pre>\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;cstdio&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\nusing namespace std;\n#define REP(i,n) for(int i=0;i&lt;(n);++i)\ntemplate&lt;class T&gt; inline int size(const T&amp;c) { return c.size();}\nconst int INF = 1000000000;\n\nint n; // number of types of marbles\nvector&lt;vector&lt;int&gt; &gt; where; // [n][2]\nvector&lt;int&gt; marbles; // [2*n]\n\nvoid readInput() {\n  char buf[30];\n  map&lt;string,int&gt; dict;\n  scanf(\"%d\", &amp;n);\n  marbles.clear(); marbles.reserve(2*n);\n  where.clear(); where.resize(n);\n  for(int i=0;i&lt;2*n;++i) {\n    scanf(\"%s\",buf);\n    string s = buf;\n    map&lt;string,int&gt;::iterator it = dict.find(s);\n    int m;\n    if(it==dict.end()) {\n      m = size(dict);\n      dict[s] = m;\n    } else {\n      m = it-&gt;second;\n    }\n    marbles.push_back(m);\n    where[m].push_back(i);\n  }\n}\n\nstruct Event {\n  int x,t;\n  // t=0 start top, 1 end top\n  // t=2 start bot, 3 end bot\n};\n\nvector&lt;int&gt; vis;\n\nbool cross(int m1,int m2) {\n  return\n      where[m1][0] &lt; where[m2][0] &amp;&amp;\n      where[m2][0] &lt; where[m1][1] &amp;&amp;\n      where[m1][1] &lt; where[m2][1] ||\n      where[m2][0] &lt; where[m1][0] &amp;&amp;\n      where[m1][0] &lt; where[m2][1] &amp;&amp;\n      where[m2][1] &lt; where[m1][1];\n}\n\nvoid dfs(int m,int sign) {\n  if(vis[m]==sign) return;\n  if(vis[m]==-sign) throw 0;\n  vis[m]=sign;\n  REP(i,n) if(i!=m &amp;&amp; cross(m,i)) dfs(i,-sign);\n}\n\nvector&lt;vector&lt;Event&gt; &gt; cacheCalcEvents;\n\nconst vector&lt;Event&gt; &amp;calcEvents(int startx) {\n  vector&lt;Event&gt; &amp;res = cacheCalcEvents[startx];\n  if(!res.empty()) return res;\n  vis.assign(n,0);\n  dfs(marbles[startx],1);\n  REP(x,2*n) {\n    int m = marbles[x];\n    if(vis[m]==0) continue;\n    int nr=0;\n    if(where[m][nr] != x) ++nr;\n    assert(where[m][nr]==x);\n    Event e; e.x=x;\n    e.t = (1-vis[m]) + nr;\n    res.push_back(e);\n  }\n  return res;\n}\n\nvector&lt;vector&lt;int&gt; &gt; cacheCalcH2;\n\nint calcH2(int a,int b,int h1) {\n  if(h1&lt;0) return INF;\n  if(a==b) return 0;\n  int &amp;res = cacheCalcH2[a][h1];\n  if(res!=-1) return res;\n  const vector&lt;Event&gt; &amp;events = calcEvents(a);\n  res = INF;\n  for(int mask = 0; mask&lt;=2; mask+=2) {\n    int top=0, bot=0;\n    int h2 = 0;\n    REP(i,size(events)+1) {\n      int alpha = i==0 ? a : events[i-1].x + 1;\n      int beta = i==size(events) ? b : events[i].x;\n      h2 = max(h2, calcH2(alpha, beta, h1 - top) + bot);\n      if(i!=size(events)) {\n        switch(events[i].t ^ mask) {\n          case 0: ++top; break;\n          case 1: --top; break;\n          case 2: ++bot; break;\n          case 3: --bot; break;\n        }\n      }\n    }\n    res = min(res, h2);\n  }\n  return res;\n}\n\nint solve() {\n  int res = INF;\n  cacheCalcH2.assign(2*n, vector&lt;int&gt;(n+1,-1));\n  cacheCalcEvents.clear(); cacheCalcEvents.resize(2*n);\n  try {\n    REP(h1,n+1) {\n      res = min(res, h1 + calcH2(0,2*n,h1));\n    }\n    return res;\n  } catch(int) { return INF; }\n}\n\nint main() {\n  int ntc; scanf(\"%d\", &amp;ntc);\n  REP(tc,ntc) {\n    readInput();\n    int res = solve();\n    if(res==INF) res = -1;\n    printf(\"Case #%d: %d\\n\", tc+1, res);\n  }\n}\n</pre>\n","id":"0000000000432b7d","statement":"<h3>Problem</h3>\n\n\n<p>You have 2<b>n</b> marbles on a square grid.  The marbles are colored in <b>n</b> different colors such that there are exactly 2 marbles of each color.  The marbles are placed at the coordinates (1,0), (2,0), ..., (2<b>n</b>, 0).</p>\n\n<p>Your task is to draw a path for each color that joins the two marbles of that color. Each path should be composed of vertical or horizontal line segments between grid points.  No two paths can intersect or touch each other.  No path may cross the y=0 line.  Each path can only touch the y=0 line at the position of the two marbles it is connecting, so the first and last line segment of each path must be vertical.</p>\n\n<p>Given an arrangement of marbles, return the minimum height of a solution, or return -1 if no solution exists. The height is defined as the difference between the highest and lowest Y-coordinates of the paths used.</p>\n\n<p>An example:\n<pre>\nred red blue yellow blue yellow\n</pre>\nOne solution would be:\n<pre>\n +---+    +-----------+\n |   |    |           |\nred red blue yellow blue yellow\n                 |           |\n                 +-----------+\n</pre>\nThe minimum height is 2 in this case.</p>\n\n<h3>Input</h3>\n<p>The first line of input gives the number of cases, <b>T</b>.\n<b>T</b> test cases follow. The first line of each case contains <b>n</b>, the number of different colors for the marbles. The next line contains a string of 2<b>n</b> words separated by spaces which correspond to the colors of the marbles, in order from left to right. Each color is a string of lower case letters ('a' .. 'z') no longer than 10 characters. There will be exactly <b>n</b> different colors and each color will appear exactly twice.</p>\n\n<h3>Output</h3>\n<p>For each test case, output one line containing \"Case #<b>x</b>: \", where <b>x</b> is the case number (starting from 1), followed by the height of any optimal solution, or -1 if no solution exists. </p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &lt;= <b>T</b> &lt;= 50.\n</p>\n<h3>Small dataset</h3>\n<p>\nTime limit: 30 seconds.<br/>\n1 &lt;= <b>n</b> &lt;= 20.<br>\n\n</p>\n<h3>Large dataset</h3>\n<p>\nTime limit: 60 seconds.<br/>\n1 &lt;= <b>n</b> &lt;= 500.<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3\nred red blue yellow blue yellow\n3\nred blue yellow red blue yellow\n3\nred blue yellow blue yellow red\n3\nred red blue blue yellow yellow\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: -1\nCase #3: 3\nCase #4: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":32}],"title":"Marbles","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nA counting problem, with a board size not too big. The problem gives a quick impression of dynamic programming on a space of exponentially many states. And it is indeed so.\n</p>\n<p>\nBy the limits of this problem, let us say the size is the larger of m and n. A solution with 2<sup>2&sdot;size</sup> states is fine, while a solution with 2<sup>4&sdot;size</sup> states is probably only good for the small dataset. However, for regular programming contest goers, there are many conventional ways to define the states for similar grid problems that fall into the latter category.\n</p>\n<p>\nSo, the key part of the problem is to find the right state space. Once it is found, the finalists can no doubt carry out the dynamic programming solution easily.\n</p>\n<p>\nThe basic picture is the lattice paths. Specifically, let us consider, in a doubly sorted grid, all the letters less than or equal to a particular character. They form an upwards closed region towards the top-left corner. In other words, if the letter in (r, c) is no greater than the prescribed character, so is the letter in (r', c'), if r' &le; r and c' &le; c. As a result, the boundary separating this region and the rest of the grid forms a lattice path from the bottom-left to the top-right, and can only go north or east. This is a well known subject -- there are (m+n choose m) such paths in total. Let us call them <i>monotone paths</i>. For two monotone paths, we say one dominates the other if one never goes above the other. Any doubly sorted grid corresponds in a one to one fashion to 26 monotone paths (some of which may be identical), one for each letter, and the path for a bigger letter dominates the paths for the smaller letters. The left picture below depicts the situation when there are three letters; and the monotone boundaries for 'a' and 'b' are highlighted.\n</p>\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2UrORWTWIY0Z45T7wxLElfFL_TZJuqP6lg7_sYp-LOpivowRvNsHvt1ofsztSMOtbCvP65NIZpmg/sortedgrid.png\">\n</p>\n<p>\nJust one step further. Let us focus not only the exact boundary for a letter but any monotone path. For any monotone path <i>P</i> and any letter <i>c</i>, define\n<blockquote>\ndp[P][c] := the number of  ways one can fill all the squares above the path <i>P</i>, using only the letters no greater than <i>c</i>, so that the upper part is doubly sorted, and any pre-filled letter in the upper part is respected.\n</blockquote>\n</p>\n<p>\nFor any monotone path except the most dominated one, we have one or more <i>maximal</i> points, those are the points where the path goes east then followed by a step upwards. In the second picture above, we highlight a monotone path with its maximal points colored. To compute dp[P][c], we can divide the situation into two cases. (1) The letter <i>c</i> does not appear at all. There are dp[P][c-1] ways to do so. (2) Otherwise, <i>c</i> must appear in at least one of the maximal points of <i>P</i>. For each non-empty subset of the maximal points, we can assign the letter c to them, reducing our task to dp[P'][c], where <i>P'</i> is a path that only differs from P in that subset of maximal points. We use inclusion-exclusion formula on all the non-empty subsets to compute the contribution to dp[P][c] in this case. \n</p>\n<p>\nSuch a solution is relatively intuitive, and is fast enough under our constraints. By adding one more helper, one can find a faster solution. Now let us refine\n<blockquote>\ndp[P][c][k] := the number of  ways one can fill all the squares above the path <i>P</i>, using only the letters no greater than <i>c</i>, <i>and the letter c does not occur anywhere after column k</i>,so that the upper part is doubly sorted, and any pre-filled letter in the upper part is respected.\n</blockquote>\nWe leave the implementation details as an easy exercise for interested readers. We mention that, when m=n, the number of states is 26&sdot;(2n choose n)&sdot;n = &Theta;(4<sup>n</sup>n<sup>0.5</sup>). Although the computation of a single dp[P][c][k] may involve up to <i>n</i> steps, the running time can be shown as &Theta;(4<sup>n</sup>n<sup>0.5</sup>) by a simple amortized analysis -- for fixed <i>P</i> and <i>c</i>, we need O(n) steps in total to compute the table for all <i>k</i>. \n</p>\n","id":"0000000000432df6","statement":"<h3>Problem</h3>\n\n<p>A rectangular grid with lower case English letters in each cell is called <i>doubly sorted</i> if in each row the letters are non-decreasing from the left to the right, and in each column the letters are non-decreasing from the top to the bottom. In the following examples, the first two grids are doubly sorted, while the other two are not:\n<pre>\nabc    ace    aceg    base\ndef    ade    cdef    base\nghi    bdg    xxyy    base\n</pre>\n</p>\n<p>You are given a partially-filled grid, where some of the cells are filled with letters. Your task is to compute the number of ways you can fill the rest of the cells so that the resulting grid is doubly sorted. The answer might be a big number; you need to output the number of ways modulo 10007.</p>\n\n<h3>Input</h3>\n\n<p>The first line of input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow. Each test case starts with a line containing two integers <b>R</b> and <b>C</b>, the number of rows and the number of columns respectively. This is followed by <b>R</b> lines, each containing a string of length <b>C</b>, giving the partially-filled grid. Each character in the grid is either a lower-case English letter, or '.', indicating that the cell is not filled yet.\n</p>\n\n<h3>Output</h3>\n\n<p>For each test case, output one line. That line should contain \"Case #X: y\", where <b>X</b> is the case number starting with 1, and <b>y</b> is the number of possible doubly-sorted grids, modulo 10007.</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 40<br/>\nEach character in the partially-filled grid is either '.' or a lower-case English letter.\n</p>\n\n<h3>Small dataset</h3>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>R</b>, <b>C</b> &le; 4<br/>\n</p>\n\n<h3>Large dataset</h3>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>R</b>, <b>C</b> &le; 10<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 2\nad\nc.\n3 3\n.a.\na.z\n.z.\n4 4\n....\n.g..\n.cj.\n....\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 23\nCase #2: 7569\nCase #3: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Doubly-sorted Grid","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Connection graph</h3>\n\n<p>We start by representing the problem as a graph problem. Each tower is a\nvertex in the graph and has a weight equal to its score. If a tower A has another tower B in its\nrange, we represent this fact as a directed edge from A to B. The problem is to\nchoose a set of vertices with maximum weight such that for every edge from A to\nB, if A is chosen then B is also chosen. In the following, we assume the number\nof towers (vertices) is <b>V</b> and the number of edges is <b>E</b>.\n\n<h3>Reduce to an instance of MIN-CUT</h3>\n\n<p>\nTo reduce the problem to an instance of MIN-CUT, we create a flow\nnetwork as follows. Create a source vertex, a sink vertex, and one vertex for\neach tower. Suppose a tower has score <b>s</b>. If <b>s</b> &gt; 0,\ncreate an edge from the vertex to the sink with capacity <b>s</b>. If\n<b>s</b> &lt; 0, create an edge from the source to this vertex with capacity\n|<b>s</b>|. Finally, for every edge in the connection graph, create a similar\nedge in the flow network with infinite capacity. The network has <b>V</b> + 2 =\nO(<b>V</b>) vertices and O(<b>V</b> + <b>E</b>) edges.\n</p>\n<p>\nNow every finite cut in the graph represents a choice of towers - we choose every tower\non the same side of the cut as the source. The infinite capacity edges enforce\nthat the choice follows the given constraints (otherwise we get a cut of\ninfinite weight). The edges from the source and to the sink penalize the\nsolution appropriately for choosing towers with negative scores and for not\nchoosing towers with positive scores. If the value of the best cut is <b>C</b>,\nthe answer is <b>S</b> - <b>C</b>, where <b>S</b> is the sum of positive\ntower scores.\n</p>\n\n<h3>Solving MIN-CUT</h3>\n<p>\nBy the max-flow min-cut theorem, we can solve the MIN-CUT instance generated above by computing the maximum flow in the same graph. To compute the maximum\nflow, we can use the Edmonds-Karp algorithm (a variant of\nFord-Fulkerson which selects augmenting paths using BFS),\nwhich results in complexity bounded by\nO(<b>V</b>(<b>V</b>+<b>E</b>)<sup>2</sup>) = O(<b>V</b><sup>5</sup>).\nIn practice, this was fast enough to solve all possible test cases.\n</p>\n<p>One could also use a more complicated push-relabel max-flow algorithm\nwhich, with a FIFO\nvertex selection rule, results in complexity O(<b>V</b><sup>3</sup>).\n</p>\n<p>Yet another algorithm, thanks to integral capacities, is the capacity\nscaling variant of Ford-Fulkerson (start by searching for augmenting paths\nwith weights being large powers of 2 first, and then decrease). This results\nin O((<b>V</b>+<b>E</b>)<sup>2</sup> log <b>F</b>) = O(<b>V</b><sup>4</sup> log\n<b>F</b>)\nwhere <b>F</b> is the maximum value of the flow.\n</p>\n\n<h3>Reducing the number of edges</h3>\n\n<p>Finally, there is a geometric trick using which we can reduce the number of\nedges <b>E</b> to O(<b>V</b>), thus reducing the complexity of the algorithms\nabove. The complexity of Edmonds-Karp becomes O(<b>V</b><sup>3</sup>) and of\ncapacity scaling: O(<b>V</b><sup>2</sup> log <b>F</b>).</p>\n\n<p>First, notice that we can remove edges without changing the final answer as\nlong as the transitive closure of the graph stays the same.</p>\n\n<p>The crucial trick is to see that if there are two directed edges A-C and B-C,\nand the angle ACB is smaller than 60 degrees, then we can remove the longer\nedge. Suppose A-C is longer than B-C. Then if we remove the edge A-C, there is\nstill going to be an indirect connection A-B-C (using shorter or equal length\nedges), thanks to the fact that the range of A is a circle.</p>\n\n<p>If we keep doing this, every vertex will end up with at most 6 incoming\nedges, thus reducing the total number of edges to at most 6<b>V</b>.</p>\n<br/><br/>\n\n<h3>More information</h3>\n<p>\nThis problem is also equivalent to the <a href=\"http://en.wikipedia.org/wiki/Closure_problem\" target=\"_blank\">Minimum Closure Problem</a>, which was studied in the 1970s and has applications in the mining industry.\n<p>\n<a href=\"http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem\" target=\"_blank\">Max Flow Min Cut Theorem</a>\n","id":"0000000000432fe0","statement":"<h3>Problem</h3>\n<p>\nYou are given a network of wireless towers.\nEach tower has a range and can send data to neighboring towers\nas long as the distance is less than or equal to the sending tower's range.\n</p>\n\n<p>\nThe towers are using an old communication protocol A,\nbut there is a new, better protocol B available. We are thinking about\nupgrading some towers to send data using protocol B to achieve better bandwidth.\n</p>\n\n<p>\nThere is one important restriction: if a tower T is using the new protocol B,\nevery tower within T's range must also be running protocol B, so that they can understand the data sent from T. The reverse is not necessary &mdash; towers\nrunning the new protocol B can be sent data from towers using the old protocol A.\n</p>\n\n<p>Your task is to select the best set of towers to upgrade from protocol A to protocol B.  There is some benefit to upgrading a tower, but there are also installation costs. So each tower will have a score, which can be positive or negative, which is the value of upgrading the tower.  Choose the set of towers to upgrade in such a way that the total score of the upgraded towers is maximized.\n</p>\n\n<h3>Input</h3>\n\nThe first line contains the number of test cases, <b>T</b>.\nEach test case starts with the number of towers, <b>n</b>. The following\n<b>n</b> lines each contain 4 integers:\n<b>x</b>, <b>y</b>, <b>r</b>, <b>s</b>.  They describe a tower at coordinates\n<b>x</b>, <b>y</b> having a range of <b>r</b> and a score (value of\nupdating to the new protocol) of <b>s</b>\n\n<h3>Output</h3>\n\nFor each test case, output:\n<pre>Case #X: score</pre>\nwhere <b>X</b> is the test case number, starting from 1, and <b>score</b> is the\ntotal score for the best choice of towers.\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 55<br/>\n-10 000 &le; <b>x</b>, <b>y</b> &le; 10 000<br/>\n1 &le; <b>r</b> &le; 20 000<br/>\n-1000 &le; <b>s</b> &le; 1000<br/>\n<br>\nNo two towers will have the same coordinates.\n</p>\n\n<h3>Small dataset</h3>\n<p>\n1 &le; <b>n</b> &le; 15\n</p>\n<h3>Large dataset</h3>\n<p>\n1 &le; <b>n</b> &le; 500\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n5\n0 1 7 10\n0 -1 7 10\n5 0 1 -15\n10 0 6 10\n15 1 2 -20\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":3},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Wi-fi Towers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe setting of this problem is no doubt discrete probability. From the definition, the space consists of <i>N</i><sup>T</sup> equally likely possible outcomes. That can be, under our limits, as huge as 10<sup>450</sup>. Clearly, a naive approach is not feasible.\n</p>\n<p>\nBut let us do a little exercise in probability. Define the random variable <i>X</i><sub>i</sub> to be the number of contests on the i-th day, the quantity we want to compute is the average of <i>X</i><sub>i</sub><sup>2</sup>, i.e., the expectation &Epsilon;(&sum; <i>X</i><sub>i</sub><sup>2</sup>). By the linearity of the expectation, we have\n<blockquote>\n&Epsilon;(&sum;<sub>1&le;i&le;N</sub> <i>X</i><sub>i</sub><sup>2</sup>) = &sum;<sub>1&le;i&le;N</sub> &Epsilon;(<i>X</i><sub>i</sub><sup>2</sup>).\n</blockquote>\nSo let us focus on the computation of the variable for a fixed day for the moment. Pick any i, and let <i>X</i> := <i>X</i><sub>i</sub>. Let us define more random variables. Define Y<sub>j</sub> to be the <i>indicator</i> of whether the j-th tournament will have a contest on the i-th day. Clearly, <i>X</i> = &sum;<sub>j</sub> Y<sub>j</sub>. So,\n<blockquote>\n(*) &nbsp;&nbsp;&nbsp; &Epsilon;(<i>X</i><sup>2</sup>) = &Epsilon;((&sum;<sub>1&le;j&le;T</sub> Y<sub>j</sub>)<sup>2</sup>) = &sum;<sub>1&le;j&le;T</sub> &Epsilon;(Y<sub>j</sub><sup>2</sup>) + 2 &sum;<sub>1&le;j&lt;k&le;T</sub> &Epsilon;(Y<sub>j</sub>Y<sub>k</sub>).\n</blockquote>\nWe observe that each terms in the last expression is easy to compute. Being the indicator random variables, the <i>Y</i>'s take value 0 or 1. So \n<ul>\n<li>Y<sub>j</sub><sup>2</sup> always has the same value as Y<sub>j</sub>, and its expectation is just the probability that Y<sub>j</sub> is 1, i.e., tournament j has a contest on day i.</li>\n<li>Y<sub>j</sub>Y<sub>k</sub> is 1 if and only if both Y<sub>j</sub> and Y<sub>k</sub> are 1. The expectation is the probability that both the j-th and the k-th tournament has a contest on day i.</li></ul>\nLet the input for the tournament j, i.e., the contest pattern be d<sub>1</sub>=1, \nd<sub>2</sub>, ..., d<sub>m</sub>. Denote D(i,j) be the number of the d's for tournament j that are less than or equal to i. There are <i>N</i> choices for the starting date of a particular tournament. It is easy to see that the first probability above is D(i,j) / N; while the second probability is D(i,j)D(i,k) / N<sup>2</sup>.\n</p>\n<p>\nSo far we addressed the problem just for a single day i. We need to do this for every i. There are 10<sup>9</sup> of them. But notice that, as long as there is no input d<sub>t</sub> = i, D(i-1, j) = D(i, j) for all j. This means that the expectation for the i-th day is the same as the expectation for the (i-1)-th. There are at most <i>T</i> max(<i>M</i>) &le; 2500 such d's in the input, so we need to compute (*) for at most 2500 days. For our problem, it is good enough to realize that there is no d &gt; 10000. So all the expectations after the 10000-th day are the same. We can just do the computation for the first 10000 days, and for the rest, a simple multiplication.\n</p>\n<p>\nThe last problem is the need for big integers. At the first glance we might have both numerators and denominators as big as 10<sup>450</sup>. But that is not the truth. Simply observe the above answer, which is a sum of various D(i,j) / N and \nD(i,j)D(i,k) / N<sup>2</sup>. We actually proved that the denominator is never bigger than <i>N</i><sup>2</sup>. A careful implementation with 64-bit integers will be good enough.\n</p>\n<p>\nFor a further speed-up. The formula in (*) involves computing O(T<sup>2</sup>) terms. But if we do it from day 1, keep D(i,j) for each j and two more variables -- S<sub>1</sub> for the sum of all the D(i,j)'s, and S<sub>2</sub> for the sum of D(i,j)<sup>2</sup>'s, then we just need constant update time when we see an input d, and also constant computation time for each day we want to compute (*).\n</p>\n<br/><br/>\n","id":"0000000000433083","statement":"<h3>Problem</h3>\n<p>\nA new year brings a new calendar, new challenges, and a lot of new fun in life. Some things, however, never change. There are still many great programming contests to be held, and our heroine Sphinny's passion for them remains unchanged.\n</p>\n<p>\nThere are several tournaments Sphinny is interested in.  Each tournament will consist of a number of rounds.  The organizer of each tournament has not decided on what date the tournament will start, but has decided how many rounds there will be in the tournament and how many days after the start date each round will be.\n</p>\n<p>\nIn some situations, two or more rounds (from different tournaments) can be scheduled on the same day. As Sphinny is so keen on problem solving, she will be happier if more rounds are scheduled on the same day. Her happiness value is computed as follows: for each day on which there are <i>S</i> rounds, her happiness will be increased by <i>S</i><sup>2</sup>.  Her happiness starts at 0 (don't worry &mdash; 0 is a happy place to start).\n</p>\n<p>\nIn the picture below there are three tournaments, each represented by a different color, and Sphinny's total happiness is 20.  One tournament starts on the second day of the year, one starts on the fifth day of the year, and one starts on the sixth day of the year.\n<br/><br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0P32ubPpr1sM6gA9UkK-L_pX1aOXbyCQPbSO3jRZ-4cEBlO3033CIn8EWEjZ5se5u3VbkAZQ/2ndyocj.png\">\n<br/><br/><br/>\n</p>\n<p>\nThere are <b>N</b> days in the year. Each tournament will begin on any of the <b>N</b> days with equal probability. The big question for this year is what the expected value of Sphinny's happiness is.\n</p>\n<p>\nAs a perfectionist, she is not going to solve the problem approximately. Instead, she wants to know the result exactly. The number of tournaments is <b>T</b>, and there are <b>N</b><sup>T</sup> equally likely ways to select the start dates of the tournaments. She is going to express her expected happiness as <i>K</i>+<i>A</i>/<i>B</i>, where <i>K</i> and <i>B</i> are positive integers and <i>A</i> is a non-negative integer less than <i>B</i>. If <i>A</i> is zero then <i>B</i> must be one, otherwise <i>A</i> and <i>B</i> must not have a common factor greater than one.\n</p>\n<p>\nIf a tournament starts late enough in the year, some of its rounds might be scheduled during the next year.  Those rounds do not contribute to Sphinny's happiness this year.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input is a single integer <b>C</b>, the number of test cases. <b>C</b> tests follow. The first line of each test case is in the form\n<pre>\nN T\n</pre>\nwhere <b>N</b> is the number of days in the year, and <b>T</b> is the number of tournaments. <b>T</b> lines then follow, one for each tournament, in the format\n<pre>\nm d<sub>2</sub> d<sub>3</sub> ... d<sub>m</sub>\n</pre>\nindicating that there are <b>m</b> rounds, and the i-th round will be held on day <b>d</b><sub>i</sub> of the tournament. The first round of a tournament is held on day 1 (<b>d</b><sub>1</sub> = 1).\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test, output one line of the form\n<pre>Case #X: K+A/B</pre>\nwhere <i>X</i> is the case number, starting from 1, and <i>K</i>, <i>A</i> and <i>B</i> are as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>C</b> &le; 50<br/>\n1 &le; <b>N</b> &le; 10<sup>9</sup><br/>\n2 &le; <b>m</b> &le; 50<br/>\n1 &lt; <b>d</b><sub>2</sub> &lt; <b>d</b><sub>3</sub> &lt; ... &lt; <b>d</b><sub>m</sub> &le; 10000\n</p>\n\n<h3>Small dataset</h3>\n<p>\n1 &le; <b>T</b> &le; 2\n</p>\n\n<h3>Large dataset</h3>\n<p>\n1 &le; <b>T</b> &le; 50\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n1 1\n2 2\n4 2\n3 2 4\n2 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1+0/1\nCase #2: 5+1/8\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Year of More Code Jam","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>This problem is similar to the classical problem of finding the closest pair in a set of points.  Algorithms that solve the closest-pair problem can be adapted to solve this one.</p>\n\n<p>The number of points can be pretty large so we need an efficient algorithm. We can solve the problem in <i>O(n log n)</i> time using divide and conquer. We will split the set of points by a vertical line into two sets of equal size.  There are now three cases for the minimum-perimeter triangle: its three points can either be entirely in the left set, entirely in the right set, or it can use points from each half.<p>\nWe find the minimum perimeters for the left and right sets using recursion.  Let the smallest of those perimeters be <i>p</i>. We can use <i>p</i> to make finding the minimum perimeter of the third case efficient, by only considering triangles that could have an area less than <i>p</i>.\n</p>\n<p>To find the minimum perimeter for the third case (if it is less than <i>p</i>) we select the points that are within a distance of <i>p/2</i> from the vertical separation line.  Then we iterate through those points from top to bottom, and maintain a list of all the points in a box of size <i>p x p/2</i>, with the bottom edge of the box at the most recently considered point.  As we add each point to the box, we compute the perimeter of all triangles using that point and each pair of points in the box.  (We could exclude triangles entirely to the left or right of the dividing line, since those have already been considered.)\n</p>\n<p>We can prove that the number of points in the box is at most 16, so we only need to consider at most a small constant number of triangles for each point.\n</p>\n<p>Splitting the current set of points by a vertical line requires the points to be sorted by <i>x</i> and going through the points vertically requires having the points sorted by <i>y</i>. If we do the <i>y</i> sort at each step that gives us an <i>O(n log<sup>2</sup> n)</i> algorithm, but we can keep the set of points twice, one array would have the points sorted by <i>x</i> and one would have the points sorted by <i>y</i>, and this way we have an <i>O(n log n)</i> algorithm.\n</p>\n<p>The time limits were a bit tight and input limits were large because some <i>O(n<sup>2</sup>)</i> algorithms work really well on random cases. This is why during the contest some solutions that had the right idea but used a <i>p x p</i> box size or sorted by <i>y</i> at each step didn't manage to solve the large test cases fast enough.\n</p>\nYou can read Tomek Czajka's source to get the details of a good implementation:\n<pre>\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;vector&gt;\nusing namespace std;\n#define REP(i,n) for(int i=0;i&lt;(n);++i)\ntemplate&lt;class T&gt; inline int size(const T&amp;c) { return c.size();}\n\nconst int BILLION = 1000000000;\nconst double INF = 1e20;\ntypedef long long LL;\n\nstruct Point {\n  int x,y;\n  Point() {}\n  Point(int x,int y):x(x),y(y) {}\n};\n\ninline Point middle(const Point &amp;a, const Point &amp;b) {\n  return Point((a.x+b.x)/2, (a.y+b.y)/2);\n}\n\nstruct CmpX {\n  inline bool operator()(const Point &amp;a, const Point &amp;b) {\n    if(a.x != b.x) return a.x &lt; b.x;\n    return a.y &lt; b.y;\n  }\n} cmpx;\n\nstruct CmpY {\n  inline bool operator()(const Point &amp;a, const Point &amp;b) {\n    if(a.y != b.y) return a.y &lt; b.y;\n    return a.x &lt; b.x;\n  }\n} cmpy;\n\ninline LL sqr(int x) { return LL(x) * LL(x); }\n\ninline double dist(const Point &amp;a, const Point &amp;b) {\n  return sqrt(double(sqr(a.x-b.x) + sqr(a.y-b.y)));\n}\n\ninline double perimeter(const Point &amp;a,\n                        const Point &amp;b,\n                        const Point &amp;c) {\n  return dist(a,b) + dist(b,c) + dist(c,a);\n}\n\ndouble calc(int n, const Point points[],\n            const vector&lt;Point&gt; &amp;pointsByY) {\n  if(n&lt;3) return INF;\n  int left = n/2;\n  int right = n-left;\n  Point split = middle(points[left-1], points[left]);\n  vector&lt;Point&gt; pointsByYLeft, pointsByYRight;\n  pointsByYLeft.reserve(left);\n  pointsByYRight.reserve(right);\n  REP(i,n) {\n    if(cmpx(pointsByY[i], split))\n      pointsByYLeft.push_back(pointsByY[i]);\n    else\n      pointsByYRight.push_back(pointsByY[i]);\n  }\n  double res = INF;\n  res = min(res, calc(left, points, pointsByYLeft));\n  res = min(res, calc(right, points+left, pointsByYRight));\n  static vector&lt;Point&gt; closeToTheLine;\n  int margin = (res &gt; INF/2) ? 2*BILLION : int(res/2);\n  closeToTheLine.clear();\n  closeToTheLine.reserve(n);\n  int start = 0;\n  for(int i=0;i&lt;n;++i) {\n    Point p = pointsByY[i];\n    if(abs(p.x - split.x) &gt; margin) continue;\n    while(start &lt; size(closeToTheLine) &amp;&amp;\n          p.y - closeToTheLine[start].y &gt; margin) ++start;\n    for(int i=start;i&lt;size(closeToTheLine);++i) {\n      for(int j=i+1;j&lt;size(closeToTheLine);++j) {\n        res = min(res, perimeter(p, closeToTheLine[i],\n                                 closeToTheLine[j]));\n      }\n    }\n    closeToTheLine.push_back(p);\n  }\n  return res;\n}\n\ndouble calc(vector&lt;Point&gt; &amp;points) {\n  sort(points.begin(), points.end(), cmpx);\n  vector&lt;Point&gt; pointsByY = points;\n  sort(pointsByY.begin(), pointsByY.end(), cmpy);\n  return calc(size(points), &amp;points[0], pointsByY);\n}\n\nint main() {\n  assert(0==system(\"cat &gt; Input.java\"));\n  fprintf(stderr, \"Compiling generator\\n\");\n  assert(0==system(\"javac Input.java\"));\n  fprintf(stderr, \"Running generator\\n\");\n  assert(0==system(\"java -Xmx512M Input &gt; input.tmp\"));\n  fprintf(stderr, \"Solving\\n\");\n  FILE *f = fopen(\"input.tmp\", \"r\");\n  int ntc; fscanf(f, \"%d\", &amp;ntc);\n  REP(tc,ntc) {\n    int n; fscanf(f, \"%d\", &amp;n);\n    vector&lt;Point&gt; points;\n    points.reserve(n);\n    REP(i,n) {\n      int x,y; fscanf(f, \"%d%d\", &amp;x, &amp;y);\n      points.push_back(Point(2*x-BILLION,2*y-BILLION));\n    }\n    double res = calc(points);\n    printf(\"Case #%d: %.15e\\n\", tc+1, res/2);\n  }\n  fclose(f);\n}\n</pre>","id":"0000000000433195","statement":"<h3>Problem</h3>\n<p>\nYou will be given a set of points with integer coordinates. You are asked to compute the smallest perimeter of a triangle with distinct vertexes from this set of points.\n</p>\n\n<h3>Input</h3>\n<p>The first line of the input data gives you the number of cases, <b>T</b>. <b>T</b> test cases follow. Each test case contains on the first line the integer <b>n</b>, the number of points in the set. <b>n</b> lines follow, each line containing two integer numbers <b>x<sub>i</sub></b>, <b>y<sub>i</sub></b>. These are the coordinates of the i-th point. There may not be more than one point at the same coordinates.</p>\n\n<h3>Output</h3>\nFor each test case, output:\n<pre>Case #<b>X</b>: <b>Y</b></pre>\n\nwhere <b>X</b> is the number of the test case and Y is the minimum perimeter. Answers with a relative or absolute error of at most 10<sup>-5</sup> will be considered correct. Degenerate triangles&nbsp;&mdash;&nbsp;triangles with zero area&nbsp;&mdash;&nbsp;are ok.\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n</p>\n1 &lt;= <b>T</b> &lt;= 15<br/>\n0 &lt;= <b>x<sub>i</sub></b>, <b>y<sub>i</sub></b> &lt;= 10<sup>9</sup>\n\n<h3>Small dataset</h3>\nTime limit: 60 seconds.<br/>\n3 &lt;= <b>n</b> &lt;= 10000\n\n<h3>Large dataset</h3>\nTime limit: 120 seconds.<br/>\n3 &lt;= <b>n</b> &lt;= 1000000\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n10\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5.656854\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Min Perimeter","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432ad5","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2009"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
