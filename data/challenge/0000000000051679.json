{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1558197000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000051679","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  We periodically include chemistry-themed problems in Code Jam, and Round 2\n  had three! The two parts of <i>New Elements</i> could be solved independently,\n  but there were some commonalities, so solving one made it perhaps a bit\n  easier to solve the other. <i>Contransmutation</i> was a spiritual successor\n  to <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000007764/000000000003675c\">this problem from Round 1B 2018</a>,\n  and it was similarly challenging. We did take a break from the chemistry lab\n  to interactively hack a vase contest in <i>Pottery Lottery</i>.\n</p><p>\n  This was an uncharacteristically tight round, with the problems having a smaller spread\n  of difficulties than usual. This was reflected in the full score for each problem being in the\n  twenties. <b>mnbvmar</b> was the first to get a perfect score to claim first place, when there\n  was a little over an hour left. <b>ksun48</b> and <b>xyz111</b> followed to\n  claim second and third. Overall, only 26 contestants managed a perfect score.\n  Getting even a single point was tough in this round, given it\n  didn't feature any simple problems, and over 2400 contestants managed to score nonetheless.\n  Congratulations!\n</p><p>\n  Preliminary results indicate that 32 points and some speed are required to advance\n  to the next round.\n</p><p>\n  After the results have been finalized, the top 1000 contestants will win\n  well-deserved Code Jam 2019 T-shirts, and will advance to Round 3, where 25\n  tickets to the World Finals await! Are you going to San Francisco?\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  New Elements, Part 1: Written by Pablo Heiber. Prepared by Jonathan Irvin\n    Gunawan.\n</p><p>\n  Pottery Lottery: Written by Ian Tullis. Prepared by John Dethridge\n    and Pi-Hsun Shih.\n</p><p>\n  New Elements, Part 2: Written by Pablo Heiber. Prepared by Micah Stairs.\n</p><p>\n  Contransmutation: Written by Pablo Heiber. Prepared by Jonathan Irvin\n    Gunawan and Darcy Best.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Darcy Best,\n  Timothy Buzzelli, John Dethridge, Jonathan Irvin Gunawan, Md Mahbubul Hasan,\n  Ray Robinson, Micah Stairs, Ian Tullis, Pi-Hsun Shih, and Adilet Zhaxybay.\n</p>\n\n<p>\n  Analysis authors:\n</p>\n<ul>\n  <li>New Elements, Part 1: Pablo Heiber and Ian Tullis</li>\n  <li>Pottery Lottery: Ian Tullis and Tony Wong</li>\n  <li>New Elements, Part 2: Jonathan Irvin Gunawan</li>\n  <li>Contransmutation: Ray Robinson and Pablo Heiber</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1558188000000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  In the first test set, there can be at most six molecules, so we can easily\n  check all 6! = 720 possible orderings of them. The nontrivial part is\n  figuring out how to check an ordering. We cannot check all possible atomic\n  weights, since they can be arbitrary integers, and those integers might need\n  to be quite large (since the <b>C<sub>i</sub></b> and <b>J<sub>i</sub></b>\n  values can be as large as 10<sup>9</sup>).\n</p><p>\n  For each ordering of molecules, we must determine whether there is at least\n  one valid pair of atomic weights w<sub>C</sub> and w<sub>J</sub> for Codium\n  and Jamarium, respectively, such that the molecules are in strictly\n  increasing order of molecular weight. We do not need to find particular\n  values; we only need to show existence or non-existence.\n</p><p>\n  Let k = w<sub>J</sub> / w<sub>C</sub>. Then, if w<sub>C</sub> and\n  w<sub>J</sub> are valid for our ordering, we can substitute\n  w<sub>J</sub> = k &times; w<sub>C</sub> in the requirement\n  for any pair of molecules (<b>C<sub>a</sub></b>, <b>J<sub>a</sub></b>),\n  (<b>C<sub>b</sub></b>, <b>J<sub>b</sub></b>) such that a &lt; b:\n</p><p>\n  <b>C<sub>a</sub></b> &times; w<sub>C</sub> + <b>J<sub>a</sub></b> &times; kw<sub>C</sub>\n  &lt;\n  <b>C<sub>b</sub></b> &times; w<sub>C</sub> + <b>J<sub>b</sub></b> &times; kw<sub>C</sub>\n</p><p>\n  If <b>J<sub>a</sub></b> = <b>J<sub>b</sub></b>, then this reduces to\n  <b>C<sub>a</sub></b> &lt; <b>C<sub>b</sub></b>, which is a simple check; if it is false,\n  then no set of atomic weights is valid, and we can stop checking this\n  ordering. Otherwise, rearranging some terms and dividing, our expression\n  becomes:\n</p><p>\n  (<b>C<sub>a</sub></b> - <b>C<sub>b</sub></b>) / (<b>J<sub>b</sub></b> - <b>J<sub>a</sub></b>) &lt; k,\n  if <b>J<sub>a</sub></b> &lt; <b>J<sub>b</sub></b>, or<br/>\n  k &lt; (<b>C<sub>a</sub></b> - <b>C<sub>b</sub></b>) / (<b>J<sub>b</sub></b> - <b>J<sub>a</sub></b>),\n  if <b>J<sub>a</sub></b> &gt; <b>J<sub>b</sub></b>.\n</p><p>\n  So, we can start by assuming that k can take on any value in an infinite\n  range. Then, whenever we check a pair of molecules, we get a new\n  (non-inclusive) upper or lower bound on the value of k, and we can update one\n  end of the range accordingly. If we find that constraints force the range to\n  be empty (e.g., because the upper end is forced to be smaller than the lower\n  end), then no valid set of atomic weights exists. Otherwise, at least one\n  does. Notice that even though the atomic weights of Codium and Jamarium must\n  both be integers, any rational value of k corresponds to some pair of\n  integers.\n</p><p>\n  This is a quick set of checks, and it is even quicker if we realize that we\n  only need to check consecutive pairs of molecules. However, as in any problem\n  involving comparisons of fractional quantities, we must be careful to compute\n  exact values instead of using floating-point approximations.\n</p>\n<h3>Test set 2</h3>\n<p>\nConsidering the solution of Test set 1 in reverse can lead us to a solution for\nTest set 2. If we consider two arbitrary molecules with indices a and b, they can\nappear in two possible orderings. If one of them is impossible according to the\nmath above, it means that the other is the ordering of the molecules for every possible\nassignment of atomic weights. If that's the case, we can ignore the pair of\nmolecules (a, b). However, if both orderings are possible, we obtain\na range of valid values for the ratio k of the form\n(0, R<sub>a,b</sub>) for one ordering and a range of the form\n(R<sub>a,b</sub>, +&infin;) for the other, where\nR<sub>a,b</sub> = |(<b>C<sub>a</sub></b> - <b>C<sub>b</sub></b>) / (<b>J<sub>a</sub></b> - <b>J<sub>b</sub></b>)|.\nThat means, for all orderings\nthat correspond to atomic weights that yield a ratio strictly less than\nR<sub>a,b</sub>, the molecules a and b appear in a specific relative\norder, and for all orderings that correspond to values yielding a ratio strictly\ngreater than R<sub>a,b</sub>, the molecules a and b appear in the other\nrelative order. If the ratio is exactly R<sub>a,b</sub>, the two molecules\nweigh exactly the same, so no ordering is valid.\n</p><p>\nBy the previous paragraph, if we consider a function f from ratios into\norderings, f is a piecewise constant function that is undefined at ratios\nR<sub>a,b</sub> for any pair a, b and is constant in any interval that\ndoesn't contain any such ratio. Moreover, the image of f over\n(0, R<sub>a,b</sub>) consists of orderings with molecules a and b in one\nrelative order and the image of f over (R<sub>a,b</sub>, +&infin;) consists\nof orderings with molecules a and b in the other relative order. Therefore,\nno two elements in f's image are the same. The number of elements in f's\nimage, which is the answer to the problem, is the number of different non-zero\nR<sub>a,b</sub> values, plus 1. Notice that it is possible that\nR<sub>a,b</sub> = R<sub>c,d</sub> for different molecules a, b, c, d, and\nwe need to count the number of unique values.\n</p><p>\nThe algorithm to count the number of different values that are equal to\nR<sub>a,b</sub> for some a, b is immediate: try every\npair of molecules, calculate the ratio as explained for the Test set 1 solution\n(if there is one), and add it to a set of fractions to discard non-uniques. This algorithm\ntakes a quadratic number of insertions into a set, which makes it quadratic or barely\nabove quadratic overall depending on the set implementation that is used.\n</p>\n","id":"0000000000146183","statement":"<h3>Problem</h3>\n<p><i>\nThe first two paragraphs (not counting this one) of this problem and \"New Elements: Part 2\"\nare identical. The problems can otherwise be solved independently; you do not need to read\nor solve one in order to read or solve the other.\n</i></p><p>\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium.\nShe has not been able to isolate them yet, but she wants to start investigating some\nimportant properties, like their atomic weights, by indirect means.\nSince Muriel is working with a single isotope of Codium and a single isotope of Jamarium,\ntheir atomic weights are strictly positive integers.\n</p><p>\nMuriel managed to create <b>N</b> different molecules, each of which contains one or\nmore atoms of Codium and one or more atoms of Jamarium, and no other elements.\nFor each molecule, she knows how many atoms of each element are present in it. The molecular\nweight of a molecule is the sum of the atomic weights of all the atoms it contains.\n</p><p>\nAs a first step towards figuring out exact molecular weights for the molecules and atomic weights\nfor the two elements, Muriel wants to sort the molecules by strictly increasing molecular weight.\nTo assess the difficulty of that task, she wants to know how many orders are valid\nconsidering only the information she has right now. An ordering of the molecules is considered\nvalid if there exist values for the atomic weights of Codium and Jamarium such that the ordering is\n<i>strictly</i> increasing in molecular weight.\n</p><p>\nTo give an example, we represent each molecule by the ordered pair of the number of\natoms of Codium and Jamarium it contains. If Muriel has 3 molecules represented\nby (1, 1), (2, 1) and (1, 2), there are two possible orderings that can be strictly increasing in\nmolecular weight:\n(1, 1), (1, 2), (2, 1) and (1, 1), (2, 1), (1, 2). The first ordering is valid for any\nassignment of atomic weights in which Codium is the heaviest of the two elements, and\nthe second is valid for any assignment in which Jamarium is the heaviest. The only case\nremaining is when both Codium and Jamarium have the same atomic weight, in which case (1, 2)\nand (2, 1) have the same molecular weight, so no strictly increasing ordering can be\nproduced for that scenario.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\nThe first line of a test case contains a single integer <b>N</b>, the number of molecules. Each\nof the next <b>N</b> lines describes a different molecule with two integers <b>C<sub>i</sub></b>\nand <b>J<sub>i</sub></b> that represent the number of Codium and Jamarium atoms in the i-th\nmolecule, respectively.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where <code>x</code>\nis the test case number (starting from 1) and <code>y</code> is the total number of valid orderings\nas defined above.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>C<sub>i</sub></b> &le; 10<sup>9</sup>, for all i. <br/>\n1 &le; <b>J<sub>i</sub></b> &le; 10<sup>9</sup>, for all i. <br/>\n(<b>C<sub>i</sub></b>, <b>J<sub>i</sub></b>) &ne; (<b>C<sub>j</sub></b>, <b>J<sub>j</sub></b>)\nfor all i &ne; j. (All molecules are different.) <br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 6.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 300.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n1 1\n1 2\n2 1\n4\n1 2\n2 4\n2 1\n4 2\n3\n1 2\n1 3\n2 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 2\nCase #3: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Sample Case #1 is explained in the statement.\n</p><p>\n  In Sample Case #2, the two valid orderings are (1, 2), (2, 1), (2, 4), (4, 2) and\n  (2, 1), (1, 2), (4, 2), (2, 4). Notice that the ordering (1, 2), (2, 1), (4, 2), (2, 4)\n  is invalid because if (1, 2) is strictly less heavy than (2, 1), then (2, 4),\n  which is exactly twice as heavy as (1, 2), must be strictly less heavy than (4, 2), which\n  is exactly twice as heavy as (2, 1).\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":14}],"title":"New Elements: Part 1","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  Let w<sub>C</sub> be the atomic weight of Codium and w<sub>J</sub> be the atomic weight of\n  Jamarium according to the rules given in the problem statement. Let &Delta;C<sub>i</sub> equal\n  <b>C</b><sub>i + 1</sub> - <b>C</b><sub>i</sub> and &Delta;J<sub>i</sub> equal\n  <b>J</b><sub>i + 1</sub> - <b>J</b><sub>i</sub>, for all 1 &le; i &lt; <b>N</b>. As in our\n  analysis for New Elements, Part 1, we have:\n</p><ul>\n  <li>-&Delta;C<sub>i</sub> / &Delta;J<sub>i</sub> &lt; w<sub>J</sub> / w<sub>C</sub>,\n      if &Delta;J<sub>i</sub> &gt; 0.</li>\n  <li>w<sub>J</sub> / w<sub>C</sub> &lt; -&Delta;C<sub>i</sub> / &Delta;J<sub>i</sub>,\n      if &Delta;J<sub>i</sub> &lt; 0.</li>\n  <li>-&Delta;C<sub>i</sub> &times; w<sub>C</sub> &lt; 0, if &Delta;J<sub>i</sub> = 0.</li>\n</ul><p>\n  Therefore, we can get the lower bound and upper bound of w<sub>J</sub> / w<sub>C</sub> just by\n  looking at consecutive indices. We can initially set the lower bound (let us represent it with the\n  reduced fraction L<sub>N</sub> / L<sub>D</sub>) to be 0 and the upper bound (let us represent it\n  with the reduced fraction U<sub>N</sub> / U<sub>D</sub>) to be &infin;. We update either\n  L<sub>N</sub> / L<sub>D</sub> or U<sub>N</sub> / U<sub>D</sub> for each pair of consecutive\n  indexes, just as in our analysis from Part 1.\n</p><p>\n  Once we have L<sub>N</sub> / L<sub>D</sub> and U<sub>N</sub> / U<sub>D</sub>, we want to find a\n  rational number w<sub>J</sub> / w<sub>C</sub> such that\n  L<sub>N</sub> / L<sub>D</sub> &lt; w<sub>J</sub> / w<sub>C</sub> &lt;\n      U<sub>N</sub> / U<sub>D</sub>.\n  If L<sub>N</sub> / L<sub>D</sub> &ge; U<sub>N</sub> / U<sub>D</sub>, then there is certainly no\n  solution. Otherwise, there must be at least one solution; for example,\n  the <a href=\"https://en.wikipedia.org/wiki/Mediant_(mathematics)\">mediant</a>\n  (L<sub>N</sub> + U<sub>N</sub>) / (L<sub>D</sub> + U<sub>D</sub>) is certainly between the\n  bounds. However, the problem asks us to minimize w<sub>C</sub> and w<sub>J</sub>\n  (first w<sub>C</sub>, and then w<sub>J</sub>).\n</p>\n<h3>Test set 1</h3>\n<p>\n  Since &Delta;J<sub>i</sub> &le; 99 in this test set, we get\n  L<sub>D</sub> + U<sub>D</sub> &le; 198. Therefore, we know that a solution with\n  w<sub>C</sub> &le; 198 exists. We can try all possible values from 1 to 198 as w<sub>C</sub>. For\n  each choice of w<sub>C</sub>, we can derive the smallest w<sub>J</sub> such that\n  L<sub>N</sub> / L<sub>D</sub> &lt; w<sub>J</sub> / w<sub>C</sub>, and then we can check whether\n  w<sub>J</sub> / w<sub>C</sub> &lt; U<sub>N</sub> / U<sub>D</sub>.\n</p>\n<h3>Test set 2</h3>\n<p>\n  For each integer C (from 1 to L<sub>D</sub> + U<sub>D</sub>), we can check whether there is a\n  rational number that is strictly between L<sub>N</sub> / L<sub>D</sub> and\n  U<sub>N</sub> / U<sub>D</sub>, and has a denominator that is not more than C. To do that, we can\n  find a rational number with denominator not more than C closest to the average of\n  L<sub>N</sub> / L<sub>D</sub> and U<sub>N</sub> / U<sub>D</sub>. This is because all rational\n  numbers that are strictly between L<sub>N</sub> / L<sub>D</sub> and U<sub>N</sub> / U<sub>D</sub>\n  are closer to the average of L<sub>N</sub> / L<sub>D</sub> and U<sub>N</sub> / U<sub>D</sub>\n  than all rational numbers that are not strictly between L<sub>N</sub> / L<sub>D</sub> and\n  U<sub>N</sub> / U<sub>D</sub>. We can do so by using a library function like Python's\n  <a href=\"https://docs.python.org/2/library/fractions.html#fractions.Fraction.limit_denominator\">\n  fractions.limit_denominator</a>, or by implementing our own approximation using\n  <a href=\"https://en.wikipedia.org/wiki/Continued_fraction#Best_rational_within_an_interval\">\n  continued fractions.</a>\n</p><p>\n  Once we can solve the problem given in the previous paragraph, we can use binary search to find\n  w<sub>C</sub> as the smallest C such that a rational number with denominator not more than C, and\n  strictly between L<sub>N</sub> / L<sub>D</sub> and U<sub>N</sub> / U<sub>D</sub> exists. Just as\n  we did for the previous test set, we can derive the smallest w<sub>J</sub> such that\n  L<sub>N</sub> / L<sub>D</sub> &lt; w<sub>J</sub> / w<sub>C</sub>.\n</p>\n","id":"0000000000146184","statement":"<h3>Problem</h3>\n<p><i>\nThe first two paragraphs (not counting this one) of this problem and \"New Elements: Part 1\"\nare identical. The problems can otherwise be solved independently; you do not need to read\nor solve one in order to read or solve the other.\n</i></p><p>\nMuriel is on the path to discovering two new elements that she has named Codium and Jamarium.\nShe has not been able to isolate them yet, but she wants to start investigating some\nimportant properties, like their atomic weights, by indirect means.\nSince Muriel is working with a single isotope of Codium and a single isotope of Jamarium,\ntheir atomic weights are strictly positive integers.\n</p><p>\nMuriel managed to create <b>N</b> different molecules, each of which contains one or\nmore atoms of Codium and one or more atoms of Jamarium, and no other elements.\nFor each molecule, she knows how many atoms of each element are present in it. The molecular\nweight of a molecule is the sum of the atomic weights of all the atoms it contains.\n</p><p>\nAs a first step, Muriel sorted the molecules by strictly increasing molecular weight. Now she\nwants to find out possible integer values for the atomic weights of both Codium and Jamarium that\nare consistent with the ordering. Since she is aware there could be many consistent pairs of\nvalues, she wants one that minimizes the atomic weight of Codium. If there are multiple\npairs in which Codium's atomic weight is minimum, she wants the one in which Jamarium's\natomic weight is minimum.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\nThe first line of a test case contains a single integer <b>N</b>, the number of molecules. Each\nof the next <b>N</b> lines describes a different molecule with two integers <b>C<sub>i</sub></b>\nand <b>J<sub>i</sub></b> that represent the number of Codium and Jamarium atoms in the i-th\nmolecule, respectively. The molecules are given in strictly increasing order of molecular\nweight.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where <code>x</code>\nis the test case number (starting from 1), and <code>y</code> is <code>IMPOSSIBLE</code> (in uppercase) if there is\nno pair of integer atomic weights that would make the order of the molecules strictly\nincreasing in molecular weight. Otherwise, <code>y</code> should be two integers\n<code>c j</code> where c is the atomic weight of Codium and j is the atomic weight of\nJamarium, chosen according to the rules above.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n2 &le; <b>N</b> &le; 10.<br/>\n(<b>C<sub>i</sub></b>, <b>J<sub>i</sub></b>) &ne; (<b>C<sub>j</sub></b>, <b>J<sub>j</sub></b>)\nfor all i &ne; j. (All molecules are different.) <br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n1 &le; <b>C<sub>i</sub></b> &le; 100, for all i. <br/>\n1 &le; <b>J<sub>i</sub></b> &le; 100, for all i. <br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n1 &le; <b>C<sub>i</sub></b> &le; 10<sup>9</sup>, for all i. <br/>\n1 &le; <b>J<sub>i</sub></b> &le; 10<sup>9</sup>, for all i. <br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n1 1\n1 2\n2 1\n4\n1 2\n2 1\n4 2\n2 4\n3\n1 2\n1 3\n2 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2 1\nCase #2: IMPOSSIBLE\nCase #3: 1 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the difference between the last two molecules is having an extra\n  atom of one element or the other. Given that the one having the extra Codium is heavier\n  overall, we conclude that Codium must be heavier than Jamarium. The values 2 and 1 for\n  the atomic weights of Codium and Jamarium make the molecular weights\n  1 &times; 2 + 1 &times; 1 = 3, 1 &times; 2 + 2 &times; 1 = 4, and\n  2 &times; 2 + 1 &times; 1 = 5, respecting the strict ordering. Since Codium is heavier\n  than Jamarium in this case, 2 is Codium's minimum atomic weight, and 1 is of course\n  Jamarium's minimum atomic weight.\n</p><p>\n  Let a, b, c and d be the molecular weights of the molecules in Sample Case #2,\n  in increasing order of molecular weight. By their atom contents, d = 2 &times; a\n  and c = 2 &times; b. It follows from a &lt; b that d = 2 &times; a &lt; 2 &times; b = c,\n  which means there is no pair of values for the atomic weights that would make the ordering\n  strictly increasing.\n</p><p>\n  In Sample Case #3, notice that the molecules happen to be sorted in strictly increasing order of\n  total number of atoms. Therefore, assigning both elements an atomic weight of 1 makes the atomic\n  weights be sorted in strictly increasing order.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":16}],"title":"New Elements: Part 2","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\nIn Test Set 1 everything is small. One possible solution is to simulate the process.\nThere is never a reason to not convert elements other than lead, so we should just apply\nthe transformations over and over until no more lead can be created. If after a long time\nthe amount of lead keeps growing, that means the total is unbounded. In the Test Set 2 section\nwe do a formal analysis on bounds, but for this one, using an intuitive definition of\n\"a lot\" should suffice. If the amount is bounded, 1 gram of a metal can transform into\nat most 512 grams of lead, since it can only go through 9 splits before getting into a cycle.\nThat means if we ever see more than 5120 grams of lead, the amount is unbounded.\n</p><p>\nHowever, the first example shows that we need to do a little more. What if lead itself\ncan be used to get more lead? If that's possible, and we can get any lead at all,\nthe final amount is definitely unbounded. If it is not possible, then we have no\nreason to ever consume lead. One way to check is to do the simulation above\nstarting with 1 gram each of the two elements that lead is turned into. If that\nleads to 0 or 1 grams of lead, then lead cannot be used to get more lead. Otherwise,\nit can.\n</p>\n<h3>Test Set 2</h3>\n<p>\nTest Set 2 is a lot larger, so a hand-wavy analysis and implementation will not work.\nHowever, we can use the same idea above more carefully. Since each metal takes at most\n<b>M</b> steps to turn into lead, we only need to do <b>M</b> iterations of a simulation,\nwhere a simulation involves going over all non-lead metals and converting all grams of them.\nThis takes O(<b>M</b><sup>2</sup>) time. To prevent the numbers from growing too big,\nwe can simply do this process twice: the first pass creates as much lead as possible from\nnon-cyclical sources, so if the second pass creates even more, then it must come from\ncyclical sources that ultimately yield an unbounded amount of lead. The second part,\nto check for lead creating more lead, is the same as before.\n</p><p>\nNotice that the result\ndoes not fit in 64 bit integers, though, and doing modulo all the time as usual doesn't work\nright away, since we cannot afford to equate \"no X\" with \"10<sup>9</sup>+7 grams of X\"\nif X has the capability of creating unbounded amounts of lead (with X being lead itself,\nor some other metal). There are multiple ways to get around the problem, including\nusing big integers, storing an additional bit for each result that represents whether it is an\nactual 0 value, and doing calculations modulo 10<sup>9</sup>+7 &times; K for some\nlarge random prime K until the very end.\n</p><p>\nThere are other solutions that only work for Test Sets 1 and 2, that are less efficient\nimplementations of the solution for Test Set 3, that is explained below.\n</p>\n<h3>Test Set 3</h3>\n<p>\n  For Test Set 3, the solution looks quite different but it is actually similar.\n  We check for cycles that may generate unbounded lead, and if there are none,\n  we can do the simulation with a single iteration, ordering the metals appropriately.\n  All of those things can be done in linear time, and we describe how below.\n</p><p>\n  One useful thing to notice early on is that if we can determine that the\n  amount of lead we can produce is bounded, the only formulas that are worth\n  using are those that can eventually (perhaps in conjunction with other\n  formulas) produce lead. Moreover, if the amount of lead is bounded, there is\n  no point in using lead as an input to any formula, because even in the best\n  case, every unit of lead will turn into one unit of lead and one unit of\n  something else that cannot be converted to lead. (Otherwise, we could simply\n  apply that series of formulas and generate as much lead as we want).\n</p><p>\n  These observations imply that we can only get an unlimited amount of lead if\n  some metal can produce itself and lead at the same time. In other words,\n  there must be a series of formulas that takes one unit of some metal X and\n  turns it into one unit of X and one unit of lead. In the process, we may end\n  up with some other metals as well, but those don't matter. Notice that if\n  that metal X directly produces metals A and B, then we require that either A\n  produces X and B produces lead, or vice versa. This is because even if X is\n  lead itself and either of A or B is also lead, without considering the other\n  result, we are just destroying 1 unit of lead to get 1 unit of lead, so the\n  total amount of lead doesn't change. In other words, in the unbounded case,\n  after applying each formula, we need to work on both of the outputs, not just\n  one of them.\n</p><p>\n  Let Q be a graph in which each metal is represented by a node, and there is\n  an edge from node u to node v if, by consuming 1 unit of u, we can produce 1\n  unit of v. Notice that if a metal i is initially not present (that is,\n  <b>G<sub>i</sub></b> = 0), and it is not reachable in Q from some j with\n  G<sub>j</sub> &gt; 0, then it is impossible to produce metal i. Therefore,\n  we can remove any such metals at the outset. In what follows, we assume that\n  Q contains no such metals.\n</p><p>\n  Let Q' be the <a href=\"https://en.wikipedia.org/wiki/Transpose_graph\">transpose</a>\n  of Q, and let L denote the node representing lead. Then, traversing Q' from\n  node L defines a subgraph Q'<sub>L</sub>, where every node is a metal that can\n  produce lead after a series of transformations. Now, let P<sub>u</sub> be the\n  number of simple paths (paths without cycles) from L to any other node u in\n  Q'<sub>L</sub>. If the amount of lead is bounded, then P<sub>u</sub> is the\n  number of units of lead we can get from every unit of u. This follows from\n  the fact that every (reversed) edge is a valid transformation where we start\n  with 1 unit of some metal and produce 1 unit of some other metal, so along\n  the path, we are using the results of previous transformations and not the\n  very first unit of metal we started with. For example, let Q'<sub>L</sub> be\n  the following graph:\n<ul>\n  <li>1 &rarr; 2</li>\n  <li>1 &rarr; 3</li>\n  <li>2 &rarr; 4</li>\n  <li>3 &rarr; 4</li>\n</ul>\n  Which means the valid transformations are:\n<ul>\n  <li>4 turns into 2 and 3</li>\n  <li>2 turns into 1 and something else</li>\n  <li>3 turns into 1 and something else</li>\n</ul>\n<p>\n  There are 2 simple paths from 1 to 4, namely, 1 &rarr; 2 &rarr; 4 and 1 &rarr; 3 &rarr; 4. Now, 1\n  unit of metal 4 can be turned into 2 units of lead (1) as follows:\n</p>\n<ul>\n  <li>Turn one unit of 4 into one unit of 2 and one unit of 3</li>\n  <li>Take the one unit of 3 from step 1 and turn it into one unit of 1 and\n    one unit of some other metal</li>\n  <li>Take the one unit of 2 from step 1 and turn it into one unit of 1 and\n    one unit of some other metal</li>\n</ul>\n<p>\n  On the other hand, notice that the nodes that form\n  a <a href=\"https://en.wikipedia.org/wiki/Strongly_connected_component\">strongly connected component (SCC)</a>\n  in Q are a set of metals that can produce each other. More formally, if u and\n  v belong to the same SCC, we can produce 1 unit of v from 1 unit of u, and\n  vice versa. With these definitions, we can say that the amount of lead is\n  unbounded if, for some node u in Q with v<sub>1</sub> and v<sub>2</sub>\n  being the two outputs of node u's formula, either:\n<ul>\n  <li>v<sub>1</sub> is in Q'<sub>L</sub>\n  and v<sub>2</sub> and u are in the same SCC, or</li>\n  <li>v<sub>2</sub> is in Q'<sub>L</sub> and v<sub>1</sub>\n  and u belong to the same SCC.</li>\n</ul>\n<p>\n  Otherwise, there is a limit on the amount of lead we can get, which can be\n  computed by multiplying P<sub>u</sub> by the initial number of units\n  <b>G<sub>u</sub></b> for each u in Q'<sub>L</sub>.\n</p><p>\n  We can compute all the SCCs in O(<b>M</b>) time using <a href=\"https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\">Tarjan's algorithm</a>\n  or <a href=\"https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm\">Kosaraju's algorithm</a>\n  , since both the number of nodes and the number of edges in the graph are\n  linear on M. Walking over the graphs defined above also takes O(<b>M</b>)\n  time, and so does checking the unbounded condition. We can also compute all\n  P<sub>u</sub> in O(<b>M</b>) time by taking advantage of the fact that if the\n  amount of lead is not unbounded, then there are no cycles in Q'<sub>L</sub>.\n  (If a cycle existed in Q'<sub>L</sub>, then by reversing the edges, we get\n  at least one metal for which the unbounded condition holds.) Therefore, the\n  nodes on Q'<sub>L</sub> can be topologically sorted. That means we can\n  compute a function F from vertices to the number of simple paths in linear\n  time, using dynamic programming with this recursive definition:\n</p>\n<ul>\n  <li>F(L) = 1</li>\n  <li>F(u) = sum(F(v)) for each v, such that there is an edge from v to u in Q'<sub>L</sub></li>\n</ul>\n<p>\n  Since the number of edges in every graph described above is also O(<b>M</b>),\n  the whole problem can be solved in linear time.\n</p>\n","id":"0000000000146185","statement":"<h3>Problem</h3>\n<p>\n  Last year, we asked you to help us\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000007764/000000000003675c\">convert expensive metals into lead</a>.\n  (You do not need to know anything about the previous problem to solve this\n  one.) But your country's leader is still greedy for more lead!\n</p><p>\n  There are <b>M</b> metals known in the world; lead is metal number 1 on your\n  periodic table. Your country's leader has asked you to use the metals in the\n  treasury to make as much lead as possible.\n</p><p>\n  For each metal (including lead), you know exactly one formula that lets you\n  destroy one gram of that metal and create one gram each of two metals.\n  (It is best not to think too much about the principle of mass conservation!)\n  Note that it is possible that the formula for the i-th metal might produce\n  the i-th metal as one of the products. The formulas do not work with partial\n  grams. However, you can use each formula as often as you would like (or not\n  at all), as long as you have a gram of the required ingredient.\n</p><p>\n  If you make optimal choices, what is the largest number of grams of lead you\n  can end up with, or is it unbounded? If it is not unbounded: since the output\n  can be a really big number, we only ask you to output the remainder of\n  dividing the result by the prime 10<sup>9</sup>+7 (that is, 1000000007).\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with an integer\n  <b>M</b>: the number of metals known in the world. Then there are <b>M</b>\n  more lines with two integers <b>R<sub>i1</sub></b> and <b>R<sub>i2</sub></b>\n  each; the i-th of these lines, counting starting from 1, indicates that you can\n  destroy one gram of metal i to create one gram of metal <b>R<sub>i1</sub></b> and\n  one gram of metal <b>R<sub>i2</sub></b>. Finally, there is one line with <b>M</b>\n  integers <b>G<sub>1</sub></b>, <b>G<sub>2</sub></b>, ..., <b>G<sub><b>M</b></sub></b>;\n  <b>G<sub>i</sub></b> is the number of grams of metal i in the treasury. Lead\n  is metal 1.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code> where\n  <code>x</code> is the test case number (starting from 1). If there is no\n  bound on the maximum amount of lead that can be produced, <code>y</code>\n  must be <code>UNBOUNDED</code>. Otherwise, <code>y</code> must be\n  the largest amount of lead, in grams, that you can end up with, modulo the\n  prime 10<sup>9</sup>+7 (that is, 1000000007).\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>R<sub>i1</sub></b> &lt; <b>R<sub>i2</sub></b> &le; <b>M</b>,\n    for all i.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>M</b> &le; 10.<br/>\n  0 &le; <b>G<sub>i</sub></b> &le; 10, for all i.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>M</b> &le; 100.<br/>\n  0 &le; <b>G<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n</p>\n\n<h4>Test set 3 (Hidden)</h4>\n<p>\n  1 &le; <b>T</b> &le; 5.<br/>\n  2 &le; <b>M</b> &le; 10<sup>5</sup>.<br/>\n  0 &le; <b>G<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2\n1 2\n1 2\n1 0\n2\n1 2\n1 2\n0 0\n4\n2 4\n3 4\n2 4\n2 3\n10 10 10 10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: UNBOUNDED\nCase #2: 0\nCase #3: 10\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  In Sample Case #1, you have one formula that turns 1 gram of lead into 1\n  gram of lead and 1 gram of the second metal, and another formula that turns\n  1 gram of the second metal into 1 gram of lead and 1 gram of the second\n  metal. You can alternate between these formulas to produce as much of both\n  metals as you want.\n</p><p>\n  Sample Case #2 has the same formulas as Sample Case #1, but you have no\n  metals to start with!\n</p><p>\n  In Sample Case #3, none of the formulas help you produce more lead, so you\n  cannot end up with more lead than you started with.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":16},{"type":2,"type__str":"HIDDEN","value":6}],"title":"Contransmutation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>A simple (but incorrect) approach</h3>\n<p>\n  Our tempting first thought might be: why not just put one of our tokens in\n  each vase? Then we can sit back and just wait to win, no matter which vase\n  gets chosen. Who needs the other 80 days?\n</p><p>\n  The flaw in this reasoning is that if multiple vases are tied for having the\n  fewest tokens, there is no winner. A quick simulation can show us that there\n  is only a unique winner around 57% of the time. So this approach has no\n  hope of passing, and we have to work harder!\n</p>\n<h3>A slightly more complex (but also incorrect) approach</h3>\n<p>\n  It might still seem that we can succeed without inspecting any vases. What if\n  we just choose one vase up front &mdash; without loss of generality, we will\n  pick vase #20 &mdash; and try to make it the winning vase? Over the course\n  of the first 99 nights, we distribute fake tokens among the other 19 vases,\n  as evenly as possible (to prevent any one of those vases from becoming more\n  of a threat than the others). The labels on these fake tokens do not matter,\n  since we are banking on vase 20 winning. Then, on the 100th night, we place\n  our token in vase 20. Since each of the other 19 vases will be burdened with\n  5 (or maybe even 6) extra tokens, the odds are good that vase 20 will have\n  the fewest, right?\n</p><p>\n  Unfortunately, those odds aren't so good. Again, we can write a quick\n  simulation to verify that our strategy will only succeed around 53% of the\n  time &mdash; it's even worse than the strategy above! The average \"burden\"\n  that we add to the other vases just isn't large enough compared to the random\n  variation in the number of tokens per vase. \n</p>\n<h3>A better approach</h3>\n<p>\n  We will need to take advantage of our inspection ability, but when should\n  we use it? There is not much value in inspecting early on in the lottery,\n  since relatively few tokens will have been placed. On the other hand, if we\n  inspect too late, we may not have enough nights left on which to react to\n  whatever information we discover.\n</p><p>\n  We can devise a version of our first approach that also incorporates\n  inspection. In this approach, V and N are parameters that we will have to\n  discover:\n</p>\n<ol>\n  <li>Choose to \"give up on\" the first V vases. We will assume that none of\n    these will win, and so the labels on the tokens we add to them will not\n    matter. Spend the first N nights sabotaging them (evenly).</li>\n  <li>Spend the next 20 turns inspecting every vase, in order.</li>\n  <li>Based on the results of our inspections, choose the vase with the fewest\n    tokens (out of the remaining 20-V vases) to be our candidate winning\n    vase.</li>\n  <li>On each of the remaining 99 - 20 - N nights, choose a vase (other than\n    our candidate vase) with the smallest number of tokens in our inspection\n    results, and add a token to it. Then, update the inspection results to\n    reflect this.</li>\n  <li>On day 100, add our own token to the candidate vase.</li>\n</ol>\n<p>\n  We might worry that our inspections are only snapshots in time that grow\n  stale. By the time we inspect vase 20, our estimate for vase 1 is already\n  out-of-date &mdash; what if more tokens have been added to it since then? To\n  compare the estimates a little more fairly, we could adjust them by the\n  expected number of tokens that have been added since the night of the\n  estimate (i.e., the number of additional nights, divided by 20). This\n  adjustment will be at most .95, which is less than a single full token, so\n  the adjustments could only possibly be used to break ties among vases with\n  the same number of tokens... and we can get the same effect by just choosing\n  the vase with the highest-numbered ID in the event of a tie.\n</p><p>\n  It is not too hard to simulate this process, so we can try out different\n  values of V and N to see what yields the best results, and find that V = 14,\n  N = 60 works about 95% of the time. That gives us, per the binomial\n  distribution, about a 99.96% chance of solving at least 225 out of 250 cases\n  correctly. Since the problem only has one Visible test set, we should just\n  submit and hope for the best!\n</p>\n<h3>Can we do even better?</h3>\n<p>\n  If we want to experiment further, there are even better solutions out there!\n  Here is a variant of the above strategy; it succeeds over 98% of the time:\n</p>\n<ul>\n  <li>Days 1-60: Put 4 tokens into each of vases 1-15.</li>\n  <li>Days 61-80: Inspect every case. Find the <i>two</i> vases with the\n    smallest number of tokens (breaking ties in favor of higher-numbered\n    vases, as we will throughout this strategy), and designate them as\n    candidates.</li>\n  <li>Days 81-94: Greedily put a token into the non-candidate vase that\n    has the smallest number of tokens, per our inspection results. Update\n    those results.</li>\n  <li>Days 95-96: Inspect the two candidates again and commit to the one\n    with fewer tokens.</li>\n  <li>Days 97-99: Sabotage the other candidate.</li>\n</ul>\n<p>\n  If we hang onto two candidates, it is less likely that both of them will\n  accumulate a lot of tokens via bad luck during the second sabotage phase. We\n  benefit from delaying our decision point for as long as possible, while still\n  leaving enough time to deal with our runner-up.\n</p>\n\n","id":"00000000001461c8","statement":"<h3>Problem</h3>\n<p>\n  The Pottery Palace is going to run a lottery featuring some valuable vases by\n  the artist Cody-Jamal. The lottery works as follows:\n</p>\n<ul>\n  <li>100 people get to play in the lottery. Each player has a unique\n    number between 1 and 100, and is given a single token with that\n    number.</li>\n  <li>There are 20 empty clay vases on a table, numbered 1 through 20. The vases\n    have narrow openings that are large enough to accept a token, but small\n    enough that players cannot look inside to see the contents.</li>\n  <li>On the i-th day of the lottery, the player with token number i chooses a\n    vase and puts their token in that vase. Since the vases are all identical\n    (apart from their labels), every player will choose one uniformly at\n    random and independently of all other players' choices.</li>\n  <li>On day 100, after player number 100 has inserted their token, the organizers\n    shake the vases to determine how many tokens are inside each one. If there\n    is <i>exactly</i> one vase that has fewer tokens than any other vase, then\n    that one is the \"winning vase\". The organizers then pour out all of the tokens\n    in that vase, and every player whose number is written on one of those poured-out\n    tokens wins a vase! If multiple vases have the same minimal amount of tokens, nobody\n    wins anything.\n</li>\n</ul>\n<p>\n  You have been hired to test the security of the lottery, and you will\n  participate in some trial runs. The company will always assign you the\n  number 100 &mdash; that is, you replace player 100.\n</p><p>\n  You have found some ways to tamper with the lottery at night, but security\n  is tight, so you can only do so much! Specifically, after each of the first\n  99 days of the lottery, you may do exactly <i>one</i> of the following:\n</p>\n<ul>\n  <li>forge a token with the player number of your choice (between 1 and 100, inclusive),\n    and add it to a vase of your choice. You are a very good forger: if there\n    is a winning vase, any forged tokens in that vase will cause the players\n    with those numbers to win (with one exception; see below).</li>\n  <li>use a special camera to see the numbers on all of the tokens in one\n    vase of your choice</li>\n</ul>\n<p>\n  You may perform different actions on different nights, and you may choose\n  dynamically: you do not need to decide on all of your actions in advance.\n</p><p>\n  On the 100th day, it is your turn to insert your token into a vase of your\n  choice (you do not need to choose uniformly at random). You cannot perform\n  any other actions on that day.\n</p><p>\n  You know that if there is a winning vase with more than one token for the same player,\n  it will be obvious that cheating has occurred and nobody will win. However, it does not\n  matter if other vases contain more than one token for the same player because the\n  organizers never see those tokens.\n</p><p>\n  Your goal is to be a winner in at least 90% of the test cases.\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the\n  information in the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\">Interactive Problems section</a>\n  of our FAQ.\n</p><p>\n  Initially, your program should read a single line containing a single integer\n  <b>T</b> indicating the number of test cases. Then, you need to process\n  <b>T</b> test cases.\n</p><p>\n  At the start of a test case, the judge outputs one line with one integer:\n  the number of the current day. (The judge starts on day 1, and on the\n  i-th day, it prints i.) After your program reads the integer, it should write\n  a line containing two integers V and P, with 1 &le; V &le; 20, and\n  0 &le; P &le; 100. The judge will interpret these as follows:\n</p>\n<ul>\n  <li>If 1 &le; P &le; 100, you put a token for player P in vase V. The judge\n    does not write anything back as a response.</li>\n  <li>If P = 0, you inspect the contents of vase V.  The judge writes one line\n    containing integers. The first integer is <b>N</b>, the number of tokens in vase\n    V, and then there are <b>N</b> more integers: the player numbers on each of the\n    tokens, in non-decreasing order.</li>\n</ul>\n<p>\n  Notice that on turn 100, you must put your own token in, so P must be 100.\n</p><p>\n  Remember that on the i-th day, for 1 &le; i &le; 99, the judge\n  simulates the action of the i-th player, as described in the statement. This\n  happens before your own action on that day.\n</p><p>\n  After you send your move for turn 100, your program should terminate if it\n  was the last test case; otherwise, it should start reading data for the next\n  test case. (Notice that the judge does not tell you whether you got each case\n  correct or incorrect.) The judge will only check whether you have enough\n  correct answers after you have attempted all <b>T</b> test cases, so you\n  should not stop early! For example, if you answer the first 225 out of 250\n  cases correctly and then exit, or provide malformed input, your solution will\n  not be considered correct.\n</p><p>\n  If your program outputs something illegal (e.g., gives an invalid value for P\n  or V, or tries to inspect a vase on turn 100), the judge will send\n  one line containing <code>-1</code> to your input stream, and it will not\n  send any other output after that. If your program continues to wait for the\n  judge after receiving <code>-1</code>, your program will time out, resulting\n  in a Time Limit Exceeded error. Notice that it is your responsibility to have\n  your program exit in time to receive a Wrong Answer judgment instead of a\n  Time Limit Exceeded error. As usual, if the total memory is exceeded, or your\n  program gets a runtime error, you will receive the appropriate judgment.\n</p>\n\n<h3>Test set 1 (Visible)</h3>\n<p>\n  <b>T</b> = 250.<br/>\n  Time limit (for the entire test set): 40 seconds.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2zuuC6f0Tpq1k6GM9-zFAXI5LMFibvRXqk6Idg5gJNeLttpymhPc0MwVDuUOLrd-t6LtARVu2CswdhAb_O/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n\n<pre>\n  t = readline_int()           // reads 250 into t\n  curr_day = readline_int()    // reads 1 (day 1)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 2 (day 2)\n  printline 8 99 to stdout     // puts a token for player 99 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 3 (day 3)\n  printline 8 100 to stdout    // puts a token for player 100 into vase 8\n  flush stdout\n  curr_day = readline_int()    // reads 4 (day 4)\n  printline 20 7 to stdout     // puts a token for player 7 into vase 20\n  flush stdout\n  curr_day = readline_int()    // reads 5 (day 5)\n  printline 8 0 to stdout      // inspects vase 8\n  flush stdout\n  tokens = readline_int_list() // reads 5 2 5 99 100 100 (players 2 and 5\n                               //   happen to have chosen vase 8)\n  curr_day = readline_int()    // reads 6 (day 6)\n  printline 8 101 to stdout    // tries to add a token with a bad player number\n  flush stdout\n  curr_day = readline_int()    // reads -1 (judge has decided our solution is\n                               //   incorrect)\n  exit                         // exits to avoid an ambiguous TLE error\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":23}],"title":"Pottery Lottery","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"}],"ticket":{"challenge_id":"0000000000051679","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2019"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
