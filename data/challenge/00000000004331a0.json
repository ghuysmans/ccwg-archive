{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1376667300000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000004331a0","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<h3>Ivan Miatselski (mystic) earns the 2013 Champion title.</h3>\n\n<p>\nThe problem set for the 2013 finals was nearly impossible to solve in its entirety. This meant that the contestants had to be strategic in deciding which problems they were going to try their hand at if they wanted a chance to win the grand prize. The point values for the problems were 25, 29, 39, 43, 64, making problem E “Let Me Tell You a Story” by far the most important. Strangely enough, it was the high point value that perhaps was the reason problem E went unsolved: many contestants mentioned after the finals that they assumed it to be too difficult because of the high point value, explaining why they didn’t try too hard to crack it.\n</p>\n\n<p>\nHowever, problem C “X Marks the Spot” suddenly took its place as the toughest problem that was still solved. Geometry problems are always hard no matter how easy they look, and only <b>staniek</b> (winner of Round 1C), managed to deal with all its tricks correctly in almost two hours: he spent one hour before trying to submit, submitted an incorrect solution for C-small, then found a bug (he was drawing the border directly through a gold mine) and fixed it in 30 more minutes, and then spent another 20 minutes before getting the large input done. That put him in the prime position to win the grand prize, and the spectators were waiting for him to solve the problems that proved to be quite tractable for other contestants and jump into the first place - but he lost his best shot at victory when the clock ran out on his attempt to solve D-large.\n</p>\n\n<p>\nThat left the prizes up for grabs for people who were solving problems A, B and D. The eventual top three all managed to solve those three problems completely, and also solve one or two other smalls. In third place was Russia’s <b>winger</b>: but spending almost an hour and a half on D made it difficult for him to challenge the first two contestants. In second place was Ukraine’s <b>Vasyl</b>, who was actually the first to get all of A, B and D solved. The winner was Belarus’s <b>mystic</b>, who overtook <b>Vasyl</b> in the last hour of the contest by solving E-small about 10 minutes earlier than his Ukrainian opponent, and then cementing his first place with C-small. Having placed second in 2011, <b>mystic</b> has finally made the final step - congratulations to him, and to all finalists!\n</p>\n\n<p>\nGoogle Code Jam 2013 is over now, but Google Code Jam 2014 will be here before you know it. We’re looking forward to seeing you all again soon!\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>\nProblem A. <i>Graduation Requirements</i> Written by David Arthur, with Onufry Wojtaszczyk.  Prepared by Onufry Wojtaszczyk.\n</p>\n<p>\nProblem B. <i>Drummer</i> Written by Igor Naverniouk.  Prepared by Jan Kuipers.\n</p>\n<p>\nProblem C. <i>X Marks the Spot</i> Written by Onufry Wojtaszczyk, with Tomek Czajka.  Prepared by John Dethridge and Tomek Czajka.\n</p>\n<p>\nProblem D. <i>Can't Stop</i> Written by David Arthur and Bartholomew Furrow.  Prepared by Tomek Kulczyński, with Bartholomew Furrow.\n</p>\n<p>\nProblem E. <i>Let Me Tell You a Story</i> Written Igor Naverniouk, with Tiancheng Lou.  Prepared by Tiancheng Lou.\n</p>\n\n<p>\nContest analysis presented by Topraj Gurung, Tsung-Hsien Lee, Denis Savenkov, Onufry Wojtaszczyk, Jonathan Paulson, Petr Mitrichev and Bartholomew Furrow. </p>\n\n<p>\nSample solutions, statement and input verification and other problem preparation by Karim Nosir, Jan Kuipers, Igor Naverniouk, Petr Mitrichev, John Dethridge, David Arthur, Onufry Wojtaszczyk, Bartholomew Furrow, Steve Thomas and Jonathan Wills. \n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1376652900000,"tasks":[{"analysis":"<h2>Median choice</h2>\n<p>Since the four quarters formed by the two lines have to contain the same number of mines, each of the two lines has to split the set in half. Thus, if we know the inclination of the two lines (given as, e.g., the directed angle the first line forms with the horizontal axis), we can position the each line in any place such that it splits the points in half (by, for instance, sorting the points by the value of the cross-product with the direction of the line). Let's begin by choosing any angle alpha as our initial angle, and draw the two lines according to the procedure above.\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1RwzCLjuWzqacFNXwPJ1CKnI21iydRNT6B5eAkI0ahbaxag7RzRvKylQAYjykGbPjIKqOw/Lines0.png\">\n\n<p>Suppose that the first quarter contains <b>X</b> points. The second quarter contains 2<b>N</b> - <b>X</b>, since there have to be 2<b>N</b> points above the red line. The third quarter will again contain <b>X</b> points (because there are 2<b>N</b> points to the right of the green line), and the fourth will contain 2<b>N</b> - <b>X</b>. So if <b>X</b> = <b>N</b>, our two lines are a correct solution. This doesn't need to be the case, though, as we can see on the figure above.</p>\n\n<h2>Rotating the lines</h2>\n<p>If the angle alpha we chose happens not to be a correct solution to the problem, we will try rotating the lines (by increasing alpha) until it becomes valid.</p>\n\n<p>Let's consider what happens when we rotate the lines. At some moment, one or both of the lines will rotate to a point where instead of splitting the set neatly in half, the \"splitting line\" passes through two mines, with 2<b>N</b>-1 mines on either side (note that we are taking advantage of the fact that no three points are collinear, so we know the line passes through exactly two points, and not, say, four). We will call the moment at which there are two points on at least one of the splitting lines a &quot;discontinuity&quot;. After we rotate a tiny bit more, the lines split the set neatly again.</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U11w3PV_RvraB1-5fpdEKV8oSRQ3K7fKQhCzMLnMxAKuVyUNenpT1o0rUnsaMQ8Thzk8Xgl/Lines1.png\">\n\n<p>We will prove in a moment that at any discontinuity, <b>X</b> changes at most by one (it can also happen to stay the same). Notice, however, that when we increase alpha by 90 degrees, the red and green lines will exchange places, which means that the first quarter (which also rotated by 90 degrees) now contains 2<b>N</b>-<b>X</b> points. Thus, somewhere in between <b>X</b> had to be exactly equal to <b>N</b>!</p>\n\n<h2>Discontinuity</h2>\n<p>Let's analyze what happened after the discontinuity. Obviously, only the points that were on the dividing lines could have changed quarters at the discontinuity. One of the points that were on the red line crosses from one of quarters (1, 2) to one of quarters (4, 3), and the other point crosses in the other direction. Thus, if the discontinuity had points on one line only, <b>X</b> changes by at most one.</p>\n\n<p>We will see that even if there were points on both lines at the discontinuity, <b>X</b> will still change only by one. The points on the red line go from quarters (1, 4) to quarters (2, 3). So, for <b>X</b> to, say, grow by two, we would have to have a point from 2 go to 3 and point from 4 go to 1 on the red line, while a point from 4 went to 3 and a point from 2 went to 1 on the green line. However, the red line (and the green line as well, but for now it's the red line that matters) is rotating clockwise - thus, it's the more leftward point that will go down, and the more rightward point that will go up &mdash; so the situation described above is impossible.</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2P-euN_21_wVwOhA8HM7fNXZAVFjkWzXnz7k6Li-b5QJiZQ6nVX9eopY4Ox-SlFr5O-115/Lines2.png\">\n\n<h2>Finding the solution</h2>\n<p>We can now use binary search to find a solution to the problem. Begin with an arbitrary angle alpha as the left bound, and alpha + 90 degrees as the right bound, assume that for the left bound <b>X</b> is smaller than <b>N</b> (if it's equal, we're done, and if it's larger, take alpha + 90 as left and alpha + 180 as right). We know somewhere between the two there is a point in which <b>X</b> = <b>N</b>. So we pick an angle midway between left and right, and check how big is <b>X</b> for this median angle. If it's equal to <b>N</b>, we are done. If it's smaller, the median angle is our new left, if it's larger, it's the new right. Proceed until success.</p>\n\n<p>A single iteration, with the standard implementation, takes O(<b>N</b> log<b>N</b>) time - sort the points twice, assign each to the appropriate quarter, find <b>X</b>. If somebody cared enough (one doesn't need to in this problem) it can be done in O(<b>N</b>) time, using a faster algorithm to find the median values (either a randomized one, like quicksort, but recursing only into the bigger of two halves, or even deterministically with the <a href=\"http://en.wikipedia.org/wiki/Median_of_medians\" target=\"_blank\">median of medians</a> algorithm.</p>\n\n<p>The key question is \"how many iterations of the binary search algorithm will we need to find the angle we are looking for?\". This depends on the size of the interval of angles that we will try to hit. This interval will occupy the space between some two discontinuities, and each discontinuity is defined by a line connecting two of the input points - thus, the size of the interval can be expressed as an angle between two lines, each crossing two points with integral coordinates no larger than 10<sup>-6</sup>. Such an angle can be on the order of 10<sup>-12</sup>, which means we will need roughly 40 steps of the binary search. Thus, our algorithm will easily run in time.</p>\n\n<h2>Precision issues</h2>\n<p>There are three types of precision issues that can hit one on the solving of this problem.</p>\n\n<p>First, it can happen that one of the lines we choose happens to be a discontinuity. This can be either worked around (by choosing a median angle a bit to the left or right - there are only finitely many discontinuities, after all), or avoided by choosing a random angle to begin with - since there are finitely many discontinuities, it's very unlikely to hit one. It's also possible to choose a deterministic angles to avoid discontinuities.</p>\n\n<p>Second, the interval of angles that we are trying to find can happen to be rather small, and so we will need many iterations of the binary search. This means that we need to use relatively high precision numbers to deal with the quantities involved. It's a pretty standard issue in geometry problems, though, and shouldn't surprise anyone.</p>\n\n<p>Third, there are limits on the precision with which we can output the result, and the checker for the problem will check whether the output values are correct. Since there is a finite precision of the output, there will be some rounding happening. This means that if we were unlucky, and our chosen angle happened to be quite close to the boundary of the \"good\" interval, the rounding can push it out of the interval. There are two things we can do to mitigate this. First, we can add a few more steps of the binary search to find a few more points within the good interval, and then choose for our answer a point that we know is relatively far from the edge. Second, we should use all the precision that we are allowed in the input. In particular, when we know the line we want to draw, we should choose the second point we output (the one other than the crossing) to be as far away from the crossing as the limits on the output allow us, to minimize the error in the angle of the line resulting from rounding.</p>","id":"0000000000432b8b","statement":"<h3>Problem</h3>\n<p>\nFair King Tyrone and his four sons conquered the nation of Carrania. His four sons immediately started to squabble about dividing the land between the four of them. The main point of contention was the gold mines of Carrania - each son wanted to have no fewer gold mines than any other.\n</p>\n\n<p>\nFair King Tyrone soon got tired of the squabbling, especially when he learned the number of mines is 4<b>N</b>, so dividing them should be easy. He gathered his sons, took a map, drew an X on it and declared each son would get one quarter of the nation, with borders defined by the X he drew.\n</p>\n\n<p>\nUnfortunately, Fair King Tyrone is a bit shortsighted, and the map he drew on was not a map of Carrania. His first minister quickly hid the map, and now tries to draw an identical X on the map of Carrania so that each son gets the same number of gold mines. Unfortunately all sons saw King Tyrone draw the X, and know the borders should be two perpendicular straight lines - so the minister has to make them so.\n</p>\n\n<p>\nHelp him! Your task is to draw two perpendicular straight lines such that no gold mine lies on a border, and the borders divide the gold mines equally.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case begins with a number <b>N</b>, describing the number of gold mines each son should get. 4<b>N</b> lines follow, each containing two integers, being the coordinates <b>x<sub>i</sub></b>, <b>y<sub>i</sub></b> of one of the gold mines. No three gold mines are co-linear.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: x<sub>a</sub> y<sub>a</sub> x<sub>b</sub> y<sub>b</sub>\", where <b>x</b> is the case number (starting from 1), (<b>x<sub>a</sub></b>, <b>y<sub>a</sub></b>) are the coordinates of the point where the two borders intersect, and (<b>x<sub>b</sub></b>, <b>y<sub>b</sub></b>) are the coordinates of some other point on the X.</p>\n<p>All coordinates must be between -10<sup>9</sup> and 10<sup>9</sup>, have at most 9 digits after the decimal point, and not use exponential notation. They must be exact: the resulting X will be drawn exactly at these coordinates. You should output IMPOSSIBLE instead if there is no good placement of borders.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 20<br/>\n-10<sup>6</sup> &le; x<sub>i</sub>, y<sub>i</sub> &le; 10<sup>6</sup><br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; N &le; 10<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; N &le; 2500<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n1\n0 0\n1 0\n0 1\n1 1\n1\n1 0\n0 1\n-1 0\n0 -1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.5 0.5 2 0.5\nCase #2: 0 0 -3 -3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":29}],"title":"X Marks the Spot","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p> \nIn this problem we are interested in finding the maximum time we can drive against the direction in a traffic circle. For small test cases, the size of the input is small enough to try all possible intersections, time to start, and check the length to drive without touching any other car. \n</p>\n\n<p>\nFor large test cases, the above approach is not good enough due to the extremely large <b>N</b> and <b>X</b> (up to 10<sup>10</sup>). Therefore in order to solve the large test cases, we transform the problem into the 2-dimensional plane with intersection and time as axes. Then, each car can be represented as line segments; your car will be represented as a line segment orthogonal to other line segments formed by other cars. Figure 1 shows the second sample test case. Lined segments corresponding to different cars are denoted with different colors while the black dotted segment corresponds to your car. Note that as the intersections are in a traffic circle, we show it by repeating intersection 5 and 1 on the two ends in Figure 1.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2G8Nw8IkkrGw3r5NgYTLUJqHBz_u9fyMEbGIia9uCybBdxtiZwIyEH4BP7xSpeYaV6-G_mDcXJs95TtQ/grad_figure_1.png\">\n<br>\n<b>Figure 1</b>\n</p>\n\n<p>\nSo the problem can be reformulated as follows: given a set of line segments, find the maximum possible length of a perpendicular segment which does not touch any other segment. Note that if two segments have a point in common the corresponding cars touch each other.\n</p>\n\n<p>\nTo solve the large test case one needs to notice that a line segment of maximum possible length can be chosen so that it goes near one of the endpoints of another segment. By “near” we mean distance = 1 in one of the axes. Indeed, if we have a segment of maximum possible length, that does not go near one of the endpoints, we can always move it so that it does, see Figure 2 for an example.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U31k_Qpj0CfgnvB_sKTrDKg-6piOcAL5IxDkLr_V7febbfnWlZA9EzAIV7NqeAmcKuvo7iMYIjGXrFG-w/grad_figure_2.png\">\n<br>\n<b>Figure 2</b>\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1Umnwgpgh6yh3GHzniqw5PTaduooQG5dtgJszeEfPLVBHgaxGVC_ISqCYJs8zTR_cRaybm307VCCj0gg/grad_figure_3.png\">\n<br>\n<b>Figure 3</b>\n</p>\n\n<p>\nThe statement is also true in examples such as in Figure 3 because intersections are arranged in a circular manner and the solution segment is near the top right endpoint which is shown with an arrow.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0bk8-5-_L9rf1JeKljHzwovhjdBddtgpfW8PSC1ffZvWHSjds4fzd-bChLy1t1AMvqC0lUSnFj1zIHuA/grad_figure_4.png\">\n<br>\n<b>Figure 4</b>\n</p>\n\n<p>\nThus we note that changes in the length of segments happen near these endpoints. Therefore to solve the problem we need to go over all endpoints of car segments and consider its neighbourhood (-1 and +1 in both of the axes). Note that we also need to consider segments that go through endpoints +/-(1,1), an example is shown in Figure 4. Then we can compute all segments that pass through these near points and pick the longest segment as the answer.\n</p>\n\n<p>\nFor each such candidate point, we need to check how far up and down a segment that go through the candidate point can reach without touching other segments. This can be done simply by going over all car segments and checking if and where our candidate segment intersect them. The complexity of this algorithm is O(C<sup>2</sup>), which is enough to solve the large case.\n</p>","id":"0000000000432e01","statement":"<h3>Problem</h3>\n<p>\nBefore graduating from Awesome Programmer University, students traditionally perform certain \"graduation requirements\". One of these is driving around a traffic circle backwards. For most people, this is crazy enough, but as an extra challenge, <i>you</i> want to see if you can go backwards around the traffic circle multiple times without stopping.\n</p>\n\n<p>\nThe traffic circle consists of <b>N</b> intersections, spaced evenly around the circle. A car would normally enter the traffic circle at one intersection, and then every second, it will move to the next counter-clockwise intersection, until eventually it reaches its destination and leaves.\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U13PNBTF3x7JCmWGFNY4-xLOpL8cLCNZzHP56rvqcHTvxuqxvolUaAw6m16z1Mk7HBTnqWq/circli.png\">\n\n<p>\nYou have been watching cars enter and leave the traffic circle for <b>X</b> seconds. For each car, you record the time it enters the circle, as well as the intersections it enters and leaves at. All cars are moving counter-clockwise at the rate of 1 intersection per second. Each car you watched exited the circle before coming back to the intersection it entered at. There are multiple lanes on the traffic circle, so multiple cars can occupy the same position at the same time.\n</p>\n\n<p>\nIf you had planned it just right, how long could you have driven clockwise in the traffic circle during this time? You must enter the circle at some integer time &gt;= 0, leave at time &lt;= <b>X</b>, and once you leave, you are not allowed to come back. When in the traffic circle, you must travel clockwise at the rate of 1 intersection per second. You want to play it safe (well, as safe as driving backwards on a traffic circle can be), so you must never touch or pass by another car. In particular, you cannot leave the circle at an intersection at which another car is entering at the same moment, and you cannot enter the circle at an intersection at which another car is leaving at the same moment. You can choose when and where to enter and leave the circle.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.\nThe first line of any test case describes the number <b>C</b> of cars you observed. The second line contains two integers, <b>X</b> and <b>N</b> &mdash; the time (in seconds) for which you observed the circle, and the number of intersections on the circle. Next <b>C</b> lines describe the cars you have seen. Each of those lines contains three integers <b>s<sub>i</sub></b>, <b>e<sub>i</sub></b> and <b>t<sub>i</sub></b> &mdash; the intersection at which the car entered the circle, the intersection on which it left and the time at which it entered. The intersections are numbered from 1 to <b>N</b>, counterclockwise (that is, the intersection number 2 is the next intersection counterclockwise from number 1).\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the maximum number of seconds you can travel on the circle. Note that y can be zero both in the case where you cannot enter the circle at all and in the case when you can enter it, but can't travel even one intersection.\n</p>\n\n<p>\nRemember that you are required to enter the circle at a time expressed as an integer number of seconds &mdash; you must enter at an integer time, and thus arrive at each intersection at an integer time.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100<br/>\n1 &le; <b>s<sub>i</sub></b>, <b>e<sub>i</sub></b> &le; <b>N</b><br/>\n<b>s<sub>i</sub></b> &ne; <b>e<sub>i</sub></b> <br/>\n0 &le; <b>t<sub>i</sub></b><br/>\nEach observed car leaves the circle at time <b>X</b> or earlier.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n3 &le; <b>N</b> &le; 10<br/>\n1 &le; <b>X</b> &le; 10<br/>\n0 &le; <b>C</b> &le; 10<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n3 &le; <b>N</b> &le; 10<sup>10</sup><br/>\n1 &le; <b>X</b> &le; 10<sup>10</sup><br/>\n0 &le; <b>C</b> &le; 1000<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n1\n3 4\n1 4 0\n6\n3 5\n5 2 0\n5 1 2\n1 3 0\n1 2 2\n2 3 0\n3 4 0\n3\n2 3\n1 3 0\n2 1 0\n3 2 0\n0\n6 4\n1\n2 3\n1 3 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 2\nCase #3: 0\nCase #4: 6\nCase #5: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first sample case, we have one car, going as in the picture in the statement. There are a number of ways allowing us to travel backwards for one second &mdash; for instance, we can enter at intersection 1 at time 1 (we can't enter at time zero, because the other car is there), and travel to intersection 4 (we can't go on to intersection 3, as we would pass the other car which will be going from 3 to 4). Another option is to enter at intersection 4 at time 0, and travel to intersection 3 (and then exit).\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0HVmKH4pb_UgARyRS-Ch8aaT1-09ay7pOlndloKbXSScxaXZ-JoJgR4742l_ldbYwcn_Ds/circle.png\">\n\n<p>\nIn the second sample case, we can travel for two seconds by entering at intersection 5 at time 1, and traveling backwards to intersection 3. In the third sample case, we can't even enter the circle - there are cars at all intersections at every full second. In the fourth case there are no cars, so we can just enter the circle at any point at time 0 and travel round and round till time 6. In the fifth case we can enter the circle, but since there are only three intersections, we will always collide with the other car if we try to move to the next one.\n</p>\n\n<p>Note: Driving against the direction of the traffic on a traffic circle is typically not a wise thing to do and may cause harm to you or other people. Google (and Google Code Jam in particular) encourages you not to try this.</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Graduation Requirements","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem can be viewed as a modified version of finding the minimum width of a convex hull [1] which can be solved using a modified version of the rotating calipers technique [2,3]. We present below the intuition on why the problem is similar to finding the modified minimum width of the convex hull.\n</p>\n\n<p>\nFirst off, we can plot the sequence of drum strikes as (<i>i, T<sub>i</sub></i> )on the 2-dimensional plane. If the drummer performs perfectly, then let's call the sequence <i> P<sub>i</sub></i> and (<i>i, P<sub>i</sub></i>) falls on the same line L (see <i>Figure 1</i> and <i>Figure 2</i>).\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1fvcDPLxfP--pKdvAWBPdYLwWVzTqWYSMnlIFeRcz8p4QjsA_kFp3cnNgiKddd5MwdKRABFRvztqviGhHb/drummer_figure1.png\">\n<br>\n<b>Figure 1</b>\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3cP2IhMVZWsxK2yTgKXYawTusPcUCB4mNOOK2ZASJm2hpfDxNgRKymaoLHxFVRNiP41NkZv5ceiTCROIqD/drummer_figure3.png\">\n<br>\n<b>Figure 2</b>\n</p>\n\n<p>\nUnfortunately the drummer does not perform perfectly and has error <i>E<sub>i</sub></i> (which is |<i>T<sub>i</sub> - P<sub>i</sub></i>|) (see Figure 3).\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3CErwDa1bQV0TqjFEUti0shE4HN4pZyfdbcI0JM7ZAatSL7dJD11SxnOTWypGd1SC3ivP11bOdRMKnkYGr/drummer_figure5.png\">\n<br>\n<b>Figure 3</b>\n</p>\n\n<p>\nSo in the example in Figure 3, we have our line <i>L</i>, and it is clear that our answer is the maximum among all <i>E<sub>i</sub></i>, which in this case is <i>E<sub>1</sub></i> (or <i>E<sub>2</sub></i> or <i>E<sub>4</sub></i>). If we draw two lines parallel to <i>L</i> shifted in the y-axis by <i>+E<sub>1</sub></i> and <i>-E<sub>1</sub></i>, denoted as <i>L<sub>+E<sub>1</sub></sub></i> and <i>L<sub>-E<sub>1</sub></sub></i> (see <i>Figure 3</i>), you will notice that the region between the two lines contains all the points (<i>i, T<sub>i</sub></i>); this example fits the definition of the problem which is a drum rhythm where each strike differs by at most <i>E</i> from some perfect rhythm. On the other hand, if we choose <i>E<sub>5</sub></i> as the error candidate, the region between the two lines <i>L<sub>+E<sub>5</sub></sub></i> and <i>L<sub>-E<sub>5</sub></sub></i> will not contain all the points (<i>i, T<sub>i</sub></i>) (see <i>Figure 4</i>).\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2xMdNMJjpj0Ptt3j500vDMLPY2FBA39aRd5U87jECy0zS9Txxp-kjUql2r5o0cAjWwbeOw2Dt4GWdDSitq/drummer_figure4.png\">\n<br>\n<b>Figure 4</b>\n</p>\n\n<p>\nIn essence, we want to find a line denoting the perfect rhythm and two parallel lines that are shifted in the y-axis by <i>+E</i> and <i>-E</i> such that the two parallel lines contain all the points (<i>i, T<sub>i</sub></i>) and also that <i>E</i> is the minimum possible value. We would like to point out that instead of trying to find the line with the perfect rhythm which can be a hard problem due to the error associated with each (<i>i, T<sub>i</sub></i>), we can instead focus on the equivalent problem of finding the two parallel lines. Note that each of these two lines must touch at least one point otherwise we can always reduce the distance between these two lines, and further reduce the distance on y-axis to get a smaller error <i>E</i>.\n</p>\n\n<p>\nIn fact, all candidate parallel lines touch (without intersecting) the convex hull of the points (<i>i, T<sub>i</sub></i>). Therefore we transform the problem to finding the minimum distance between two parallel lines in y-axis touching (without intersecting) the convex hull. For example, the convex hull of the points in <i>Figure 2</i> are shown in <i>Figure 5</i>.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1dfDSkTW5u9FPLtcG0y7A81kDFLIVq51bRWt_KvPf-kQOkWekXYG5b9m380gluj_6mZ_lkK0thwcvs6oz5/drummer_figure2.png\">\n<br>\n<b>Figure 5</b>\n</p>\n\n<p>\nTherefore to solve this problem, we first compute the convex hull of the points (<i>i, T<sub>i</sub></i>). Then we go through all the line segments on the boundary of the convex hull and find the corresponding parallel line on the opposite side of the convex hull (see <i>Figure 5</i> for some examples), then get the y-distance between these two parallel lines, and report the minimum among all such y-distances.\n</p>\n","id":"0000000000432feb","statement":"<h3>Problem</h3>\n<p>\nThe drummer has a very important role in any band -- keeping the rhythm. If the drummer's rhythm is uneven, it can ruin the entire performance.\n</p>\n\n<p>\nYou are the lead singer of a very popular rock band, and you have a bit of a problem. Your drummer has just quit the band to become a professional video gamer. You need to find a new drummer immediately. Fortunately, there is no shortage of candidates. Everyone wants a chance to join your band. Your task is to find the best drummer among the candidates, and you want the person who can keep the most consistent rhythm.\n</p>\n\n<p>\nYour plan is as follows. You will ask each candidate to audition individually. During the audition, the candidate will play one drum by striking it with a drum stick several times. Ideally, the time difference between consecutive strikes should be exactly the same, producing a perfect rhythm. In a perfect rhythm, the drum strikes will have time stamps that follow an arithmetic progression like this: <nobr>T<sub>0</sub>, T<sub>0</sub> + K, T<sub>0</sub> + 2*K, ..., T<sub>0</sub> + (<b>N</b> - 1)*K.</nobr>\n</p>\n\n<p>\nIn real life, of course, it is nearly impossible for a human to produce a perfect rhythm. Therefore, each candidate drummer will produce a rhythm that has an error <b>E</b>, such that each <nobr>T<sub>i</sub></nobr> differs by at most <b>E</b> from some perfect rhythm. Given a candidate's sequence of drum strikes, find the smallest possible <b>E</b> among all perfect rhythms that the candidate might have been trying to play.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one consists of two lines and represents the audition of one candidate. The first line contains a single integer -- <b>N</b>. The next line contains <b>N</b> integers separated by spaces -- the time stamps, in milliseconds, of the drum strikes played by the candidate. The time stamps are in increasing order.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: <b>E</b>\", where x is the case number (starting from 1) and <b>E</b> is the smallest among all possible numbers that describe the error of the candidate's drum strike sequence.\n</p>\n\n<p>\nYour answer will be considered correct if it is within an absolute or relative error of 10<sup>-6</sup> of the correct answer.  See the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an explanation of what that means, and what formats of floating-point numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>N</b> &le; 10.<br/>\n0 &le; T<sub>i</sub> &le; 100.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\nFor 90% of the test cases, 2 &le; <b>N</b> &le; 1000.<br/>\nFor all test cases, 2 &le; <b>N</b> &le; 50000.<br/>\n0 &le; T<sub>i</sub> &le; 10<sup>6</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2\n10 70\n4\n0 10 19 30\n6\n2 5 10 15 20 24\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 0.5\nCase #3: 0.75\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Drummer","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Dissecting the problem</h3>\n<p>The problem statement asks for the number of ways to remove elements from a sequence until we obtain a non-increasing sequence. Looking at the problem from the end, suppose we know the final non-increasing sequence, and it's of length <b>K</b>. Certain elements have been eliminated, and we removed <b>N</b>-<b>K</b> elements in total. There are (<b>N</b>-<b>K</b>)! (factorial of <b>N</b>-<b>K</b>) ways to remove those elements. So the first approximation seems to be to sum those factorials over all non-increasing subsequences of the the original sequence.</p>\n\n<p>However, this is not entirely correct. Some non-increasing subsequences are not even reachable since we stop as soon as our sequence becomes non-increasing. For example, in the second example from the problem statement the sequence is non-increasing from the start, so no proper subsequence is reachable at all. For subsequences that are reachable, not every way of reaching them might be possible. For example, in the first example from the problem statement we can reach the '7 &lt;first 6&gt;' subsequence (note, it should be considered different from '7 &lt;second 6&gt;' subsequence) by eliminating the second 6, and then 4. However, it can't be reached by doing those operations in reverse order, since we'd stop right after eliminating 4.</p>\n\n<p>Now instead of all (<b>N</b>-<b>K</b>)! ways to reach a certain subsequence, we need to count just the possible ways. The main trick in solving this problem is: let's count the impossible ways instead, and then subtract. The impossible ways are simply those when before the last removal, the subsequence was already a non-increasing sequence of length <b>K</b>+1. And for each such subsequence there are exactly <b>K</b>+1 ways to make an impossible removal and arrive at a subsequence of length <b>K</b>. That means the sum of numbers of impossible ways to reach all non-increasing subsequences of length <b>K</b> is equal to the total number of non-increasing subsequences of length <b>K</b>+1 times (<b>N</b>-<b>K</b>-1)! (the number of ways to reach the longer subsequence) times <b>K</b>+1.</p>\n\n<p>To summarize, suppose <b>A</b><sub><b>K</b></sub> is the number of non-increasing subsequences of length <b>K</b>. Then the answer to this problem is sum over <b>K</b> of <b>A</b><sub><b>K</b></sub>*(<b>N</b>-<b>K</b>)!-<b>A</b><sub><b>K</b>+1</sub>*(<b>N</b>-<b>K</b>-1)!*(<b>K</b>+1).</p>\n\n<h3>Solving the sub-problem</h3>\n\n<p>We've now reduced our problem to a much simpler one: find <b>A</b><sub><b>K</b></sub>. This problem can be solved used a somewhat standard dynamic programming approach, with a twist to make it run faster.</p>\n\n<p>First, let's assume that all input numbers are different, and between 0 and <b>N</b>-1. It's not hard to transform them in this way without changing the answer. If there are equal numbers, we'll slightly reduce the number to the right, so that non-increasingness of all subsequences is preserved.</p>\n\n<p>Our dynamic programming problem will now be: what is the number of non-increasing subsequences of length <b>P</b> that end with number <b>Q</b>? Let's call that number <b>B</b><sub><b>P</b>,<b>Q</b></sub>. We will find them in the order <b>Q</b>s appear in the sequence.</p>\n\n<p>It's not hard to see that <b>B</b><sub><b>P</b>,<b>Q</b></sub> is just the sum of <b>B</b><sub><b>P</b>-1,<b>Q'</b></sub> for all numbers <b>Q'</b> that are greater than <b>Q</b> and appear before <b>Q</b> in the sequence. Since we process the states in the order <b>Q</b>s appear in the sequence, we just need to take the sum over all <b>Q'</b> that are greater than <b>Q</b>.</p>\n\n<p>This is already a working solution for our problem, but it is a bit too slow: it runs in O(<b>N</b><sup>3</sup>) which is a bit too much for <b>N</b>=8000. We have O(<b>N</b><sup>2</sup>) states in our dynamic programming, and we need to find a sum of O(<b>N</b>) numbers to process each state. However, we can compute such sum faster! We just need an array-like data structure that supports changing elements and finding the sum of its suffix (over all <b>Q'</b> that are greater than <b>Q</b>), and the <a href=\"http://en.wikipedia.org/wiki/Fenwick_tree\" target=\"_blank\">Fenwick tree</a> is a data structure that does exactly that, performing each operation in O(log<b>N</b>) time, for a total running time of O(<b>N</b><sup>2</sup>*log<b>N</b>).</p>","id":"0000000000433107","statement":"<h3>Problem</h3>\n<p>\nThe story goes...\n</p>\n\n<p><i>\nA long, long time ago, King Tyrone the Fair had 4 ministers. The first minister (the king's top adviser) was paid 7 gold pieces per week. The second minister was paid 4 gold pieces per week. The third and fourth ministers were each paid 6 gold pieces per week. Unfortunately, Tyrone accidentally forgot the Ministerial Compensation List in the photo copier one day, and the List ended up on the front page of the Kingdom Times newspaper. At this point, the second minister requested to speak to the king, upset that his own salary was lower than that of the lower ranked third minister.\n</i></p>\n\n<p><i>\nHis Fairness King Tyrone saw no other solution than to fire the third minister. After all, lowering the third minister's salary, raising the salary of the second minister, or changing job titles were all unfair solutions to the problem, in the king's opinion. And who are we to question King Tyrone? Of course, firing the third minister did not solve the problem. The second minister continued to complain because his salary was still lower than that of the fourth minister. So King Tyrone fired the fourth minister as well. At this point, neither of the two remaining ministers complained, and everyone lived happily ever after.\n</i></p>\n\n<p>\n...wait a minute. I messed that up. I'm sorry. My memory is not what it used to be. One moment please... Right. King Tyrone the Fair. Four ministers. Paid 7, 4, 6, and 6 respectively. Ah, yes. The ending went like this...\n</p>\n\n<p><i>\nWhen the second minister complained of unfairness, King Tyrone fired the first minister. Some might say this was a bit harsh, as the first minister wasn't involved in any way, but we shouldn't question King Tyrone. Obviously, the second minister still complained, so King Tyrone simply fired him. Of the remaining two ministers, each one was being paid at least as much as any minister below him, so none of them complained. And everyone lived happily ever after.\n</i></p>\n\n<p>\nMuch better... I think. Maybe? Now I'm not sure anymore. I know for certain that there were <b>N</b> ministers, and I clearly remember their salaries. I also know that every time a minister's salary was lower than the salary of a minister below him, somebody would complain, and <i>some minister</i> got fired; but that it could have been <i>any minister</i>, regardless of whether that minister had anything at all to do with the problem. Ministers continued to be fired until no one complained because all of the salaries were non-increasing. At that point, the firings stopped. But I do not remember in which order the ministers got fired.\n</p>\n\n<p>\nCan you help me fix my story? Or at least please tell me how many different stories I could have told. Two stories are different if the sequences of fired ministers in them are not the same.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one consists of two lines. The first line will contain an integer <b>N</b>, and the second line will contain <b>N</b> space-separated integers denoting the ministers' salaries, in order from the first minister to the <b>N</b>'th minister.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of stories I could tell you, modulo 10007.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nEach salary will be positive and at most 10000.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\nFor 80% of test cases, 1 &le; <b>N</b> &le; 2000.<br/>\nFor all test cases, 1 &le; <b>N</b> &le; 8000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n7 4 6 6\n8\n90 80 70 60 50 50 40 30\n2\n7 8\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 14\nCase #2: 1\nCase #3: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":50}],"title":"Let Me Tell You a Story","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<b>Divide and Conquer</b><p>\nThere is a nice divide-and-conquer solution. Split the input down the middle; the best interval is either entirely in the left half, entirely in the right half, or crosses the middle. We handle the right and left cases recursively; if we can handle the \"crosses\" case in linear time, we will have an <code>O(N lg N)</code> algorithm, which is good enough.\n<p>\nIf the best interval crosses the middle, we know it must use the middle element, so we must pick one of the <b>D</b> numbers in that roll to use. Now go out as far as we can to the left and right with that number. Once we stop, we can extend either to the left or the right, so there are <code>2D</code> different numbers to try. Expand again, and get <code>2D</code> more numbers to try for a final expansion. In total, we only tried <code>D*2D*2D</code> different choices, so the whole thing runs in <code>256N</code> time, and we get our <code>O(N lg N)</code> time algorithm.\n<p>\nNote: surprisingly for a divide and conquer algorithm, we don't use any information from the left and right halves to solve the middle case; the fact that it crosses is enough.\n\n<p><b>Slow and Simple</b><p>\nThere's another set of approaches to this problem. Try every starting position, expanding out to the right and only making choices when necessary (just as in the divide-and-conquer). This is <code>O(D<sup>K</sup> * N)</code> for each starting position, or <code>O(D<sup>K</sup> * N<sup>2</sup>)</code> overall, which is too slow. However, there are several different improvements (some small, some large) one could make in order to make this linear in N.\n\n<p><b>Linear Time</b><p>\nOne improvement works in this way: Every time you pick a number, check if the roll before your starting position contains that number. If so, we can safely ignore that choice (because we would have done better starting one roll earlier and choosing the same set of numbers).\n<p>\nIt turns out that this runs in linear time, but the reason why isn't obvious. We want to prove that a particular index <code>i</code> is only visited from <code>O(1)</code> starting positions. Imagine we have reached <code>i</code> from <code>start</code>. Now imagine starting at <code>i</code> and going leftward (as usual, we expand left as far as possible before picking each new number). If we only choose numbers from the set that got us from <code>start</code> to <code>i</code>, we must get back to <code>start</code> (and no further, since the optimization above guaranteed that <code>start - 1</code> doesn't contain any of our numbers). But there are only <code>1 + D + D<sup>2</sup> + D<sup>3</sup></code> different choices of numbers starting from <code>i</code>, so there are only that many possible positions for <code>start</code>, so <code>i</code> will only be visited <code>O(D<sup>3</sup>)</code> times.\n</p>","id":"000000000043333a","statement":"<h3>Problem</h3>\n<p>\nThis problem was inspired by a board game called Can't Stop, designed by Sid Sackson. This problem has a similar idea, but does not assume you have played Can't Stop.\n</p>\n\n<p>\nYou're playing a (very large) board game. In this game, you're given a sequence of <b>N</b> <i>roll sets</i>. Each roll set consists of <b>D</b> die rolls. Each die roll is an integer.\n</p>\n\n<p>\nTo win the game, you have to find the largest <i>totally awesome interval</i> of the sequence. An interval is any consecutive sequence of roll sets. An interval is called totally awesome if there exist <b>k</b> numbers such that every roll set in the interval contains at least one of those <b>k</b> numbers.\n</p>\n\n<p>\nFor example, suppose <b>D</b>=2 and <b>k</b>=3, and the roll sets are as follows:\n<pre>\nSet 0: 10 20\nSet 1: 50 60\nSet 2: 70 30\nSet 3: 40 40\nSet 4: 30 30\nSet 5: 20 40\n</pre>\nThe interval from Set 0 to Set 2 is totally awesome because roll sets 0-2 all contain 10, 50 or 70.  The interval from Set 1 to Set 5 is totally awesome because roll sets 1-5 all contain 50, 30 or 40. That interval contains 5 roll sets, and it is the largest totally awesome interval.\n</p>\n\n<p>\nYour job is to output the indices of the first and last roll set in the longest totally awesome interval. If there are multiple totally awesome intervals of that length, output the indices for the one with the lowest first index. Note that the first roll set has index 0.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case starts with three space-separated integers: <b>N</b>, <b>D</b> and <b>k</b>, as described above.  On the next line, there will be <b>N</b>*<b>D</b> integers. The first <b>D</b> integers will be the rolls from the first roll set; the second <b>D</b> integers will be the rolls from the second roll set; and so on.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y z\", where x is the case number (starting from 1), and y and z are the first and last indices of the longest totally awesome interval (with ties broken using the lowest index), as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>D</b> &le; 4.<br/>\n1 &le; every die roll &le; 10<sup>5</sup>.<br/>\nFor 6 test cases, 1 &le; <b>N</b> &le; 10<sup>5</sup>.<br/>\nFor all the other test cases, 1 &le; <b>N</b> &le; 10<sup>3</sup>.<br/> \n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n<b>k</b> = 2.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n2 &le; <b>k</b> &le; 3.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n8 1 2\n1 2 3 2 4 5 4 6\n4 3 2\n1 2 3 4 5 6 7 8 9 10 11 12\n6 2 3\n10 20 50 60 70 30 40 40 30 30 20 40\n10 1 3\n2 4 3 1 4 5 3 1 1 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1 3\nCase #2: 0 1\nCase #3: 1 5\nCase #4: 1 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe board game Can't Stop was designed by Sid Sackson, and has been published by many publishers. Neither Mr. Sackson nor any of the publishers endorses, or has any involvement with, Google Code Jam.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":32}],"title":"Can't Stop","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000004331a0","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2013"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
