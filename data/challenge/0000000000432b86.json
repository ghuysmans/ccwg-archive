{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1368358200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432b86","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>The last Round 1 again had an attendance in the vicinity of 5000 &mdash; pretty impressive, given that 2000 people already advanced. Our contestants were faced with a substring-counting problem Consonants, where to solve the large you had to deal with million-character names; followed by the tricky puzzle of Pogo and an implementation-intense problem called Great Wall.</p>\n\n<p>The large input size in consonants caused the solutions of a large number of contestants to time out &mdash; quadratic solutions weren't cutting it, after all, and nearly 60% of contestants who attempted the large failed. The large of pogo was even more tricky &mdash; while for the small you could do some variation around exhaustive search, for the large you needed a few observations to come up with a greedy solution. Only 19% of contestants who attacked this problem succeeded. Finally, the Great Wall had a rather complex input that scared many people off, the first submission for the small came over half an hour into the contest; and the large required some variation on the theme of interval trees.</p>\n\n<p>The competition was off to a blazing start, with xiaowuc1 solving the small of Consonants in an astounding time below two minutes! The other problems proved more problematic, however. In the end, it turned out that solving any one problem by itself was not enough to advance. The most popular way to get a spot in Round 2 was to deal with Consonants large and both remaining smalls, followed by dropping the Great Wall small in favor of doing the other problems really fast.</p>\n\n<p>Congratulations to everybody who got through to Round 2, and we hope you enjoyed all the Round 1 problems!</p>\n\n<hr/>\n<p>Cast</p>\n<p>Problem A. <i>Consonants</i> written by Khaled Hafez and Petr Mitrichev. Prepared by Onufry Wojtaszczyk and Hackson Leung.</p>\n\n<p>Problem B. <i>Pogo</i> written by David Arthur. Prepared by Onufry Wojtaszczyk and Ahmed Aly.</p>\n\n<p>Problem C. <i>The Great Wall</i> written by Onufry Wojtaszczyk. Prepared by Adrian Kuegel and Steve Thomas.</p>\n\n<p>Contest analysis presented by Onufry Wojtaszczyk, John Dethridge and Hackson Leung. Solutions and other problem preparation by Igor Naverniouk, Jan Kuipers, Tomek Czajka and Tomek Kulczynski.</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1368349200000,"tasks":[{"analysis":"<h2> The small input </h2>\n<p>\nDespite the very long statement, solving the small input wasn't actually that hard. Still, the long statement scared many contestants off, which is probably why we saw the first submission only after half an hour of the contest, and relatively few submissions to the problem in general. With at most 10 tribes, at most 10 attacks and all the attacks happening on a short section of the Wall, we can just simulate all that happens. Let's look at it a bit more carefully.\n</p>\n\n<p>\nSince <b>delta_p</b> is limited by 10, a tribe attacks at most 10 times, and the initial attack is between -100 and 100, all the attacks will occur between -200 and 200. Thus, we can afford to remember the height of the wall at each interesting point. This brings us to the first trick of this problem &mdash; what are the points we should be interested in?\n</p>\n\n<p>\nNote that since the edges of attacked areas are always integers, the height of the wall in each open interval (<i>x, x+1</i>) for integral <i>x</i> is always constant. Moreover, the height at the integral points is never lower than at any of the two neighboring open intervals, since any attack that affects any of these intervals will also affect the integral point next to it. As <b>w<sub>i</sub></b> &lt; <b>e<sub>i</sub></b>, any attack always affects at least one whole interval, and so the success of the attack depends only on the height of the wall in the intervals, and not on the edges. Thus, it is enough to keep information about the height of the wall in points of the form <b>x</b> + 0.5 for integral <b>x</b>. There are 400 such points to consider in the small input, and the height of each is initially zero.\n</p>\n\n<p>\nThere are a 100 attacks to consider. We can begin by generating all of them explicitly (noting the beginning and end point, day and strength for each of them), and sorting them by time of occurrence. For each day on which at least one attack occurs, we first check for each attack whether it succeeds (by examining the wall height at each attacked interval). Afterwards, for all attacks we go over all affected intervals and increase the height of the wall if necessary. Note that it is important to increase the wall height only after checking <i>all</i> the attacks that occur on a given day.\n</p>\n\n<h2> The large input </h2>\n<p>\nThe numbers are much bigger for the large input. We can have 10<sup>6</sup> attacks, and they can range over an interval of length over 10<sup>8</sup>. Let's analyse which parts of the previous approach will work, and which will not.\n</p>\n\n<p>\nWe can still generate all the attacks explicitly, and sort them by time. We probably need a more concise way to represent the Wall, though, and we surely need a faster way to check whether an attack succeeds and updating wall heights.\n</p>\n\n<p>\nThe problem of concise representation can be solved by noticing that since we have only 10<sup>6</sup> attacks, we will have around 10<sup>6</sup> interesting points. A sample way to take advantage of this it to \"compress\" all attack coordinates &mdash; sort all the coordinates that are beginnings or ends of attacks, and consider as interesting only the points in the middles of intervals of adjacent endpoints. We will end up with at most 2 x 10<sup>6</sup> points, and each will represent an interval such that the height of the wall on this interval is always the same. Using this tric to compress the attack coordinates, we can assume all attacks happen in a space of at most 2 x 10<sup>6</sup> points. We can rename these points to be consecutive for convenience.\n</p>\n\n<p>\nTo attack the problem of checking attack success and updating the wall, we will need some variant of an <a href=\"http://en.wikipedia.org/wiki/Interval_tree\" target=\"_blank\">interval tree</a>. We will present two interval-tree based approaches below.\n</p>\n\n<p>\nAn interval tree is a tree, in which each node represents an interval [<b>m</b> x 2<sup><b>k</b></sup>, <b>m</b> x 2<sup><b>k</b></sup>] for some <b>m,k</b>. The parent of a node containing an interval <b>I</b> will be the node representing a twice longer interval containing <b>I</b> (so, if <b>I</b> is [<b>m</b> x 2<sup><b>k</b></sup>, <b>m</b> x 2<sup><b>k</b></sup>], the parent is [(<b>m</b> / 2) x 2<sup><b>k+1</b></sup>, (<b>m</b>/2 + 1) x 2<sup><b>k+1</b></sup>]). This is the common pattern for interval trees, the trick is in what to store in nodes.\n</p>\n\n<h2> High and low</h2>\n<p>\nIn the first approach, we will try to answer the questions directly by the means of using a modified interval tree. We will store two values in each node &mdash; hi and lo. The \"hi\" value will be pretty standard, and will be defined so that the height of the wall at any given point is the maximum \"hi\" value of all the intervals containing this point. This can be updated in logarithmic time when any interval of the wall is attacked - we can split any interval into a logarithmic number of intervals represented by nodes, and update the hi value in each of them. This will allow us to update the wall height, and to figure out what the height of the wall at a given point is, each in logarithmic time. We still need a way to figure out whether an attack will succeed in logarithmic time, though.\n</p>\n\n<p>\nWe will use the \"lo\" values for that. For a given node <b>X</b> and a path to a leaf from <b>X</b> we can define the maximum \"hi\" value on this path as the \"partial height\" of the leaf node. This is what would be the height, if we disregarded all the nodes above <b>X</b> (in particular, \"partial heights\" measured from the root node are simply wall heights). We now define the \"lo\" value of <b>X</b> as the smallest partial height of a descendant of <b>X</b>. We need to see how this is useful, and how to update it in logarithmic time when updating the \"hi\" values.\n</p>\n\n<p>\nNote that if we have a \"lo\" value for a node calculated, we can easily figure out the height of the lowest wall point in this interval - it's the maximum of the \"lo\" value of this node and the \"hi\" values of all the ancestors of this node. Thus, to figure out whether an attack will succeed on a general interval we split it into a logarithmic number of intervals represented by nodes, and figure out the lowest wall segment in each of these sub-intervals. If any of these is lower than the strength of the attack, it will succeed. This is logarithmic-squared as described, but it's easy to implement it to actually be logarithmic.\n</p>\n\n<p>\nNow note that the \"lo\" values have a simple recursive definition - take the minimum of the \"lo\" values of the children, or the \"hi\" value of the node itself, whichever is higher. This means that when updating the \"hi\" value for a node, we only need to update the \"lo\" values for this node and its ancestors - meaning we can update \"lo\" values in logarithmic-squared time for each attack (and, again, it's simple to update them in logarithmic time).\n</p>\n\n<h2> Order by strength </h2>\n<p>\nAnother approach that allows us to solve this problem with an interval tree is to order the attacks by strength, descending, and not by chronology. In this approach, for each point we know what was the earliest time at which it was attacked. Note that since we process from the strongest attack, any section of the wall that was attacked earlier by an attack we already processed is immune to attacks that come later and are processed later. Thus, to learn whether the attack is successful we need to find what's the latest attack time in the whole interval this attack covers; and subsequently we need to update the attack times to the minimum of the time that was stored so far, and the time of the currently processed attack.\n</p>\n\n<p>\nThis is called a min-max interval tree (we update with the minimum, and we query for the maximum). We encourage you to figure out what to store in the nodes to make this work in logarithmic time!\n</p>","id":"0000000000432f3d","statement":"<h3>Problem</h3>\n<p>\nYou are studying the history of the <a href=\"http://en.wikipedia.org/wiki/Great_Wall_of_China\" target=\"_blank\">Great Wall of China</a>, which was built by the Chinese to protect against military incursions from the North. For the purposes of this problem, the Great Wall stretches from infinity in the East to minus infinity in the West. As this is a lot of distance to cover, the Great Wall was not built at once. Instead, for this problem we assume that the builder used a reactive strategy: whenever a part of the border was attacked successfully, the Wall on this part of the border would be raised to the height sufficient to stop an identical attack in the future.\n</p>\n\n<p>\nThe north border of China was frequently attacked by nomadic tribes. For the purposes of this problem, we assume that each tribe attacks the border on some interval with some strength <i>S</i>. In order to repel the attack, the Wall must have height <i>S</i> all along the defended interval. If even a short stretch of the Wall is lower than needed, the attack will breach the Wall at this point and succeed. Note that even a successful attack does not damage the Wall. After the attack, every attacked fragment of the Wall that was lower than <i>S</i> is raised to height <i>S</i> &mdash; in other words, the Wall is increased in the minimal way that would have stopped the attack. Note that if two or more attacks happened on the exact same day, the Wall was raised only after they all resolved, and is raised in the minimum way that would stop all of them.\n</p>\n\n<p>\nSince nomadic tribes are nomadic, they did not necessarily restrict themselves to a single attack. Instead, they tended to move (either to the East or to the West), and periodically attack the Wall. To simplify the problem, we assume they moved with constant speed and attacked the Wall at constant intervals; moreover we assume that the strength with which a given tribe attacked the Wall changed by a constant amount after each attack (either decreased from attrition, or grew from experience).\n</p>\n\n<p>\nAssuming that initially (in 250 BC) the Wall was nonexistent (i.e., of height zero everywhere), and given the full description of all the nomadic tribes that attacked the Wall, determine how many of the attacks were successful.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case begins with a line containing a single integer <b>N</b>: the number of the tribes attacking the Wall. <b>N</b> lines follow, each describing one tribe. The <b>i</b>th line contains eight integers <b>d<sub>i</sub></b>, <b>n<sub>i</sub></b>, <b>w<sub>i</sub></b>, <b>e<sub>i</sub></b>, <b>s<sub>i</sub></b>, <b>delta_d<sub>i</sub></b>, <b>delta_p<sub>i</sub></b> and <b>delta_s<sub>i</sub></b> separated by spaces, describing a single nomadic tribe:\n</p>\n<p>\n<ul>\n<li><b>d<sub>i</sub></b> &ndash; the day of the tribe's first attack (where 1st January, 250BC, is considered day 0)</li>\n<li><b>n<sub>i</sub></b> &ndash; the number of attacks from this tribe</li>\n<li><b>w<sub>i</sub></b>, <b>e<sub>i</sub></b> &ndash; the westmost and eastmost points respectively of the Wall attacked on the first attack</li>\n<li><b>s<sub>i</sub></b> &ndash; the strength of the first attack</li>\n<li><b>delta_d<sub>i</sub></b> &ndash; the number of days between subsequent attacks by this tribe</li>\n<li><b>delta_p<sub>i</sub></b> &ndash; the distance this tribe travels to the east between subsequent attacks (if this is negative, the tribe travels to the west)</li>\n<li><b>delta_s<sub>i</sub></b> &ndash; the change in strength between subsequent attacks</li>\n</ul>\n</p>\n\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of attacks that succeed.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 60 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n0 &le; <b>d<sub>i</sub></b>.<br/>\n1 &le; <b>delta_d<sub>i</sub></b> &le; 676060.<br/>\n<b>d<sub>i</sub></b> + (<b>n<sub>i</sub></b> - 1) * <b>delta_d<sub>i</sub></b> &le; 676060.<br/>\n1 &le; <b>s<sub>i</sub></b> &le; 10<sup>6</sup>.<br/>\n-10<sup>5</sup> &le; <b>delta_s<sub>i</sub></b> &le; 10<sup>5</sup>.<br/> \n<b>s<sub>i</sub></b> + (<b>n<sub>i</sub></b> - 1) * <b>delta_s<sub>i</sub></b> &ge; 1.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 10.<br/>\n1 &le; <b>n<sub>i</sub></b> &le; 10.<br/>\n-100 &le; <b>w<sub>i</sub></b> &lt; <b>e<sub>i</sub></b> &le; 100.<br/>\n-10 &le; <b>delta_p<sub>i</sub></b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>n<sub>i</sub></b> &le; 1000.<br/>\n-10<sup>6</sup> &le; <b>w<sub>i</sub></b> &lt; <b>e<sub>i</sub></b> &le; 10<sup>6</sup>.<br/>\n-10<sup>5</sup> &le; <b>delta_p<sub>i</sub></b> &le; 10<sup>5</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2\n0 3 0 2 10 2 3 -2\n10 3 2 3 8 7 2 0\n3\n1 2 0 5 10 2 8 0\n0 3 0 1 7 1 2 2\n3 3 0 5 1 1 4 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5\nCase #2: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first case, the first tribe attacks three times: on day 0 it hits the interval [0,2] at height 10, on day 2 it hits [3,5] at height 8 and on day 4 it hits [6,8] at height 6; all three attacks succeed. Then the second tribe attacks three times, each time at height 8 - on day 10 it hits [2,3] (this succeeds, for example at position 2.5, where the Wall has still height 0), on day 17 it hits [4,5] (this fails, the Wall is already of height 8 in the interval [3, 5], which covers [4, 5]), and on day 24 it hits [6,7] (this succeeds, as the Wall there was of height 6).\n</p>\n\n<p>\nIn the second case there are three tribes, and their attacks intermingle. The sequence is as follows:\n<ul>\n<li> On day 0, Tribe 2 attacks [0,1] at height 7 and succeeds. </li>\n<li> On day 1, Tribe 1 attacks [0,5] at height 10, and Tribe 2 attacks [2,3] at height 9. Both attacks succeed (as they were simultaneous, the Wall built after the attack of the first tribe isn't there in time to stop the second tribe).</li>\n<li> On day 2, Tribe 2 attacks [4,5] at height 11 and succeeds (the Wall there was at height 10). </li>\n<li> On day 3, Tribe 1 attacks [8,13] at height 10 and succeeds. Simultaneously, Tribe 3 attacks [0,5] at height 1 and fails (there's a Wall of heights 10 and 11 there).</li>\n<li> On day 4 Tribe 3 attacks [4,9] at height 1 and succeeds (there was no Wall \nbetween 5 and 8). </li>\n<li> Finally, on day 5 Tribe 3 attacks [8,13] at height 1 and fails (since a Wall of height 10 is there).</li>\n</ul>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":28}],"title":"The Great Wall","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>The small dataset</h2>\n<p>The small dataset did not require finding the optimal solution, instead accepting any solution that solved the problem within 500 moves. This allowed for a variety of approaches. One such approach is as follows: note that with two subsequent jumps in two opposite directions you can move one unit in a chosen direction. By a sequence of at most 200 such pairs (so in total at most 400 moves) you can reach any point with |X|, |Y| &le; 100.\n</p>\n\n<p>\nThere were also other approaches possible, for instance a shortest-path search, if one could prove or guess that it's OK to limit the search space somehow. It turns out that one can actually just search for a path within the points with |x|, |y| &le; 100, we will see why in the next section. Thus, Dijkstra's algorithm or just breadth-first search will provide a short enough path to the target.\n</p>\n\n<h2>The large dataset </h2>\n<p>\nFor the large dataset, we not only need to return the best possible solution, but also deal with more distant targets, so neither of the approaches above will work. We will begin with a few easy observations:\n<ul>\n<li>First, if we want to reach the target in <b>N</b> moves, we have to have 1 + 2 + ... + <b>N</b> &ge; |<b>X</b>| + |<b>Y</b>|.</li>\n<li>Moreover, if we want to reach the target in <b>N</b> moves, the parity of the numbers 1 + 2 + ... + <b>N</b> and |<b>X</b>| + |<b>Y</b>| has to be the same. This is because the parity of the sum of the lengths of jumps we make in the North-South direction has to match the parity of |<b>Y</b>|, and the sum of lengths of West-East jumps has to match the parity of |<b>X</b>|.</li>\n</ul>\nIt turns out that if <b>N</b> satisfies these two conditions, it is possible to reach (X, Y) with <b>N</b> jumps.\n</p>\n\n<p>\nLet's consider a point (<b>X</b>, <b>Y</b>), and any <b>N</b> satisfying the two conditions above. For the sake of brevity, assume |<b>X</b>| &ge; |<b>Y</b>|, and <b>X</b> &ge; 0 (it's easy to provide symmetric arguments for the other four cases). In this case, we will assume the last move was East. This means the first <b>N</b>-1 moves have to reach (<b>X</b>-<b>N</b>, <b>Y</b>). We will proceed recursively, so we just have to prove that (<b>X</b>-<b>N</b>, <b>Y</b>) and <b>N</b>-1 satisfy the conditions above.\n</p>\n\n<p>\nFor <b>N</b> = 1 or 2, it's easy to enumerate all the possible <b>X</b> and <b>Y</b>. For <b>N</b> = 1, there are four possibilities, and in each case our strategy produces the correct move. For <b>N</b> = 2, if we assume <b>X</b> is positive and greater than |<b>Y</b>|, the only possibilities are (3, 0), (2, 1), (2, -1) and (1, 0); after the move they turn to (1, 0), (0, 1), (0, -1) and (-1, 0) &mdash; all of which satify the conditions for <b>N</b> = 1.\n</p>\n\n<p>\nFor larger <b>N</b>, the parity condition is trivial &mdash; both considered parities stay the same if <b>N</b> was even, and both change if <b>N</b> is odd. For the inequality condition, if <b>N</b> &le; <b>X</b>, both sides just decrease by <b>N</b>, so the only interesting case is if <b>X</b> &lt; <b>N</b>. However, in this case, we move to (<b>X</b> - <b>N</b>, <b>Y</b>), and the sum of absolute values is <b>N</b> - <b>X</b> + |<b>Y</b>| &le; <b>N</b> - <b>X</b> + <b>X</b> = <b>N</b> &le; 1 + ... + <b>N</b> - 1. Thus, the conditions are satisfied after one move, and we can continue with our strategy.\n</p>\n\n<p>\nThis logic again translates to simple code:\n<pre>\ndef Solve(x, y):\n  N = 0\n  sum = 0\n  while sum &lt; abs(x) + abs(y) or (sum + x + y) % 2 == 1:\n    N += 1\n    sum += N\n  result = \"\"\n  while N &gt; 0:\n    if abs(x) &gt; abs(y):\n      if x &gt; 0: \n        result += 'E'\n        x -= N\n      else:\n        result += 'W'\n        x += N\n    else:\n      if y &gt; 0:\n        result += 'N'\n        y -= N\n      else:\n        result += 'S'\n        y += N\n    N -= 1\n  return result.reversed()\n</pre>\n","id":"0000000000433102","statement":"<h3>Problem</h3>\n<p>\nYou have just got the best gift ever, a Pogo stick. The pogo stick is something you use to jump off the ground while standing on it.\n<br><br>\nThis Pogo stick is a special one: the first jump will move you a distance of 1 unit, the second jump will move you 2 units, the third jump will move you 3 units and so on. You can jump in only four directions using this stick: north (increasing y), south (decreasing y), east (increasing x) or west (decreasing x).\n<br><br>\nNow you want to play a game in your backyard, which we model as an infinite plane. You are standing with your stick in at point (0, 0) and you want to go to point (<b>X</b>, <b>Y</b>).\n<br><br>\nThe point (<b>X</b>, <b>Y</b>) will never be (0, 0), and it will always be reachable from your starting point.\n<br><br>\n<b>Check the output section carefully</b>, because the required outputs for the small and large datasets are not the same.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, one per line. Each line consists of 2 integers separated by a single space, <b>X</b> and <b>Y</b>, the coordinates of the point you want to reach.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is a string represents the directions of the moves, for example if you are going to move north then south then east then west, this string should be NSEW.\n<br><br>\nFor the small dataset, the output is considered correct if it does not take more than 500 moves to reach the destination in each test case.\n<br><br>\nFor the large dataset, the output is considered correct if it reaches the destination point in the minimum possible number of moves.\n<br><br>\nIf there are multiple correct solutions, print any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 50.<br>\n0 &le; |<b>X</b>|, |<b>Y</b>| &le; 100.<br>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 100.<br>\n0 &le; |<b>X</b>|, |<b>Y</b>| &le; 10<sup>6</sup>.<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 4\n-3 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: ENWSEN\nCase #2: ENSWN\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe output for the first sample test case will not be considered correct if it is in the large dataset, because the number of moves is not the minimum. WNSEN would be a correct output for this test case if it were in the large dataset.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Pogo","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Solving the small</h2>\n<p>\nIt cannot be simpler than trying each possible substring  given the name. For a given substring, we just check if there exists <b>n</b> consecutive consonants. If it is true, we count this substring into part of the <b>n</b>-value. There are O(<b>L</b><sup>2</sup>) substrings, and it takes O(<b>L</b>) time to check for at least <b>n</b> consecutive consonants. In total each case takes O(<b>L</b><sup>3</sup>) time to solve, which is acceptable to solve the small input. This approach is, of course, not fast enough to solve the large input.\n</p>\n<h2>Improving the naive algorithm</h2>\n<p>\nIn fact we can skip the linear time checking for all possible substrings. Here we assume the index is zero based. Suppose we start from the <b>i</b>-th character. We also have <b>c</b> that starts as zero. When we iterate up to the <b>j</b>-th character, if it is a consonant, we increase <b>c</b> by 1, otherwise reset it to zero. Actually <b>c</b> is the number of consecutive consonants that starts after the <b>i</b>-th character and ends at the <b>j</b>-th character. If we meet the first instance such that <b>c</b> &ge; <b>n</b>, we can conclude that every substring which starts at the <b>i</b>-th character and ends at the <b>k</b>-th character, where <b>k</b> &ge; <b>j</b>, is the desired substring. Then we know that we can add <b>L</b> - <b>j</b> to the answer, and proceed to the next starting character. This algorithm runs in O(<b>L</b><sup>2</sup>) time, which is still not sufficient in solving the large input. But the concept of computing <b>c</b> is the key to solve the problem completely.\n</p>\n<h2>Further improving</h2>\n<p>\nLet us extend the definition of <b>c</b> to every character, call it <b>c<sub>i</sub></b>: the number of consecutive consonants that ends at the <b>i</b>-th character. For example, suppose the string is <b>quartz</b>, then <b>c<sub>0</sub></b> = 1, <b>c<sub>2</sub></b> = 0, and <b>c<sub>5</sub></b> = 3. We can use similar approach mentioned in the last section to compute every <b>c<sub>i</sub></b> in O(<b>L</b>) time. Also define a pair (<b>x</b>, <b>y</b>) to be the substring that starts at the <b>x</b>-th character and ends at the <b>y</b>-th character.\n</p>\n<p>\nKnowing from the previous section, if we know that <b>c<sub>i</sub></b> &ge; <b>n</b>, then we know that substrings (<b>i</b> - <b>c<sub>i</sub></b> + <b>p</b>, <b>i</b> + <b>q</b>), where 1 &le; <b>p</b> &le; <b>c<sub>i</sub></b> - <b>n</b> + 1 and 0 &le; <b>q</b> &le; <b>L</b> - <b>i</b> - 1, are the desired substrings. It implies that there are (<b>c<sub>i</sub></b> - <b>n</b> + 1) &times; (<b>L</b> - <b>i</b>) substrings. If you proceed like this, you missed some substrings. Consider the string <b>axb</b> with <b>n</b> = 1. We see that <b>c<sub>1</sub></b> = 1 but we only count 2 substrings, namely <b>x</b> and <b>xb</b>. We miss the <b>prefix</b> options, namely <b>ax</b> and <b>axb</b>. It looks like we can consider the substrings (<b>p</b>, <b>i</b> + <b>q</b>), where 0 &le; <b>p</b> &le; <b>i</b> - <b>n</b> + 1 and 0 &le; <b>q</b> &le; <b>L</b> - <b>i</b> - 1. Unfortunately, in this case we may count certain substrings multiple times. Consider the string <b>xaxb</b> with <b>n</b> = 1, where we count <b>xax</b> and <b>xaxb</b> twice since <b>c<sub>0</sub></b> = <b>c<sub>2</sub></b> = 1.\n</p>\n<p>\nTo correctly count the substrings, we need to choose the appropriate range of <b>p</b>. In fact, we just need one more value: the last <b>j</b> &lt; <b>i</b> such that <b>c<sub>j</sub></b> &ge; <b>n</b>. Let <b>r</b> = <b>j</b> - <b>n</b> + 2 if there is such <b>j</b>, or <b>r</b> = 0 otherwise. Then we have the right set of substrings (<b>p</b>, <b>i</b> + <b>q</b>), where <b>r</b> &le; <b>p</b> &le; <b>i</b> - <b>n</b> + 1 and 0 &le; <b>q</b> &le; <b>L</b> - <b>i</b> - 1. In fact, <b>r</b> means the longest possible prefix so that (<b>r</b>, <b>i</b> - <b>n</b>) contains at most <b>n</b> - 1 consecutive consonants and therefore we avoid repeated counting. Hence for each <b>c<sub>i</sub></b> &ge; <b>n</b> we count (<b>i</b> - <b>n</b> - <b>r</b> + 2) &times; (<b>L</b> - <b>i</b>). Summing up we have the answer. <b>r</b> is updated whenever we see that <b>c<sub>i</sub></b> &ge; <b>n</b> before iterating the next position. Therefore it takes constant time to update the value. Overall the running time is O(<b>L</b>), which is enough to solve the large input.\n</p>\n<p>\nDespite the complications, the algorithm is extremely simple. The following is a sample solution:\n<pre>\ndef Solve(s, n):\n  L = len(s)\n  cnt, r, c = 0, 0, 0\n  for i in range(L):\n    c = c + 1 if s[i] not in \"aeiou\" else 0\n    if c &gt;= n:\n      cnt += (i - n - r + 2) * (L - i)\n      r = i - n + 2\n  return cnt\n</pre>\n</p>","id":"0000000000433336","statement":"<h3>Problem</h3>\n<p>\nIn English, there are 26 letters that are either <b>vowels</b> or <b>consonants</b>. In this problem, we consider <b>a, e, i, o,</b> and <b>u</b> to be vowels, and the other 21 letters to be consonants.\n</p>\n<p>\nA tribe living in the Greatest Colorful Jungle has a tradition of naming their members using English letters. But it is not easy to come up with a good name for a new member because it reflects the member's social status within the tribe. It is believed that the less common the name he or she is given, the more socially privileged he or she is. \n</p>\n<p>\nThe leader of the tribe is a professional linguist. He notices that hard-to-pronounce names are uncommon, and the reason is that they have too many <b>consecutive consonants</b>. Therefore, he announces that the social status of a member in the tribe is determined by its <nobr><b>n</b>-value</nobr>, which is the number of substrings with at least <b>n</b> consecutive consonants in the name. For example, when <nobr><b>n</b> = 3</nobr>, the name \"quartz\" has the <nobr><b>n</b>-value</nobr> of 4 because the substrings <b>quartz</b>, <b>uartz</b>, <b>artz</b>, and <b>rtz</b> have at least 3 consecutive consonants each. A greater <nobr><b>n</b>-value</nobr> means a greater social status in the tribe. Two substrings are considered different if they begin or end at a different point (even if they consist of the same letters), for instance &quot;tsetse&quot; contains 11 substrings with two consecutive consonants, even though some of them (like \"<b>tse</b>tse\" and \"tse<b>tse</b>\") contain the same letters.\n</p>\n<p>All members in the tribe must have their names and <b>n</b> given by the leader. Although the leader is a linguist and able to ensure that the given names are meaningful, he is not good at calculating the <nobr><b>n</b>-values</nobr>. Please help the leader determine the <nobr><b>n</b>-value</nobr> of each name. Note that different names may have different values of <b>n</b> associated with them.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. The first line of each test case gives the name of a member as a string of length <b>L</b>, and an integer <b>n</b>. Each name consists of one or more lower-case English letters.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the <nobr><b>n</b>-value</nobr> of the member's name.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &lt; <b>n</b> &le; <b>L</b>.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>L</b> &le; 100.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>L</b> &le; 10<sup>6</sup>.<br/>\nThe input file will be no larger than 6MB.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\nquartz 3\nstraight 3\ngcj 2\ntsetse 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 11\nCase #3: 3\nCase #4: 11\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Consonants","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432b86","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2013"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
