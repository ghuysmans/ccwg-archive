{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1652545800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000008778ec","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Code Jam's 2022 Round 2 was a different kind of challenge, with no easy points on the table.\n  The first problem, <i>Spiraling Into Control</i> had competitors taking shortcuts through a strange\n  house with plenty of rooms. Some clever observations could be made that help solve this problem.\n  Next was <i>Pixelated Circle</i> which required some math and proofs to quickly identify missing\n  pixels in an incorrect implementation of a 2D circle-drawing program. <i>Saving the Jelly</i>\n  followed and required some matching and graph algorithms to help save Mr. Jolly's favorite candy.\n  Finally, <i>I, O Bot</i> rounded out the set with contestants helping a robot cleanup giant\n  beachballs after a giant moon party.\n</p><p>\n  <b>Um_nik</b> was the fastest to a perfect score at 1 hour and 46 minutes, and with no penalty\n  attempts, which assured them the top position. <b>Benq</b> followed just a few minutes behind, also\n  solving all four problems on their first try. <b>djq_cpp</b> rounded out the top 3 by solving all\n  four problems with few enough penalty attempts to secure their 3rd place position.\n  In the end, over 3000 contestants got a positive number of points.\n  The preliminary cutoff to advance to Round 3 is 25 points and a low enough penalty.\n</p><p>\n  The results will be reviewed in the coming days. Those who are in the top 1000 after the round is\n  finalized will advance to the last elimination round of the year! There are 3 weeks to get\n  ready for Round 3 (see the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/schedule\" target=\"_blank\">schedule</a>\n  for details). You can practice with any of our past problems from the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/archive\" target=\"_blank\">archive</a>.\n</p><p>\n  For those of you for whom this round is the end of the season, we hope you are very proud of making\n  it this far. We are thrilled to see the problem solving skills of this community improve\n  year after year. You can see a certificate highlighting\n  your accomplishment in your\n  <a href=\"https://codingcompetitions.withgoogle.com/profile\" target=\"_blank\">profile page</a>.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p>\n<p>\n  Spiraling Into Control: Written and prepared by Ian Tullis.\n</p><p>\n  Pixelated Circle: Written by Archie Pusaka. Prepared by Chun-nien Chan.\n</p><p>\n  Saving the Jelly: Written by Onufry Wojtaszczyk. Prepared by Nour Yosri and Yossi Matsumoto.\n</p><p>\n  I, O Bot: Written by Anurag Singh. Prepared by Rahul Goswami.\n</p><p>\nSolutions and other problem preparation and review by Akul Siddalingaswamy, Alan Lou, Alex Szeto,  Anson Ho, Anurag Singh, Archie Pusaka, Arjun Sanjeev, Bartosz Kostka, Bohdan Pryshchenko, Chu-ling Ko, Chun-nien Chan, Darcy Best, Devansh Gautam, Gil Vegliach, Ian Tullis, Ikumi Hide, Kevin Tran, Krists Boitmanis, Md Mahbubul Hasan, Mohamed Yosri Ahmed, Nafis Sadique, Nour Yosri, Onufry Wojtaszczyk, Pablo Heiber, Rahul Goswami, Ruoyu Zhang, S Jayasurya, and Timothy Buzzelli.\n</p><p>\nAnalysis authors:\n</p><ul>\n  <li>Spiraling Into Control: Ian Tullis.</li>\n  <li>Pixelated Circle: Chun-nien Chan.</li>\n  <li>Saving the Jelly: Kevin Tran.</li>\n  <li>I, O Bot: Krists Boitmanis.</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1652536800000,"tasks":[{"analysis":"<p>\n  There is no value in carrying balls across the origin without depositing them into the warehouse, therefore,\n  collecting the balls with positive coordinates $$$\\mathbf{X_i}$$$ and those with negative coordinates\n  are two similar but independent tasks. Hence, in what follows, we assume that $$$\\mathbf{X_i}>0$$$ for\n  all $$$i$$$. Moreover, let us assume that the balls are sorted in ascending order by $$$\\mathbf{X_i}$$$.\n</p>\n\n<p>\n  A solution to the problem consists of a number of passes or round-trips from the origin and back\n  with one or two balls collected in each pass. The time required to collect a single ball $$$i$$$\n  in a pass is $$$2\\mathbf{X_i}$$$. The time required to collect two balls $$$i$$$ and $$$j$$$ is\n  $$$2\\times\\max(\\mathbf{X_i},\\mathbf{X_j})$$$ if the balls are of different shapes and\n  $$$2\\times\\max(\\mathbf{X_i},\\mathbf{X_j})+\\mathbf{C}$$$ otherwise. We say that two balls $$$i$$$ and $$$j$$$ are\n  <i>matched</i> (and write $$$(i,j)$$$) if they are\n  collected in the same pass. Since the order of passes is not affecting the overall time for\n  collecting all balls, we can equivalently think of the problem as one of finding an optimal\n  matching of balls.\n</p>\n<p>\n  The following observation will be useful throughout the analysis.\n</p>\n\n<p>\n  <i>Observation 1:</i> Suppose we want to collect the first $$$i$$$ balls ($$$i \\ge 2$$$) and\n  $$$\\mathbf{S_i} \\neq \\mathbf{S_{i-1}}$$$. In an optimal matching, the $$$i$$$-th ball is matched with the\n  $$$(i-1)$$$-th ball.\n</p>\n\n<p>\n  <i>Proof:</i> Consider any matching of balls, where $$$i$$$-th ball is <i>not</i> matched with\n  $$$(i-1)$$$-th ball, and assume that $$$i$$$-th ball is a $$$0$$$.<br/>\n  1. If none of the two balls is matched, we can match the balls and save $$$2\\mathbf{X_{i-1}}$$$ seconds.<br/>\n  2. If there is a matching $$$(i-1,j)$$$, $$$j \\lt i-1$$$, and $$$i$$$-th ball\n  is not matched, then we can match $$$(i-1)$$$-th ball with $$$i$$$-th ball instead and save at least\n  $$$2\\times(\\mathbf{X_{i-1}}-\\mathbf{X_j})$$$ seconds ($$$2\\times(\\mathbf{X_{i-1}}-\\mathbf{X_j})+\\mathbf{C}$$$, if $$$j$$$-th ball is\n  $$$1$$$&NoBreak;-shaped).<br/>\n  3. Similarly, if there is a matching $$$(i,j)$$$, $$$j \\lt i-1$$$, and\n  $$$(i-1)$$$-th ball is not matched, we can match $$$i$$$-th ball with $$$(i-1)$$$-th ball instead\n  and, again, save at least $$$2\\times(\\mathbf{X_{i-1}}-\\mathbf{X_j})$$$ seconds.<br/>\n  4. Lastly, if there are matchings $$$(i,j)$$$ and $$$(i-1,k)$$$, $$$j \\lt i-1$$$ and\n  $$$k \\lt i-1$$$, then we can rearrange the matchings as $$$(i,i-1)$$$ and $$$(j,k)$$$ saving\n  at least $$$2\\times(\\mathbf{X_{i-1}}-\\max(\\mathbf{X_j},\\mathbf{X_k}))$$$ seconds.\n</p>\n\n<h3>\n  Test Set 1\n</h3>\n\n<p>\n  Observation 1 helps us match the balls if the last two balls have different shapes. But what if\n  they have the same shape, say a $$$0$$$?\n</p>\n\n<p>\n  <i>Observation 2:</i> Suppose we want to collect the first $$$i$$$ balls ($$$i \\ge 2$$$) and\n  $$$\\mathbf{S_i}=\\mathbf{S_{i-1}}=0$$$. There is an optimal matching of balls such that one of the\n  following conditions holds:<br/>\n  1. The last two $$$0$$$&NoBreak;-shaped balls $$$i$$$ and $$$i-1$$$ are matched.<br/>\n  2. There is a matching $$$(i,j)$$$ with $$$\\mathbf{S_j}=1$$$ and, for all $$$k \\in [j+1,i]$$$&NoBreak;, $$$\\mathbf{S_k}=0$$$.\n  In other words, $$$i$$$-th ball is matched with the nearest $$$1$$$&NoBreak;-shaped ball on its left.<br/>\n  3. There are no $$$1$$$&NoBreak;-shaped balls and $$$i$$$-th ball remains unmatched.\n</p>\n\n<p>\n  <i>Proof:</i> The full proof is a lengthy case analysis, which we omit here. The idea is\n  that matching $$$i$$$-th ball with the rightmost ball of a particular shape is generally at least\n  as good as matching with another ball of that shape. For example, suppose that $$$i$$$-th ball\n  is matched with a $$$1$$$&NoBreak;-shaped ball $$$l$$$ such that there is another $$$1$$$&NoBreak;-shaped ball $$$j$$$ with\n  $$$l \\lt j \\lt i$$$. If the ball $$$j$$$ is unmatched, we can match the ball $$$i$$$ with $$$j$$$\n  instead and save $$$2\\times(\\mathbf{X_j}-\\mathbf{X_l})$$$ seconds. Otherwise, if the ball $$$j$$$ is matched\n  with some other ball $$$k$$$, we can swap the roles of balls $$$l$$$ and $$$j$$$ and create\n  the matchings $$$(i,j)$$$ and $$$(k,l)$$$ obtaining the same overall time (if $$$k \\gt j$$$) or\n  better.\n</p>\n\n<p>\n  This means that we can try matching the last $$$0$$$&NoBreak;-shaped ball with the $$$0$$$&NoBreak;-shaped ball before or the rightmost\n  $$$1$$$&NoBreak;-shaped ball (if any), and at least one of these moves will be optimal.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U239hwuK1jWg3jA36mv7LzK1bymLEb9WlmHINW_eKNzVWctpUXFcTHcMdAmTqERD-DICg6Cokw58H1N5wTocItIlsXKzA/i_o_bot_analysis_1.png\"\n      alt=\"The image shows the last five of i balls. The last three are 0-shaped, the remaining two are\n            1-shaped. The i-th ball is connected to (i-1)-th and (i-3)-th balls with lines.\"/>\n</p>\n<p>\n  The two observations lead to a dynamic programming solution. Let $$$dp[i][j]$$$ be the optimum\n  time to collect the first $$$i$$$ $$$0$$$&NoBreak;-shaped balls and the first $$$j$$$ $$$1$$$&NoBreak;-shaped balls. The base case is\n  $$$dp[0][0]=0$$$. For $$$i+j>0$$$, suppose again that the rightmost of these $$$i+j$$$ balls is\n  $$$0$$$&NoBreak;-shaped and it has the coordinate $$$x$$$. The case when the rightmost ball is $$$1$$$&NoBreak;-shaped is symmetric.\n  To eliminate some other corner cases, $$$dp[1][0]=2x$$$,\n  $$$dp[i][0]=\\min(dp[i-1][0],dp[i-2][0]+\\mathbf{C})+2x$$$ for $$$i \\ge 2$$$, and $$$dp[1][j]=dp[0][j-1]+2x$$$\n  for $$$j \\ge 1$$$. For the general case with $$$i \\ge 2$$$ and $$$j \\ge 1$$$, if the penultimate\n  ball is $$$1$$$&NoBreak;-shaped, then $$$dp[i][j]=dp[i-1][j-1]+2x$$$ (Observation 1). Otherwise, we can choose to\n  match the last $$$0$$$&NoBreak;-shaped ball with the previous $$$0$$$&NoBreak;-shaped ball or the rightmost $$$1$$$&NoBreak;-shaped ball (Observation 2),\n  namely, $$$dp[i][j]=\\min(dp[i-2][j]+\\mathbf{C},dp[i-1][j-1])+2x$$$.\n</p>\n<p>\n  The final answer is $$$dp[N_0][N_1]$$$, where $$$N_0$$$ and $$$N_1$$$ denote the total number of $$$0$$$&NoBreak;-shaped and $$$1$$$&NoBreak;-shaped\n  balls, respectively. The time complexity of this algorithm is $$$O(\\mathbf{N}^2)$$$.\n</p>\n\n<h3>\n  Test Set 2\n</h3>\n\n<p>\n  Using dynamic programming from a different angle, we can solve the problem in linear time, apart from\n  the initial sorting. Let $$$dp[i]$$$ be the optimum time to collect the first $$$i$$$ balls. As\n  the base cases, $$$dp[0]=0$$$ and $$$dp[1]=2\\mathbf{X_1}$$$. To calculate $$$dp[i]$$$ for $$$i \\ge 2$$$,\n  suppose once more that the $$$i$$$-th ball is $$$0$$$&NoBreak;-shaped. If the $$$(i-1)$$$-th ball is $$$1$$$&NoBreak;-shaped, we can\n  match the last two balls and $$$dp[i]=dp[i-2]+2\\mathbf{X_i}$$$ (Observation 1). Otherwise, using\n  Observation 2, we have the options to match the last two $$$0$$$&NoBreak;-shaped balls and collect all balls in\n  $$$dp[i-2]+\\mathbf{C}+2\\mathbf{X_i}$$$ seconds, or to match $$$i$$$-th ball with the rightmost $$$1$$$&NoBreak;-shaped ball\n  $$$j$$$. The dynamic programing recurrence is not obvious in the latter case, though, as we do\n  not know the optimum matching for the first $$$i-1$$$ balls except for ball $$$j$$$. What happens\n  to the $$$0$$$&NoBreak;-shaped balls in-between $$$j$$$ and $$$i$$$? We are missing another key observation here.\n</p>\n<p>\n  <i>Observation 3:</i> If there is an optimal matching of the first $$$i$$$ balls such that\n  the $$$0$$$&NoBreak;-shaped ball $$$i$$$ is matched with the rightmost $$$1$$$&NoBreak;-shaped ball $$$j$$$ and $$$i-1 \\neq j$$$, then\n  the $$$0$$$&NoBreak;-shaped ball $$$i-1$$$ is <i>not</i> matched with another $$$0$$$&NoBreak;-shaped ball.\n</p>\n<p>\n  <i>Proof:</i> Assume on the contrary that we have two pairs of matched balls $$$(i,j)$$$ and\n  $$$(i-1,k)$$$, $$$k \\lt i-1$$$, such that ball $$$k$$$ is $$$0$$$&NoBreak;-shaped. These two matched pairs contribute\n  $$$2\\mathbf{X_i}+2\\mathbf{X_{i-1}}+\\mathbf{C}$$$ seconds to the overall matching cost. But then we can rearrange the\n  matchings as $$$(i,i-1)$$$ and $$$(j,k)$$$ costing us only\n  $$$2\\mathbf{X_i}+\\mathbf{C}+2\\times\\max(\\mathbf{X_j},\\mathbf{X_k})$$$ seconds, which is $$$2(\\mathbf{X_{i-1}}-\\max(\\mathbf{X_j},\\mathbf{X_k}))$$$\n  seconds less. This contradicts the optimality assumption of the given matching.\n</p>\n<p>\n  It follows from Observation 3 that the $$$0$$$&NoBreak;-shaped ball $$$i-1$$$ must be matched with another $$$1$$$&NoBreak;-shaped ball,\n  specifically the rightmost unmatched $$$1$$$&NoBreak;-shaped ball. And we can extend this argument and repeatedly\n  match $$$0$$$&NoBreak;-shaped balls with $$$1$$$&NoBreak;-shaped balls sweeping leftward for as long as there is another $$$0$$$&NoBreak;-shaped ball to\n  the right of a matched $$$1$$$&NoBreak;-shaped ball. This process is ilustrated in the drawing below.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1mRudHGQlOFDCmZ_9hOb6Jlf3xDOgwt295XefdBPNoLcTgLIRg4gazrmE6duhuRYiCh6YT494rMby2toXRtRNDhjDhxQ/i_o_bot_analysis_2.png\"\n      alt=\"The image shows the last 12 of the first i balls with the following shapes:\n            ??1111001000. ? stands for Undefined. The last 0-shaped ball is labeled i. The\n            last 1-shaped ball is labeled j. The second ball with unspecified shape is labeled k.\n            Lines between balls indicate matchings (i,i-3),(i-1,i-6),(i-2,i-7),(i-4,i-8), and\n            (i-5,i-9).\"/>\n</p>\n<p>\n  Let $$$k$$$ be the rightmost unmatched ball after the above $$$0$$$&NoBreak;-&NoBreak;$$$1$$$ matching process. There\n  are no shape changes in the set of balls $$$\\{k+1,k+2,\\ldots,i\\}$$$ and the cost of collecting\n  those balls is twice the sum $$$X_\\mathrm{0-shaped}(k+1,i)$$$ of $$$x$$$-coordinates of $$$0$$$&NoBreak;-shaped balls in\n  $$$\\{k+1,k+2,\\ldots,i\\}$$$. Therefore, the cost of collecting all $$$i$$$ balls in this way is\n  $$$dp[k]+2\\times X_\\mathrm{0-shaped}(k+1,i)$$$.\n</p>\n<p>\n  $$$X_\\mathrm{0-shaped}(k+1,i)$$$ can be calculated in $$$O(1)$$$ time using prefix sums. But how do we\n  get the index $$$k$$$ efficiently without actually carrying out the matching process? Note that\n  $$$k$$$ is the largest index such that $$$k \\lt i$$$ and the set $$$\\{k+1,k+2,\\ldots,i\\}$$$\n  contains equal number of $$$0$$$&NoBreak;-shaped and $$$1$$$&NoBreak;-shaped balls. Consider the balance $$$b_i$$$ of 0/1 balls at\n  each index $$$i$$$, namely, $$$b_i=z_i-o_i$$$, where $$$z_i$$$ and $$$o_i$$$ is the number of\n  $$$0$$$&NoBreak;-shaped and $$$1$$$&NoBreak;-shaped balls in the set $$$\\{1,2,\\ldots,i\\}$$$. The set $$$\\{k+1,k+2,\\ldots,i\\}$$$ has\n  equal number of $$$0$$$&NoBreak;-shaped and $$$1$$$&NoBreak;-shaped balls if and only if $$$b_k=b_i$$$. The index $$$k$$$ can be looked\n  up in $$$O(1)$$$ time if we maintain a hash-table of indices, when each balance was last\n  registered. If the current balance $$$b_i$$$ is seen for the first time, it means that there are\n  not enough $$$1$$$&NoBreak;-shaped balls to match all $$$0$$$&NoBreak;-shaped balls with, and we can choose $$$k=0$$$.\n</p>\n<p>\n  We are performing a constant number of operations at each index in this approach, so the overall\n  time complexity is dominated by the sorting, thus $$$O(\\mathbf{N} \\log \\mathbf{N})$$$.\n</p>\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2J2FM3PGRT5y49kYeOddZQMroInxoGcS7tr0iVsRN64ougS_dUYbKiIoVrrDXDHk2Fed0D0ahu/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b15167","statement":"<h3>Problem</h3>\n\n<p>\n  To welcome attendees to a developers' conference on Jupiter's moon of Io, the organizers inflated\n  many giant beach balls. Each ball is in roughly the shape of either a $$$1$$$ or a $$$0$$$, since\n  those look sort of like the letters I and O. The conference just ended, and so now the beach\n  balls need to be cleaned up. Luckily, the beach ball cleanup robot, BALL-E, is on the job!\n</p><p>\n  The conference was held on an infinite horizontal line, with station $$$0$$$ in the middle,\n  stations $$$1, 2, \\dots$$$ to the right, and stations $$$-1, -2, \\dots$$$ to the left. Station 0\n  contains the conference's only beach ball storage warehouse. Each other station contains at most\n  one beach ball.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2t5wx-YIRLGJfpQjMj_UntAH7JBfTTpjz3deg0jevHOk58lRRc1RUkOuE-YQx600bf1UX0oEdIIEM/i_o_bot.png\" alt=\"Illustration of Sample Cases 1, 2, and 3.\"/>\n</p><p>\n  BALL-E has two storage compartments, each of which can hold a single beach ball. One compartment\n  can only hold $$$1$$$&NoBreak;-shaped balls and the other can only hold $$$0$$$&NoBreak;-shaped balls. (The\n  $$$1$$$&NoBreak;-shaped balls are more oblong than the $$$0$$$&NoBreak;-shaped balls, so neither shape of ball will\n  fit in the other shape's compartment.)\n</p><p>\n  BALL-E initially has both the $$$0$$$ and $$$1$$$ compartments empty, and it starts off at\n  station $$$0$$$. The robot can do the following things:\n</p>\n<ul>\n  <li>Move left one station or right one station. This costs 1 unit of power.</li>\n  <li>If there is a ball at the current station, and BALL-E is not already storing a ball of that\n    shape, it can put the ball in the appropriate compartment. This takes 0 units of power.</li>\n  <li>If there is a ball at the current station, BALL-E can compress it so that its shape becomes\n    the other shape. That is, a $$$1$$$&NoBreak;-shaped ball becomes a $$$0$$$&NoBreak;-shaped ball, or vice versa.\n    It takes $$$\\mathbf{C}$$$ units of power to do this. Note that BALL-E may not change the shape of a ball\n    that it has already put into one of its compartments.</li>\n  <li> If BALL-E is at station 0 and is storing at least one ball, it can deposit all balls from\n    its compartment(s) into the beach ball storage warehouse. This takes 0 units of power and\n    leaves both compartments empty.</li>\n</ul>\n<p>\n  Notice that if BALL-E moves to a station and there is a ball there, BALL-E is not required to\n  pick it up immediately, even if the robot has an open compartment for it. Also, if BALL-E moves\n  to the station with the warehouse, it is not required to deposit any balls it has.\n</p><p>\n Find the minimum number of units of power needed for BALL-E to transfer all of the balls to the\n  warehouse, using only the moves described above.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.<br/>\nThe first line of each test case contains two integers, $$$\\mathbf{N}$$$ and $$$\\mathbf{C}$$$: the number of balls and the\n  amount of power units needed to change the shape of a ball, respectively.<br/>\nThe next $$$\\mathbf{N}$$$ lines describe the positions (i.e., station numbers) and the shapes of the balls.\n  The $$$i$$$-th line contains two integers, $$$\\mathbf{X_i}$$$ and $$$\\mathbf{S_i}$$$: the position and the shape of the\n  $$$i$$$-th ball, respectively.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is the <i>minimum</i> number\n  of units of power needed to transfer all of the balls to the warehouse, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 40 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n$$$0 \\le \\mathbf{S_i} \\le 1$$$, for all $$$i$$$.<br/>\n$$$-10^9 \\le \\mathbf{X_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n$$$0 \\le \\mathbf{C} \\le 10^9$$$.<br/>\n$$$\\mathbf{X_i} &ne; 0$$$, for all $$$i$$$.<br/>\nAll $$$\\mathbf{X_i}$$$ are distinct.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\nFor at most 15 cases:<br/>\n$$$1 \\le \\mathbf{N} \\le 5000$$$.<br/>\nFor the remaining cases:<br/>\n$$$1 \\le \\mathbf{N} \\le 100$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n\nFor at most 15 cases:<br/>\n$$$1 \\le \\mathbf{N} \\le 10^5$$$.<br/>\nFor the remaining cases:<br/>\n$$$1 \\le \\mathbf{N} \\le 5000$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0zOqfFw21lBZgoZLB8oIPUgJQBadhyBc3Ozb5-SAt3f3G4-Iasx4H54kFOPhQpNa-2u4UBK4UXTbF7fkNk5eM8tAfGoZKL/i_o_bot_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n5 0\n3 0\n6 0\n8 0\n10 1\n15 1\n5 10\n3 0\n6 0\n8 0\n10 1\n15 1\n5 1\n3 0\n6 0\n8 0\n10 1\n15 1\n2 0\n1000000000 0\n-1000000000 1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2j0Wi4XjGbz-ly1n2wXsA8QG-N10dKkBEnbbqj7MYnYgnL1hdY8IdTQOUdZh6gsfJurjG8RHfB9AqNeHpEBSntbcKctr3PVg/i_o_bot_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 52\nCase #2: 56\nCase #3: 54\nCase #4: 4000000000\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1 (illustrated in the statement), there are $$$\\mathbf{N} = 5$$$ balls and $$$\\mathbf{C} = 0$$$. One optimal strategy\n  is to make three round trips from (and back to) the warehouse:\n</p>\n<ul>\n  <li>\n    First round trip: Move to station $$$3$$$, pick up the $$$0$$$ ball there and store it in\n    the $$$0$$$ compartment, move back to station $$$0$$$, and deposit the ball in the warehouse.\n    This takes $$$6$$$ units of power.\n  </li><li>\n    Second round trip: Move to station $$$8$$$, pick up the $$$0$$$ ball there, and store it\n    in the $$$0$$$ compartment. Move to station $$$6$$$, change the $$$0$$$ ball there into a\n    $$$1$$$ ball, and pick it up and store it in the $$$1$$$ compartment. Move to station $$$0$$$\n    and deposit both balls in the warehouse. This takes $$$16$$$ units of power. (Recall that in\n    this case, it takes $$$0$$$ units of power to change a ball's shape.)\n  </li><li>\n    Third round trip: Move to station $$$10$$$. Change the $$$1$$$ ball there into a $$$0$$$\n    ball, and pick it up and store it in the $$$0$$$ compartment. Move to station $$$15$$$.\n    Pick up the $$$1$$$ ball there and store it in the $$$1$$$ compartment. Move to station\n    $$$0$$$ and deposit both balls in the warehouse. This takes $$$30$$$ units of power.\n  </li>\n</ul>\n<p>\n  The total number of units of power needed to collect all the balls is $$$52$$$.\n</p><p>\n  Sample Case #2 is like Sample Case #1, but now with $$$\\mathbf{C} = 10$$$. Now BALL-E has to\n  use at least $$$56$$$ units of power:\n</p>\n<ul>\n  <li>\n    First round trip: Get the ball from station $$$3$$$. This takes $$$6$$$ units of power.\n  </li><li>\n    Second round trip: Get the differently-shaped balls from stations $$$6$$$ and $$$10$$$.\n    (These are a $$$0$$$ and a $$$1$$$, respectively, so there is no need to change the shape\n    of either of them.) This takes $$$20$$$ units of power.\n  </li><li>\n    Third round trip: Get the differently-shaped balls from stations $$$8$$$ and $$$15$$$.\n    This takes $$$30$$$ units of power.\n  </li>\n</ul>\n<p>\n  Sample Case #3 is also like Sample Case #1, but now with $$$\\mathbf{C} = 1$$$. Here, BALL-E\n  needs at least $$$54$$$ units of power:\n</p>\n<ul>\n  <li>\n    First round trip: Get the ball from station $$$3$$$. This takes $$$6$$$ units of power.\n  </li><li>\n    Second round trip: Get the ball from station $$$8$$$. When passing through station $$$6$$$\n    on the way back, change the shape of the ball there and get it. This takes $$$17$$$ units of\n    power.\n  </li><li>\n    Third round trip: Do the same with the balls at stations $$$15$$$ and $$$10$$$. This takes\n    $$$31$$$ units of power.\n  </li>\n</ul>\n<p>\n  In Sample Case #4, one optimal strategy is for BALL-E to move to station $$$-1000000000$$$, get\n  the $$$1$$$ ball there, move to station $$$1000000000$$$, get the $$$0$$$ ball there, and then\n  return to station $$$0$$$ to deposit both of them.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":20}],"title":"I, O Bot","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  Let $$$C$$$ and $$$C_w$$$ be the set of pixels colored by\n  <code>draw_circle_filled</code>($$$\\mathbf{R}$$$) and\n  <code>draw_circle_filled_wrong</code>($$$\\mathbf{R}$$$), the number of pixels that have\n  different colors in these pictures would be the cardinality (size) of the\n  symmetric difference of $$$C$$$ and $$$C_w$$$, that is: $$$|C \\Delta C_w| =\n  |(C \\setminus C_w) \\cup (C_w \\setminus C) |$$$.\n</p>\n\n<h3>Test Set 1</h3>\n<p>\n  For test set 1, $$$\\mathbf{R}$$$ is small enough to build the sets of colored pixels from\n  <code>draw_circle_filled</code>($$$\\mathbf{R}$$$) and\n  <code>draw_circle_filled_wrong</code>($$$\\mathbf{R}$$$) with hash set of tuples. By\n  implementing the pseudocode in the problem statement, the time complexity\n  would be $$$O(\\mathbf{R}^2)$$$ to get all colored pixels and $$$O(\\mathbf{R}^2)$$$ to\n  compute the symmetric difference of the two sets.\n</p>\n\n<h3>Test Set 2</h3>\n<p>\n  The key observation for optimizing the solution is that for any $$$\\mathbf{R}$$$, every\n  pixel colored by <code>draw_circle_filled_wrong</code>($$$\\mathbf{R}$$$) is also colored by\n  <code>draw_circle_filled</code>($$$\\mathbf{R}$$$), that is $$$C_w \\subseteq C$$$.\n  Therefore, we can simplify the size of symmetric difference to:\n</p>\n<!-- prettier-ignore -->\n<div>\n    $$$\\begin{equation}\\begin{split}\n  |C \\Delta C_w| &= |(C \\setminus C_w) \\cup(C_w \\setminus C) | \\\\\n  &= |(C \\setminus C_w) \\cup \\emptyset | \\\\\n  &= |C| - |C\\cap C_w| \\\\\n  &= |C| - |C_w| \\\\\n  \\end{split}\\end{equation}$$$\n</div>\n<p>\n  which means we can count the number of pixels colored by\n  <code>draw_circle_filled</code>($$$\\mathbf{R}$$$) and\n  <code>draw_circle_filled_wrong</code>($$$\\mathbf{R}$$$) separately, and the answer would be\n  the difference between these two numbers. The proof of this observation is\n  given at the <a href=\"#proof-cw-in-c\">end of this analysis</a>.\n</p>\n\n<h4>Count pixels colored by <code>draw_circle_filled</code>($$$\\mathbf{R}$$$)</h4>\n<p>\n  To get the number of pixels colored by <code>draw_circle_filled</code>($$$\\mathbf{R}$$$),\n  we need to iterate through all possible values of $$$x$$$ and find\n  $$$y_{min}$$$ and $$$y_{max}$$$ for each $$$x$$$ which satisfy\n  $$$\\mathbf{round}(\\sqrt{x^2 + y^2}) \\le \\mathbf{R}$$$ for all $$$y_{min} \\leq y \\leq\n  y_{max}$$$. A solution for them is $$$y_{max} = \\mathbf{floor}(\\sqrt{\\mathbf{R} + 0.5}^2 -\n  x^2)$$$ and $$$y_{min} = -y_{max}$$$. Therefore, we can get the number of\n  colored pixels with a for-loop for the following equation:\n</p>\n<div>\n  $$$\\begin{equation} |C| = \\sum_{x=-\\mathbf{R}}^{\\mathbf{R}}{\\mathbf{floor}(\\sqrt{(\\mathbf{R} + 0.5)^2 -\n  x^2}) \\times 2 + 1} \\end{equation}$$$\n</div>\n<p>Time complexity: $$$O(\\mathbf{R})$$$</p>\n\n<h4>Count pixels colored by <code>draw_circle_filled_wrong</code>($$$\\mathbf{R}$$$)</h4>\n<p>\n  <code>draw_circle_filled_wrong</code>($$$\\mathbf{R}$$$) is composed of\n  <code>draw_circle_perimeter($$$r$$$)</code> calls with $$$r$$$ from $$$0$$$ to\n  $$$\\mathbf{R}$$$. Notice that pixels colored by\n  <code>draw_circle_perimeter($$$r_1$$$)</code> and\n  <code>draw_circle_perimeter($$$r_2$$$)</code> never overlap if $$$r_1 \\neq\n  r_2$$$. Based on this observation, we can count the number of pixels colored\n  by each <code>draw_circle_perimeter($$$r$$$)</code> separately and sum them up\n  to get the total number of colored pixels. The proof of this observation is\n  given at the\n  <a href=\"#proof-disjoint-draw-circle-perimeter\">end of this analysis</a>.\n</p>\n<p>\n  Looking into function <code>draw_circle_perimeter($$$r$$$)</code>, we can\n  break the colored pixels into 4 quadrants and count them separately. Since the\n  colored pattern is symmetric to both x-axis and y-axis, we just need to count\n  the pixels in Quadrant 1 (Q1), and the total count excluding the origin pixel\n  would be that number times 4, and plus 1 to include the origin pixel.\n</p>\n<p>\n  For $$$r \\ge 1$$$, the colored pixels in Q1 are symmetric to the line\n  $$$x=y$$$, and there are exactly $$$x_t$$$ colored pixels between y-axis and\n  $$$(x_t, y_t)$$$, the closest point to line $$$x=y$$$ (above or on the line,\n  $$$x_t \\ge y_t$$$). Since $$$x=y$$$ is at $$$45^{\\circ}$$$ to the x-axis, the\n  integer $$$x_t$$$ would be either $$$\\mathbf{ceil}(r/\\mathbf{cos}(45^{\\circ}))$$$ or\n  $$$\\mathbf{floor}(r/\\mathbf{cos}(45^{\\circ}))$$$. We can compute the corresponding $$$y_t =\n  \\mathbf{round}(\\sqrt{r^2 - x_t^2})$$$ and choose the closer one above or on the line\n  $$$x=y$$$. Afterwards, the number of colored pixels in Q1 including x-axis\n  would be $$$2 \\times x_t + 1$$$, and minus 1 if $$$(x_t, y_t)$$$ lies on the\n  line $$$x=y$$$ since it is not mirrored in this case.\n</p>\n<p>\n  Time complexity: $$$O(1)$$$ for counting pixels colored by\n  <code>draw_circle_perimeter($$$r$$$)</code>, and $$$O(\\mathbf{R})$$$ for all colored\n  pixels.\n</p>\n<h4 id=\"proof-cw-in-c\">Proof: $$$C_w \\subseteq C$$$</h4>\n<p>\n  For every positive $$$\\mathbf{R}$$$, $$$r$$$ and $$$x$$$ such that $$$0 \\leq r \\leq \\mathbf{R}$$$\n  and $$$-r \\leq x \\leq r$$$, we want to prove that the following inequality\n  always satisfies:\n</p>\n<!-- prettier-ignore -->\n<div>\n  $$$\\begin{equation}\\begin{split}\n  & \\mathbf{round}(\\sqrt{x^2 + \\mathbf{round}(\\sqrt{r^2 - x^2})^2}) \\leq r \\\\\n  \\iff& \\sqrt{x^2 + \\mathbf{round}(\\sqrt{r^2 - x^2})^2} - 0.5 \\leq r \\\\\n  \\iff& \\sqrt{x^2 + \\mathbf{round}(\\sqrt{r^2 - x^2})^2} \\leq r + 0.5 \\\\\n  \\iff& x^2 + \\mathbf{round}(\\sqrt{r^2 - x^2})^2 \\leq r^2 + r + 0.25 \\\\\n  \\iff& x^2 + (\\sqrt{r^2 - x^2} + 0.5)^2 \\leq r^2 + r + 0.25 \\\\\n  \\iff& r^2 + \\sqrt{r^2 - x^2} + 0.25 \\leq r^2 + r + 0.25 \\\\\n  \\end{split}\\end{equation}$$$\n</div>\n<p>\n  which always holds since $$$\\sqrt{r^2 - x^2} \\leq \\sqrt{r^2} = r$$$ when\n  $$$|x| \\leq r$$$ and $$$r \\ge 0$$$.\n</p>\n<p>\n  Secondly, $$$y = \\mathbf{round}(\\sqrt{r^2 - x^2}) \\leq \\mathbf{round}(\\sqrt{r^2}) \\leq\n  \\mathbf{R}$$$. Therefore $$$-\\mathbf{R} \\leq y \\leq \\mathbf{R}$$$ always holds.\n</p>\n<p>\n  The proof above shows that pixels colored by\n  <code>draw_circle_filled_wrong</code>($$$r$$$) with $$$0 \\leq r \\leq \\mathbf{R}$$$\n  also satisfy the coloring condition in <code>draw_circle_filled</code>($$$\\mathbf{R}$$$),\n  which implies $$$C_w \\subseteq C$$$.\n</p>\n\n<h4 id=\"proof-disjoint-draw-circle-perimeter\">\n  Proof: <code>draw_circle_perimeter($$$r_1$$$)</code> and\n  <code>draw_circle_perimeter($$$r_2$$$)</code> never overlap\n</h4>\n<p>\n  For the first coloring statement in\n  <code>draw_circle_perimeter($$$r$$$)</code>, we want to prove that given a\n  fixed $$$x$$$, the inequality $$$y_1 = \\mathbf{round}(\\sqrt{r_1^2 - x^2}) \\neq y_2 =\n  \\mathbf{round}(\\sqrt{r_2^2 - x^2})$$$ for any pair of integers $$$r_1$$$ and\n  $$$r_2$$$ such that $$$r_1 \\gt r_2 \\geq 0$$$ and $$$|x| \\leq r_2$$$ is always\n  true:\n</p>\n<!-- prettier-ignore -->\n<div>\n  $$$\\begin{equation}\\begin{split}\n  &|\\sqrt{r_1^2 - x^2} - \\sqrt{r_2^2 - x^2}| &\\\\\n  =\\;& \\sqrt{r_1^2 - x^2} - \\sqrt{r_2^2 - x^2} &\\; r_1 \\gt r_2 \\\\\n  \\geq\\;& \\sqrt{r_1^2 - x^2} - \\sqrt{(r_1 - 1)^2 - x^2} &\\; r_1 \\texttt{ and } r_2 \\texttt{ are integers} \\\\\n  \\geq\\;& (\\sqrt{r_1^2} - \\sqrt{x^2}) - (\\sqrt{(r_1 - 1)^2} - \\sqrt{x^2}) &\\; \\texttt{for any } |x| \\leq r_1 - 1 \\\\\n  =\\;& r_1 - x - (r_1 - 1) + x \\\\\n  =\\;& 1\n  \\end{split}\\end{equation}$$$\n</div>\n<p>Based on the proof above, we can further get:</p>\n<!-- prettier-ignore -->\n<div>\n  $$$\\begin{equation}\\begin{split}\n  & \\mathbf{round}(\\sqrt{r_1^2 - x^2}) -\\mathbf{round}(\\sqrt{r_2^2 - x^2}) \\\\\n  \\geq\\;& \\mathbf{round}(\\sqrt{r_1^2 - x^2}) -\\mathbf{round}(\\sqrt{(r_1 - 1)^2 - x^2})\\\\\n  \\geq\\;& \\mathbf{round}(\\sqrt{r_1^2 - x^2}) - \\mathbf{round}(\\sqrt{r_1^2 - x^2} - 1) \\\\\n  \\geq\\;& 1 \\\\\n  \\end{split}\\end{equation}$$$\n</div>\n<p>\n  Therefore $$$y_1 \\neq y_2$$$ always holds for all $$$r_1 \\gt r_2 \\geq 0$$$\n  given a fixed $$$x$$$ such that $$$|x| \\leq r_2$$$. For the cases that $$$r_2\n  \\lt |x| \\leq r_1$$$, the pixels will nevery satisfy the coloring condition in\n  <code>draw_circle_perimeter($$$r_2$$$)</code>.\n</p>\n<p>\n  We can further extend the proof above for the 2nd, 3rd, and 4th coloring\n  statement in <code>draw_circle_perimeter($$$r$$$)</code> and prove that pixels\n  colored by <code>draw_circle_perimeter($$$r_1$$$)</code> and\n  <code>draw_circle_perimeter($$$r_2$$$)</code> never overlap.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0J9wzQ9orEpq2l15-h9YJyQ1lxRKRZ8PFCS_T07_HkOEzvUEzJLmsW_Hh2ULHkknKU7NQXEMRq/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b158f7","statement":"<h3>Problem</h3>\n<p>\nTypical computer images are matrices of pixels, with each pixel being a small square of a specific\ncolor. Drawing lines that are not perfectly parallel to the axes of the pixel matrix results\nin imperfections. Drawing circles is an extreme example where those imperfections arise.\n</p><p>\nSuppose we have a picture consisting\nof $$$2\\mathbf{R}+1$$$ by $$$2\\mathbf{R}+1$$$ pixels, and we number the rows and columns of pixels between\n$$$-\\mathbf{R}$$$ and $$$\\mathbf{R}$$$, such that the center pixel is at row $$$0$$$ and column $$$0$$$. Initially,\nall pixels are white. Then, a circle of radius $$$\\mathbf{R}$$$ and centered in the picture can be drawn in\nblack by the following pseudocode, where <code>set_pixel_to_black(x, y)</code> makes the\npixel at row $$$x$$$ and column $$$y$$$ be colored black.\n</p><pre>\ndraw_circle_perimeter(R):\n  for x between -R and R, inclusive {\n    y = round(sqrt(R * R - x * x))   # round to nearest integer, breaking ties towards zero\n    set_pixel_to_black(x, y)\n    set_pixel_to_black(x, -y)\n    set_pixel_to_black(y, x)\n    set_pixel_to_black(-y, x)\n  }\n</pre><p>\nNotice that some pixels may be set to black more than once by the code, but the operation is\nidempotent (that is, calling <code>set_pixel_to_black</code> on a pixel that is already black changes\nnothing).\n</p><p>\nThe following is pseudocode for a function to draw a filled circle\n(starting from an all-white picture).\n</p><pre>\ndraw_circle_filled(R):\n  for x between -R and R, inclusive {\n    for y between -R and R, inclusive {\n      if round(sqrt(x * x + y * y)) &lt;= R:\n        set_pixel_to_black(x, y)\n    }\n  }\n</pre><p>\nAnd finally, the following is pseudocode to incorrectly draw a filled circle:\n</p><pre>\ndraw_circle_filled_wrong(R):\n  for r between 0 and R, inclusive {\n    draw_circle_perimeter(r)\n  }\n</pre>\n<p>\nGiven $$$\\mathbf{R}$$$, calculate the number of pixels that would have different colors between a picture in\nwhich <code>draw_circle_filled</code>($$$\\mathbf{R}$$$) is called and another one in which\n<code>draw_circle_filled_wrong</code>($$$\\mathbf{R}$$$) is called.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case is described in a single line containing a single integer $$$\\mathbf{R}$$$, the radius\nof the circle to draw.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is\nthe number of pixels that would have different colors between a picture in\nwhich <code>draw_circle_filled</code>($$$\\mathbf{R}$$$) is called and another one in which\n<code>draw_circle_filled_wrong</code>($$$\\mathbf{R}$$$) is called.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 10 seconds.<br/>\n\n$$$1 \\le \\mathbf{R} \\le 100$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 15 seconds.<br/>\n\n$$$1 \\le \\mathbf{R} \\le 10^5$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3ZdwvdYiL0ciHEC3sK-Qn62LdUDasnior10AKwz0kffEYebkrJoKnVdmLrUOzeRWX0PmiANWpNz1HVn45R-GtefbGymwgZYV6BeMKGnO1c/pixelated_circle_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n2\n8\n50\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3FVYwzt6k3D5wOVVCROTg7xEadCd_4ZtS97UDUysXNXva6XDuRQEqQAkVfrbRLwc7fLS08NWpaKwyY1n8DtEuJDogLuIh7pU8_27pe6QJoTw/pixelated_circle_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 4\nCase #2: 24\nCase #3: 812\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n  <p>\n    In Sample Case #1, 21 pixels are drawn in black by calling\n    <code>draw_circle_filled(2)</code> (shown in the left picture). 17 pixels are drawn in black\n    by calling <code>draw_circle_filled_wrong(2)</code> (shown in the right picture). Four pixels\n    would have different colors between the two pictures: $$$(-1, -1)$$$, $$$(-1, 1)$$$,\n    $$$(1, -1)$$$, and $$$(1, 1)$$$, where $$$(x, y)$$$ represents the pixel at row $$$x$$$ and\n    column $$$y$$$, with the rows and columns numbered as described in the statement.\n  </p>\n  <p align=\"center\">\n    <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0ouocLNFv7S2SyPqsbNndVBJ7q-SbpXavKAPQArt6r44qF6210eXUT4y6ULhBd_z-39auECtdwU9X8/sample_1.png\" alt=\"Result of draw_circle_filled(2)\" style=\"margin: 0 1rem;\"/>\n    <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2CuZTJ1B-JSr8NewwRCBhLPqsqlZ-7KWXgEiHEypQXDFgfejJV_b-J9wKKUnUZIwuM6qW37ScEedk5AiMTj1q7/sample_1_wrong.png\" alt=\"Result of draw_circle_filled_wrong(2)\" style=\"margin: 0 1rem;\"/>\n  </p>\n  <p>\n    In Sample Case #2, the following pictures are the images generated by calling\n    <code>draw_circle_filled(8)</code> (left) and <code>draw_circle_filled_wrong(8)</code> (right).\n  </p>\n  <p align=\"center\">\n    <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3vP0AyQVFBOpJ8aZkKjasXFBvWMhgTlyd0ECfCqN4mpF0xkqHC5VrPMok13EkQ9wz_iHzPd5dMmnFi/sample_2.png\" alt=\"Result of draw_circle_filled(8)\" style=\"margin: 0 1rem;\"/>\n    <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U26wVKAcEiDMbQzMTpkP4WVnfn08bOqZjEoe_1dDfdmB7nbeTYIZl7jpNc3AKSiXAmGIlrgNa2AtG_f7vvaVSll/sample_2_wrong.png\" alt=\"Result of draw_circle_filled_wrong(8)\" style=\"margin: 0 1rem;\"/>\n  </p>\n</sampleio>\n\n\n\n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":16}],"title":"Pixelated Circle","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  With $$$\\mathbf{N} \\leq 10$$$, it is possible to use dynamic programming with bitmasking, with one bit\n  for each candy and each student remaining. This effectively lets us try all possible orderings of\n  students as well as all possible ways to break ties. The total complexity is $$$O(\\mathbf{N}^2 \\times 2^{2 \\times \\mathbf{N}})$$$.\n  This runs in time because we only consider states where the same number of candies and students\n  have been matched.\n</p>\n<h3>Test Set 2</h3>\n<p>\n  Firstly, lets construct a bipartite graph with the $$$\\mathbf{N}$$$ children and the $$$\\mathbf{N}$$$ candies as\n  vertices (not including Mr Jolly's blueberry jelly).\n  Add an edge from child $$$a$$$ to candy $$$b$$$ if child $$$a$$$ is equally close or closer to $$$b$$$ than the\n  blueberry jelly.\n</p><p>\n  It's clear that a necessary (but perhaps not sufficient) condition for Mr Jolly to get his\n  blueberry jelly is that the graph has a <a href=\"https://en.wikipedia.org/wiki/Maximum_cardinality_matching\">perfect matching</a>.\n</p><p>\n  It turns out, this is also a sufficient condition. Let's try to show this by turning a perfect\n  matching into an order that Mr. Jolly can call the children's names.\n</p><p>\n  Firstly, if there is a child who is matched to the candy that is closest to them, then we can call that\n  child's name and remove them and the candy from the graph.\n</p><p>\n  Otherwise, we are in the situation where every child is matched to a (ungrabbed) candy that is <i>not</i> the closest one to them.\n  Then, we will find a cycle in the graph using the following procedure. Pick an arbitrary child $$$a$$$\n  to start at.\n</p>\n<ol>\n  <li>Find the candy $$$b$$$ that is closest to child $$$a$$$. Go to $$$b$$$.\n      This edge is guaranteed not to be part of the current matching.\n  </li>\n  <li>Find the child $$$a$$$ that is currently matched to candy $$$b$$$. Go to $$$a$$$.\n      This edge is in the current matching.\n  </li>\n</ol>\n<p>\n  Eventually, this process will create a cycle of even length (not necessarily including the child\n  we started with). Because we alternated between edges in the matching and edges not in the\n  matching, we can swap the matched edges/unmatched edges to create a new perfect matching.\n  Note that in doing so, all the children in the cycle are now matched to the closest candy to them,\n  so at least one child's name can now be called.\n</p><p>\n  We have shown that a perfect matching is a necessary condition, and that an order can be\n  constructed from a perfect matching that satisfies Mr. Jolly's requirements, thus proving that a\n  perfect matching exists if and only if Mr. Jolly's requirements can be satisfied.\n</p><p>\n  A perfect matching can be found in $$$O(\\mathbf{N}^2 \\sqrt{\\mathbf{N}})$$$ using <a href=\"https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\">Hopcroft-Karp</a>,\n  and constructing a solution can be done in $$$O(\\mathbf{N}^2)$$$ if implemented with some care.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0X3fWqYIgCsYicJYze0bIcF45g2uwNHr-piPt_R2HuxPekrclOiDAJ4DAL889KoOFBjj8R5WJd/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b158f8","statement":"<h3>Problem</h3>\n<p>\n  Mr. Jolly teaches football (or soccer, for US speakers) to $$$\\mathbf{N}$$$ children numbered from $$$1$$$ to $$$\\mathbf{N}$$$.\n  He has taken to leaving sweets on the field where the games take place, one for each child.\n  After the game is finished, each child can grab and eat one sweet as their reward.\n</p><p>\n  The children are tired after games, so each child wants to grab the sweet closest to them (using Euclidean distance).\n  This could lead to fights &mdash; if the same sweet is closest to two or more children.\n  To avoid that, after the game all the children stop where they are, and Mr. Jolly calls out their\n  names, one by one. When a child's name is called, they grab the closest sweet to them (out of the ones\n  that weren't already grabbed, of course). In the case where two or more sweets are tied for the\n  smallest distance, Mr. Jolly can decide which one the child grabs.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1CcXd8Jws7R6CKgIbNOm6nfoytsZF2R91p0URTeULXhch8rzxVZwyQ1R1XIH6Wyf6hGPPgtUdwLMd3WuGv9b_vQ14/saving_the_jelly.png\" alt=\"Illustration of Sample Case #2.\"/>\n</p><p>\n  This has worked very well for Mr. Jolly for a while now, but today disaster struck! While laying\n  out the sweets, Mr. Jolly accidentally dropped his blueberry jelly that he planned to eat\n  after all the children go home. So now there are $$$\\mathbf{N}$$$ children on the field, and $$$\\mathbf{N}+1$$$\n  sweets. The sweets are numbered from $$$1$$$ to $$$\\mathbf{N} + 1$$$, with sweet $$$1$$$ being Mr. Jolly's blueberry\n  jelly. Is there a way for Mr. Jolly to save his blueberry jelly by calling the children's names in\n  such an order that the blueberry jelly is the one sweet left over?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow. Each test\n  begins with a line containing a single integer, $$$\\mathbf{N}$$$, the number of children on the field. The next\n  $$$\\mathbf{N}$$$ lines describe the positions of the children. Each of these lines contains two integers,\n  $$$\\mathbf{X_i}$$$ and $$$\\mathbf{Y_i}$$$, representing the position of the $$$i$$$&NoBreak;-th child after the game ends.\n  Then there are $$$\\mathbf{N}+1$$$ more lines that describe the positions of sweets after the game, where the\n  first of the sweets is Mr. Jolly's blueberry jelly. Each of these lines contains two integers,\n  $$$\\mathbf{X_j}$$$ and $$$\\mathbf{Y_j}$$$, representing the position of the $$$j$$$&NoBreak;-th sweet.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\n  where $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is <code>IMPOSSIBLE</code> if\n  there is no way Mr. Jolly can choose the children (and break ties for the closest sweet) to leave\n  his blueberry jelly uneaten. Otherwise, if Mr. Jolly can save his blueberry jelly, $$$y$$$ is\n  <code>POSSIBLE</code>. If Mr. Jolly can save his jelly, output $$$\\mathbf{N}$$$ additional lines representing\n  the order the children will go and which jellies they will pick. The $$$i$$$&NoBreak;-th line\n  should contain two integers $$$A_i$$$ and $$$B_i$$$ representing that child $$$A_i$$$ will go next\n  and will pick sweet $$$B_i$$$. The sweet $$$B_i$$$ must be the closest (or tied for the closest)\n  sweet to child $$$A_i$$$ when they go to pick their sweet.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n  $$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n  $$$-10^9 \\le \\mathbf{X_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n  $$$-10^9 \\le \\mathbf{Y_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n  $$$-10^9 \\le \\mathbf{X_j} \\le 10^9$$$, for all $$$j$$$.<br/>\n  $$$-10^9 \\le \\mathbf{Y_j} \\le 10^9$$$, for all $$$j$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 10 seconds.<br/>\n\n  $$$1 \\le \\mathbf{N} \\le 10$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 45 seconds.<br/>\n\n  $$$1 \\le \\mathbf{N} \\le 1000$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2W7Uhn9LdHCxgxfsCR0VZxBSG9YIiNJxUuNi_kLZmRh4w8xI69G9FXwnFToozS4ucRUp1IvZxxTjo0raZlIW8rSlqZMt1HtFu_-eSawDKe/saving_the_jelly_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n2\n-3 0\n-1 0\n3 0\n-2 -1\n-2 1\n1\n0 0\n1 1\n2 2\n3\n10 0\n-10 0\n0 0\n0 5\n-1 0\n5 0\n0 -5\n2\n3 4\n3 4\n5 7\n3 4\n5 7\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2kq2GHlb2cG7M4EsofiPClhZUhtd6weYeAIpSvp_vTq6mawZ0GDEQezgpcXuCVcaCBRnYX25eKFH_QAxBSu0-yhfXyZXy3oX5xBPNRTwdimQ/saving_the_jelly_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: POSSIBLE\n2 2\n1 3\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n3 2\n2 4\n1 3\nCase #4: POSSIBLE\n1 2\n2 3\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Sample Case #1 is illustrated in the image above. Notice that each child is equally close to\n  each of the two non-blueberry-jelly sweets. In our solution, Mr. Jolly assigns the second sweet\n  to the second child and the third sweet to the first child, successfully leaving the first sweet\n  (the blueberry jelly) for himself.\n</p><p>\n  In Sample Case #2, the sole child is closer to the blueberry jelly than to the other sweet, so\n  Mr. Jolly cannot prevent his precious blueberry jelly from being eaten.\n</p><p>\n  In Sample Case #3, we present one of many solutions; it is actually possible to call the children\n  in any order.\n</p><p>\n  In Sample Case #4, note that children might share the same position, sweets might share the same\n  position, and children and sweets might share the same position.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Saving the Jelly","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>\n  Test Sets 1 and 2\n</h3>\n<p>\n  You may or may not have run across the old chestnut of a technical\n  interview question that asks you to number all of the cells of a grid in\n  a spiral pattern. In this problem, doing that is potentially helpful for\n  the first two test sets. However, the last test set can be (and must be)\n  solved without explicitly creating and numbering a spiral. (For a case with\n  $$$\\mathbf{N} = 9999$$$, we would need to store and number almost $$$10^8$$$\n  cells!) We'll worry about that later in the analysis.\n</p><p>\n  To make a numbered spiral, we can create a grid and loop through it,\n  starting from the upper left cell, and making a 90 degree turn to the right\n  each time we encounter a grid boundary or an already-numbered cell. One\n  clean way to do this is to use an array of \"directions\":\n  $$$((0, 1), (1, 0), (0, -1), (-1, 0))$$$, where the starting direction\n  $$$(0, 1)$$$ means stay in the same row and move one column right, and so\n  on, with the other three referring to moves downward, leftward, and upward,\n  respectively, in the grid. When our current direction is\n  $$$(\\Delta r, \\Delta c)$$$ and we are at cell $$$(r, c)$$$ in the grid, we\n  check cell $$$(r + \\Delta r, c + \\Delta c)$$$ to see if it is outside the\n  grid or has already been numbered. If so, we choose the next direction in\n  the direction vector, looping back to the start if we go off the end, and\n  then calculate $$$(r + \\Delta r, c + \\Delta c)$$$ using the new\n  $$$(\\Delta r, \\Delta c)$$$. Then, whether or not we changed direction, we\n  label the current cell, increment our label counter, and proceed to the cell\n  $$$(r + \\Delta r, c + \\Delta c)$$$. We stop when we label the $$$\\mathbf{N}^2$$$-th\n  cell.\n</p><p>\n  For Test Set 1, we can exhaustively enumerate all legal paths, using our\n  spiral numbering to determine which moves are allowed. We can keep track of\n  the shortcuts taken in each possible path, and see whether any path finishes\n  in exactly $$$\\mathbf{K}$$$ moves. Since there is a shortcut to take (or not take) in\n  almost every cell, this solution is exponential.\n</p><p>\n  For Test Set 2, we can refine this idea to avoid explicitly considering all\n  possible paths. For each cell in the grid, we create an array that can hold\n  up to one path for every possible number of moves \"so far\". Then we proceed\n  along the spiral in consecutive numerical order. For every cell we visit,\n  for every path in that cell's array, we try to extend it into all legal\n  neighboring cells.\n</p><p>\n  For example, in a $$$5 \\times 5$$$ grid, we start at cell 1 with only a way\n  to get there in 0 moves. We tell each of the legal neighboring cells\n  (2 and 16) that we have a way to get there in 1 move, starting from cell 1.\n  Then, in cell 2, we tell each of cells 3 and 17 that we have a way to get\n  there in 2 moves, with the starting prefix $$$1, 2$$$, and so on. The key\n  difference from the Test Set 1 solution is that when a cell is offered a\n  path and it already has a path with exactly that number of moves, it does\n  not store the new path. This cuts down on the proliferation of possible\n  paths.\n</p><p>\n  And so we have a\n  <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\" target=\"_blank\">dynamic programming</a>\n  / <a href=\"https://en.wikipedia.org/wiki/Memoization\" target=\"_blank\">memoization</a>\n  solution. Since there is at most one shortcut to take in each cell, we do\n  constant work per cell; since we are populating a table that is\n  $$$\\mathbf{N}^2 \\times \\mathbf{N}$$$, this solution takes $$$O(\\mathbf{N}^3)$$$ time.\n</p>\n\n<h3>\n  Test Set 3\n</h3>\n<p>\n  To be able to handle grids with $$$\\mathbf{N}$$$ up to 9999, we need to do three things\n  efficiently:\n</p>\n<ul>\n  <li>Given a value of $$$\\mathbf{K}$$$, determine whether a path with exactly $$$\\mathbf{K}$$$ moves\n    exists.</li>\n  <li>Find such a path.</li>\n  <li>Given the coordinates of a grid cell, find its number in the spiral.</li>\n</ul>\n<p>\n  We can begin by observing that the following values of $$$\\mathbf{K}$$$ are\n  <code>IMPOSSIBLE</code>:\n</p>\n<ol>\n  <li>\n    $$$\\mathbf{K} \\lt \\mathbf{N}-1$$$. In this case, even if we move as directly as possible\n    toward the center (taking only shortcuts), there are not enough moves to\n    get there.\n  </li><li>\n    Odd $$$\\mathbf{K}$$$. We can see this via a \"checkerboard argument\". Imagine that the\n    grid has a\n  <a href=\"https://en.wikipedia.org/wiki/Checkerboard\" target=\"_blank\">checkerboard pattern</a>,\n    with the upper left cell being black.\n    Then the diagonal running from the upper left cell to the lower right cell\n    is entirely black, and so the central cell is black. Now, each move is in\n    an orthogonal (i.e., \"compass\") direction, so each move either takes us\n    from a black cell to a red cell or vice versa. Therefore, to end on the\n    central cell, which is black, we must make an even number of moves.\n  </li>\n</ol>\n<p>\n  As it turns out, these are the <i>only</i> impossible cases! To see why, it\n  helps to think of the spiral as consisting of concentric square rings, with\n  \"ring\" 0 being just the central cell, ring 1 being the eight cells around\n  that, ring 2 being the sixteen cells around ring 1, and so on. For example,\n  the rings in the $$$\\mathbf{N} = 7$$$ grid look like this:\n</p>\n<br>\n<pre>\n  3333333\n  3222223\n  3211123\n  3210123\n  3211123\n  3222223\n  3333333\n</pre>\n<p>\n  In ring 1, there are three possible shortcuts: we can move into ring 0 from\n  the top, right, or bottom, and this will save us 6, 4, or 2 moves,\n  respectively, compared to just walking through all of ring 1 (and into ring\n  0) without taking a shortcut. But we can only take one of these shortcuts.\n</p><p>\n  In ring 2 (and beyond), for simplicity, let's only consider taking shortcuts\n  that are in the same row or column as the central cell. There are four such\n  shortcuts, and they will save us 14, 12, 10, or 8 moves, respectively.\n  Notice that if we take the 8-move shortcut from ring 2, for example, we\n  cannot use any of the shortcuts in ring 1. However, if we take the 14-move\n  shortcut from ring 2, we will still have access to all three shortcuts in\n  ring 1.\n</p><p>\n  Similarly, in ring 3, the shortcuts save us 22, 20, 18, or 16 moves, and if\n  we take the first of these, we still have access to all four shortcuts in\n  ring 2.\n</p><p>\n  We can turn these observations into a constructive solution for any even $$$\\mathbf{K}$$$\n  that has an answer:\n<p><ul>\n  <li>\n    If we want to save between 2 and 22 moves, we take the specific shortcut\n    with that savings.\n  </li><li>\n    If we want to save between 24 and 36 moves, we can take the 22-move\n    shortcut and then take the specific shortcut (from ring 1 or 2) that gets\n    us the remaining savings.\n  </li><li>\n    If we want to save 38, 40, or 42 moves, we can take the 22-move and\n    14-move shortcuts and then the 2, 4, or 6-move shortcut from ring 1.\n  </li><li>\n    We already established that we cannot save 44 moves or more (since then\n    $$$\\mathbf{K}$$$ would be less than $$$\\mathbf{N}-1$$$).\n  </li>\n</ul>\n<p>\n  Generalizing this strategy: we can find the number of moves we need to save\n  (which is $$$\\mathbf{N}^2 - 1 - \\mathbf{K}$$$; call it $$$s$$$), and then proceed from the\n  outermost ring to the innermost. At each ring $$$r$$$,\n</p><ol>\n  <li>\n    If $$$s$$$ is greater than or equal to the number of moves saved by the\n    largest shortcut (i.e., $$$8r - 2$$$ moves), we take that shortcut,\n    subtract its savings from $$$s$$$, and proceed to the $$$r-1$$$-th ring.\n  </li><li>\n    If $$$s$$$ is equal to the number of moves saved by some other shortcut\n    in ring $$$r$$$ (i.e., $$$8r - 4$$$, $$$8r - 6$$$, or $$$8r - 8$$$), we\n    take that shortcut and stop. (We must be careful not to do this when\n    $$$8r - 8 = 0$$$, since that move &mdash; from cell $$$\\mathbf{N}^2 - 1$$$ to\n    cell $$$\\mathbf{N}^2$$$ &mdash; saves us nothing and is not a shortcut!\n  </li><li>\n    Otherwise, we reject all shortcuts in ring $$$r$$$, and proceed to ring\n    $$$r-1$$$.\n  </li>\n</ol>\n<p>\n  All that remains is to find the room numbers for the shortcuts that we take.\n  Instead of trying to generate the entire spiral, we can notice that, say,\n  the upper left corners of the rings (starting in the central cell and going\n  outward) have values\n  $$$\\mathbf{N}^2, \\mathbf{N}^2 - 8, \\mathbf{N}^2 - 8 - 16, \\mathbf{N}^2 - 8 - 16 - 24,$$$ etc. We can\n  even turn this into a formula: the upper left cell of ring $$$r$$$ has\n  number $$$\\mathbf{N}^2 - 8 \\sum_{i=0}^r i = \\mathbf{N}^2 - 4(r)(r+1)$$$.\n</p><p>\n  Once we have the number of the upper left cell of a ring, it is not too\n  hard to find the values of the cells we are using for shortcuts in that ring\n  (i.e., the ones in the central row or column). If the upper left cell's\n  number is $$$x$$$, the shortcuts have numbers $$$x+r, x+3r, x+5r, x+7r$$$.\n</p><p>\n  Because there are $$$\\frac{\\mathbf{N}+1}{2}$$$ rings in total, and we do\n  $$$O(1)$$$ work in each of them, this solution is\n  $$$O(\\mathbf{N})$$$ and easily passes Test Set 3. There are values of\n  $$$\\mathbf{K}$$$ that require a shortcut to be used in every ring (except the central\n  cell), so we can't do better than this in general.\n</p>\n\n<h3>\n  It could have been worse...\n</h3>\n<p>\n  We thought about presenting this problem in a different way, without\n  mentioning spirals: starting from the upper left cell of an\n  $$$\\mathbf{N} \\times \\mathbf{N}$$$ grid, give a path that reaches the central cell in\n  exactly $$$\\mathbf{K}$$$ moves, or say it is impossible. One solution is to come up with\n  the spiral path and strategy from this problem! But there were many other\n  time-wasting roads to go down there, and the problem was already challenging\n  for the first problem of a Round 2.\n</p>\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2qz-91zhX7AKtfdJ9geaJk1rGhB9ir0397pGoQPODZ99BIuxF6BDDs9-_sZYDys7d0UvIfbfQZ/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b15a74","statement":"<h3>Problem</h3>\n<p>\nAs punishment for being naughty, Dante has been trapped in a strange house with many rooms.\nThe house is an $$$\\mathbf{N} \\times \\mathbf{N}$$$ grid of rooms, with $$$\\mathbf{N}$$$ odd and greater than $$$1$$$. The\nupper left room is numbered $$$1$$$, and then the other rooms are numbered\n$$$2$$$, $$$3$$$, ..., $$$\\mathbf{N}^2$$$, in a clockwise spiral pattern. That is, the numbering proceeds\nalong the top row of the grid and then makes a 90 degree turn to the right whenever a grid boundary\nor an already numbered room is encountered, and finishes in the central room of the grid. Because\n$$$\\mathbf{N}$$$ is odd, there is always a room in the exact center of the house, and it is always numbered\n$$$\\mathbf{N}^2$$$.\n</p><p>\nFor example, here are the room numberings for houses with $$$\\mathbf{N} = 3$$$ and $$$\\mathbf{N} = 5$$$:\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3DS0-kk5agu7h2fda7BHPLUmcnK9498g6aNGSiEuUXn_iaXsYatLn_8o2452ugzse0I_ES6VuZd_owok1OC1SnTEvcx75wfIs/spiraling_into_control.png\"\n      alt=\"The image shows a 3x3 grid of rooms and a 5x5 grid of rooms. Each room is numbered as described above.\"/>\n</p><p>\nDante starts off in room $$$1$$$ and is trying to reach the central room (room $$$\\mathbf{N}^2$$$).\nThroughout his journey, he can only make moves from his current room to higher-numbered, adjacent\nrooms. (Two rooms must share an edge &mdash; not just a corner &mdash; to be adjacent.)\n</p><p>\nDante knows that he could walk from room to room in consecutive numerical order &mdash; i.e., if he\nis currently in room $$$x$$$, he would move to room $$$x+1$$$, and so on. This would take\nhim exactly $$$\\mathbf{N}^2 - 1$$$ moves. But Dante wants to do things his way! Specifically, he wants to\nreach the central room in exactly $$$\\mathbf{K}$$$ moves, for some $$$\\mathbf{K}$$$ strictly less than $$$\\mathbf{N}^2 - 1$$$.\n</p><p>\nDante can accomplish this by taking one or more <i>shortcuts</i>. A shortcut is a move between\nrooms that are not consecutively numbered.\n</p><p>\nFor example, in the $$$5 \\times 5$$$ house above,\n<ul>\n  <li>If Dante is at $$$1$$$, he cannot move to $$$17$$$, but he can move to $$$2$$$ or to\n    $$$16$$$. The move to $$$2$$$ is not a shortcut, since $$$1 + 1 = 2$$$. The move to\n    $$$16$$$ is a shortcut, since $$$1 + 1 \\neq 16$$$.</li>\n  <li>From $$$2$$$, it is possible to move to $$$3$$$ (not a shortcut) or to $$$17$$$ (a shortcut),\n    but not to $$$1$$$, $$$16$$$, or $$$18$$$.</li>\n  <li>From $$$24$$$, Dante can only move to $$$25$$$ (not a shortcut).</li>\n  <li>It is not possible to move out of room $$$25$$$.</li>\n</ul>\n<p>\nAs a specific example using the $$$5 \\times 5$$$ house above, suppose that $$$\\mathbf{K}$$$ = $$$4$$$. One\noption is for Dante to move from $$$1$$$ to $$$2$$$, then move from $$$2$$$ to $$$17$$$ (which is\na shortcut), then move from $$$17$$$ to $$$18$$$, then move from $$$18$$$ to $$$25$$$ (which is\nanother shortcut). This is illustrated below (the red arrows represent shortcuts):\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1a4v8UWEYflxlwTYZhR6y-aC8tBE62S8a5EVJe8Rb-YJJ_1VFAv7SbhL-1Jt-a3J8BjKjZR0OC7BZniVDXHf2pebLF76Cr4X-cdqNROKTm_A/spiraling_into_control_example.png\"\n      alt=\"The image shows a 5x5 grid of rooms numbered as described in the statement. A path with arrows goes from 1 to 2 to 17 to 18 to 25. The arrows between 2 and 17 as well as 18 and 25 are red to show they are shortcuts.\"/>\n</p><p>\n  Can you help Dante find a sequence of exactly $$$\\mathbf{K}$$$ moves that gets him to the central room, or\n  tell him that it is impossible?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case consists of one line with two integers $$$\\mathbf{N}$$$ and $$$\\mathbf{K}$$$, where $$$\\mathbf{N}$$$ is the dimension of\nthe house (i.e. the number of rows of rooms, which is the same as the number of columns of rooms),\nand $$$\\mathbf{K}$$$ is the exact number of moves that Dante wants to make while traveling from room $$$1$$$\nto room $$$\\mathbf{N}^2$$$.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1).\n</p><p>\nIf no valid sequence of exactly $$$\\mathbf{K}$$$ moves will get Dante to the central room, $$$y$$$ must be\n<code>IMPOSSIBLE</code>.\n</p><p>\nOtherwise, $$$y$$$ must be an integer: the number of times that Dante takes a shortcut, as\ndescribed above. (Notice that because Dante wants to finish in strictly less than\n$$$\\mathbf{N}^2 - 1$$$ moves, he must always use at least one shortcut.) Then, output $$$y$$$ more lines\nof two integers each. The $$$i$$$-th of these lines represents the $$$i$$$-th time in Dante's\njourney that he takes a shortcut, i.e., he moves from some room $$$a_i$$$ to another room $$$b_i$$$\nsuch that $$$a_i + 1 \\lt b_i$$$.\n</p><p>\nNotice that because these lines follow the order of the journey, $$$a_i \\lt a_{i+1}$$$ for all\n$$$1 \\le i \\lt y$$$.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n$$$1 \\le \\mathbf{K} \\lt \\mathbf{N}^2 - 1$$$.<br/>\n$$$ \\mathbf{N} \\mod 2 \\equiv 1$$$. ($$$\\mathbf{N}$$$ is odd.)<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 5 seconds.<br/>\n\n$$$3 \\le \\mathbf{N} \\le 9$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Visible Verdict)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n\n$$$3 \\le \\mathbf{N} \\le 39$$$.<br/>\n</p>\n\n<h4>Test Set 3 (Hidden Verdict)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n\n$$$3 \\le \\mathbf{N} \\le 9999$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1WS9aYf-HR26wFS3hg9ekjKiGvTS4pYUb0DssBOSlRHOT0U7UiHSXqmwhlg3ZnWdiC2l6KtipCz5ORq4kzI9aUZ2OqzWqK5JRvsQbTGM-0lwqOgEXT/spiraling_into_control_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n5 4\n5 3\n5 12\n3 1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2rSN0_uv4QlDaPvTwbHdOTLcOS3kvKm5waT29seFHe8azL8M1nIXlK9UpEBmS5YeK2e9Vyu-TpJX39t-Q8Bw6PO36hWKC4Tuv02gchDCvM0aE5e5_j1w/spiraling_into_control_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 2\n2 17\n18 25\nCase #2: IMPOSSIBLE\nCase #3: 2\n11 22\n22 25\nCase #4: IMPOSSIBLE\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<p>\n  Sample Case #1 is described in the problem statement. Dante's route is\n  $$$1 \\to 2 \\to 17 \\to 18 \\to 25$$$. Because $$$1 \\to 2$$$ and\n  $$$17 \\to 18$$$ are moves between consecutively numbered rooms, they are not included in the\n  output. Only the shortcuts ($$$2 \\to 17$$$ and $$$18 \\to 25$$$) are included.\n</p><p>\n  In Sample Case #2, there is no solution. (Recall that there is no way for Dante to move\n  diagonally.)\n</p><p>\n  In Sample Case #3, observe that $$$22$$$ appears both as the end of one shortcut and the\n  start of the next. It would not be valid to include the line <code>11 22 25</code> in the output;\n  each line must represent a single shortcut.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1cflwm3NYFICzRuKsSxnFcGBWiJR3YVObCzPq7_f01LBYXXZJ4z2unlczXL1nTlZ0SAyZu3qSslBeKbHXYSpy4p0bYMcM9IOI9FR5GbcIzOf-7/spiraling_into_control_example_2.png\"\n      alt=\"The image shows a 5x5 grid of rooms numbered as described in the statement. A path with arrows is shown as described above. The arrows between 11 and 22 as well as 22 and 25 are red to show they are shortcuts.\"/>\n</p><p>\n  There is another solution that uses only one shortcut: Dante can\n  move from $$$1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 6$$$, then move from\n  $$$6 \\to 19$$$ (a shortcut), then move from\n  $$$19 \\to 20 \\to 21 \\to 22 \\to 23 \\to 24 \\to 25$$$. This is also valid; there is no requirement\n  to minimize (or maximize) the number of shortcuts taken.\n</p><p>\n  In Sample Case #4, Dante cannot get to the central room ($$$9$$$, in this case) in just one move.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":3},{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Spiraling Into Control","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000008778ec","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2022","ui_appearance":0,"ui_appearance__str":"APPEARANCE_TYPE_DEFAULT"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
