{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1334448000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432b33","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nGoogle Code Jam 2012 has begun, and our contestants have made a huge showing!  We have 15692 qualifiers, out of 20613 people who downloaded at least one input.  We had contestants representing 149 different regions of the world, using 73 programming languages.  All those numbers are records for us!\n</p>\n\n<p>\nThis year marked a change to our rules: before, every problem had to have one Small input and one Large input.  This year we led off with a problem that had only a Small input, and we might make other problems that are unusual in that way as the contest goes on.\n</p>\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Speaking in Tongues</i> Written and prepared by David Arthur.</p>\n<p>Problem B. <i>Dancing With the Googlers</i> Written by Bartholomew Furrow.  Prepared by Onufry Wojtaszczyk and Bartholomew Furrow.</p>\n<p>Problem C. <i>Recycled Numbers</i> Written by David Arthur.  Prepared by David Arthur and Sean Henderson.</p>\n<p>Problem D. <i>Hall of Mirrors</i> Written by David Arthur.  Prepared by Bartholomew Furrow.</p>\n<p>Contest analysis presented by David Arthur, Tomek Czajka, Ahmed Aly, and David Arthur again.</p>\n<p>Solutions and other problem preparation by Igor Naverniouk, Adam Polak, Andrei Missine, John Dethridge, Jon Calhoun, Luka Kalinovcic, Khaled Hafez, and Tim Kirchner.</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1334358000000,"tasks":[{"analysis":"<p>To keep things exciting, we ended the qualification round with Hall of Mirrors: a truly challenging problem. It is difficult to see how to get started, and then it is even more difficult to actually get the implementation right!</p>\n\n<br/>\n<p><b>How To Understand Mirrors</b></p>\n\n<p>The first step in solving this problem is reducing the set of all light ray angles to something that you can actually check. And to do that, it is helpful to use a famous trick for thinking about mirrors. Look at the two diagrams below. Do you see why they are really illustrating the exact same thing?</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1ap4SuwlzSHsgoFaPZl3j1r9i11C2r9Ti3FEqS8SGAeuRLRNBSUW_L1cLVsC0qVFTFXsrqcfZc8A6nMrQ/reflected_room.png\">\n\n<p>In the left picture, there is a light ray in a 2x1 room that reflects off three mirrors, and then ends back where it started. Let's focus on where the light ray reflects off the bottom mirror. Instead of drawing the reflected light ray, let's take the <i>entire room</i>, and draw it reflected about this mirror. We can then draw the rest of the light ray's path in this picture. This is illustrated in the left diagram below:</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2YE9c4vZCi62kVXdZz73EGk__Wg05ITSb6LhMsLG8kPrWtvhNjASeVMCSmLm4S7YDryGZhqPQJ2j8-hJRL/reflected_room2.png\">\n\n<p>Next, once the light ray hits the right mirror, we can again draw the entire room reflected about that mirror, and then continue drawing the rest of the path there. Finally, we can do the same thing for the one remaining mirror to get the original picture from above. This kind of drawing has two really nice properties for us:</p>\n\n<ul>\n<li> The light ray is perfectly straight, and it never bends or turns.\n<li> No matter how many reflections we do, and no matter where they are, the reflected position of your starting point will always be in the middle of some square.\n</ul>\n\n</p>Together, these imply the key fact you need to get started: for a light ray to even have a chance of reflecting back to you in distance at most <b>D</b>, it must be directed towards the center of a square that is distance at most <b>D</b> from you.</p>\n\n<br/>\n<p><b>The Small Input</b></p>\n\n<p>If you get this far, you can either try to solve just the small input or both the small and the large. The small input isn't that much <i>smaller</i> really, but it is <i>simpler</i> because you cannot have mirrors in the middle of rooms. This means that we can take the original room and repeatedly reflect it about each of the four walls to cover the whole plane. This is shown below:\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0AuVKJf_57JxsHOEWXVsl3WkdYCLJNgHLR0-iWLtQuzyjdqw_iHv_Qf7Y07hw8XsnrBLZpy3iYfV9Ifw/small_example.png\">\n\n<p>Now let's look at your position in each of these reflected rooms. We claim that these give precisely the directions you can look in order to see a reflection of yourself. Try tracing through a few cases and you will see why.\n</p>\n\n<p>So to solve the problem, you can iterate over all of these positions that are within distance <b>D</b> of you, and count how many unique directions they give. (Remember that the light ray stops once it returns to you, so if two reflections are in precisely the same direction, only one is visible.)</p>\n\n<br/>\n<p><b>The Large Input</b></p>\n\n<p>The large input is not any harder conceptually, but you will have to do some more implementation. The idea is to iterate over all squares within distance <b>D</b> of your starting location, and to follow light rays that are directed towards each of these squares. In particular, how many of these light rays return to the starting position after distance <b>D</b>? The challenge of following rays through a 2-dimensional grid is called \"ray casting\", and solving it efficiently was the key to Wolfenstein 3D and other games of that era.</p>\n\n<p>This isn't too hard in theory, but the implementation can get nasty if you do not set things up carefully. One approach that helps is to first focus on rays that are moving more vertically than they are horizontally. Then, iterate over each horizontal line the ray touches. Between each of these steps, it will touch 0 or 1 vertical lines, making the processing fairly straightforward (except for corners!).</p>\n\n<p>If you are stuck, try looking through the submitted solutions.</p>","id":"0000000000432a8a","statement":"<h3>Problem</h3>\n<p>\nYou live in a 2-dimensional plane, and one of your favourite places to visit is the Hall of Mirrors.  The Hall of Mirrors is a room (a 2-dimensional room, of course) that is laid out in a grid.  Every square on the grid contains either a square mirror, empty space, or you.  You have width 0 and height 0, and you are located in the exact centre of your grid square.\n</p>\n<p>\nDespite being very small, you can see your reflection when it is reflected back to you exactly.  For example, consider the following layout, where <code>'#'</code> indicates a square mirror that completely fills its square, <code>'.'</code> indicates empty space, and the capital letter <code>'X'</code> indicates you are in the center of that square:\n<pre>\n######\n#..X.#\n#.#..#\n#...##\n######\n</pre>\nIf you look straight up or straight to the right, you will be able to see your reflection.\n</p>\n<p>\nUnfortunately in the Hall of Mirrors it is very foggy, so you can't see further than <b>D</b> units away.  Suppose <b>D</b>=3.  If you look up, your reflection will be 1 unit away (0.5 to the mirror, and 0.5 back).  If you look right, your reflection will be 3 units away (1.5 to the mirror, and 1.5 back), and you will be able to see it.  If you look down, your reflection will be 5 units away and you won't be able to see it.\n</p>\n<p>\nIt's important to understand how light travels in the Hall of Mirrors.  Light travels in a straight line until it hits a mirror.  If light hits any part of a mirror but its corner, it will be reflected in the normal way: it will bounce off with an angle of reflection equal to the angle of incidence.  If, on the other hand, the light would touch the corner of a mirror, the situation is more complicated.  The following diagrams explain the cases:\n</p>\n<p>\nIn the following cases, light approaches a corner and is reflected, changing its direction:\n<br/><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1xJUXFpMTrKY-ofpJ98-FJ0i78gI0tg9nSrH8FxrtrSaPFnuDFCw3OUN96g4O3_JuehMo2cm3fEw/reflection.png\"><br/>\nIn the first two cases, light approached two adjacent mirrors at the point where they met.  Light was reflected in the same way as if it had hit the middle of a long mirror.  In the third case, light approached the corners of three adjacent mirrors, and returned in exactly the direction it came from.\n</p>\n<p>\nIn the following cases, light approaches the corners of one or more mirrors, but does not bounce, and instead continues in the same direction:\n<br/><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2NnLmUTkpkSGjXP6d84kjS1WhJlWprYCRjruGiwEmA4zsvZmI0g5pp5QXMF4Rj4l5NueViziXdd84STw/no_reflection.png\"><br/>\nThis happens when light reaches distance 0 from the corner of a mirror, but would not have to pass through the mirror in order to continue in the same direction.  In this way, a ray of light can pass between two mirrors that are diagonally adjacent to each other -- effectively going through a space of size 0.  Good thing it's of size 0 too, so it fits!\n</p>\n<p>\nIn the final case, light approaches the corner of one mirror and is destroyed:\n<br/><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0E3-c-sGbfXVbSpx5jalhVWCcAehTTKFVaGFoSiUE4JCM2F7r1v7GmW81di1ztNdorqTpQ1YSM-LA/destruction.png\"/><br/>\nThe mirror was in the path of the light, and the ray of light didn't approach the corners of any other mirrors.\n</p>\n<p>\nNote that light stops when it hits you, but it has to hit the exact centre of your grid square.\n</p>\n<p>\nHow many images of yourself can you see?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case starts with a line containing three space-separated integers, <b>H</b>, <b>W</b> and <b>D</b>.  <b>H</b> lines follow, and each contains <b>W</b> characters.  The characters constitute a map of the Hall of Mirrors for that test case, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of reflections of yourself you can see.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 60 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n3 &le; <b>H</b>, <b>W</b> &le; 30.<br/>\n1 &le; <b>D</b> &le; 50.<br/>\nAll characters in each map will be <code>'#'</code>, <code>'.'</code>, or <code>'X'</code>.<br/>\nExactly one character in each map will be <code>'X'</code>.<br/>\nThe first row, the last row, the first column and the last column of each map will be entirely filled with <code>'#'</code> characters.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\nThere will be no more than <code>2W+2H-4</code> <code>'#'</code> characters.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\nThe restriction from the Small dataset does not apply.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">6\n3 3 1\n###\n#X#\n###\n3 3 2\n###\n#X#\n###\n4 3 8\n###\n#X#\n#.#\n###\n7 7 4\n#######\n#.....#\n#.....#\n#..X..#\n#....##\n#.....#\n#######\n5 6 3\n######\n#..X.#\n#.#..#\n#...##\n######\n5 6 10\n######\n#..X.#\n#.#..#\n#...##\n######\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 8\nCase #3: 68\nCase #4: 0\nCase #5: 2\nCase #6: 28\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first case, light travels exactly distance 1 if you look directly up, down, left or right.\n</p>\n<p>\nIn the second case, light travels distance 1.414... if you look up-right, up-left, down-right or down-left.  Since light does not travel through you, looking directly up only shows you one image of yourself.\n</p>\n<p>\nIn the fifth case, while the nearby mirror is close enough to reflect light back to you, light that hits the corner of the mirror is destroyed rather than reflected.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Hall of Mirrors","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>Many contestants got stuck in this problem because of the sample test case number 4. Let's say <i>n</i> is 1212, then after moving 1 or 3 digits you will get 2121, hence the pair (1212, 2121) will be counted twice if you count all possible moves. You can avoid this by breaking out of the loop once you reach the original number again, which will happen after moving 2 digits in the above example.</p>\n\n<p>For the small input you can simply check for each pair (<i>n</i>, <i>m</i>), <b>A</b> &le; <i>n</i> &lt; <i>m</i> &le; <b>B</b>,  whether it satisfies the conditions mentioned in the problem statement, and whether you can obtain <i>m</i> by moving some digits from the back of <i>n</i> to the front without changing their order. To check if you can obtain <i>m</i> from <i>n</i> simply try to move all possible groups of digits from <i>n</i> and check if what you get is <i>m</i>. The digit shifting can be done using string manipulation or mathematical expressions, both will run within the time limit.</p>\n\n<p>But the previous solution will not run within the time limit for the large test cases. So here is another solution which should run within the time limit. For each number <i>n</i>, <b>A</b> &le; <i>n</i> &le; <b>B</b>, try to move all possible groups of digits from its back to its front and check if the resulting number satisfies the conditions or not. If it does satisfy the conditions then increment the result. Don't forget to avoid counting the same number twice.</p>\n\n<p>Here is a sample solution:</p>\n\n<pre>\nint solve(int A, int B) {\n    int power = 1, temp = A;\n    while (temp &gt;= 10) {\n        power *= 10;\n        temp /= 10;\n    }\n    int result = 0;\n    for (int n = A; n &lt;= B; ++n) {\n        temp = n;\n        while (true) {\n            temp = (temp / 10) + ((temp % 10) * power);\n            if (temp == n)\n                break;\n            if (temp &gt; n &amp;&amp; temp &lt;= B)\n                result++;\n        }\n    }\n    return result;\n}\n</pre>","id":"0000000000432be6","statement":"<h3>Problem</h3>\n<p>\nDo you ever become frustrated with television because you keep seeing the same things, recycled over and over again? Well I personally don't care about television, but I do sometimes feel that way about numbers.\n</p>\n\n<p>\nLet's say a pair of distinct positive integers (<i>n</i>, <i>m</i>) is <i>recycled</i> if you can obtain <i>m</i> by moving some digits from the back of <i>n</i> to the front without changing their order. For example, (12345, 34512) is a recycled pair since you can obtain 34512 by moving 345 from the end of 12345 to the front. Note that <i>n</i> and <i>m</i> must have the same number of digits in order to be a recycled pair. Neither <i>n</i> nor <i>m</i> can have leading zeros.\n</p>\n\n<p>\nGiven integers <b>A</b> and <b>B</b> with the same number of digits and no leading zeros, how many distinct recycled pairs (<i>n</i>, <i>m</i>) are there with <b>A</b> &le; <i>n</i> &lt; <i>m</i> &le; <b>B</b>?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case consists of a single line containing the integers <b>A</b> and <b>B</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1), and y is the number of recycled pairs (<i>n</i>, <i>m</i>) with <b>A</b> &le; <i>n</i> &lt; <i>m</i> &le; <b>B</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 30 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n<b>A</b> and <b>B</b> have the same number of digits.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>A</b> &le; <b>B</b> &le; 1000.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>A</b> &le; <b>B</b> &le; 2000000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 9\n10 40\n100 500\n1111 2222\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 3\nCase #3: 156\nCase #4: 287\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h4>Are we sure about the output to Case #4?</h4>\n<p>\nYes, we're sure about the output to Case #4.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Recycled Numbers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>In most Google Code Jam problems, each test case is completely separate and nothing you learn from one will be useful in another. This problem was different however:</p>\n\n<p><i>\"Googlerese is based on the best possible replacement mapping, and we will never change it. It will always be the same. In every test case.\"</i></p>\n\n<p>We meant it when we said this! There really is just one mapping, and the main challenge here is figuring out what it is. Fortunately, there is a lot we can learn from the sample input and output. For example, by looking at the first word in the first line, we know that \"our\" becomes \"ejp\" in Googlerese, so 'o' -&gt; 'e', 'u' -&gt; 'j', and 'r' -&gt; 'p'. If you go through the entire text, you will that there is almost enough information to reconstruct the entire mapping:</p>\n\n<pre>\n'a' -&gt; 'y'\n'b' -&gt; 'n'\n'c' -&gt; 'f'\n'd' -&gt; 'i'\n'e' -&gt; 'c'\n'f' -&gt; 'w'\n'g' -&gt; 'l'\n'h' -&gt; 'b'\n'i' -&gt; 'k'\n'j' -&gt; 'u'\n'k' -&gt; 'o'\n'l' -&gt; 'm'\n'm' -&gt; 'x'\n'n' -&gt; 's'\n'o' -&gt; 'e'\n'p' -&gt; 'v'\n'q' -&gt; ???\n'r' -&gt; 'p'\n's' -&gt; 'd'\n't' -&gt; 'r'\n'u' -&gt; 'j'\n'v' -&gt; 'g'\n'w' -&gt; 't'\n'x' -&gt; 'h'\n'y' -&gt; 'a'\n'z' -&gt; ???\n</pre>\n\n<p>We just need to figure out how to translate 'q' and 'z'. But if you read the problem statement carefully, you will notice there was one more example we gave you! \"a zoo\" gets translated to \"y qee\". This means that 'z' gets mapped to 'q'.</p>\n\n<p>Next we have to figure out what 'q' gets mapped to. For this part, you need to remember that every letter gets mapped to something different. And if you look carefully, there is already a letter getting mapped to everything except for 'z'. This leaves only one possibity: 'q' must get mapped to 'z'.</p>\n\n<p>And now we have the full translation mapping, and all we need to do is write a program to apply it to a bunch of text. Here is a solution in Python:</p>\n\n<pre>\ntranslate_to_english = {\n    ' ': ' ', 'a': 'y', 'b': 'h', 'c': 'e', 'd': 's',\n    'e': 'o', 'f': 'c', 'g': 'v', 'h': 'x', 'i': 'd',\n    'j': 'u', 'k': 'i', 'l': 'g', 'm': 'l', 'n': 'b',\n    'o': 'k', 'p': 'r', 'q': 'z', 'r': 't', 's': 'n',\n    't': 'w', 'u': 'j', 'v': 'p', 'w': 'f', 'x': 'm',\n    'y': 'a', 'z': 'q'}\n\nfor tc in xrange(1, int(raw_input()) + 1):\n  english = ''.join(\n      [translate_to_english[ch] for ch in raw_input()])\n  print 'Case #%d: %s' % (tc, english)\n</pre>","id":"0000000000432cd2","statement":"<h3>Problem</h3>\n\n<p>\nWe have come up with the best possible language here at Google, called Googlerese. To translate text into Googlerese, we take any message and replace each English letter with another English letter. This mapping is <i>one-to-one</i> and <i>onto</i>, which means that the same input letter always gets replaced with the same output letter, and different input letters always get replaced with different output letters. A letter may be replaced by itself. Spaces are left as-is.\n</p>\n\n<p>\nFor example (and here is a hint!), our awesome translation algorithm includes the following three mappings: 'a' -&gt; 'y', 'o' -&gt; 'e', and 'z' -&gt; 'q'. This means that \"a zoo\" will become \"y qee\".\n</p>\n\n<p>\nGooglerese is based on the best possible replacement mapping, and we will never change it. It will always be the same. In every test case. We will not tell you the rest of our mapping because that would make the problem too easy, but there are a few examples below that may help.</p>\n\n<p>\nGiven some text in Googlerese, can you translate it to back to normal text?\n</p>\n\n<h3>Solving this problem</h3>\n<p>\nUsually, Google Code Jam problems have 1 Small input and 1 Large input.  This problem has only <b>1 Small input</b>.  Once you have solved the Small input, you have finished solving this problem.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, one per line.\n</p>\n\n<p>\nEach line consists of a string <b>G</b> in Googlerese, made up of one or more words containing the letters 'a' - 'z'. There will be exactly one space (' ') character between consecutive words and no spaces at the beginning or at the end of any line.\n</p>\n\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>X</b>: <b>S</b>\" where <b>X</b> is the case number and <b>S</b> is the string that becomes <b>G</b> in Googlerese.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds.<br/>\nMemory limit: 1GB.<br/>\nThere is only one test set which has visible verdict.<br/>\n1 &le; <b>T</b> &le; 30.<br/>\n<b>G</b> contains at most 100 characters.<br/>\nNone of the text is guaranteed to be valid English.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\nejp mysljylc kd kxveddknmc re jsicpdrysi\nrbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd\nde kr kd eoya kw aej tysr re ujdr lkgc jv\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: our language is impossible to understand\nCase #2: there are twenty six factorial possibilities\nCase #3: so it is okay if you want to just give up\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15}],"title":"Speaking in Tongues","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nClever contestants will have noticed that this problem might be based on an actual television show.  The author of the problem found himself watching an episode of <i>Dancing With the Stars</i> (the show and its distributor, BBC Worldwide, do not endorse and are not involved with Google Code Jam), and having forgotten whether any of the contestants had earned a score of at least 8 from any of the judges.\n</p>\n<p>\nThe judges on that show very often agree within 1 point of each other, and it really is surprising when they disagree by so much.  There are a few key observations that help us solve this problem:\n</p>\n<ol>\n<li>\nAny non-surprising score is expressed uniquely by an unordered triplet of judges' scores.  21 must be 7 7 7; 22 must be 7 7 8; 23 must be 7 8 8.\n</li>\n<li>\nThere only a few kinds of surprising scores.  21 could be 6 7 8; 22 could be 6 8 8; 23 could be 9 7 7.  There's a repeating pattern of surprising scores that extends from 2 (0, 0, 2) to 28 (8, 10, 10).\n</li>\n<li>\nThe repeating pattern stops at 2 and 28 because 1 and 29 can't be surprising: we can't use (-1, 1, 1) for 1: -1 is not allowed as a score.  We also can't use (9, 9, 11) for 29.\n</li>\n</ol>\n<p>\nPutting all of these facts together, we can easily construct a mapping from each total score to its <i>best result</i> if it's surprising, and to its best result if it isn't surprising:\n</p>\n<p>\n<pre>\nunsurprising(0) = 0\nunsurprising(1) = 1\nunsurprising(2) = 1\nunsurprising(n) = unsuprising(n-3) + 1\nunsurprising(n) = ceiling(n/3), for 0 &lt;= n &lt;= 30\n\nsurprising(2) = 2\nsurprising(3) = 2\nsurprising(4) = 2\nsurprising(5) = 3\nsurprising(n) = surprising(n-3) + 1\nsurprising(n) = ceiling((n-1)/3) + 1, for 2 &lt;= n &lt;= 28\n</pre>\n</p>\n<p>\nMany contestants wrote an initial solution that didn't take into account that 0, 1, 29 and 30 can't be surprising, and so failed one of our sample inputs.  That's what they're there for!\n</p>\n<p>\nOne way to build the tables of unsurprising(n) and surprising(n) that doesn't require so much thought could involve writing three loops to go through all possible sets of judges' scores, checking whether each combination of three was valid or surprising, and building the maps that way.\n</p>\n<p>\nNow, for each value t<sub>i</sub> we have one of three cases:\n<ul>\n<li>unsurprising(t<sub>i</sub>) &gt;= p. This Googler can be \"good\" (i.e. have a maximum score of at least p) even with an unsurprising triplet.\n<li> 2 &lt;= t<sub>i</sub> &lt;= 28 and surprising(t<sub>i</sub>) &gt;= p &gt; unsurprising(t<sub>i</sub>). This Googler can be \"good\" only by using a surprising triplet.\n<li>Otherwise, the Googler can't be \"good\".\n</ul>\nA simple greedy algorithm works: take all of the Googlers of the first type, and as many as possible (at most S) of the second type.","id":"000000000043315e","statement":"<h3>Problem</h3>\n\n<p>\nYou're watching a show where Googlers (employees of Google) dance, and then each dancer is given a <i>triplet of scores</i> by three judges.  Each triplet of scores consists of three integer scores from 0 to 10 inclusive.  The judges have very similar standards, so it's <i>surprising</i> if a triplet of scores contains two scores that are 2 apart.  No triplet of scores contains scores that are more than 2 apart.\n</p>\n<p>\nFor example: (8, 8, 8) and (7, 8, 7) are not surprising.  (6, 7, 8) and (6, 8, 8) are surprising.  (7, 6, 9) will never happen.\n</p>\n<p>\nThe <i>total points</i> for a Googler is the sum of the three scores in that Googler's triplet of scores.  The <i>best result</i> for a Googler is the maximum of the three scores in that Googler's triplet of scores.  Given the total points for each Googler, as well as the number of surprising triplets of scores, what is the maximum number of Googlers that could have had a best result of at least <b>p</b>?\n</p>\n<p>\nFor example, suppose there were 6 Googlers, and they had the following total points:\n<code>29, 20, 8, 18, 18, 21</code>.  You remember that there were 2 surprising triplets of scores, and you want to know how many Googlers could have gotten a best result of 8 or better.\n</p>\n<p>\nWith those total points, and knowing that two of the triplets were surprising, the triplets of scores could have been:\n<pre>\n10 9 10\n6 6 8 (*)\n2 3 3\n6 6 6\n6 6 6\n6 7 8 (*)\n</pre>\nThe cases marked with a (*) are the surprising cases.  This gives us 3 Googlers who got at least one score of 8 or better.  There's no series of triplets of scores that would give us a higher number than 3, so the answer is 3.\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of a single line containing integers separated by single spaces.  The first integer will be <b>N</b>, the number of Googlers, and the second integer will be <b>S</b>, the number of surprising triplets of scores.  The third integer will be <b>p</b>, as described above.  Next will be <b>N</b> integers <b>t<sub>i</sub></b>: the total points of the Googlers.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the maximum number of Googlers who could have had a best result of greater than or equal to <b>p</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 40 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &le; <b>S</b> &le; N.<br/>\n0 &le; <b>p</b> &le; 10.<br/>\n0 &le; <b>t<sub>i</sub></b> &le; 30.<br/>\nAt least <b>S</b> of the <b>t<sub>i</sub></b> values will be between 2 and 28, inclusive.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 3.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3 1 5 15 13 11\n3 0 8 23 22 21\n2 1 1 8 0\n6 2 8 29 20 8 18 18 21\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 2\nCase #3: 1\nCase #4: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Dancing With the Googlers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432b33","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2012"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
