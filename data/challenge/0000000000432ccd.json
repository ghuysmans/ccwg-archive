{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1274614200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432ccd","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThis last sub-round of round 1 saw the largest number of contestants and the largest amount of controversy. Problem A was about permutations masquerading as a geometry problem. Problem B was a crazy twist on Binary Search. And Problem C was a combination of parsing, dynamic programming and clever trickery.\n</p>\n<p>\n<i>Load Testing</i> turned out to be the most unusual problem. We received dozens of requests for additional hints and explanations of sample test cases. It was a challenge for the judges to explain the problem as clearly as possible while remaining fair to all contestants. If our responses seemed harsh and unhelpful at times, please know that we tried our best to remain as fair as possible. Perhaps the analysis of Problem B can help clear up any remaining confusion.\n</p>\n<p>\nZhukovDmitry finished all 3 problems in just over 38 minutes, closely followed by darnley, who was only 22 seconds behind. aytawgf took the third place in just under one hour of total time.\n</p>\n<p>\nCongratulations to the 3000 contestants who have advanced to Round 2.\n</p>\n\n<h3>Cast</h3>\n<p>Problem A. <i>Rope Intranet</i> Written by Cosmin Negruseri. Prepared by Petr Mitrichev.</p>\n<p>Problem B. <i>Load Testing</i> Written by Bartholomew Furrow. Prepared by Petr Mitrichev and Bartholomew Furrow.</p>\n<p>Problem C. <i>Making Chess Boards</i> Written and prepared by Igor Naverniouk.</p>\n<p>Contest analysis presented by Petr Mitrichev, Igor Naverniouk, and Cosmin Negruseri.</p>\n<p>Solutions and other problem preparation provided by David Arthur, Xiaomin Chen, Ante Derek, and John Dethridge.</p>\n<p>\nAnd a special thanks to Martin Gardner, whose books have inspired and educated many of us.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1274605200000,"tasks":[{"analysis":"<h3>Finding the largest chess board</h3>\n<p>\nFirst, we need a quick way to find the largest chess board. There is classic dynamic programming trick that goes like this. Let's compute, for each cell <nobr>(i, j)</nobr>, the size of the largest square whose bottom-right corner is <nobr>(i, j)</nobr>. Let's call this value larg[i][j]. It is easy to compute larg[i][0] and larg[0][j] -- they are always 1. For any other cell, the value of larg[i][j] is always at least 1, and it is larger only if the following condition holds:\n<pre>\n  if (board[i - 1][j] != board[i][j] &amp;&amp;\n      board[i][j - 1] != board[i][j] &amp;&amp;\n      board[i - 1][j - 1] == board[i][j]) {\n    larg[i][j] = 1 + min(larg[i - 1][j],\n                         larg[i][j - 1],\n                         larg[i - 1][j - 1]);\n  }\n</pre>\nIn a single, linear-time, row-by-row scan, we can compute the values of larg[][] for all cells.\n</p>\n\n<h3>Finding the chess board to remove</h3>\n<p>\nNow that we have larg[][], it is very easy to find the first chess board that we should cut out. Its bottom-right corner is in the cell that has the largest possible value in larg[][]. If there are several such cells, we use the tie-breaking rules described in the problem and choose the one that comes first in lexicographic order of <nobr>(i, j)</nobr>.\n</p>\n<p>\nWe can do this in linear time by scanning larg[][], but since we will have to do this many times, it is better to make a heap of triples of the form\n<pre>\n  (-larg[i][j], i, j)\n</pre>\nand take the smallest element from that heap. This way, we are sorting all cells by decreasing size, then by increasing row, then by increasing column. As long as we can update this heap efficiently after cutting out a chess board, we can always retrieve the smallest element in <nobr>O(log(m*n))</nobr> time. We could also use a balanced binary search tree instead of a heap.\n</p>\n\n<h3>Removing the chess board and updating larg[][]</h3>\n<p>\nConsider removing the first 6x6 chess board from the example input described in the problem statement. How should we update larg[][]? First of all, we can fill the 6x6 square of cells with zeros because there are no more chess boards to be removed from those locations. But that is not all. There are other cells that might need to be updated. Where are they, and how many of them are there?\n</p>\n<p>\nNaively, we can simply recompute the values of all non-zero cells in larg[][] and continue. If we do that, we will have a <nobr>O(m<sup>2</sup>*n<sup>2</sup>)</nobr> algorithm, which is too slow.\n</p>\n<p>\nFirst of all, notice that we do not need to update rows above or to the left of the 6x6 square. Any square chess boards whose bottom-right corners are in those areas still exist and can be cut out later. The only chess boards that we need to worry about are those that overlap the 6x6 board that we have just removed. Also, notice that we have just removed the largest possible chess board, so we only need to care about remaining boards of size 6 or smaller. Where can their bottom-right corners lie in order for those boards to overlap <i>our</i> board? They must be in the 12x12 square whose center is at <nobr>(i, j)</nobr> -- the bottom-right corner of our board.\n</p>\n<p>\nThat's an area of size <nobr>4*6<sup>2</sup></nobr>. In fact, whenever we remove a board of size k-by-k, we only need to update an area of larg[][] of size at most <nobr>2k-by-2k</nobr>. Since we can only remove each cell at most once, all of the updating work requires linear time in total; <nobr>4*m*n</nobr> updates, to be precise.\n</p>\n\n<h3>Updating the heap</h3>\n<p>\nEach time we update larg[][], we must also update the heap that lets us find the next board to remove. This means finding and removing an old entry, as well as inserting a new entry. With pointers from cells to heap elements, or by using a balanced binary search tree, both steps can be done in <nobr>O(m*n)</nobr> time.\n</p>\n<p>\nIn total, this algorithm runs in <nobr>O(n*m*log(n*m))</nobr> time, which is plenty fast for the problem's constraints.\n</p>","id":"0000000000432a84","statement":"<h3>Problem</h3>\n<p>\nThe chess board industry has fallen on hard times and needs your help. It is a little-known fact that chess boards are made from the bark of the extremely rare Croatian Chess Board tree, (<i>Biggus Mobydiccus</i>). The bark of that tree is stripped and unwrapped into a huge rectangular sheet of chess board material. The rectangle is a grid of black and white squares.\n</p>\n\n<p>\nYour task is to make as many large square chess boards as possible. A chess board is a piece of the bark that is a square, with sides parallel to the sides of the bark rectangle, with cells colored in the pattern of a chess board (no two cells of the same color can share an edge).\n</p>\n\n<p>\nEach time you cut out a chess board, you must choose the largest possible chess board left in the sheet.  If there are several such boards, pick the topmost one. If there is still a tie, pick the leftmost one.  Continue cutting out chess boards until there is no bark left. You may need to go as far as cutting out 1-by-1 mini chess boards.\n</p>\n\n<p>\nHere is an example showing the bark of a Chess Board tree and the first few chess boards that will be cut out of it.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1MPDixBiVWw2ybQVdPPWAeAOG4sZ4XDsyF_nHT_HYdzlpyagX8zVVedxeRxmL2TDAR/mcb.png\">\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one starts with a line containing the dimensions of the bark grid, <b>M</b> and <b>N</b>. <b>N</b> will always be a multiple of 4. The next <b>M</b> lines will each contain an (<b>N</b>/4)-character hexadecimal integer, representing a row of the bark grid. The binary representation of these integers will give you a strings of <b>N</b> bits, one for each row. Zeros represent black squares; ones represent white squares of the grid.  The rows are given in the input from top to bottom. In each row, the most-significant bit of the hexadecimal integer corresponds to the leftmost cell in that row.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: <b>K</b>\", where x is the case number (starting from 1) and <b>K</b> is the number of different chess board sizes that you can cut out by following the procedure described above. The next <b>K</b> lines should contain two integers each -- the size of the chess board (from largest to smallest) and the number of chess boards of that size that you can cut out.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100;<br>\n<b>N</b> will be divisible by 4;<br>\nEach hexadecimal integer will contain exactly <b>N</b>/4 characters.<br>\nOnly the characters 0-9 and A-F will be used.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>M</b> &le; 32;<br>\n1 &le; <b>N</b> &le; 32.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>M</b> &le; 512;<br>\n1 &le; <b>N</b> &le; 512;<br>\nThe input file will be at most 200kB in size.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n15 20\n55555\nFFAAA\n2AAD5\nD552A\n2AAD5\nD542A\n4AD4D\nB52B2\n52AAD\nAD552\nAA52D\nAAAAA\n5AA55\nA55AA\n5AA55\n4 4\n0\n0\n0\n0\n4 4\n3\n3\nC\nC\n4 4\n6\n9\n9\n6\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5\n6 2\n4 3\n3 7\n2 15\n1 57\nCase #2: 1\n1 16\nCase #3: 2\n2 1\n1 12\nCase #4: 1\n2 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>The first example test case represents the image above.</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":18},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Making Chess Boards","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Understanding the sample cases</h3>\n<p>In order to solve this problem, one first needs to get a feeling of what's asked, and looking at the sample cases is a good way to achieve that.</p>\n<p>Take a look at the first sample case. The answer given is 2. How do we achieve the result with just 2 loadtests? Let's make a couple guesses. Suppose we do a loadtest that checks if the site supports 100 users. If we learn that the site can't support 100 users, then we're done: we know we can support 50 users but can't support 100 which is 50*2. However, if we learn that the site can actually support 100 users, we have a very difficult task at hand now: we have only one loadtest left, and we know that the site can support 100 users but can't support 700. Is it possible to solve it?</p>\n<p>Suppose we now loadtest to check if the site supports 300 users. If we learn that the site can't support 300 users, then we've failed to solve the problem: we know we can support 100, but can't support 300 - but 300 is more than 100*2, so we don't have enough knowledge. Moreover, this actually helps us to prove that our loadtest must test for 200 users or less, otherwise we will hit the same issue.</p>\n<p>Now we know that our second loadtest must use at most 200 users. But even when it's exactly 200, suppose we learn that our site can actually support all of them. Then we've failed to solve the problem again: we know we can support 200, but can't support 700 - but 700 is more than 200*2.</p>\n<p>So there's no good choice for our second loadtest. It means that the choice of the first loadtest was wrong - 100 users is too small for it.</p>\n<h3>What have we learned?</h3>\n<p>However, we've learned an important lesson in our failed attempt to understand the example case: when we have only one loadtest left, and we know that the site can support <b>L</b> people but can't support <b>P</b> people, we must loadtest with such number <b>X</b> that <b>L</b>*<b>C</b>&gt;=<b>X</b>, and at the same time <b>X</b>*<b>C</b>&gt;=<b>P</b>. The first inequality will help us solve the problem when the loadtest fails, and the second one is helpful if the loadtest succeeds.</p>\n<p>Since there's no such number <b>X</b> for <b>L</b>=100, <b>P</b>=700, <b>C</b>=2, our first attempt above has failed.</p>\n<p>The question now is: how to check if such <b>X</b> exists? From the first equation, we get <b>X</b>&lt;=<b>L</b>*<b>C</b>. From the second one, we get <b>X</b>&gt;=<b>P</b>/<b>C</b>. Such <b>X</b> exists if and only if <b>L</b>*<b>C</b>&gt;=<b>P</b>/<b>C</b>, which means <b>L</b>*<b>C</b><sup>2</sup>&gt;=<b>P</b>. Forgetting the formulas, the upper bound of our range should be at most <b>C</b><sup>2</sup> times more than the lower bound. In that case, we can just take <b>X</b>=<b>L</b>*<b>C</b> for our only loadtest.</p>\n<h3>The second attempt at understanding the first sample case</h3>\n<p>Equipped with this knowledge, we get back to the first sample case. 100 was wrong since 100*2<sup>2</sup>=100*4&lt;700. Maybe we should loadtest for 300 people first? If the loadtest succeeds, then we will have one loadtest left, 300 people OK, 700 people not OK, and since 300*4&gt;=700, we can solve the problem. However, what if the loadtest doesn't succeed? We know that our system can support 50 people but can't support 300 people and have only one loadtest left. Since 50*4&lt;300, we can't do that. So the choice of 300 was also wrong.</p>\n<p>What if we try 200 as the first loadtest? In case it succeeds, we get one loadtest, 200 OK, 700 not OK, 200*4&gt;=700 - we can do that. In case it fails, we get 50 OK, 200 not OK, 50*4&gt;=200 - we can do that as well. So we've finally figured out the algorithm to solve the first sample case using just 2 loadtests:</p>\n<pre>Loadtest for 200 people. If the site can support 200 people:\n  Loadtest for 400 people.\nIf the site can't support 200 people:\n  Loadtest for 100 people.</pre>\n<h3>What have we learned?</h3>\n<p>So how do we figure out if two loadtests are enough? This is actually surprisingly similar to the study of the one loadtest case.</p>\n<p>When we have two loadtests left, and we know that the site can support <b>L</b> people but can't support <b>P</b> people, we must loadtest with such number <b>X</b> that <b>L</b>*<b>C</b><sup>2</sup>&gt;=<b>X</b>, and at the same time <b>X</b>*<b>C</b><sup>2</sup>&gt;=<b>P</b>. The first inequality will help us solve the problem using one remaining loadtest when the loadtest fails, and the second one is helpful if the loadtest succeeds. \n<p>Using the same argument as above, one can see that such number <b>X</b> exists if and only if <b>L</b>*<b>C</b><sup>4</sup>&gt;=<b>P</b> (we got <b>C</b><sup>4</sup> as <b>C</b><sup>2</sup>*<b>C</b><sup>2</sup>).</p>\n<h3>More loadtests?</h3>\n<p>Now it's not so hard to figure out what happens with more than two loadtests. It's possible to solve the problem using three loadtests if and only if <b>L</b>*<b>C</b><sup>8</sup>&gt;=<b>P</b>. For four loadtests, we get <b>L</b>*<b>C</b><sup>16</sup>&gt;=<b>P</b>. And so on. That pretty much describes the solution for this problem.\n<h3>Understanding the sample cases, attempt 3</h3>\n<p>Now we can finally figure out the algorithm to solve the third sample case:  <b>L</b>=1, <b>P</b>=1000, <b>C</b>=2. In order to do this in four loadtests, our first loadtest can be for <b>L</b>*<b>C</b><sup>8</sup>=256:</p>\n<pre>Loadtest for 256 people. If the site can support them:\n  Loadtest for 512 people.\nIf we can't support 256 people:\n  Loadtest for 16 people. If the site can support them:\n    Loadtest for 64 people. If the site can support them:\n      Loadtest for 128 people.\n    If we can't support 64 people:\n      Loadtest for 32 people.\n  If we can't support 16 people:\n    Loadtest for 4 people. If the site can support them:\n      Loadtest for 8 people.\n    If we can't support 4 people:\n      Loadtest for 2 people.</pre>\n<p>This looks quite similar to the binary search algorithm, but performed on exponential scale.</p>\n<h3>Conclusion</h3>\n<p>We started solving this problem by trying to understand the answers for the sample cases, and by the time we actually understood them, we already have a complete solution. The only remaining thing is to implement the solution carefully avoiding the integer overflow issues.</p>\n","id":"0000000000432be0","statement":"<h3>Problem</h3>\n<p>\nNow that you have won Code Jam and been hired by Google as a software engineer, you have been assigned to work on their wildly popular programming contest website.  \n</p>\n<p>\nGoogle is expecting a lot of participants (<b>P</b>) in Code Jam next year, and they want to make sure that the site can support that many people at the same time.  During Code Jam 2010 you learned that the site could support at least <b>L</b> people at a time without any errors, but you also know that the site can't yet support <b>P</b> people.\n</p>\n<p>\nTo determine how many more machines you'll need, you want to know within a factor of <b>C</b> how many people the site can support.  This means that there is an integer <b>a</b> such that you know the site can support <b>a</b> people, but you know the site can't support <b>a</b> * <b>C</b> people.\n</p>\n<p>\nYou can run a series of <i>load tests</i>, each of which will determine whether the site can support at least <b>X</b> people for some integer value of <b>X</b> that you choose.  If you pick an optimal strategy, choosing what tests to run based on the results of previous tests, how many load tests do you need in the worst case?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow, each of which contains space-separated integers <b>L</b>, <b>P</b> and <b>C</b> in that order.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of load tests you need to run in the worst case before knowing within a factor of <b>C</b> how many people the site can support.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 1000.<br/>\n2 &le; <b>C</b> &le; 10.<br/>\n<b>L</b>, <b>P</b> and <b>C</b> are all integers.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>L</b> &lt; <b>P</b> &le; 10<sup>3</sup>.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>L</b> &lt; <b>P</b> &le; 10<sup>9</sup>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n50 700 2\n19 57 3\n1 1000 2\n24 97 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 0\nCase #3: 4\nCase #4: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h4>Explanation</h4>\n<p>\nIn Case #2, we already know that the site can support between 19 and 57 people.  Since those are a factor of 3 apart, we don't need to do any testing.\n</p>\n<p>\nIn Case #4, we can test 48; but if the site can support 48 people, we need more testing, because 48*2 &lt; 97.  We could test 49; but if the site can't support 49 people, we need more testing, because 24 * 2 &lt; 49.  So we need two tests.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Load Testing","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem was easier than it could have been, since the constraints don't require you to write an efficient solution. To solve it you can simply iterate through each pair of ropes and test if they intersect. Checking for intersection can be done in various ways. One way is to write the two line equations and then solve a system of linear equations with two variables to find the intersection point. An easier solution is to simply check if the order of the ends of the pair of ropes on the first building is the opposite of the order of the ends of the ropes on the second building. This translates to the code:\n<pre>\n(A[i] - A[j]) * (B[i] - B[j]) &lt; 0\n</pre>\nThis algorithm takes <i>O(n<sup>2</sup>)</i> and it's fast enough to solve our problem.\n</p>\n<p>\nThis problem is very similar to the classic one which asks for the number of inversions within a given permutation. An inversion for a permutation <i>p</i> is a pair of two indexes <i>i &lt; j</i> such that <i>p<sub>i</sub> &gt; p<sub>j</sub></i>. Let's see why these problems are equivalent. If <i>ra</i> is the rank of <i>A[i]</i> when we sort <i>A</i> and <i>rb</i> is the rank of <i>B[i]</i> when we sort <i>B</i>, then the ropes problem becomes the inversion count problem on the permutation <i>p</i> where <i>p<sub>ra</sub> = rb</i> for each <i>i</i>.\n</p>\n<p>\nThis new problem is a good application for divide and conquer algorithms, and can be solved in <i>O(n log n)</i> time. Merge sort can be adapted nicely to not only sort an array, but count the number of inversions as well. Other solutions use data structures like segment trees, augmented balanced binary search trees or augmented skip lists.</p>\n\n<a href=\"http://www.google.com/search?q=number+of+inversions+in+a+permutation\" target=\"_blank\">Number of inversions in a permutation</a>","id":"000000000043315a","statement":"<h3>Problem</h3>\n<p>\nA company is located in two very tall buildings. The company intranet connecting the buildings consists of many wires, each connecting a window on the first building to a window on the second building.</p>\n<p>You are looking at those buildings from the side, so that one of the buildings is to the left and one is to the right. The windows on the left building are seen as points on its right wall, and the windows on the right building are seen as points on its left wall. Wires are straight segments connecting a window on the left building to a window on the right building.</p>\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1Sp8vmKbRG-HDDS0mjIBlDFjk1kRQ1Yyc341E4YN9APo6HaqHMPeb_q-I_C0mDtCL2f2UoYIpIU7Vg/RopeIntranet.png\"></p>\n<p>You've noticed that no two wires share an endpoint (in other words, there's at most one wire going out of each window). However, from your viewpoint, some of the wires intersect midway. You've also noticed that exactly two wires meet at each intersection point.</p>\n<p>On the above picture, the intersection points are the black circles, while the windows are the white circles.</p>\n<p>How many intersection points do you see?</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each case begins with a line containing an integer <b>N</b>, denoting the number of wires you see.\n</p>\n\n<p>\nThe next <b>N</b> lines each describe one wire with two integers <b>A<sub>i</sub></b> and <b>B<sub>i</sub></b>. These describe the windows that this wire connects: <b>A<sub>i</sub></b> is the height of the window on the left building, and <b>B<sub>i</sub></b> is the height of the window on the right building.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of intersection points you see.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 15.<br/>\n1 &le; <b>A<sub>i</sub></b> &le; 10<sup>4</sup>.<br/>\n1 &le; <b>B<sub>i</sub></b> &le; 10<sup>4</sup>.<br/>\nWithin each test case, all <b>A<sub>i</sub></b> are different.<br/>\nWithin each test case, all <b>B<sub>i</sub></b> are different.<br/>\nNo three wires intersect at the same point.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 2.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\n1 10\n5 5\n7 7\n2\n1 1\n2 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Rope Intranet","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432ccd","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2010"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
