{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1470429000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201b72","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nOur 2016 final round featured five problems instead of the typical six, but\nthey were a bit tougher on average than usual, and they were sufficient to keep\nall of our contestants busy. Nobody solved all five, but each of the five was\nsolved at least once.\n</p><p>\n<i>Integeregex</i> was a relatively approachable but implementation-heavy\nproblem involving regular expressions and automata. <i>Family Hotel</i> and\n<i>Gallery of Pillars</i> were challenging combinatorics and math/geometry\nproblems, respectively. <i>Map Reduce</i> was a graph problem that required\nsome tough but satisfying insights, and <i>Radioactive Islands</i> was an\nunusual path optimization exercise that allowed several possible approaches.\n</p><p>\nkevinsogo jumped out to an impressive early lead with A, B, and C in just over\ntwo hours. About 45 minutes after that, defending champion Gennady.Korotkevich\nstarted to turn up the heat with an impressive flurry of solving that included\nD, C-small, and B-large. Throughout most of the last hour, there were several\nopportunities for another contestant to pass Gennady.Korotkevich, but he pulled\nout of reach in the last 10 minutes with the first and only complete solution\nto E. This left him just one dataset (C-large) shy of a perfect score, and he\ntook the championship for the third year in a row!\n</p><p>\nkevinsogo and EgorKulikov spent some time grappling with D and C, respectively,\nbut ultimately attained impressive scores of 120 and took the honors of second\nand third place. semiexp. and rng..58 also distinguished themselves as the\nfirst solvers of problems B and C, respectively. (EgorKulikov was the first to\nsolve A, and Gennady.Korotkevich had the first solutions for D and E.)\n</p><p>\nThat wraps up our 2016 season! We hope you enjoyed participating, and we'll be\nback again next year to serve up another selection of challenging and fun\nproblems!\n</p><p>\nYou can enjoy a detailed writeup of each problem in the following tabs, but\nadditionally, you can check out the part of the livestream in which two of the\nCode Jam engineers provide a quick explanation of the problems\n<a href=\"https://www.youtube.com/watch?v=4diQ6JXY4cI&t=5h23m39s\" target=\"_blank\">here</a>.\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>Integeregex</i>): Written by Pablo Heiber. Prepared by Alex Li,\nSeth Troisi, and Ian Tullis.\n</p><p>\nProblem B (<i>Family Hotel</i>): Written and prepared by Petr Mitrichev.\n</p><p>\nProblem C (<i>Gallery of Pillars</i>): Written by David Arthur. Prepared by\nPablo Heiber.\n</p><p>\nProblem D (<i>Map Reduce</i>): Written by David Arthur and Pablo Heiber.\nPrepared by Pablo Heiber and Alex Li.\n</p><p>\nProblem E (<i>Radioactive Islands</i>): Written by John Dethridge. Prepared by\nJohn Dethridge and Igor Naverniouk.\n</p>\nSolutions and other problem preparation and review by Shane Carr, John\nDethridge, Andy Huang, Alex Li, Alex Meed, Petr Mitrichev, Onufry Wojtaszczyk,\nKarol Pokorski, and Ian Tullis.\n</p><p>\nAnalysis authors:\n</p>\n<ul>\n<li>Integeregex: Seth Troisi</li>\n<li>Family Hotel: Mohammad Hossein Bateni</li>\n<li>Gallery of Pillars: Pablo Heiber</li>\n<li>Map Reduce: David Arthur and Alex Meed</li>\n<li>Radioactive Islands: John Dethridge, Igor Naverniouk, and Ian Tullis</li>\n</ul>\n<p>\nPictures in statements and analyses by Brian Hirashiki.\n</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1470414600000,"tasks":[{"analysis":"<h2>Map Reduce: Analysis</h2>\n<h3>Some initial checks</h3>\n<p>\nFirst, calculate two values: the length L<sub>i</sub> of any shortest path from\nthe start to the finish (using\n<a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">BFS</a>), and the\n<a href=\"https://en.wikipedia.org/wiki/Taxicab_geometry\">Manhattan distance</a>\nM from the start to the finish (ignoring walls). Based on those results, we can\nimmediately detect some impossible cases:\n</p>\n<ul>\n<li>We can only remove walls, so we have no way to <i>increase</i> the length\nof the shortest path above L<sub>i</sub>. So, if L<sub>i</sub> is less than\n<b>D</b>, there is no solution.</li>\n<li>Similarly, if M is greater than <b>D</b>, removing walls does not help;\neven a blank maze consisting of only a border would still have a shortest path\nlength &gt; <b>D</b>.</li>\n<li>If the parity of L<sub>i</sub> and <b>D</b> is different, there is no\nsolution. The lengths of all paths between any two given cells have the same\nparity, because each step flips the parity of the sum of the indices of the row\nand column.\n</li>\n</ul></p>\n<p>\nSurprisingly, in any other case, there is always a solution. The rest of\nthe problem is to provide a constructive proof of that fact.\n</p>\n<h3>A crucial observation</h3>\n<p>\nWe want to remove walls to change the current shortest path length L to match\n<b>D</b>. The key to solving this problem is to notice that we can always\nremove a wall such that the new shortest path has a length of either L or L-2.\nThe proof of this is somewhat difficult, but we can discuss it intuitively (a\nformal proof follows at the end of this analysis).\n</p><p>\nConsider a connected component of walls. It either includes the border or it\ndoesn't. Now, pick some wall W within that connected component that is as far\nas possible away from either the border, or some arbitrary wall within the\ncomponent if it doesn't include the border. Using the fact that all empty\nspaces are connected and that no two walls can connect at a corner, we can find\nthat the 3&times;3 neighborhood of W looks like one of the following cases,\nup to symmetry (<code>#</code> is a wall, <code>.</code> is a space,\n<code>?</code> can be either):\n</p>\n<pre>\n...  ?#?  ?##\n.W.  .W.  .W#\n...  ...  ..?\n</pre>\n<p>\nLet's consider each case in turn. We will show that if the shortest path\nproceeded through the 3&times;3 neighborhood of W, removing W will decrease the\nlength of the shortest path by at most 2:\n</p>\n<ul>\n<li><i>W has zero neighbors that are walls</i>: The only path that would be\n  shortened by removing W is a path that goes around W. So, removing W will\n  shorten the path by 2, since the path can now go directly through W.</li>\n<li><i>W has one neighbor that is a wall</i>: Say we have the case pictured\n  above, and the shortest path proceeds from the top-left corner around the\n  bottom to the top-right corner. Removing W again shortens the path by 2.</li>\n<li><i>W has two neighbors that are walls</i>: Removing W doesn't shorten the\n  path at all. (The reason we have this case is that removing this wall can\n  open up other walls to be removed.)</li>\n</ul>\n</p><p>\nHere are some illustrations of the above three cases. (For simplicity, we\nassume here that all the <code>?</code>s are walls, but the argument holds\nregardless.)\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2L6iUrlFWrur2cNG9Z7J_Z92Fpn1jgkBf436SrdIdoK2xkLcqftkcxXazIWslApRbaOb91qxo/mr_paths.png\"/>\n<p>To solve the problem, then, we just continually remove walls from the map\n(keeping in mind that removing a wall may make another wall removable) until\nthe shortest path is equal to <b>D</b>. For the Small, we can repeatedly scan\nthe map for removable walls and remove a wall; we continue this until the\nshortest path is the required length.\n</p><p>\nFor the Large dataset, scanning the map repeatedly is too slow, so we need a\ndifferent approach. We can figure out a list of walls to remove,\nin order, then binary search on the number of walls to remove to make a path of\nthe required length. To find this list, we can scan the map once, then\ninitialize a queue containing all the removable walls. Then, each time we\nchoose a wall to remove next, we scan each of its neighbors to see if it's\nremovable, and add any newly-removable walls to the back of the queue. We also\nneed to scan the neighbors for walls that may have become unremovable, and\nremove any such walls from the queue. For example, if a connected component is\njust a 2x2 square, all of its walls are initially removable, but after removing\none of them, only two of the three remaining walls can be removed. So we may\nsometimes need to remove a wall from the queue, and then perhaps even re-insert\nit later.\n</p><p>\nWith this method, we're only scanning the entire map once, then doing constant\nadditional work per wall we remove (O(N) total), so it's fast enough for the\nLarge. (This method will eventually remove every wall, except that it might\nleave an extra-thick unremovable border. This border doesn't matter, since\nremoving it wouldn't change the shortest path.)\n</p>\n<h3>A formal proof</h3>\n<p>\nAs before, let L<sub>i</sub> be the shortest path initially and M be the\nManhattan distance. We claim that the problem is solvable for any <b>D</b> (of\nthe same parity as L<sub>i</sub>) between L<sub>i</sub> and M. It suffices to\nshow that you can always delete a wall while keeping the maze valid and without\ndecreasing the current shortest path length L by more than 2.\n</p><p>\nConsider some connected component of walls. If it includes the outer boundary,\nlet B be the set of walls on the outer boundary. Otherwise, let B be an\narbitrary wall in the component. Let A be a wall in the component that is\nadjacent to an empty cell and maximally far apart from B (based on distance\nstaying within the component). We'll delete A.\n</p><p>\nThis adds an empty cell adjacent to another one, and so all empty cells stay\nconnected. We next need to show that it can't make two walls touch only at a\ncorner. By way of contradiction, suppose that X and Y are walls adjacent to\nboth A and an empty cell Z. Z and A are connected by empty cells, so X and Y\ncannot be connected by walls after deleting A. Thus one of X or Y must be\nfurther from B than A is. But X and Y are not on the outer boundary, and are\nconnected to B before A is deleted, and are adjacent to Z, so we have a\ncontradiction.\n</p><p>\nFinally, we need to show that deleting A cannot make two empty cells greater\nthan two steps closer to each other. The only way this could happen is if A\nwere adjacent to empty opposite cells X and Y, and walls W and Z. As above,\nX and Y are connected, so Z and W cannot be connected by walls after deleting\nA. This leads to the same contradiction as before. W and Z may not be adjacent\nto an empty cell, but they are adjacent to something other than A that is.\nEither W or Z or this adjacent cell will contradict the choice of A. Note that\nthe key claim here is false if walls are allowed to touch only at corners, but\nthe problem setup disallows that.\n</p>\n","id":"0000000000201b73","statement":"<h3>Problem</h3>\n\n<p>\nBen the brilliant video game designer is trying to design maps for his upcoming\naugmented-reality mobile game. Recently, he has created a map which is\nrepresented as a matrix of <b>R</b> rows and <b>C</b> columns. The map consists\nof a bunch of <code>.</code> characters representing empty squares, a bunch of\n<code>#</code> characters representing impassable walls, a single start position\nrepresented by <code>S</code> and a single finish position represented by\n<code>F</code>. For example, the map could look like:\n</p>\n<pre>\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.###\n#.#.........#\n#############\n</pre>\n\n<p>\nIn Ben's game, a <i>path</i> is a sequence of steps (up, down, left or right)\nto go from one cell to another while not going through any impassable walls.\n</p>\n\n<p>\nBen considers a <i>good</i> map to have the following properties:\n</p>\n\n<ul>\n<li>There is a path between any two empty squares (including the start and\nfinish positions).</li>\n<li>To preserve structural integrity, impassable walls must meet at edges and\nnot just corners. For every 2&times;2 region in the map, if the region contains\nexactly two walls, then those walls are either in the same row or the same\ncolumn. In other words, there is no 2&times;2 region where the walls are in one\nof these two configurations:\n<br/>\n<p>\n<code>\n#.&nbsp;&nbsp;&nbsp;.#<br>\n.#&nbsp;&nbsp;&nbsp;#.<br>\n</code>\n</p>\n</li>\n<li>The boundary consists of only impassable walls. A cell is considered part\nof the boundary if it is in the uppermost/lowermost rows or if it is in the\nleftmost/rightmost columns.</li>\n</ul>\n\n<p>\nThe distance of the shortest path is the minimum number of steps required to\nreach the finish position from the start position. For instance, the shortest\npath in the above example takes 17 steps.\n</p>\n\n<p>\nBeing such a clever mapmaker, Ben realized that he has created a map that is too\nhard for his friends to solve. He would like to reduce its difficulty by\nremoving some of the impassable walls. In particular, he wants to know whether\nit is possible to remove zero or more impassable walls from his map such that\nthe shortest path from start to finish takes <i>exactly</i> <b>D</b> steps, and\nthat the resulting map is still <i>good</i>. Note that it is not enough to\nsimply find <i>a</i> path with <b>D</b> steps; <b>D</b> must be the number of\nsteps in the <i>shortest</i> path.\n</p>\n\n<p>\nFor example, if <b>D</b> = 15, we could remove the impassable wall directly\nbelow the finish position to get a good solution.\n</p>\n\n<pre>\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.#.#\n#.#.........#\n#############\n</pre>\n\n<p>\nThere is no solution if <b>D</b> = 5.\n</p>\n\n<h3>Input</h3>\n\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each test case starts with a line containing three\nspace-separated integers <b>R</b>, <b>C</b> and <b>D</b>: the number of rows and\ncolumns in the map, and the desired number of steps in the shortest path from\nstart to finish after possibly removing impassable walls. <b>R</b> lines follow,\neach consisting of <b>C</b> characters (either <code>.</code>, <code>#</code>,\n<code>S</code> or <code>F</code>) representing Ben's map.\n</p>\n\n<p>\nIt is guaranteed that the map is good, as described in the problem statement.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe word <code>POSSIBLE</code> or <code>IMPOSSIBLE</code>, depending on whether\nthe shortest path can be made equal to <b>D</b> by removing some number of walls\nsuch that the map is still good. If it is possible, output <b>R</b> more lines\ncontaining <b>C</b> characters each, representing the new map. In your output,\nreplace the <code>#</code> characters for removed walls (if any) with\n<code>.</code> characters.\n</p>\n\n<p>\nIf multiple solutions are possible, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\nEach test case contains exactly one <code>S</code> and exactly one <code>F</code>.<br/>\nThe input file is at most 3MB in size.\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n3 &le; <b>R</b> &le; 40.<br/>\n3 &le; <b>C</b> &le; 40.<br/>\n1 &le; <b>D</b> &le; 1600.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 300 seconds.<br/>\n3 &le; <b>R</b> &le; 1000.<br/>\n3 &le; <b>C</b> &le; 1000.<br/>\n1 &le; <b>D</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n<p><b>NOTE:</b> The Large output breaks the usual cap on Code Jam output size,\nbut you can upload it as normal.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n6 13 15\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.###\n#.#.........#\n#############\n5 8 3\n########\n#S.....#\n####...#\n#F.....#\n########\n4 10 11\n##########\n#S#...#.F#\n#...#...##\n##########\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: POSSIBLE\n#############\n#S..#..##...#\n###.##..#.#F#\n#...##.##.#.#\n#.#.........#\n#############\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n##########\n#S#...#.F#\n#...#...##\n##########\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe sample output displays one set of answers to the sample cases. Other\nanswers may be possible.\n</p>\n\n<p>\nSample case #1 is the example in the problem statement.\n</p>\n\n<p>\nIn sample case #2, it is possible to remove walls to make the distance of the\nshortest path either 2 or 4, for example. However, there is no way to make the\ndistance of the shortest path exactly 3.\n</p>\n\n<p>\nIn sample case #3, the shortest path already takes 11 steps to begin with, so\nthere is no need to reduce the difficulty of the map.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":20},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Map Reduce","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Analysis</h3>\n<p>\n  One handy property of regular expressions is that matching one of them is equivalent to being\n  accepted by a special type of machine called a\n  <a href=\"https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton\">nondeterministic finite\n  automaton</a> (NFA).\n</p><p>\n  An NFA is a graph of states and transitions, with a special initial and final state. Each\n  transition is labeled with a digit or &epsilon;. When processing a string, the machine may move\n  from a current state to another state by taking an &epsilon;-transition, or by taking a digit\n  transition that matches the current digit of the string and moving to the next digit. After\n  the last digit of the input string is read, only &epsilon;-transitions are allowed. If there is\n  a path from the initial digit to the last digit that reads the entire input, we say the input\n  string is accepted or matched, and that path is called an accepting path.\n</p>\n\n<h3>Build an NFA that matches strings to the regular expressions of the problem.</h3>\n<p>\n  <a href=https://en.wikipedia.org/wiki/Thompson%27s_construction>Thompson's construction</a> is\n  one algorithm to construct an NFA that matches regular expressions.<br/>\n\n  The general outline is start with two special states: the initial state, <code>q</code>, and a\n  final accepting state, <code>f</code>.<br/>\n  Then build up the NFA f(E) recursively:\n  <ul>\n    <li>If E is a digit, then f(E) contains only the two special states linked with a transition\n      labeled with E.</li>\n    <li>f(E = E<sub>1</sub>E<sub>2</sub>) is the union of f(E<sub>1</sub>) and f(E<sub>2</sub>),\n      using the initial state of f(E<sub>1</sub>) as initial state of f(E), the final state of\n      f(E<sub>2</sub>) as final state, and adding an &epsilon;-transition from the final state\n      of f(E<sub>1</sub>) to the initial state of f(E<sub>2</sub>).</li>\n    <li>f(E = (E<sub>1</sub>|E<sub>2</sub>|...|E<sub>N</sub>)) is the union of all the\n      f(E<sub>i</sub>) plus an additional initial and final state. Then, &epsilon;-transitions are\n      added from the initial state of F(E) to each initial state of an f(E<sub>i</sub>) and\n      from the final state of each f(E<sub>i</sub>) to the final state of f(E).\n    <li>f(E = (E<sub>1</sub>)*) is just f(E<sub>1</sub>) with an additional &epsilon;-transition\n      from the final state to the initial state.\n  </ul>\n</p>\n\n<p>\n  Here's an example NFA built from the Integeregex <code>(13|1)((2)*|3)</code><br/>\n  <table>\n    <tr><td><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2kjpYLGYsWB4ZXrsAZbLnLWi1QadTQ82H1koAkYYUdT1VL2HJ9de3snwIiPvd43DxFr5uvGfw2/analysis1.png\"/></td>\n  </table>\n</p>\n<p>\n\n<h3>Checking that a single string matches</h3>\n<p>\n  Consider the following example: the input string <code>1322</code> has an accepting path on the\n  NFA above that goes through these states:\n  <code>q</code>, s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>, s<sub>6</sub>, s<sub>7</sub>,\n  s<sub>8</sub>, s<sub>7</sub>, s<sub>8</sub>, <code>f</code>.<br/>\n  Notice that there are multiple paths for each string, some may be accepting and some others may\n  not. Just one accepting path is enough for the string to be accepted.\n</p>\n\n<p>\n  Start with the set of possible states containing only the initial state (<code>q</code>).<br/>\n  For each character C in the string:<br/>\n  &nbsp;&nbsp;For each of the last possible states:<br/>\n  &nbsp;&nbsp;&nbsp;&nbsp;Find all the states that can be reached by &epsilon;-transitions then a\n      transition on C.<br/>\n  &nbsp;&nbsp;&nbsp;&nbsp;Add these to the new set of all possible states.<br/>\n  From the last set of possible states:<br/>\n  &nbsp;&nbsp;if the accepting state (<code>f<code>) is reached from any of these states by\n    &epsilon;-transitions then the NFA (and the regular expression) match!.<br/>\n  <br/>\n  For example to check the string <code>1233</code> against our example NFA:<br/>\n  the NFA starts in the initial state <code>q</code><br/>\n  After &epsilon;-transitions and a transition on 1, the NFA can be in any of the states\n    {s<sub>2</sub>, s<sub>5</sub>}.<br/>\n  After &epsilon;-transitions and a transition on 3, the NFA can be in any of the states\n    {s<sub>3</sub>, s<sub>10</sub>}.<br/>\n  After &epsilon;-transitions and a transition on 2, the NFA can only be state s<sub>8</sub>.<br/>\n  After &epsilon;-transitions and a transition on 2, the NFA can only be state s<sub>8</sub>.<br/>\n  Because the accepting state <code>f</code> can be reached from s<sub>8</sub> with\n  &epsilon;-transitions, the NFA, and the regular expression, match <code>1322</code>!<br/>\n</p>\n\n<h3>Quickly counting all numbers that match the NFA</h3>\n<p>\n  We can now use dynamic programming to quickly check how many numbers less than or equal to X\n  match the NFA.<br/>\n  We keep a map of (is_empty, is_prefix_of_x, possible_states) to memoize the result starting from\n  that state.<br/>\n  We use is_empty to keep from adding zeros at the front of the number.<br/>\n  We use is_prefix_of_x to keep from counting numbers larger than X.<br/>\n</p><pre>\ndef MatchNFA(X, transitions):\n  x_digits = []\n  for c in str(X):\n    x_digits.append(int(c))\n\n  # Start of numbers with same length  as X.\n  count_state = { (True, True, 'p') : 1 }\n  for index in range(len(X)):\n    # Start of shorter and shorter numbers.\n    new_count_state = { (True, False, 'p') : 1 }\n\n    for (is_empty, is_prefix_of_x, states), count in count_state.items():\n      for new_digit in range(10):\n        if is_empty and new_digit == 0:\n          continue # Numbers can't start with 0.\n\n        if is_prefix_of_x and new_digit &gt; x_digits[index]:\n          continue # Numbers can't be greater than X.\n\n        # Find all possible states if new_digit was next in the string\n        new_possible_states = []\n        for start_state in states:\n          # Add all states that can be reached from start_state by (&epsilon;)* new_digit\n          for epsilon_state in transitions[start_state]['']:\n            new_possible_states += transitions[epsilon_state][new_digit]\n        new_count_state[(False, is_prefix_of_x and new_digit == x_digits[index],\n                         set(new_possible_states))] += count\n    count_state = new_count_state\n\n  count_match = 0\n  for (is_prefix_of_x, states), count in count_state.items():\n    for final_state in states:\n      if 'f' in transitions[state]['']\n        count_match += count\n\n  return count_match</pre><p>\n  Finally we calculate the number of matching numbers between A and B as\n  MatchNFA(B, transitions) - MatchNFA(A-1, transitions).<br/>\n</p>\n\n<p>\n  As the number of states in the NFA grows, <code>new_possible_states</code> can grow exponentially\n  large (it can theoretically be the powerset of the states). However, the small maximum length\n  of the regular expression and the amount of non-digit characters consumed to include disjunctions\n  or repetitions make it so that the number is actually really small (for a computer) in practice.\n  There are mathematically provable bounds on the number, but the proofs are too long to fit\n  in the margins of this analysis.\n</p>\n","id":"0000000000201bf8","statement":"<h3>Problem</h3>\n<p>\nIn this problem, a valid regular expression is one of the following. In the\nfollowing descriptions, <i>E</i><sub>1</sub>, <i>E</i><sub>2</sub>, etc. denote\n(not necessarily different) valid regular expressions.\n</p>\n<ul>\n<li>A decimal digit: that is, one of <code>0 1 2 3 4 5 6 7 8 9</code>.</li>\n<li>Concatenation: <i>E</i><sub>1</sub><i>E</i><sub>2</sub>.</li>\n<li>Disjunction:\n<code>(</code><i>E</i><sub>1</sub><code>|</code><i>E</i><sub>2</sub>\n<code>|</code>...<code>|</code><i>E</i><sub>N</sub><code>)</code>, for at least\ntwo expressions. Note that the outer parentheses are required.</li>\n<li>Repetition: <code>(</code><i>E</i><sub>1</sub><code>)*</code>. Note that\nthe outer parentheses are required.</li>\n</ul>\n<p>\nFor example, <code>7</code>, <code>23</code>, <code>(7)*</code>,\n<code>(45)*</code>, <code>(1|2|3)</code>, <code>((2)*|3)</code>,\n<code>(1|2|3)</code>, and <code>((0|1))*</code> are valid expressions.\n<code>(7)</code>, <code>4|5</code>, <code>4*</code>, <code>(1|)</code>, and\n<code>(0|1)*</code> are not.\n</p><p>\nWe say that an expression <i>E</i> matches a string of digits <i>D</i> if and\nonly if at least one of the following is true:\n</p>\n<ul>\n<li><i>E</i> = <i>D</i>.</li>\n<li><i>E</i> = <i>E</i><sub>1</sub><i>E</i><sub>2</sub> and there exist\n<i>D</i><sub>1</sub> and <i>D</i><sub>2</sub> such that\n<i>D</i> = <i>D</i><sub>1</sub><i>D</i><sub>2</sub> and <i>E</i><sub>i</sub>\nmatches <i>D</i><sub>i</sub>.</li>\n<li><i>E</i> = <code>(</code><i>E</i><sub>1</sub><code>|</code>\n<i>E</i><sub>2</sub><code>|</code>...<code>|</code>\n<i>E</i><sub>N</sub><code>)</code> and at least one of the <i>E</i><sub>i</sub>\nmatches <i>D</i>.</li>\n<li><i>E</i> = <code>(</code><i>E</i><sub>1</sub><code>)*</code> and\nthere exist <i>D</i><sub>1</sub>, <i>D</i><sub>2</sub>, ...,\n<i>D</i><sub>N</sub> for some non-negative integer N such that <i>D</i> =\n<i>D</i><sub>1</sub><i>D</i><sub>2</sub>...<i>D</i><sub>N</sub> and\n<i>E</i><sub>1</sub> matches each of the <i>D</i><sub>i</sub>. In particular,\nnote that <code>(</code><i>E</i><sub>1</sub><code>)*</code> matches the empty\nstring.</li>\n</ul>\n<p>\nFor example, the expression <code>((1|2))*3</code> matches <code>3</code>,\n<code>13</code>, <code>123</code>, and <code>2221123</code>, among other\nstrings. However, it does <i>not</i> match <code>1234</code>,\n<code>3123</code>, <code>12</code>, or <code>33</code>, among other strings.\n</p><p>\nGiven a valid regular expression <b>R</b>, for how many integers between\n<b>A</b> and <b>B</b>, inclusive, does <b>R</b> match the integer's base 10\nrepresentation (with no leading zeroes)?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow; each consists of two lines. The first line has two positive\nintegers <b>A</b> and <b>B</b>: the inclusive limits of the integer range we\nare interested in. The second has a string <b>R</b> consisting only of\ncharacters in the set <code>0123456789()|*</code>, which is guaranteed to be a\nvalid regular expression as described in the statement above.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe number of integers in the inclusive range [<b>A</b>, <b>B</b>] that the\nthe regular expression <b>R</b> matches.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>A</b> &le; <b>B</b> &le; 10<sup>18</sup>.<br/>\n1 &le; length of <b>R</b> &le; 30.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n<b>R</b> contains no <code>|</code> characters.\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nNo additional limits.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">8\n1 1000\n(0)*1(0)*\n379009 379009\n379009\n1 10000\n(12)*(34)*\n4 5\n45\n1 100\n((0|1))*\n1 50\n(01|23|45|67|23)\n1 1000000000000000000\n((0|1|2|3|4|5|6|7|8|9))*\n1 1000\n1(56|(((7|8))*9)*)\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 1\nCase #3: 5\nCase #4: 0\nCase #5: 4\nCase #6: 2\nCase #7: 1000000000000000000\nCase #8: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nNote that sample cases 5 through 8 would not appear in the Small dataset.\n</p><p>\nIn sample case 1, the matches in range are 1, 10, 100, and 1000.\n</p><p>\nIn sample case 2, the match in range is 379009.\n</p><p>\nIn sample case 3, the matches in range are 12, 34, 1212, 1234, and 3434.\n</p><p>\nIn sample case 4, there are no matches in range.\n</p><p>\nIn sample case 5, the matches in range are 1, 10, 11, and 100.\n</p><p>\nIn sample case 6, the matches in range are 23 and 45.\n</p><p>\nIn sample case 7, it is possible to form any number in the range.\n</p><p>\nIn sample case 8, the matches in range are 1, 19, 156, 179, 189, and 199.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Integeregex","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Radioactive Islands: Analysis</h2>\n<p>\nThis optimization problem touches on topics that are a bit further afield from\nour other problems!  But a wide range of reasonable solution approaches\ncan be successful.\n</p><p>\nWe will start with some general insights, and then move on to a few of the many\npossible solutions.\n</p>\n<h3>Never get too close to an island</h3>\n<p>\nThe radiation dose rate rises sharply as we approach an island, so any path\nthat passes too close to an island is worse than a path that takes the time to\ntravel around it at a greater distance away.\n</p><p>\nThis is helpful because we can be more confident about numerical precision when\nfinding approximations to the best path, since areas where the dose rate is low\nare also those where the derivative of the dose rate with respect to position\nis low.\n</p>\n<h3>Never move left</h3>\n<p>\nAlthough the input limits do not allow it, suppose that the boat started\n0.000001 km to the left of an island. In that case, the effects of the island\nwould be much worse than the effects of the background radiation, and we'd want\nto move left to \"escape\" from the island as fast as possible and eventually\nmake a wide curve around it.\n</p>\n<p>\nAlso, consider a scenario where the difference in the Y-coordinates of the endpoints is\nlarge enough that the angle between them is nearly 90&deg; from horizontal, and where\nthere is an island in the middle of the direct path between the endpoints.\nThen an optimal path could start by moving almost vertically but slightly to the left,\nbecause that would give the island a wider berth without significantly increasing the\ntotal length of the path.\n</p>\n<p>\nHowever, we've made the input \"nice\" &mdash; the boat always starts 10 km to the left of the\nislands, where the maximum dose rate from the islands is at most 0.02&mu;Sv/h, and the\nmaximum angle between the endpoints is 45&deg; from horizontal, so any movement to the left\nat the start would be misguided.\n</p><p>\nSimilarly, leftward moves in the middle of the path do not help either &mdash; a path\nwhich zig-zags back and repeats some X-coordinates can be altered to take a more direct\nroute with a lower total radiation dose.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U25yBbDhCX583rtweQG_WwxBnwzCXhNCc3d16LFUC5KugVQLe_Pa5QDr-iBgA643iGjkWYbpyeagA/curvedpath.png\">\n<p>\n</p>\n<h3>Solution #1: Hill-climbing</h3>\n<p>\n</p><p>\nThis optimization problem is well-suited for hill-climbing because it is easy to iteratively\ntake a reasonable path and \"nudge\" it towards a better path in such a way that it will\nconverge quickly towards a local minimum.\n</p>\n<p>\nHow many local minima are there?\nSince we should never move left, and there's only one or two islands,\nthe optimal paths can only take so many forms.\nWith one island, the optimal path will either go above the island, or go below\nit. With two islands, the optimal path will either go above both islands,\nbetween the two islands, or below both islands.\n</p>\n<p>\nSo if we start with a reasonable path for each of these forms and hill-climb from there,\nwe will find each of the two or three local minima.\n</p>\nAn easy way to do this is to\nmodel a path as a series of many small straight line segments. For each\nsuch segment, we can use calculus to find the amount of radiation\nreceived along that part of the path. Let's consider one such segment, running\nfrom (x<sub>1</sub>,y<sub>1</sub>) to (x<sub>2</sub>,y<sub>2</sub>), that we\ntravel along between time 0 and time 1 (we've rescaled the times for\nconvenience). Then the x and y coordinates, as a function of time t, are:\n</p>\n<p>\nx(t) = x<sub>1</sub> + t(x<sub>2</sub>-x<sub>1</sub>)<br>\ny(t) = y<sub>1</sub> + t(y<sub>2</sub>-y<sub>1</sub>)<br>\n</p><p>\nSuppose that there are two islands (the one island case is just a simpler\nversion of this), and the y coordinates of the islands are y<sub>i1</sub> and\ny<sub>i2</sub>. (Recall that the x coordinates of both islands are 0.) Then the\ntotal amount of radiation is the definite integral from 0 to 1 of:\n</p><p>\n[1 + 1 / (x(t)<sup>2</sup> + (y(t)-y<sub>i1</sub>)<sup>2</sup>)) + 1 / (x(t)<sup>2</sup> + (y(t)-y<sub>i2</sub>)<sup>2</sup>))] &times; [sqrt((x<sub>2</sub>-x<sub>1</sub>)<sup>2</sup> + (y<sub>2</sub>-y<sub>i1</sub>)<sup>2</sup>))] dt\n</p><p>\nThis integral can be solved exactly, but that's not necessary.  Multiplying the\nlength of the segment by the average of the dose rates at the endpoints of the segment is\nsufficiently accurate, if enough segments are used.\n</p><p>\nThe question is how to find the right positions for our segments. We can lay\ndown a rough path with endpoints whose X-coordinates are fixed and evenly-spaced\nbetween -10 and +10.  Now, the Y-coordinates are a vector of real numbers,\nand we need to optimize that vector.\n</p><p>\nWe can use <a href=\"https://en.wikipedia.org/wiki/Gradient_descent\">gradient descent</a>\nto do this &mdash; we need to iterate finding a direction to move the vector in\nsuch that the total radiation decreases.\n</p></p>\nAdjusting one value at a time doesn't work &mdash; even if a particular point needs\nto be moved upward, if we move only that one point upward, we'll soon be increasing the total\nradiation dose because the path will have a \"kink\" in it.  But almost any other scheme will do &mdash;\nchoosing an interval of points and nudging them all up or down in a triangular shape, moving the points\nin the middle more than the points at the end, will preserve the smoothness of the path.\n</p></p>\nOther more sophisticated nonlinear optimization techniques like the\n<a href=\"https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm\">BFGS algorithm</a>\nwork also.\n</p>\n<h3>Solution #2: Calculus of Variations</h3>\n<p>\nWe can consider the Y-coordinate of the ship to be a function of its X-coordinate\nand write the total radiation dose as an integral involving that function, then use\ntechniques from the\n<a href=\"https://en.wikipedia.org/wiki/Calculus_of_variations\">calculus of variations</a>\nto minimize it. The\n<a href=\"https://en.wikipedia.org/wiki/Euler%E2%80%93Lagrange_equation\">Euler-Lagrange equation</a>\ngives us a condition, expressed as a differential equation, that any solution must satisfy.\nThis condition is entirely local, so if we knew the\ninitial direction the ship should travel, we could find the entire path by\nusing a numerical integration technique such as a\n<a href=\"https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods\">Runge&ndash;Kutta method</a>,\nto find a solution to the differential\nequation using the known initial conditions. However, we don't know the initial\ndirection of the boat &mdash; we only know its starting and ending positions!\n</p><p>\nIf we guess an initial direction for the boat that's reasonable, then\nintegrating will trace out a path, but the y-coordinate of the endpoint will\nprobably not be right. So, we can do a binary search to find the initial\ndirection that does lead us to the desired endpoint. If we repeat the binary\nsearch for ranges that correspond to each of the forms the path can take, then\nwe will find the optimal path.\n</p><p>\nSimple numerical integration techniques using finite differences are accurate\nenough to solve this problem, but one has to be careful of initial directions\nthat point too directly towards an island or that have too large a slope, as those\ncases can have large numerical errors that might cause the binary search\nto take the wrong branch.\n</p><p>\nKalininN used this method to solve the Small dataset, and his solution would\nhave worked for the Large with some minor tweaking.\n</p>\n<h3>Solution #3: Dynamic Programming</h3>\n<p>\nAnother approach is to overlay a grid of points on the map, and use dynamic\nprogramming to find the optimal path through them.  This is possible because\nthe precision bound for this problem was not too strict, but it is still difficult to\nget right.  A grid with too few points cannot model the optimal path accurately\nenough to get the right answer, and a grid with too many points would result in\na dynamic programming problem that is too big to solve in time.\n</p><p>\nGennady.Korotkevich, the only contestant to solve the Large dataset, successfully\nused this approach.  He had two insights that made this method workable.\n</p><p>\nThe ship's path is largely horizontal, with gradual changes in angle; the problem\nis mostly a question of how to carefully\nmodulate the boat's vertical position. So the grid of points can have coarser\nhorizontal granularity than vertical granularity; Gennady used a ratio of 20 to\n1.  In the final minutes of the contest, Gennady was testing two solutions,\nwhich only differed in their horizontal granularity.  The coarser grid turned\nout to be more accurate, because it was able to model angles more\nprecisely.  A grid that was finer in both the horizontal and vertical directions\nwould have been more accurate, but might have been too slow.\n</p><p>\nThe second insight was that the path should have no segments which have a very steep\nangle, so when computing the optimal value for a point in one column, only\npoints in the previous column within a certain vertical range need to be considered.\nThe size of that range was controlled by a constant called <code>MAGIC</code> in\nGennady's code. His solution ran in well\nunder the time limit allowed for the Large, and the answers were within our\nsomewhat generous error bounds.\n</p><p>\nIt is possible to get a very accurate result quickly with this method by starting with a\ncoarse grid, finding the optimal path in that grid, then iteratively improving the\npath by using finer and finer grids overlaying the space close to the path.\n</p><p>\nYou can download our contestants' submissions to this problem (and others) from\nthe Finals scoreboard.\n</p>\n","id":"0000000000201bf9","statement":"<h3>Problem</h3>\n<p>\nYou are steering a boat from the coordinates (-10, <b>A</b>) to the coordinates\n(10, <b>B</b>). The coordinates are measured in kilometers, and your boat\ntravels at a constant speed of 1 kilometer per hour. You have full control over\nthe path the boat takes. We model the boat as a single point.\n</p><p>\nThere are <b>N</b> islands in the area; we model them as single points. The\ni-th island is at the coordinates (0, <b>C<sub>i</sub></b>).\n</p><p>\nThe area is radioactive, and you constantly receive 1 microsievert per hour of\nradiation from the general environment, no matter where you are. Moreover,\nthe islands themselves are radioactive, and you constantly receive additional\nradiation at a rate of (D<sub>i</sub>)<sup>-2</sup> microsieverts per hour from\nthe i-th island, where D<sub>i</sub> is your current distance (in kilometers)\nfrom the i-th island. (Formally: let D<sub>i</sub>(t) be your distance from\nthe i-th island as a function of time t, and X be the total time your journey takes. Then the\ntotal radiation received from the i-th island is the definite integral from 0\nto X of D<sub>i</sub>(t)<sup>-2</sup>.) You can get as close to an island as you would like,\nas long as you do not match its exact coordinates.\n</p><p>\nFind the minimum total radiation dose that you can receive if you plot your\ncourse optimally.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>; <b>T</b>\ntest cases follow. Each test cases consists of two lines. The first line of a\ntest case consists of three values: an integer <b>N</b>, and two floating-point\nnumbers <b>A</b> and <b>B</b>, as described in the statement above. The second\nline of a test case consists of <b>N</b> floating-point numbers\n<b>C<sub>i</sub></b>; the i-th of these numbers gives the y coordinate of the\ni-th island.\n</p><p>\nAll floating-point numbers are specified to exactly two decimal places.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe minimum radiation dose (in microsieverts) received while completing the\njourney.\n</p><p>\n<code>y</code> will be considered correct if it is within an absolute or\nrelative error of 10<sup>-3</sup> of the correct answer. See the\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an\nexplanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n-10.00 &le; <b>A</b> &le; 10.00.<br/>\n-10.00 &le; <b>B</b> &le; 10.00.<br/>\n-10.00 &le; <b>C<sub>i</sub></b> &le; 10.00, for all i.<br/>\n<b>C<sub>i</sub></b> &ne; <b>C<sub>j</sub></b>, for all i &ne; j.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n<b>T</b> &le; 20;<br/>\n<b>N</b> = 1.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 240 seconds.<br/>\n<b>T</b> &le; 50;<br/>\n1 &le; <b>N</b> &le; 2.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2jmPOUSluXpQCZezkcsj697mgcDr6XZZEbQusyyczjOHOEPI7dYGisKLi6oqiFdCwBJBjNnitTtucn0krTr6c6cnhGZZ97AKB7Pc0_bCps51EI/radioactive_islands_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n1 1.00 -2.00\n0.00\n2 0.00 0.00\n3.00 -3.00\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3F7YEpQa2MaUE1WlnWGkrs230rmCVRvjBfeZtXWc52cpHtVrQ4t33Tv7W2cL3Y6SwEkL5rmoyFYgyEfmJgldRzzXzzCMF3lJXL92-mBumzx2k8Kg/radioactive_islands_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 21.806\nCase #2: 21.706\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\nHere is a diagram of the optimal path for sample case #1. We have enlarged\nthe island to make it more visible, but remember to treat it as a single point.\n</p>\n\n<img alt=\"Optimal path for sample case #1.\" src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0l3xaU8NEAdSww6mPNKcSoqFZmTCyjZOu0sM39YBUOfpXwMDv_Tj4QW9NxIsgwe-of3ts/case1.png\">\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":25},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Radioactive Islands","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  Let P(<b>N</b>, <b>K</b>) denote the probability that room <b>K</b>\n  is occupied when the NO VACANCY sign goes up.  This is essentially\n  what the problem asks for, except that it is requested in a special\n  format.  We will get to that later.\n</p>\n\n<h3>Small input</h3>\n<p>\n  We first present an algorithm for the small input.  There\n  are <b>N</b>-1 ways to accommodate the first family, each with\n  probability 1/(<b>N</b>-1).  Suppose we assign to them adjacent\n  rooms i and i+1.  If either is equal to <b>K</b>, we are done.\n  Otherwise, <b>K</b> falls either in the interval [1, i-1] or in the\n  interval [i+2, <b>N</b>].  Take the former case without loss of\n  generality.  What happens in the interval [i+2, <b>N</b>] is now\n  irrelevant.  Hence the problem reduces to finding P(i-1, <b>K</b>).\n  Working out the math, we get the following recurrence relation:\n</p>\n\n<p>\n  <ul>\n  <li> P(1, 1) = 0, and </li>\n  <li>\n  P(<b>N</b>, <b>K</b>) = 1/(<b>N</b>-1) [\n  &mu;(<b>K</b>+1 &le; <b>N</b>) + &mu;(<b>K</b>-1 &ge; 1) +\n  &Sigma;<sub><b>K</b>+1 &le; i &le; <b>N</b>-1</sub> P(i-1, <b>K</b>) +\n  &Sigma;<sub>1 &le; i &le; <b>K</b>-2</sub> P(<b>N</b>-i-1, <b>N</b>-<b>K</b>+1) ],\n  where 1 &le; <b>K</b> &le; <b>N</b>, 2 &le; <b>N</b>,\n  and &mu;(condition) = 1 if condition holds and 0 otherwise.\n  </li>\n  </ul>\n</p>\n\n<p>\n  Setting aside the issues of precision and the special format\n  requirements of the output, we can use dynamic programming to\n  compute P(<b>N</b>, <b>K</b>) in time O(<b>N</b><sup>3</sup>).  This\n  is too slow even for the small case.  However, by defining S(n, k) =\n  &Sigma;<sub>k &le; i &le; n</sub> P(i, k), the recurrence simplifies\n  as follows:\n</p>\n\n<p>\n  P(<b>N</b>, <b>K</b>) = 1/(<b>N</b>-1) [\n  &mu;(<b>K</b>+1 &le; <b>N</b>) + &mu;(<b>K</b>-1 &ge; 1) +\n  S(<b>N</b>-2, <b>K</b>) + S(<b>N</b>-2, <b>N</b>-<b>K</b>+1) ].\n</p>\n\n<p>\n  The above recurrence can be used for an O(<b>N</b><sup>2</sup>)-time\n  algorithm, which is sufficient for the small input.\n</p>\n\n<h3>Modular arithmetic</h3>\n<p>\n  Before proceeding to a faster solution for the large input, let us\n  address the output format.  Let M = 10<sup>9</sup>+7 be the prime\n  specified in the problem statement.  For a rational solution p/q, we\n  are asked to output the unique integer y such that 0 &le; y &lt; M\n  and y*q = p (mod M).  In terms of the field (Z<sub>M</sub>, +, *),\n  we are simply looking for p/q (mod M) = p * q<sup>-1</sup>, where\n  the latter\n  (i.e., <a href=\"https://en.wikipedia.org/wiki/Modular_multiplicative_inverse\">the\n  inverse of q modulo M</a>) equals q<sup>M-2</sup>\n  by <a href=\"https://en.wikipedia.org/wiki/Euler%27s_theorem\">Euler's\n  theorem</a>\n  (or <a href=\"https://en.wikipedia.org/wiki/Fermat%27s_little_theorem\">Fermat's\n  little theorem</a>).  This computation requires\n  only <a href=\"https://en.wikipedia.org/wiki/Modular_exponentiation\">logarithmically\n  many operations</a> on integers less than M<sup>2</sup>.  In fact,\n  all the arithmetic can be carried out in this field, hence there is\n  no need for large integers or any floating-point operations.  Note\n  that the division operation in the recurrence is well-defined since\n  we never divide by a multiple of M.\n</p>\n\n<h3>Large input</h3>\n<p>\n  To solve the large input, we observe the following:\n</p>\n\n<p>\n  <em>Claim</em>:\n  P(<b>N</b>, <b>K</b>) = 1\n  - F(<b>K</b>) * F(<b>N</b>-<b>K</b>+1), where F(q) = 1-P(q, 1)\n  denotes the probability of the left-most room being unoccupied at\n  the end of the day.\n</p>\n\n<p>\n  <em>Proof</em>: \n  This can be proved rigorously via induction with the base cases\n  being when <b>K</b> &isin; {1, <B>N</b>}, and using the recurrence\n  relation.  A more elegant proof, though, is as follows.\n  Suppose room K is left unoccupied until the end. In that case we\n  essentially have two independent hotels, one formed with rooms from\n  1 to <b>K</b>, and the other with rooms from <b>K</b>\n  to <b>N</b>. The first hotel gets those guests that are assigned to\n  rooms between (1,2) and (<b>K</b>-1,<b>K</b>), and the second hotel\n  gets those guests that are assigned to rooms between\n  (<b>K</b>,<b>K</b>+1) and (<b>N</b>-1,<b>N</b>). It's easy to see\n  that those two \"sub-streams\" of guests that are going to each hotel\n  are also uniformly and independently distributed. The only\n  difference between having such two hotels and one big hotel is that\n  room K could be occupied twice in the two hotel case, but since\n  we're considering the case where it's left unoccupied, this does not\n  happen. Now since the two hotels are independent, we just need to\n  multiply the probabilities that room <b>K</b>, which is a border\n  room in both hotels, is left unoccupied.\n  &#9632;\n</p>\n\n<p>\n  The recurrence for P(<b>N</b>, <b>K</b>) has a simpler form\n  for <b>K</b>=1, as follows:\n</p>\n\n<p>\n  <ul>\n    <li>P(1, 1) = 0, and</li>\n    <li>\n      P(<b>N</b>, 1) = 1/(<b>N</b>-1) [ 1 + S(<b>N</b>-2, 1) ] \n      for <b>N</b> &ge; 2.\n    </li>\n  </ul>\n</p>\n\n<p>\n  Since the two one-dimensional arrays can be filled at the same time,\n  there is an O(<b>N</b>)-time algorithm to compute all values of\n  P(<b>N</b>, 1), hence F(<b>N</b>), which leads to a constant-time\n  operation for each P(<b>N</b>, <b>K</b>) query in the input.\n</p>\n\n<h3>Final remarks</h3>\n<p>\n  For the curious, the above recurrence yields the following solution\n  for F(q):\n</p>\n\n<p>\n  F(q) = &Sigma;<sub>0 &le; i &le; q-1</sub> (-1)<sup>i</sup> 1/i!, \n  for q &ge; 1.\n</p>\n\n<p>\n  This has a combinatorial meaning, as well.  Consider a permutation\n  &pi; of 1, &hellip;, <b>N</b>-1, where &pi;<sub>i</sub> denotes the\n  time at which we try to assign pair of rooms i and i+1 (if both are\n  vacant).  Convince yourself that the number of such permutations\n  producing a certain outcome of room assignments is proportional to\n  that outcome's probability.\n  Now F(q) is equal to the probability that the length of the\n  decreasing sequence at the beginning of &pi; be even.  We calculate\n  this via Principle of Inclusion-Exclusion.\n</p>\n\n<p>\n  Since the claim above is the crux of the solution for large input,\n  it is worth noting that some contestants got the idea by simply\n  looking at the table of 1-P(<b>N</b>, <b>K</b>) for small values\n  of <b>N</b> and <b>K</b>.\n</p>\n","id":"0000000000201c93","statement":"<h3>Family Hotel</h3>\n<p>\nYou run a hotel with <b>N</b> rooms arranged along one long corridor, numbered from 1 to <b>N</b>\n  along that corridor. Your guests are big families, and every family asks for exactly two adjacent\n  rooms when they arrive. Two rooms are adjacent if their numbers differ by exactly 1.\n</p>\n<p>\nAt the start of the day today, your hotel was empty. You have been using the following simple\n  strategy to assign rooms to your guests.\n  As each family arrives, you consider all possible pairs of adjacent rooms that are both free,\n  pick one of those pairs uniformly at random, and assign the two rooms in that pair to the family.\n  New families constantly arrive, one family at a time, but once there are no more pairs of adjacent rooms that are\n  both free, you turn on the NO VACANCY sign and you do not give out any more rooms.\n</p>\n<p>\nGiven a specific room number, what is the probability that it will be occupied at the time that\n  you turn on the NO VACANCY sign?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> lines follow. Each\n  line contains two numbers: the number of rooms <b>N</b> and the room number <b>K</b> that we\n  are interested in.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is\n  the test case number (starting from 1) and <code>y</code> is the sought probability computed\n  <i>modulo 10<sup>9</sup>+7</i>, which is defined precisely as follows.\n  Represent the probability that room <b>K</b> is occupied as an irreducible fraction\n  <code>p/q</code>. The number <code>y</code> then must satisfy the modular equation\n  <code>y &times; q &equiv; p (mod 10<sup>9</sup>+7)</code>, and be between 0 and\n  10<sup>9</sup>+6, inclusive. It can be shown that under the constraints of this problem such a\n  number <code>y</code> always exists and is uniquely determined.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>K</b> &le; <b>N</b>.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 10<sup>4</sup>.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 10<sup>7</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3 1\n3 2\n4 1\n4 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 500000004\nCase #2: 1\nCase #3: 666666672\nCase #4: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn sample case #3, there are four rooms and we are looking for probability that the\n  first room is occupied. When the first family arrives, there are 3 possible situations, each with\n  probability 1/3: occupy rooms 1+2, 2+3 or 3+4. In the first situation, the first room is already\n  occupied and will stay occupied.\n  In the second situation, the first room is free and no more families can be accommodated, so\n  it will stay free. Finally, in the third situation, the next arriving family\n  will definitely get rooms 1+2, and thus the first room will be occupied.\n  The probability that the first room is occupied\n  is thus 2/3, and the answer is 666666672, since\n  <code>(666666672 * 3) mod 1000000007 = 2 mod 1000000007</code>.\n</p>\n<p>\n  The probability for sample case #1 is 1/2, and for sample cases #2 and #4 it is 1.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Family Hotel","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Gallery of Pillars: Analysis</h2>\n<p>\nA convenient way to look at this problem is to set up a coordinate system with the viewer at the\norigin and the center of every pillar at other coordinates (x,y) with x and y non-negative\nintegers less than <b>N</b>.\n</p><p>\nLet us focus on a given pillar centered at (x,y). Suppose some other pillar centered at (a,b)\nintersects the\nsegment [(0,0),(x,y)]. Then, (a,b) blocks at least half the view of (x,y), from the segment towards\none of the sides. Then, if we consider the pillar centered at (x - a, y - b), that is, the\none symmetric across the midpoint of the segment [(0,0),(x,y)], the distance from that pillar\nto the segment is the same, so it also covers the segment; it's located on the other side of the\nsegment from (a,b), and so it blocks the other half of the view. It follows that the pillar\ncentered at (x,y) is visible from the origin if and only if the segment [(0,0),(x,y)] does not\nintersect any other pillar. The following picture illustrates the situation.\n</p>\n<div style=\"text-align:center\"><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0SdRJ6aqIq0n0jxQhHeuWMTqBh2sU37XvOqepmXfHUztmiEOgjUGo1jjsJZbPRHtXSFudjV72w/editorial.png\" width=\"400\" height=\"400\"/></div>\n<p>\nAssume the pillar centered at (a,b) intersects the segment [(0,0),(x,y)]. Clearly, a &le; x and\nb &le; y. Moreover, the square of the\n<a href=\"https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\">\ndistance between the point and the segment</a> can be expressed as<br/>\nd<sup>2</sup> = (ay - bx)<sup>2</sup> / (x<sup>2</sup> + y<sup>2</sup>).<br/>\nSince the pillar intersects the segment, d<sup>2</sup> &times; 10<sup>6</sup> &le; <b>R</b>.\n</p><p>\nFrom this expression, we can tell in constant time whether a given pillar blocks the view of some\nother pillar. This immediately gives an O(<b>N</b><sup>4</sup>) solution to the problem: for\neach pillar, check every other pillar to see whether it blocks it. This is just shy of fast enough\nfor the Small, but there is a simple improvement: instead of checking every possible (a,b) for each\n(x,y), it's enough, for each possible a between 0 and x - 1, to try only b = a * y / x, rounded up\nand down (that is, the two points with that a coordinate that are clearly closest to the segment).\nThis makes the complexity O(<b>N</b><sup>3</sup>), which is definitely fast enough to solve the\nSmall dataset.\n</p><p>\nThe Large dataset, as usual, requires a bit more work. Let us pick up where we left off:\nour expression for the squared distance<br/>\nd<sup>2</sup> = (ay - bx)<sup>2</sup> / (x<sup>2</sup> + y<sup>2</sup>).<br/>\nIf x and y are not relatively prime, choosing a = x / gcd(x,y) and b = y / gcd(x,y) yields a\npair (a,b) that fullfills every condition to cover (x,y). This is to be expected, as (a,b) clearly\ncovers all pillars (ka,kb) for each k &gt; 1. If x and y are not relatively prime, then\n<a href=\"https://en.wikipedia.org/wiki/Diophantine_equation\">there exist</a>\npositive a and b such that |ay - bx| = 1. Since |ay - bx| is an integer, and it can only be 0 within\nour constraints when x and y are not relatively prime, choosing a pair that makes it 1 yields the\nclosest distance. Thus, a pillar (x,y) is visible if and only if x and y are relatively prime and\n10<sup>6</sup> / (x<sup>2</sup> + y<sup>2</sup>) &lt; <b>R</b>. That is, we need to count the pairs\nof relatively prime integers within a circle of radius 10<sup>6</sup> / <b>R</b> and a square of\nsize <b>N</b> by <b>N</b>.\n</p><p>\nIf <b>N</b> &ge; 10<sup>6</sup> / <b>R</b>, then the square contains the circle, so let us assume\nfurther that <b>N</b> &le; 10<sup>6</sup> / <b>R</b> &le; 10<sup>6</sup>. We can count all points\ninside the area, then subtract the multiples of 2, 3, 5, ..., etc, then add the multiples of\n2 &times; 3 = 6, 2 &times; 5 = 10, 3 &times; 5 = 15, etc, that were subtracted twice,\nand keep doing the <a href=\"https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle\">\ninclusion-exclusion argument</a> for each possible divisor k\nbetween 1 and <b>N</b>. The count for points that are multiples of a given k should be multiplied by\nthe <a href=\"https://en.wikipedia.org/wiki/M%C3%B6bius_function\">M&ouml;bius function</a> of k.\nCalculating that function for each number between 1 and <b>N</b> can be done efficiently with\na slight modification of the <a href=\"https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">sieve of\nEratosthenes</a>, which runs in linear time. For each k, we count by iterating the possible values\nof x, k, 2k, 3k, etc, and for each one we find the range of possible y values. We can do that by\ntaking the minimum of <b>N</b> and the square root of\n(10<sup>6</sup> / <b>R</b>)<sup>2</sup> - x<sup>2</sup>, or by binary search, or by linear\nsearch. Notice that the maximum value of y decreases from one value of x to the next, so if we\npick up at the value considered for the previous x, the linear search will only take linear time\noverall (constant amortized time per each value of x). Linear and binary search are guaranteed to\ngive a precise number, but using the square root also works because we are dealing with fairly\nsmall values.\nFor the most efficient versions, the time complexity of the algorithm to get the count for a given\nvalue of k is O(<b>N</b> / k). Since the summation of 1 / k up to k = <b>N</b> can be approximated\nby log <b>N</b>, the overall complexity of the algorithm is O(<b>N</b> log <b>N</b>). Using binary\nsearch to find the range of values for y only adds a second log factor, yielding an overall\nO(<b>N</b> log<sup>2</sup> <b>N</b>). Both are efficient enough for <b>N</b> up to 10<sup>6</sup>.\n</p>\n","id":"0000000000201d21","statement":"<h3>Problem</h3>\n<p>\nYour friend Cody-Jamal is working on his new artistic installment called \"Gallery of Pillars\". The\ninstallment is to be exhibited in a square gallery of <b>N</b> by <b>N</b> meters. The gallery is\ndivided into <b>N</b><sup>2</sup> squares of 1 by 1 meter, forming an <b>N</b> by <b>N</b> matrix.\nThe exact center of the southwest corner cell is called the <i>viewpoint</i>; a person viewing the\nartwork is supposed to stand there. Each other cell contains a cylindrical pillar. All pillars have\ntwo circular bases of radius <b>R</b>: one resting on the floor, in the center of its corresponding\ncell, and the other touching the gallery's ceiling. The observer will stand in the viewpoint,\nobserve the <b>N</b><sup>2</sup> - 1 pillars, and marvel.\n</p><p>\nCody-Jamal is currently scouting venues trying to see how large he can make the value of <b>N</b>.\nAlso, he has not decided which material the pillars will be made of; it could be concrete,\nor carbon nanotubes, so the radius <b>R</b> of the base of each pillar could vary from 1 micrometer\nto almost half a meter. Notice that a radius of half a meter would make neighboring pillars touch.\n</p><p>\nYou, as a trained mathematician, quickly observe that there could be pillars impossible to see\nfrom the viewpoint. Cody-Jamal asks your help in determining, for different\ncombinations of <b>N</b> and <b>R</b>, the number of visible pillars. Formally, a pillar is visible\nif and only if there is a straight line segment that runs from the center of the southwest corner\ncell (the viewpoint) to any point on the pillar's boundary, and does not touch or intersect any\nother pillar.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> lines follow.\nEach line describes a different test case with two integers <b>N</b> and <b>R</b>. <b>N</b> is the\nnumber of 1 meter square cells along either dimension of the gallery, and <b>R</b> is the radius of\neach pillar, in micrometers. Thus, <b>R</b> / 10<sup>6</sup> is the radius of each pillar in meters.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is the\ntest case number (starting from 1) and <code>y</code> is the number of pillars in the installment\nthat are visible from the viewpoint.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>R</b> &lt; 10<sup>6</sup> / 2.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 300.\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n4 100000\n4 300000\n3 300000\n100 499999\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 9\nCase #2: 7\nCase #3: 5\nCase #4: 3\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe pictures below illustrate the first two samples (not to scale). In the center of the black\ncircle is the observer. The other circles are pillars, with the visible ones in gray and the\nnot visible ones in red. The blue dotted lines represent some of the unblocked lines of sight; the red dotted lines represent blocked lines of sight (that turn gray at the point at which they are first blocked).\n</p><table>\n<tr><td><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0OeRZFKxjpPlcacnz47XHcn46G7KvhSsggZvIXQ4glz5SNoq1bIlSgeRgay1EI5oDUDUCElA/sample1.png\"/></td>\n<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>\n<td><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0fs8k5asz832zVF3XK1LoRfzUcYcupHulwnthZjZxanTBHzg7RGB9X_KFQ6cZg3cnmtE0cqQ/sample2.png\"/></td></td>\n</table>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Gallery of Pillars","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201b72","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2016"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
