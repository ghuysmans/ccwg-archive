{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1280493900000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043324a","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThis was our most difficult round ever. Two problems, E and F, remained unsolved in the end -- a floating point geometry problem and a tricky backtracking problem.\n</p>\n\n<p>\nmarek.cygan put the first entry onto the scoreboard just under 14 minutes into the competition with a correct submission of B-small. The rest of the round was a turbulent race, with many re-orderings of the top 5.\n</p>\n\n<p>\nFor the first 47 minutes of the competition, two-time defending champion ACRush had no submissions. He seemed to be looking at the screen, writing something on paper, but not typing. At 47m13s, he submitted a correct solution to C-small and quickly followed that 3 minutes later with a correct submission to D-small, making his presence in the top 10 known to all.\n</p>\n\n<p>\nBy this point, it had become clear that B was the most tractable problem of the round. Every one of the top 10 finishers ended up solving B, D and A-small. Nine of the top ten contestants solved C. The top 5 spots ended up being decided based on A-large, E-small and F-small.\n</p>\n\n<p>\nAt the 2h28m mark, earl became the first contestant to crack open problem E. One minute later, ACRush solved E-small as well and moved into the top spot for the next four minutes, until Egor solved D and took the #1 spot away from ACRush.\n</p>\n\n<p>\nEgor ended up winning the title of Code Jam 2010 Champion with a definitive 11-point lead over 2nd-placed krijgertje. Burunduk1 took 3rd place, having been the only contestant to solve F-small correctly, which gave him a 6-point lead over ACRush, who finished in 4th. In 5th was marek.cygan, with B, C, D and A-small.\n</p>\n\n<p>\nThe last few minutes of the round saw a flurry of 11 submissions from ACRush on F-small, all incorrect. In total, 6 contestants solved E-small, but none of their solutions could pass E-large, which required one to detect and short-circuit loops in the ninja's rope. Although Egor and Eryx attempted E-large during the last minute, both of their solutions timed out.\n</p>\n\n<p>\nCongratulations to all of the competitors. We hope to see you back next year.\n</p>\n\n<h3>Cast</h3>\n<p>Problem A. <i>Letter Stamper</i> Written by Cosmin Negruseri. Prepared by Xiaomin Chen and David Arthur.</p>\n<p>Problem B. <i>City Tour</i> Written by Cosmin Negruseri. Prepared by David Arthur and Ante Derek.</p>\n<p>Problem C. <i>Candy Store</i> Written by Bartholomew Furrow. Prepared by David Arthur and Bartholomew Furrow.</p>\n<p>Problem D. <i>Travel Plan</i> Written by Cosmin Negruseri. Prepared by Petr Mitrichev.</p>\n<p>Problem E. <i>Ninjutsu</i> Written by Igor Naverniouk and Junbin Teng. Prepared by Igor Naverniouk, Bartholomew Furrow, Tomek Czajka, and Derek Kisman.</p>\n<p>Problem F. <i>The Paths of Yin Yang</i> Written by Xiaomin Chen. Prepared by Xiaomin Chen, David Arthur, and Derek Kisman.</p>\n\n<p>Contest analysis presented by David Arthur, Xiaomin Chen, Derek Kisman, Igor Naverniouk, and Cosmin Negruseri.</p>\n<p>Solutions and other problem preparation provided by Marius Andrei and John Dethridge.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1280479500000,"tasks":[{"analysis":"<p>\nThe problem idea originated from the report of one of Robert Tarjan's talks, where a quadratic solution for four letters was claimed. We found the easier three-letter version was already very interesting, and presented it to you as the first problem for this Code Jam final.\n</p>\n<p>\nWe note that the general case where the alphabet size is not restricted to a small constant such as 3 can be solved by dynamic programming in O(n^3). It had appeared in several programming contests before.\n</p>\n<p>\nThe current state is characterized by a pair <code>(S, K)</code>, where <code>S</code> is the suffix of the input string you still need to print (so the next letter you need to print is the head of <code>S</code>), and <code>K</code> is the stack. For each situation, we need to decide if the next step is a push, a pop, or a print.\n</p>\n<p>\nWe state some rules that are satisfied by an optimal sequence. These will make the solution quite clear. There can be other optimal sequences, but you can always reduce them to one that satisfies these conditions.\n</p>\n<h3>Rule 1. If the first letter of <code>S</code> is the same as the top of <code>K</code>, then the next step is a print.</h3>\n<h3>Rule 2. You never need to push the letter that's already on top of the stack. Therefore no letters appears on the stack twice in a row.</h3>\n<h3>Rule 3. Immediately after you push a letter <code>X</code>, the next step is to print <code>X</code>.</h3>\n<p>\nThe rules above are trivial and we omit the reasoning. But it might worth spending a little time convincing yourself formally.\n</p>\n<h3>Rule 4. There should never be three consecutive letters in the stack of the form <code>XYX</code>.</h3>\n<p>\nLet us justify this rule. Suppose an optimal solution has XYX on the stack. Let's modify it. At some point the top of the stack is XY and we were going to push another X. Instead, we will pop the Y. Then we continue as before, until we were going to pop the second X that now doesn't exist. Instead, we will push Y, arriving at the same state as before. This way we have shortened the stack while achieving a solution of the same length. By induction you can keep simplifying the solution until all 4 rules are satisfied.\n</p>\n<p>\nRule 4, together with Rule 2, implies that the stack always contains a cycle of 3 letters, e.g. <code>ABCABCABC...</code>. The state of the stack then is completely defined by the first two letters and the stack height. There are only 6 patterns, and the height of the stack is never bigger than <code>n</code>. Hence the number of possible states <code>(S, K)</code> is <code>O(n^2)</code>. This gives a quadratic dynamic programming solution.\n</p>\n","id":"00000000004329fa","statement":"<h3>Problem</h3>\n\n<p>\nRoland is a high-school math teacher. Every day, he gets hundreds of papers from his students. For each paper, he carefully chooses a letter grade: 'A', 'B' or 'C'. (Roland's students are too smart to get lower grades like a 'D' or an 'F'). Once the grades are all decided, Roland passes the papers onto his assistant - you. Your job is to stamp the correct grade onto each paper.\n</p>\n\n<p>\nYou have a low-tech but functional letter stamp that you use for this. To print out a letter, you attach a special plate to the front of the stamp corresponding to that letter, dip it in ink, and then apply it to the paper.\n</p>\n\n<p>\nThe interesting thing is that instead of removing the plate when you want to switch letters, you can just put a new plate on top of the old one. In fact, you can think of the plates on the letter stamp as being a stack, supporting the following operations:\n<ul>\n<li> Push a letter on to the top of the stack. (This corresponds to attaching a new plate to the front of the stamp.)</li>\n<li> Pop a letter from the top of the stack. (This corresponds to removing the plate from the front of the stamp.)</li>\n<li> Print the letter on the top of the stack. (This corresponds to actually using the stamp.) Of course, the stack must actually have a letter on it for this to work.</li>\n</ul>\n</p>\n\n<p>\nGiven a sequence of letter grades ('A', 'B', and 'C'), how many operations do you need to print the whole sequence in order? The stack begins empty, and you must empty it when you are done. However, you have unlimited supplies of each kind of plate that you can use in the meantime.\n</p>\n\n<p>\nFor example, if you wanted to print the sequence \"ABCCBA\", then you could do it in 12 operations, as shown below:\n\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n\n<td>\n<br/>\n<span class=\"io-table-header\">Operation</span>\n<br/>&nbsp;\n</td>\n\n<td>\n<br/>\n<span class=\"io-table-header\">Printed so far</span>\n<br/>&nbsp;\n</td>\n\n<td>\n<br/>\n<span class=\"io-table-header\">Stack</span>\n<br/>&nbsp;\n</td>\n\n</tr>\n<tr>\n\n<td>\n<code>\n0. -<br/>\n1. Push A<br/>\n2. Print<br/>\n3. Push B<br/>\n4. Print<br/>\n5. Push C<br/>\n6. Print<br/>\n7. Print<br/>\n8. Pop<br/>\n9. Print<br/>\n10. Pop<br/>\n11. Print<br/>\n12. Pop<br/>\n</code>\n</td>\n\n<td>\n<code>\n-<br/>\n-<br/>\nA<br/>\nA<br/>\nAB<br/>\nAB<br/>\nABC<br/>\nABCC<br/>\nABCC<br/>\nABCCB<br/>\nABCCB<br/>\nABCCBA<br/>\nABCCBA<br/>\n</code>\n</td>\n\n<td>\n<code>\n-<br/>\nA<br/>\nA<br/>\nAB<br/>\nAB<br/>\nABC<br/>\nABC<br/>\nABC<br/>\nAB<br/>\nAB<br/>\nA<br/>\nA<br/>\n-<br/>\n</code>\n</td>\n\n</tr></table>\n</div>\n\n<h3>Input</h3>\n\n<p>\nThe first line of the input file contains the number of cases, <b>T</b>. <b>T</b> test cases follow, one per line. Each of these lines contains a single string <b>S</b>, representing the sequence of characters that you want to print out in order.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: N\", where x is the case number (starting from 1) and N is the minimum number of stack operations required to print out <b>S</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n<b>S</b> is a non-empty string containing only the letters 'A', 'B', and 'C'.\n</p>\n\n<h3>Small dataset (Test set 1 - Visible)</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n<b>S</b> has at most 100 characters.\n</p>\n\n<h3>Large dataset (Test set 2 - Hidden)</h3>\n<p>\n1 &le; <b>T</b> &le; 20.<br/>\n<b>S</b> has at most 7000 characters.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\nABCCBA\nAAABAAB\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 12\nCase #2: 13\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Letter Stamper","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n<blockquote>\n<i>\nPlenty and void grow from each other;<br/>\nhard and easy foster each other;<br/>\nlong and short shadow each other;<br/>\nelegance and mudanity prosper together;<br/>\nmusic and voice complement each other;<br/>\nback and front stay together;<br/>\nthey last forever.<br/>\n</i>\nThis version, translated by our colleague Yifan Shi, is certainly closer to the original meaning of the text.\n</blockquote>\n</p>\n\n<h3>Impressions</h3>\n\n<p>\nOne may discover a series of observations in attacking this problem.\nSome are obvious, while\tothers need some hard work and inspiration.\nOur algorithm searches all the possible\tsolutions and counts them. Imagine\nyourself to be a detective facing such an empty\trectangular board.\nYour job is to reveal all the possible solutions, quickly.\n</p>\n\n<p>\nFor any solution, as the problem stated, almost all the points have\ndegree (number of neighboring squares with the same color as itself)\n2; and there are exactly 4 points having degree\t1. Let us call the\npoints with degree 1 <i>end points</i>;\n</p>\n<p>\nOnce we have decided all the degrees, we can try to reconstruct\tthe\ncolor of each square by brute force search. Suppose in a general case,\nwe have\tcolored a square <code>A</code>, and we also colored all but only\none of its neighbor <code>B</code>, then we do not need\tto try both\nblack and white\tfor <code>B</code>, it is decided by the color of the\nother squares, and the degree of <code>A</code>.\n</p>\n<p>\nThis gives us a\tmuch faster way\tto recover all the solutions than searching\nblindly. One can see that if all the colors of the first row are decided,\nand we proceed from top\tdown, then in each step\twe always have a square\t\n(in fact close to <code>M</code> squares) who is in the\tsame situation as\n<code>A</code> above. So, once we decided the combination\n<code>(color of the first row, the position of the 4 end points)</code>,\nall we have to do is to\tcheck in <code>O(NM)</code> time if a solution arises.\n</p>\n<p>\nThere are 2<sup>M</sup>\tways to\tcolor the first\trow, and\n<code>&Theta;((NM)<sup>4</sup>)</code> ways to pick the\tend points.\nBoth numbers are too big. One may easily see most of the 2<sup>M</sup>\ncolorings of the first row will\tobviously fail to give a solution,\nas we will discuss in the next section.\tAfter that, we will work on\nhow to reduce the number of positions for the end points.\n</p>\n\n<h3>A bit of Topology</h3>\n<p>\nRather than looking at the first row, let us consider the <i>outer loop</i> of the\nboard. That is, the positions on the boundary. It is easy to see that they cannot be\nof the same color -- the outer loop must contain both black and white squares.\n</p>\n<p>\nWe can say much more about the outer loop. It must be exactly one segment of black\nsquares, and the rest is exactly one segment of white squares! The reason can be seen\nfrom the picture on the left below. If there are at least two black segments (and hence at \nleast two white segments), there is no way one can connected both the black pieces\nand white pieces from the inside of the board.\n</p>\n<p>\n<br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0Orn23cogD2M2zr88nmibGEfzNXa6bFkl5ikLBrRsLPQio7vqdSRR5ho1XAWrPQDrS9tVXqw/yysol01.png\">\n<br/><br/>\n</p>\n<p>\nThe second picture shows a forbidden configuration for a 2 by 2 square. If we have a chessboard-like situation, there is no way to connect both black squares and white squares.\n</p>\n\n<h3>Position for end points</h3>\n<p>\nSuppose <code>A</code> is a white end point, and <code>B</code> is its sole white neighbor, as in the picture below.\n</p>\n<p>\n<br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1_-SosbRmx4W3-JJ8TvCfwNWaMEFAQH2fNq-nV0pcso8H-6UvMCF4sK4OUm_jM8xf4HU0fGA/yysol02.png\">\n<br/><br/>\n</p>\n<p>\n<ul>\n<li>Because <code>A</code> has no other white neighbors, so the positions labeled with <code>1</code> must be black.</li>\n<li>To avoid 2 by 2 chessboard, the positions labeled with <code>2</code> must be black as well.</li>\n<li>Because the first row labeled with 1 and 2 has no other black neighbors, so the positions labeled with <code>3</code> must be white.</li>\n<li>To avoid 2 by 2 chessboard, the positions labeled with <code>4</code> must be white as well.</li>\n</ul>\nThis deduction can go on until we hit the boundary of the board. In our picture <code>X</code> is a point on the boundary, and it is also the place where black and white squares meet on the boundary. Yet we can continue the deduction along the other direction, until we get a point <code>Y</code> on the boundary as well.\n</p>\n<p>\nThis gives a nice connection between the end points and the outer loop. From an end point, we draw two diagonal rays (both with 135 degrees to its neighbor with the same color), both rays hit the boundary either at a corner, or at a point where the black and white squares meet on the outer loop.\n</p>\n<p>\nLet us summarize our algorithm. We start by fixing the outer loop as a segment of black squares and the rest white. Then from each corner we draw a diagonal line; also from each point on the outer loop that is next to a different color on the loop, we draw one diagonal line going away from the neighbor with the different color. Thus we have 8 diagonals. These diagonals will produce no more than 16 intersections. Those are all the possible positions for the end points.\n</p>\n<p>\nThere are <code>O((N+M)<sup>2</sup>)</code> ways to fix the outer loop, and thus <code>O((N+M)<sup>2</sup>)</code> ways to fix the outer loop and the end points. For each of these, one can check if a solution arises in <code>O(MN)</code> time. So the running time is O(MN(N+M)<sup>2</sup>). The constant is not very small, but tolerable. And one can reduce it using symmetry.\n</p>\n<p>\nBelow is one of a good solution. We may see how the end points and outer loop are connected by the diagonals.\n</p>\n<p>\n<br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2TJgKbqcibR2bsQYG60VFzhKkfUMFqk8x6tpqwuKohbyhQm2SH2jdjHGHwaSEapxnjISE-SALuVQA/pathyysol03.png\">\n<br/><br/>\n</p>\n","id":"0000000000432a86","statement":"<p>\n<blockquote>\n<i>\nSo, If and Else grow out of each other; <br/> \nHardness and Tractability complete each other; <br/>\nLong int and Short int shape each other; <br/> \nHigh bits and Low bits determine each other; <br/> \nMusic and Voice give harmony to each other; <br/> \nPush_front and Push_back give sequence to each other. <br/> \n</i>\n-- Tao Te Ching, Laozi, Zhou dynasty, ancient China.<br/>\n&nbsp;&nbsp;&nbsp;&nbsp;Translated (loosely) by yours truly.\n</blockquote>\n</p>\n<h3>Problem</h3>\n<p>\nGiven an rectangular grid of <b>N</b> rows and <b>M</b> columns, each cell can be labeled black (Yin) or white (Yang). Two cells are <i>neighbors</i> if they share a common unit-length edge segment. The grid is <i>valid</i> if all the black cells form a path, and all the white cells form a path. A <i>path</i> is a set <code>S</code> of cells defined as follows:\n<ul>\n<li>The cells form a connected piece. From each cell in <code>S</code>, you can reach any other cell in <code>S</code> by moving between neighbors within <code>S</code>.</li>\n<li>Exactly two cells in <code>S</code> have exactly one neighbor in <code>S</code> each.  These are the \"ends\" of the path.</li>\n<li>Every other cell in <code>S</code> has exactly two neighbors in <code>S</code>.\n</li>\n</ul>\n</p>\n<p>\nFor example, in the picture below, the first grid is valid, while the second grid is not -- although the black cells form a path, the white cells do not.<br/>\n<br/><br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U11-rk8CzIXdViPRtwsVT4571LKX1Pb7PmH3Qz8eI5KPZz6YoPB3o3l3TC0gKEpWfS3l_Foig/yinyang.png\">\n<br/><br/><br/>\n</p>\n<p>\nGiven <b>N</b> and <b>M</b>, compute the number of valid grids.  Note that symmetry doesn't matter -- as long as two valid grids differ in one position they are considered different, even if one can be rotated or flipped to the other.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input will be a single integer <b>T</b>, the number of test cases. <b>T</b> lines follow, each of which contains two integers separated by a space: \"<b>N M</b>\", as defined above.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output a line in the form \"Case #<b>x</b>: <b>A</b>\", where <b>x</b> is the case number, starting from 1, and <b>A</b> is the number of valid grids of the specified size.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 50\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds per test set.<br/>\n4 &le; <b>N</b>, <b>M</b> &le; 10\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds per test set.<br/>\nFor 80% of the test cases, 4 &le; <b>N</b>, <b>M</b> &le; 50 <br/>\nFor 90% of the test cases, 4 &le; <b>N</b>, <b>M</b> &le; 70 <br/>\nFor all test cases, 4 &le; <b>N</b>, <b>M</b> &le; 100\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 4\n4 6\n5 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 24\nCase #2: 44\nCase #3: 48\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":17},{"type":2,"type__str":"HIDDEN","value":35}],"title":"The Paths of Yin Yang","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>This proved to be the easiest problem in the finals for the experienced competitors.</p>\n\n<p>We get some insight into the problem by noticing the graph resembles a tree. These graphs are actually called partial 2-trees. We can actually build a tree if we follow the way the graph is constructed. We build another graph that associates a node to each new added cycle of length this cycle shares an edge to an old cycle so we add an edge between the two respective nodes in the second graph. This way we have built the tree decomposition of these graphs. As on trees many problems that are hard to solve on general graphs have polynomial algorithms on this type of graphs.</p>\n\n<p>Let's solve the related problem of finding the longest path in a tree. We can use dynamic programming and depth first search. We mark a node as a root. Every path in the tree has exactly one node that is closest to the root and this node splits the path in two downward paths. Now for each node in the tree we compute the longest downwards path that starts in it. To find the largest path in the tree we look at each node and at the two longest paths that start in it's children. This solves the problem in linear time.\n<p>\nThe solution for our original problem is pretty similar. For each edge (x,y), we compute the cycle that contains it and and all the other nodes in the cycle have larger indexes. Let's call this a downward cycle since it goes the opposite direction of where the initial three nodes are. To find that number we have to look at all higher indexed nodes that were connected to this edge and try to use them as intermediary points in the cycle. So for a given intermediary point z we can build a cycle by looking at the longest downward cycle that contains the edge (x,z) and the longest downward cycle that contains the edge (z,y), use all the edges, add edge (x,y) and remove the edges (x,z) and (z,y).\n</p>\n<p>\nWe also compute the largest downward cycle which contains these two nodes but doesn't contain this edge, this is a union of the cycle that goes through these nodes and the second largest path from which we remove the edge (x,y).\n</p>\n<p>\nAnd here is some code that does implements this solution:\n</p>\n<pre>\nint best_so_far = 0;\n\nint best(int x, int y, int N, int[][] a) {\n    int max_len = 2;\n    int second_max_len = -1;\n    for (int i = Math.max(x, y) + 1; i &lt; N; i++) {\n      if (a[x][i] * a[y][i] &gt; 0) {\n        int len =  best(x, i, N, a) + best(y, i, N, a) - 1;\n        if (len &gt; max_len) {\n          second_max_len = max_len;\n          max_len = len;\n        } else if (len &gt; second_max_len) {\n          second_max_len = len;\n        }\n      }\n    }\n    best_so_far = Math.max(max_len, best_so_far);\n    best_so_far = Math.max(max_len + second_max_len - 2,\n                           best_so_far);\n    return max_len;\n}\n</pre>\n<p>\nAnother cool solution is based on the idea of contracting each node of degree two. We replace it with an edge which has the weight equal to the sum of the weights of the two incoming edges. It's a pretty neat idea and we'll let you figure out the details on your own.\n</p>","id":"0000000000432b2e","statement":"<h3>Problem</h3>\n<p>\nDuring summer time, old cities in Europe are swarming with tourists who roam the streets and visit points of interest. \n<p>\n</p>\nMany old cities were built organically and not according to some architecture plan, but, strangely, their growth exhibits a similar pattern: the cities started from three points of interest, with each pair being connected by a bidirectional street; then, gradually, new points of interest were added. Any new point of interest was connected by two new bidirectional streets to two different previous points of interest which were already directly connected by a street.\n</p>\n<p>A tourist visiting such a city would like to do a tour visiting as many points of interest as possible. The tour can start at any point of interest and must end at the same point of interest. The tour may visit each street at most once and each point of interest at most once (with the exception of the first point of interest which is visited exactly twice).\n</p>\n<p>\nYou are given the description of how the city grew. Find the largest number of different points of interest a single tour can visit in this city.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input file contains the number of cases, <b>T</b>. <b>T</b> test cases follow.\n</p>\n\n<p>\nEach case begins with the integer <b>N</b> - the total number of points of interest in the city. Points are denoted with numbers from 1 to <b>N</b>; numbers 1, 2, and 3 denote the three original points when the city started, while numbers 4, ..., <b>N</b> denote the other points in the order they were added to the city.\n</p>\n<p>\nThe next <b>N</b>-3 lines each contain a pair of space-separated integers <b>A</b>, <b>B</b>, indicating that the corresponding point of interest was connected by streets to points <b>A</b> and <b>B</b>. First of these lines corresponds to point number 4, second to point number 5, etc.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the largest number of points of interest a tour can visit in this city.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 50.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n4 &le; <b>N</b> &le; 15.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n4 &le; <b>N</b> &le; 1000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n1 2\n2 1\n6\n1 2\n1 4\n4 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":23}],"title":"City Tour","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Getting something discrete</h3>\n<p>A fact that jumps out immediately is that this problem is not discrete.\nThe rope length that gives an optimal solution might be a real number, and\nthere does not seem to be a way to ensure that this number is rational or\ndiscrete in any other way.</p>\n\n<p>Given any real-valued rope length, we can simulate and count the bends, but\nthis number is not a convex function of the rope length, so ternary search is\nout.</p>\n\n<p>What we really wish we could do is dynamic programming, where the state is a\ntriple -- the point we are currently swinging around, the direction the end of\nthe rope is pointing in, and the length of the rope. Two of these values are\nreal numbers. However, let's see how many different real values we actually\nneed to care about.</p>\n\n<p>As we are swinging the end of the rope around some point <b>P</b>, nothing\ninteresting happens until the moving segment of the rope touches another point,\n<b>Q</b>. At that... point, we need to make a decision -- we could either bend\nthe rope and switch to swinging around point <b>Q</b>, or cut the rope at\nexactly point <b>Q</b> and continue swinging around <b>P</b>. There are at most\n<b>N</b><sup>2</sup> pairs of points, so we only need to consider at most\n<b>N</b><sup>2</sup> different directions. That takes care of the second DP\nparameter.</p>\n\n<p>What about the rope length? Using the same reasoning as above, we can show\nthat there is only a finite number of rope lengths that are interesting.\nFirstly, note that bending the rope does not change its length. Whenever we\nswing around point <b>P</b> and hit point <b>Q</b>, there is a binary decision\n-- is the rotating rope segment longer than the distance from <b>P</b> to\n<b>Q</b>, or shorter?</p>\n\n<p>In other words, the interval of real numbers between 0 and <b>R</b> can be\nsplit into a finite number of of sub-intervals, such that the number-of-bends\nfunction has a constant value on each sub-interval. This observation suggests\nthe following, naive dynamic programming (DP) solution. The DP state is a pair\nof points (<b>P</b>, <b>Q</b>) and a real-valued rope length, <b>r</b>. The\nanswer is the maximum number of bends we can achieve by continuing to spin\naround point <b>P</b>, if we are currently poining in the direction of point\n<b>Q</b> and have a swinging segment of the rope of length <b>r</b>. To be a\nbit more precise, we will actually need to have twice as many states -- one for\npoining in the direction of <b>Q</b>, and one for poining 180 degrees away from\n<b>Q</b>. We need the second kind of state for the situation when we decide to\nbend the rope and continue swinging around <b>Q</b>. At that point, we will\nstart pointing in the direction 180 degrees away from <b>Q</b>. One way to\nimplement this solution is simply to use a point, a 2D vector and a length as\nthe state, instead of two points and a length.</p>\n\n<p>Next, let's get rid of the real-valued length as a DP parameter. Because\nrope length only changes when we decide to cut it, we can replace the\nreal-valued length parameter with an integer -- the number of bends since the\nlast time we have cut the rope. Let's also replace the first two parameters\nwith the pair of points that caused the cut. We are now interested in all\nsituations of the following sort -- we were swinging around point <b>P</b>,\nwith the end of the rope poining in the direction\n<nobr>(<b>dx</b>, <b>dy</b>)</nobr>, at which point we cut the rope, and since\nthen, we have made <b>K</b> bends. This information is enough to identify a\nstate uniquely, and it implies a particular remaining rope length. Our DP state\nnow becomes a triple of <b>P</b>, <nobr>(<b>dx</b>, <b>dy</b>)</nobr> and\n<b>K</b>.</p>\n\n<h3>Floating point issues</h3>\n<p>We now have an almost completely discrete problem. The only place where\nfloating point numbers are necessary is in the testing of whether the current\nrope length is long enough to hit some given point, or does the rope's end pass\nunderneath that point? Given the guarantee that the optimal solution works for a long range of rope lengths (0.999999), we can avoid floating point rounding trouble by being conservative: only assume that the rope can hit a point if its length is longer by at least, say, 0.5 than the distance to the point. If it is shorter than that, then certainly such a solution doesn't work for a long enough range of rope lengths, so it's not the optimal solution by the guarantee.\n</p>\n\n<h3>Dealing with loops</h3>\n<p>The naive solution is too slow. Consider, for example, the case where we\nhave a rope of length 10<sup>9</sup> and two points: <nobr>(0, 0)</nobr> and\n<nobr>(0, 1)</nobr>. The optimal solution uses the full length of the rope to\ncreate <nobr>10<sup>9</sup>-1</nobr> bends. Of course, we are just going around\nin loops, so we need a way to detect and handle such loops to have a chance at\na polynomial-time solution.</p>\n\n<p>First, let's reorganize the naive DP solution a bit to make loop detection\neasier. We will have a simpler, three-parameter state and use a memoized\nrecursive function. Each call of the function will correspond to a situation of\nthe following kind -- we are spinning around a point <b>P</b>, with the end of\nthe rope pointing in the direction <nobr>(<b>dx</b>, <b>dy</b>)</nobr>, and we\nhave just cut the rope because it has touched another point, <b>Q</b>. The total\nnumber of such states is O(<b>N</b>^3), but many of them are not possible and\nwill never be visited.</p>\n\n<p>Inside the function, we will simulate the wrapping of the rope and make\nrecursive calls in situations when we decide to cut the rope further. If we\nsimulate the wrapping process naively, we may need to make a huge number of\nrecursive calls. Instead, imagine that we find ourselves in a situation\nwhere we have just bent the rope around some point <b>A</b>, and we are about\nto bend it again around some point <b>B</b>. If this is not the first time we\nhave seen the pair <nobr>(<b>A</b>, <b>B</b>)</nobr>, then we are looping\naround the same set of points. The second time we hit this pair, we will have a\nshorter remaining rope length, <b>r</b>, and we can figure out how much rope\none revolution consumes by subtracting the new value of <b>r</b> from the value\nwe had when we first encountered the pair.</p>\n\n<p>Once we detect a loop, we can choose the number of full revolutions we want\nto make before we cut the rope and enter inside the convex hull of the points\nwe are looping around. Clearly, it never makes sense to cut off more than one\nwhole loop perimeter. We would be throwing away free rope bends. The optimal\nnumber of revolutions is, thus, the total remaining rope length, divided by the\nperimeter of the loop, floored, minus one.</p>\n\n<h3>Putting together a complete solution</h3>\n<p>We now have a DP solution with O(<b>N</b>^3) states and O(<b>N</b>^2) work\nper state (linear number of recursive calls; linear amount of work to find the\nnext point for each call). We can speed this up by precomputing next points for\neach state, but this is not necessary. It turns out that the number of\nreachable states is small enough for this solution to pass.\n</p>\n\n<p>Remaining difficulty is in dealing with collinear points. Since all\ncoordinates are integers, this should be done exactly, without using floating\npoint computations.</p>\n","id":"0000000000432be2","statement":"<h3>Problem</h3>\n\n<p>Ninjutsu is the martial art of the mysterious Japanese assassins, ninja.  As\na beginner in the practice of ninjutsu, your first task is to master the use of\nthe grappling hook.</p>\n\n<p>A grappling hook is a technologically-advanced device consisting of a hook\ntied to some (very strong and very thin) rope.  Proper use of a grappling hook\ninvolves throwing the hook at a target and hoping that it catches.</p>\n\n<p>This time, it did!  You are now hooked onto a target that is located at (0,\n0). Your rope extends to the left, and you're at the end of it; when you jump,\nyou will start swinging counter-clockwise around the target.  There are other\ntargets located to the right and above (0, 0), at (x<sub>i</sub>,\ny<sub>i</sub>)) with <nobr>x<sub>i</sub> &ge; 0</nobr> and\n<nobr>y<sub>i</sub> &ge; 0</nobr>  When an interior point of the rope (not\neither end) contacts one or more targets, the rope will bend around the target\nclosest to its moving end.  Ignore your starting velocity; because you are a\nninja, it is fast enough that you will continue bending around targets until\nyou are spinning around a single one.</p>\n\n<p>Your rope currently has length <b>R</b>, but you may choose to cut it down to\nany shorter length <b>r</b> (including non-integers) before you start swinging.\nAs such, you will start at <nobr>(-<b>r</b>, 0)</nobr> and swing down\n(counter-clockwise) toward <nobr>(0, -<b>r</b>)</nobr>.</p>\n\n<p>What is the maximum number of bends you can put into the rope with one\nswing?  A bend happens when your rope touches a target and then rotates some\nnon-zero number of degrees around that target.  The rope will always remain\nperfectly straight (again, this is possible because you are a ninja), except at\nbends.</p>\n\n<h3>Example</h3>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3ZsCfOmkknRq07V14wZ4vxwo0wv-bIKGS8npwExD34Z0Jn1otD0XTQcpz_Ms0dTB1Of8L_wNQm/ninjutsu1.png\"><br>\n<p>In the example above, there are 6 points:\n<ul>\n  <li>(0, 0),</li>\n  <li>(3, 1),</li>\n  <li>(12, 4),</li>\n  <li>(14, 5),</li>\n  <li>(13, 7), and</li>\n  <li>(7, 10).</li>\n</ul>\nYou have a rope of length 24. If you do not cut the rope, then you will bend\naround point <nobr>(12, 4)</nobr>, then around point <nobr>(14, 5)</nobr>,\nthen around point <nobr>(13, 7)</nobr>, and finally, you will be stuck orbiting\npoint <nobr>(7, 10)</nobr> with about 0.1705 units of rope remaining. This\namounts to a total of 4 bends. Although you touch point <nobr>(3, 1)</nobr>,\nit does not contribute a bend because it is collinear with the points\n<nobr>(0, 0)</nobr> and <nobr>(12, 4)</nobr>.</p>\n\n<p>If, however, you cut the rope by 0.18 units, you will not have enough\nlength to reach point <nobr>(7, 10)</nobr> and will instead follow the path\n<pre>\n(0, 0)--(12, 4)--(14, 5)--(13, 7)--(12, 4)--(14, 5)\n</pre>\nand will end up orbiting point <nobr>(14, 5)</nobr> with about 1.3004 units of\nrope remaining. This path amounts to 5 bends, in total, and is an optimal\nsolution.</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U06r1TLm_cuRh95X8DTL_CCGqyAT9-NWTstH0Qd_39VPXNyt27GsO6-wbJxiO_aRP30L-uO8sta/ninjutsu2.png\"><br>\n\n<p>Case #1 in the sample input below represents this example.</p>\n\n\n<h3>Input</h3>\n<p>The input will start with a line containing <b>T</b>, the number of test\ncases to follow. Each test case will start with two integers together on a\nline: <b>N</b> and <b>R</b>. The next <b>N</b> lines will each contain a pair\nof integers -- <b>x<sub>i</sub></b> and <b>y<sub>i</sub></b> -- the\ncoordinates of the targets, starting with the target at (0, 0).\n\n<h3>Output</h3>\nFor each test case, output a line of the form \"Case #<b>C</b>: <b>k</b>\", where\n<b>C</b> is the 1-based case number, and <b>k</b> is the maximum number of\nbends that can be made in the rope in one swing.\n\n<h3>Limits</h3>\nTime limit: 60 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100<br>\nAll target coordinates are integers.<br>\nAll targets will be at different locations.<br>\nThe first target listed will be located at (0, 0).<br>\nThere will be at least one value of <b>r</b> that gives an optimal solution\nand has the property that a rope of length <nobr><b>r</b> - 0.999999</nobr> also\ngives the same solution (the same sequence of bends).<br>\n\n<h3>Small dataset (Test set 1 - Visible)</h3>\n1 &le; <b>N</b> &le; 10<br>\n1 &le; <b>R</b> &le; 1,000<br>\n0 &le; <b>x<sub>i</sub></b> &le; 1,000<br>\n0 &le; <b>y<sub>i</sub></b> &le; 1,000<br>\n\n<h3>Large dataset (Test set 2 - Hidden)</h3>\n1 &le; <b>N</b> &le; 1,000<br>\n1 &le; <b>R</b> &le; 10<sup>9</sup><br>\n0 &le; <b>x<sub>i</sub></b> &le; 10<sup>9</sup><br>\n0 &le; <b>y<sub>i</sub></b> &le; 10<sup>9</sup><br>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">6\n6 24\n0 0\n3 1\n12 4\n14 5\n13 7\n7 10\n2 1\n0 0\n2 0\n2 1\n0 0\n1 0\n2 10\n0 0\n4 0\n3 50\n0 0\n9 0\n10 0\n3 12\n0 0\n3 0\n3 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5\nCase #2: 0\nCase #3: 0\nCase #4: 2\nCase #5: 12\nCase #6: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Ninjutsu","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Summary</h3>\n\n<p>\nAt first this problem seems intimidating.  There are a huge number of ways customers can order, and even once you've decided which boxes to order, verifying that all possible scenarios are covered is non-trivial.\n</p>\n\n<p>\nBut as it turns out, a greedy algorithm for choosing the boxes, and a greedy approach to handing them out, ends up working!  And as with most greedy problems, the difficulty lies only in convincing yourself that it works.  It's actually the easiest problem in the set to implement.  The only thing you must overcome is self-doubt!\n</p>\n\n<h3>Proof</h3>\n\n<p>\nSuppose that part of our order is a set of boxes with total weight N grams, with no box larger than X = floor(N/k)+1.  Furthermore, suppose that we know these boxes have the property that if the k customers' orders don't total more than N grams, these boxes can be used greedily to satisfy their orders.  \"Greedily\" means that when a customer comes to the store, you simply find the largest box that is less than or equal to his order, and give it to him, repeating until you've filled his order exactly.  This is our inductive hypothesis: a guarantee that this strategy works.\n</p>\n\n<p>\nNow, suppose we order another box with weight X (ie, floor(N/k)+1) grams, making a new set of boxes with total weight N+X grams (and note that no box is larger than floor((N+X)/k)+1, trivially).  Suppose the k customers order no more than N+X grams.  What happens if we apply the greedy strategy?  Well, as soon as we see an order of &ge; X cents, we will use this new X-gram box on it immediately.  If we now pretend that the customer instead ordered X fewer cents, then we know the greedy strategy with the rest of the boxes works.  The choices made by the strategy are unchanged aside from the use of the new box.  If it turns out that there is NO order of &ge; X cents, then the total is at most k*(X-1) &le; k*(N/k) = N grams.  The new box can't ever be used, so the greedy strategy does the same thing for these orders that it did before, and thus it works.\n</p>\n\n<p>\nSo using induction, we now have what I'll call \"The Algorithm\", which constructs sets of boxes that work greedily.  We start with 0 boxes, and keep adding new boxes of size floor(\"total sum so far\"/k)+1.  eg, first we'll add k boxes of size 1 (which we obviously need), then a box of size 2, and so on.\n</p>\n\n<p>\nOk, now how do we prove that this is the best we can do?  Suppose we've ordered some set S of boxes that works.  Sort the boxes from smallest to largest, and consider the first box that is larger than would be chosen by \"The Algorithm\" based on all the boxes smaller than it.  In other words, if this box is of size Y, and N is the total of all the boxes smaller than it, Y &gt; X = floor(N/k)+1.  (Note that X &le; C since N &lt; k*C.)  What happens if the customers all order X cents?  None of the boxes of size Y or greater can be used, and the total is k*X &gt; N, so all the boxes smaller than Y don't add up to enough to handle them.  This can't possibly work, regardless of strategy.\n</p>\n\n<p>\nThus, every box in S, considered in sequence, is no larger than would be added by \"The Algorithm\" based on the previous boxes.  But if any box chosen is STRICTLY smaller, then \"The Algorithm\"'s later selections will all be reduced accordingly (it is monotonic in that sense).  Since S must have sum at least k*C, if we ignore S and instead order an equal number of boxes using \"The Algorithm\", their sum will be at least k*C as well.  This proves that \"The Algorithm\" is the best we can do.\n</p>\n\n<h3>Implementation</h3>\n\n<p>\n\"The Algorithm\" is really, really simple to code.  In fact, this is a complete implementation of a Candy Store solution:\n</p>\n\n<pre>long long T, k, C, prob = 1;\nfor (cin &gt;&gt; T; T--;) {\n  cin &gt;&gt; k &gt;&gt; C;\n  long long sum = 0, num_boxes = 0;\n  while (sum &lt; k*C) {\n    num_boxes++;\n    sum += (sum / k) + 1;\n  }\n  cout &lt;&lt; \"Case #\" &lt;&lt; prob++ &lt;&lt; \": \" &lt;&lt; num_boxes &lt;&lt; endl;\n}\n</pre>\n\n<h3>Other Cool Stuff</h3>\n\n<p>\nThe observant among you may have noticed that this solution is very general, and remains unchanged even if we vary the problem a little.  For instance:\n</p>\n\n<p>\n- The bound C is effectively useless.  We can throw it out and let customers order any amount, as long as the TOTAL order is no more than k*C.\n</p>\n\n<p>\n- We can do no better even if we're told all the customers' orders in advance (at the beginning of the day).  The \"online\" solution is just as good as an \"offline\" one.\n</p>\n\n<p>\n- We can do no better even if we constrain the customers to all order the same amount as each other.  This was actually the original proposed form of the problem.\n</p>\n\n","id":"0000000000432cce","statement":"<h3>Problem</h3>\n<p>\nOwning a candy store is tough!  You have to optimize all kinds of things.  Lately you've been selling a very popular kind of candy called Whizboppers.  These candies become rotten very quickly, which gives them the following properties:\n<ul>\n  <li>You must buy new Whizboppers from your supplier every morning.</li>\n  <li>You must sell Whizboppers in the boxes you bought from your supplier that morning.</li>\n</ul>\nYou can order Whizboppers from your supplier in boxes that contain any integer number of grams.\n</p>\n<p>\nEvery day up to <b>k</b> people visit your store, and, starting from the first person, they will choose an integer number of cents to spend on Whizboppers: between 1 and <b>C</b> cents inclusive.  You're going to sell Whizboppers for 1 cent per gram; so if a person wants to spend 4 cents, you will give that person exactly 4 grams of candy.  You might do this by giving the person a 4-gram box, or perhaps a 2-gram box and two 1-gram boxes.\n</p>\n<p>\nWhat is the minimum number of boxes you need to order so that, no matter what amount each person orders, you can always give all of the people the mass of Whizboppers they want?\n</p>\n<p>\n<b>Note</b>: When a person chooses how much candy to buy, you know what other people have already bought, but you don't know what future people will buy.\n</p>\n<p>\nFor example, if up to 2 people visit your store every day, and they spend up to 2 cents each (k=2, C=2), you could buy four 1-gram boxes from your supplier.  But you can do better: if you buy two 1-gram boxes and one 2-gram box, you can satisfy your customers.  Here's how:\n<pre>\nFirst Person   Boxes given   Second Person   Boxes given\n--------------------------------------------------------\n  2 cents      1 x 2-gram      2 cents       2 x 1-gram\n                               1 cent        1 x 1-gram\n  -----------------------------------------------------\n  1 cent       1 x 1-gram      2 cents       1 x 2-gram\n                               1 cent        1 x 1-gram\n</pre>\nRegardless of what the first person orders, you can give out boxes so that the second person can still get the right amount of candy.  So for k=2, C=2, you can serve any sequence of orders with 3 boxes.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow, each of which contains two integers: <b>k</b> and <b>C</b>, the maximum number of people and the maximum number of cents each person may spend.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the minimum number of boxes you need to order every day.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>k</b> &le; 20.<br/>\n1 &le; <b>C</b> &le; 3.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>k</b> &le; 1000.<br/>\n1 &le; <b>C</b> &le; 10<sup>12</sup>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 5\n2 2\n10 3\n2 50\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 3\nCase #3: 19\nCase #4: 11\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Explanation</h3>\n<p>\nIn the first case, you can buy one 1-gram box and two 2-gram boxes.  In the second case, you can buy two 1-gram boxes and one 2-gram box.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Candy Store","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>As with City Tour, this problem is closely related to <a href=\"http://www.google.com/search?q=hamiltonian+cycle\" target=\"_blank\">Hamiltonian cycles</a>. The good news is that here, the graph consists only of points on a line, and is therefore much easier to analyze. The bad news is we aren't looking for just any Hamiltonian cycle, or even the shortest one; we are looking for one of a particular length. A question this precise requires a complete search of some kind.</p>\n\n<p>The simplest approach is to try all possible travel plans one at a time. This is much too slow for the large input, but it is fine for the small input.</p>\n\n<p>Given that <code>N &le; 30</code> throughout, you might next think to try a dynamic programming solution that tracks how far you have gone and which nodes you have visited so far. Unfortunately, this is also too slow - large values of <b>F</b> are a big problem!</p>\n\n<h3>A <code>3<sup>N</code> solution</h3>\n\n<p>The first key step to solving this problem is to go from <code>N!</code> time to <code>3<sup>N</sup></code> time.</p>\n\n<p>We first divide the line into intervals <code>I<sub>1</sub>, I<sub>2</sub>, ..., I<sub>N-1</sub></code>. Let <code>t<sub>j</sub></code> denote the number of times that the travel plan crosses interval <code>I<sub>j</sub></code>, and let <code>d<sub>j</sub></code> denote the length of interval <code>I<sub>j</sub></code>. Then the total length of the travel plan is exactly <code>t<sub>1</sub> * d<sub>1</sub> + t<sub>2</sub> * d<sub>2</sub> + ... + t<sub>N-1</sub> * d<sub>N-1</sub></code>. So this means that all we need to do is figure out what each <code>t<sub>j</sub></code> should be.</p>\n\n<p>The big question is what <code>t<sub>j</sub></code> values are possible? Well, let's take a look.</p>\n\n<ul>\n\n<li> Each <code>t<sub>j</sub></code> must be positive.<br/> <i>Reason:</i> If <code>t<sub>j</sub> = 0</code>, then the travel plan never crosses the corresponding interval, and therefore cannot visit every planet.</li>\n\n<li> For each <code>j</code>, <code>t<sub>j</sub> - t<sub>j-1</sub></code> must be -2, 0, or 2.<br/><i>Reason:</i> Let <code>P</code> denote the planet between the intervals <code>I<sub>j-1</sub></code> and <code>I<sub>j</sub></code>. In our travel plan, we can stop at <code>P</code> at most once. Every other time, we must travel through, which contributes 1 to both <code>t<sub>j-1</sub></code> and <code>t<sub>j</sub></code>. The one time we do hit the planet, we come in along one interval, and then leave along one interval. (These two intervals may or may not be the same.) This part of the travel plan contributes either (a) 1 to both <code>t<sub>j-1</sub></code> and <code>t<sub>j</sub></code>, or (b) 2 to one of these values, and 0 to the other. Regardless, <code>t<sub>j</sub> - t<sub>j-1</sub></code> must be -2, 0, or 2.</li>\n\n<li> <code>t<sub>0</sub></code> and <code>t<sub>N-1</sub></code> must both be 2. <br/><i>Reason:</i> Consider the \"outside interval\" <code>I<sub>-1</sub></code> that is past the furthest planets. The travel plan cannot traverse this interval, so <code>t<sub>-1</sub> = 0</code>. The observation here now follows immediately from the previous two.</li>\n\n<li> Every choice of <code>t<sub>j</sub></code> satisfying the previous conditions can be achieved by a legal travel plan.\n\n<br/><i>Reason:</i> We can construct such a travel plan by scanning from left to right across the intervals. At any given time during the construction, we will have decided  what the travel plan does to the left of some planet <code>P</code>. Specifically, for each trip left of <code>P</code>, we will know what the trip does until it goes right of <code>P</code> again. We will not however know what happens between these visits, or even what order they occur in.<br/>\nNow, suppose we want to extend our partial travel plan past the next interval <code>I<sub>j</sub></code>. If <code>t<sub>j</sub> = t<sub>j-1</sub> - 2</code>, then we need to merge two of our current trips via a stop to <code>P</code>, and extend the rest along <code>I<sub>j</sub></code>. If <code>t<sub>j</sub> = t<sub>j-1</sub> + 2</code>, then we add a new trip that goes along <code>I<sub>j</sub></code>, stops at <code>P</code>, and then goes back again. In the final case we just extend each trip along <code>I<sub>j</sub></code>, having one stop at <code>P</code> without changing direction.\n<br/>If you think about this for a while, you should be able to convince yourself that this method does indeed generate a valid travel plan.</li>\n\n</ul>\n\n<p>Okay! We can now describe a <code>3<sup>N</sup></code> time solution to the original problem. Given <code>t<sub>j-1</sub></code>, there are at most 3 possible choices for <code>t<sub>j</sub></code>. Trying each one in turn, we can iterate over all possible assignments for the <code>t<sub>j</sub></code>'s, and then pick the one that leads to the optimal length travel plan.</p>\n\n<h3>A <code>3<sup>N/2</code> solution</h3>\n\n<p>Even this <code>3<sup>N</sup></code> time algorithm is too slow however. Fortunately, there is a very handy trick for situations like this.</p>\n\n<p>Let's consider the middle interval <code>I<sub>N/2</sub></code> and some fixed value for <code>t<sub>N/2</sub></code>. Using the approach described above, we can enumerate in <code>3<sup>N/2</sup></code> time all choices for <code>t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>N/2-1</sub></code> that are consistent with <code>t<sub>N/2</sub></code>. Let <b>A</b> be the set of all possible values <code>t<sub>1</sub> * d<sub>1</sub> + t<sub>2</sub> * d<sub>2</sub> + ... + t<sub>N/2</sub> * d<sub>N/2</sub></code> that can be achieved in this way.</p>\n\n<p>Similarly, we can calculate <b>B</b>, the set of all possible values of <code>t<sub>N/2+1</sub> * d<sub>N/2+1</sub> + t<sub>N/2+2</sub> * d<sub>N/2+2</sub> + ... + t<sub>N-1</sub> * d<sub>N-1</sub></code> that are consistent with <code>t<sub>N/2</sub></code>. All this takes <code>3<sup>N/2</sup></code> time. What's left is to find two numbers in <b>A</b> and <b>B</b> whose sum is as close as possible to <b>F</b> without exceeding it. One efficient way to do this is to sort <b>B</b>, and then for each element in <b>A</b>, use binary search to decide which element in <b>B</b> you should try matching it with. That gives a O(3<sup>N/2</sup> * N) solution.\n</p>\n<p>\nThis can be improved to O(3<sup>N/2</sup>) by rearranging the formula a little: <code>t<sub>1</sub> * (d<sub>1</sub> + ... + d<sub>N/2</sub>) + (t<sub>2</sub> - t<sub>1</sub>) * (d<sub>2</sub> + ... + d<sub>N/2</sub>) + ... + (t<sub>N/2</sub> - t<sub>N/2-1</sub>) * d<sub>N/2<sub></code>. The list of these sums can be generated in sorted order iteratively by repeated merging while adding new terms. The difference <code>t<sub>j+1</sub> - t<sub>j</sub></code> is always one of -2, 0, 2, so we need to merge 3 sorted lists to add a new term.\n</p>\n<p>\nWhen we have the two lists <b>A</b> and <b>B</b> in sorted order, we can process them in linear time with a single scan using two pointers.\n</p>\n","id":"000000000043315c","statement":"<h3>Problem</h3>\n<p>\nIn a yet-to-be-announced and rechecked discovery by Antarctic astronomers, it is written that there are <b>N</b> inhabited planets in space, all lying along the same straight line, with the <b>i</b>-th planet lying at coordinate <b>X</b><sub><b>i</b></sub> along the line (<b>i</b> = 1, 2, ..., <b>N</b>). Earth is the first planet, lying at coordinate zero, so <b>X</b><sub>1</sub> will always be equal to 0.\n</p>\n<p>\nBeing very excited about this fact, you start planning a trip to visit all the planets. Since unknown planets can be dangerous, you want to visit each planet exactly once before returning to Earth. You have <b>F</b> units of fuel, and you want to spend as much of it on this trip as possible so that your final landing on Earth is safer. Your spaceship is pretty basic and can only fly along a straight line from any planet <b>i</b> to any other planet <b>j</b>, consuming |<b>X</b><sub><b>i</b></sub>-<b>X</b><sub><b>j</b></sub>| units of fuel along the way. It can't turn without landing.\n</p>\n<p>\nSo you need to create a travel plan that requires at most <b>F</b> units of fuel, starts from Earth, visits each of the other planets exactly once, and then returns to Earth. If there are several such plans, you should find the one that consumes most fuel. Output the amount of fuel consumed.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case description starts with a line containing the number of planets <b>N</b>. The next line contains <b>N</b> numbers <b>X</b><sub><b>i</b></sub>, the coordinates of the planets. The next line contains the amount of fuel <b>F</b> that you have.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing either \"Case #x: NO SOLUTION\", when there's no such travel plan, or \"Case #x: y\", where x is the case number (starting from 1) and y is the maximum amount of fuel consumed.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>F</b> &le; 10<sup>17</sup>.<br/>\n-10<sup>15</sup> &le; <b>X</b><sub>i</sub> &le; 10<sup>15</sup>.<br/>\n<b>X</b><sub>1</sub>=0.<br/>\nAll <b>X</b><sub>i</sub> are different.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n2 &le; <b>N</b> &le; 10.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 20.<br/>\n2 &le; <b>N</b> &le; 30.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n0 10 -10\n40\n5\n0 1 2 3 4\n13\n5\n0 1 2 3 4\n7\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 40\nCase #2: 12\nCase #3: NO SOLUTION\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":3},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Travel Plan","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043324a","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2010"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
