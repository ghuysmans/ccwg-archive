{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1494693000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201900","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  This year's Round 2 started off with another tasty treat:\n  <i>Fresh Chocolate</i>, which asked contestants to work within rules set\n  down by a miserly chocolate factory owner. Some greedy insights and\n  case-based analysis were sufficient to solve the problem.\n  <i>Roller Coaster Scheduling</i> also had a greedy solution, but it was\n  much harder to get there! <i>Beaming With Joy</i> was about reducing a grid\n  of laser beams to a satisfiability problem, and <i>Shoot the Turrets</i> was\n  a challenging graph problem that involved an incremental series of matchings.\n  As usual, there was a substantial jump in difficulty between the Round 1s and\n  Round 2!\n</p><p>\n  This round was tougher than even the typical Round 2. Quite a few former\n  Round 3 advancers and finalists had trouble with the Large datasets of the\n  A and B problems, and C and D certainly weren't any simpler than those! D in\n  particular was quite tough, with only 19 correct Large solutions. Even the\n  Smalls of B through D were tricky in their own right.\n</p><p>\n  jsannemo was the first to obtain a perfect score, in\n  just under 1 hour and 44 minutes, and six more contestants (EgorKulikov, shik, fagu, krijgertje, Endagorion, and matthew99) followed with their own 100s.\n  Congratulations &mdash; that's no easy feat!\n  The top 500 cutoff turned out to be 37 points plus some speed (usually\n  A + B), and the top 1000 (T-shirt) cutoff was 25 points, or 23 points plus a <i>lot</i> of speed!\n</p><p>\n  Our top 1000 contestants in this round win this year's edition of the\n  coveted Code Jam T-shirt, and our top 500 advance to the even tougher Round\n  3 &mdash; the last online round before the World Finals! Even if you did not\n  advance or win a shirt, it is still quite an accomplishment to make it to\n  Round 2! And, of course, Distributed Round 1 will offer another\n  T-shirt opportunity, plus the chance to advance along the parallel\n  Distributed track. Don't miss it!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Problem A (Fresh Chocolate): Written and prepared by Pablo Heiber.\n</p><p>\n  Problem B (Roller Coaster Scheduling): Written and prepared by Pablo Heiber.\n</p><p>\n  Problem C (Beaming With Joy): Written by Pablo Heiber. Prepared by Pablo\n  Heiber and Ian Tullis.\n</p><p>\n  Problem D (Shoot the Turrets): Written by Onufry Wojtaszczyk. Prepared by\n  Karol Pokorski.\n</p><p>\n  Solutions and other problem preparation and review by Ahmed Aly, Shane Carr,\n  John Dethridge, Minh Doan, Jackson Gatenby, Md Mahbubul Hasan, Brian\n  Hirashiki, Andy Huang, Lalit Kundu, Zhusong Li, Wei Liu, Alex Meed, Petr\n  Mitrichev, Trung Thanh Nguyen, and Josef Ziegler.\n</p><p>\n  All analyses by Pablo Heiber.\n</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1494684000000,"tasks":[{"analysis":"<h2>Fresh Chocolate: Analysis</h2>\n\n<p>\nThe main initial observation to have is that the group sizes are only important\n<a href=\"https://en.wikipedia.org/wiki/Modular_arithmetic\">modulo</a> <b>P</b>.\nThen, we can just take the smallest possible equivalent size for each group, and further assume\nthat all of them are within the range [1,<b>P</b>]. Moreover, you may find it easier to map them\nall to the range [0,<b>P</b>-1], using the modulo operation, as long as you don't mind working with\n0, which is not a real group size.\n</p><p>\nWe can see now that a test case with <b>P</b>=2 can be described\nby 2 integers: the number of groups with odd size, and the number of groups with even size.\nSimilarly, each test case can be described by a tuple of exactly <b>P</b> integers\na<sub>0</sub>, a<sub>1</sub>, ..., a<sub><b>P</b>-1</sub>, where a<sub>i</sub> is the\nnumber of groups of size equal to i modulo <b>P</b>.\n</p><p>\nThe groups counted in a<sub>0</sub>, i.e., those with a group size multiple of <b>P</b>, are the\nsimplest. No matter when they are brought in for the tour, the number of leftovers after they\nare given chocolate is the same as before. Therefore, their position won't change how many of the\nother groups get all fresh chocolate. This implies that it's always optimal to greedily choose a\nposition for them where they get all fresh chocolate, and that we can accomplish that by putting\nthem all at the beginning. Since the starting group gets fresh chocolate, a stream of groups with\nsizes that are multiples of <b>P</b> will all get fresh chocolate and will leave no leftovers for\nthe next group. That is, we can solve the problem disregarding a<sub>0</sub>, and then add\na<sub>0</sub> to the result. After this simplification, there are only <b>P</b>-1 numbers left to\nconsider.\n</p>\n<h3>Small dataset</h3>\n<p>\nFor the Small dataset, there are only two possible values for <b>P</b>, so we can consider them\nseparately.\n</p><p>\nFor <b>P</b>=2, there is only one number to consider: a<sub>1</sub>. Since all groups are\nequivalent, there are no decisions to be made.\nAll odd-sized groups will alternate between getting all fresh chocolate and getting a leftover\npiece. Since the last group will get fresh chocolate if there is an odd number of such groups,\nthe number of groups that get fresh chocolate is ceiling(a<sub>1</sub> / 2).\n</p><p>\nFor <b>P</b>=3, there are two numbers to consider: a<sub>1</sub> and a<sub>2</sub>. Intuitively,\nwe should pair each 1-person group with a 2-person group to go back to having no leftovers as\nsoon as possible, and that's indeed optimal: start with an alternation of\nmin(a<sub>1</sub>, a<sub>2</sub>) pairs, where we get min(a<sub>1</sub>, a<sub>2</sub>) added\nto our result, and then add pairs, of which min(a<sub>1</sub>, a<sub>2</sub>) will get all fresh\nchocolate. Then add all the remaining M = |a<sub>1</sub> - a<sub>2</sub>| groups (all\nof size 1 or 2 modulo <b>P</b>, depending on which type had more to begin with). Of those,\nceiling(M / 3) will get all fresh chocolate. This last calculation is similar to what we saw for\nodd-sized groups for <b>P</b> = 2. We will prove the optimality of this strategy below.\n</p>\n<h3>Large dataset</h3>\n<p>\nThe remaining <b>P</b>=4 case is a bit more complicated than just combining our insights from the\n<b>P</b>=2 and <b>P</b>=3 cases. To formalize our discussion, and to prove the correctness of our\nSmall algorithm, we will introduce some names. Let us\ncall a group fresh if it is given all fresh chocolate, and not fresh if it gets at least one\nleftover piece.\nAlso, we will call a group with a number of people equal to k modulo <b>P</b> a \"k-group\".\n</p><p>\nGiven some fixed arrival order, let us partition it into blocks, where each block is an interval of\nconsecutive groups that starts with a fresh group and doesn't contain any other fresh groups.\nThat is, we start a new block right before each fresh group. The problem is now equivalent to\nfinding the order that maximizes the number of blocks. A group is fresh if and only if the sum\nof all people in the groups that preceded it is a multiple of <b>P</b>. This implies that\nreordering within a block won't make any other blocks invalid, so it won't make a solution worse\n(although it could improve it by partitioning a block into more than one block). Also notice that,\nwith the possible exception of the last block, reordering blocks also doesn't alter the optimality\nof a solution.\n</p><p>\nSuppose we have an optimal ordering of the groups, disregarding 0-groups as we mentioned above.\nFirst, we can see that if a block contains a k-group and a different (<b>P</b>-k)-group, then\nit only contains those two: otherwise, we can reorder the block putting the two named groups\nfirst, and since the sum of people of the two groups is a multiple of <b>P</b>, that partitions\nthe block further, which means the original solution is not optimal. Second, let us show that it\nis always optimal to pair a k-group with a (<b>P</b>-k)-group into a block. Assume an\noptimal order with a maximal number of blocks consisting of a k-group and a (<b>P</b>-k)-group.\nThen, suppose there is\na k-group in a block A with no (<b>P</b>-k)-group and a (<b>P</b>-k)-group in a block B with no\nk-group. We can build another solution by making a new block C consisting of the k-group from\nblock A and the (<b>P</b>-k)-group from block B, and another block D consisting of the union of the\nremaining elements of blocks A and B.\nIf D doesn't sum up to a multiple of <b>P</b>, that implies that either A or B didn't to begin with,\nso we can just place D at the end in place of the one that didn't.\nC can be placed anywhere in the solution. This\nmakes a solution with an additional pair that is also optimal, which contradicts the assumption\nthat a k-group and a (<b>P</b>-k)-group existed in separate blocks.\nThis proves that, for <b>P</b>=3, it\nis always optimal to pair 1-groups and 2-groups as we explained above.\n</p><p>\nFor <b>P</b>=4, the consequence of the above theorem is that we should pair 2-groups with\nthemselves as much as possible and 1-groups with 3-groups as much as possible. This leaves at\nmost one 2-group left, and possibly some 1-groups or 3-groups left over, but not both. Since we need\nfour 1-groups or four 3-groups to form a non-ending block, and we can use a 2-group to form a\nnon-ending block with only two additional groups of either type, it is always optimal to place\nthe 2-group first, and then whatever 1-groups or 3-groups may be left.\nOverall, the solution for <b>P</b>=4 is a<sub>0</sub> as usual (singleton blocks of 0-groups),\nplus floor(a<sub>2</sub> / 2) (blocks of two 2-groups),\nplus min(a<sub>1</sub>, a<sub>3</sub>) (blocks of a 1-group and a 3-group), plus\nceiling((2 &times; (a<sub>2</sub> mod 2) + |a<sub>1</sub> - a<sub>3</sub>|) / 4) (the leftover\nblocks at the end).\n</p><p>\nNotice that even though the formality of this analysis may be daunting, it is reasonable to arrive\nat the solution by intuition, and the code is really short. If you have a candidate solution but\nyou find it hard to prove, you can always compare it against a brute force solution for small\nvalues of N to get a little extra assurance. Or there is also ...\n</p>\n<h3>A dynamic programming solution</h3>\n<p>\nThe insight that a case is represented by a <b>P</b>-uple is enough to enable a standard dynamic\nprogramming solution for this problem. Use <b>P</b>-uples and an additional integer\nwith the number of leftovers as current state, and recursively try which type of group to place\nnext (there are only <b>P</b> alternatives). Memoizing this recursion is fast enough, as the domain\nis just the product of all integers in the initial tuple, times <b>P</b>.\nWhen the group types' sizes are as close to one another as possible, we get the largest possible\ndomain size, which is (<b>N</b>/<b>P</b>)<sup><b>P</b></sup> &times; <b>P</b>.\nConsidering the additional iteration over\n<b>P</b> possibilities to compute each value, the overall time complexity of this approach is\nO((<b>N</b>/<b>P</b>)<sup><b>P</b></sup> &times; <b>P</b><sup>2</sup>). Even for the largest case,\nthis is almost instant in a fast language, and gives plenty of wiggle room to memoize with\ndictionaries and use slower languages. A purposefully non-optimized implementation in Python takes\nat most half a second to solve a case in a modern machine, so it finishes 100\ncases with a lot of time to spare. Moreover, just noticing that groups of size multiple of <b>P</b>\ncan optimally be placed first makes the effective value of <b>P</b> be one less, which greatly\nimproves speed and makes the solution solve every test case instantly.\n</p>\n","id":"00000000002017f4","statement":"<h3>Problem</h3>\n<p>\n  You are the public relations manager for a chocolate manufacturer.\n  Unfortunately, the company's image has suffered because customers think the\n  owner is cheap and miserly. You hope to undo that impression by offering a\n  free factory tour and chocolate tasting.\n</p><p>\n  Soon after starting the new project, you realized that the company owner's\n  reputation is well-deserved: he only agreed to give away free chocolate if\n  you would minimize the cost. The chocolate to be given away comes in packs of\n  <b>P</b> pieces. You would like to open new packs for each tour group, but\n  the owner insists that if there are leftover pieces from one group, they must\n  be used with the next tour group before opening up any new packs.\n</p><p>\n  For instance, suppose that each pack contains <b>P</b>=3 pieces, and that a\n  tour group with 5 people comes. You will open two packs to give one piece to\n  each person, and you will have one piece left over. Suppose that after that,\n  another tour group with 6 people comes. They will receive the leftover piece,\n  and then you will open two more packs to finish giving them their samples,\n  and so you will have one piece left over again. If two groups with 4 people\n  each come right after, the first of those will get the leftover piece plus a\n  full pack, and the last 4 person group will get their pieces from two newly\n  opened packs. Notice that you cannot open new packs until all leftovers have\n  been used up, even if you plan on using all of the newly opened pack\n  immediately.\n</p><p>\n  In the example above, 2 out of the 4 groups (the first and last groups) got\n  all of their chocolate from freshly opened packs. The other 2 groups got some\n  fresh chocolate and some leftovers. You know that giving out leftovers is not\n  the best way to undo the owner's miserly image, but you had to accept this\n  system in order to get your cheap boss to agree to the project. Despite the\n  unfavorable context, you are committed to doing a good job.\n</p><p>\n  You have requests from <b>N</b> groups, and each group has specified the\n  number of people that will come into the factory. Groups will come in one at\n  a time. You want to bring them in in an order that maximizes the number of\n  groups that get only fresh chocolate and no leftovers. You cannot reject\n  groups, nor have a group get chocolate more than once, and you need to give\n  exactly one piece to each person in each group.\n</p><p>\n  In the example above, if instead of 5, 6, 4, 4, the order were 4, 5, 6, 4, a\n  total of 3 groups (all but the 5 person group) would get only fresh chocolate.\n  For that set of groups, it is not possible to do better, as no arrangement\n  would cause all groups to get only fresh chocolate.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case consists of two lines. The first\n  line contains two integers <b>N</b>, the number of groups coming for a tour,\n  and <b>P</b>, the number of pieces of chocolate per pack. The second line\n  contains <b>N</b> integers <b>G<sub>1</sub></b>, <b>G<sub>2</sub></b>, ...,\n  <b>G<sub>N</sub></b>, the number of people in each of the groups.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the number of groups that will receive only fresh chocolate if you bring\n  them in in an order that maximizes that number.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>N</b> &le; 100.<br/>\n  1 &le; <b>G<sub>i</sub></b> &le; 100, for all i.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n  2 &le; <b>P</b> &le; 3.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 40 seconds.<br/>\n  2 &le; <b>P</b> &le; 4.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 3\n4 5 6 4\n4 2\n4 5 6 4\n3 3\n1 1 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 4\nCase #3: 1\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Sample Case #1 is the one explained in the statement. Besides the possible\n  optimal order given above, other orders like 6, 5, 4, 4 also maximize the\n  number of groups with only fresh chocolate, although the groups that get the\n  fresh chocolate are not necesarily the same. Notice that we only care about\n  the number of groups that get the best experience, not the total number of\n  people in them.\n</p><p>\n  In Sample Case #2, the groups are the same as in Case #1, but the packs\n  contain two pieces each. In this case, several ways of ordering them &mdash;\n  for instance, 4, 4, 6, 5 &mdash; make all groups get only fresh chocolate.\n</p><p>\n  In Sample Case #3, all groups are single individuals, and they will all eat\n  from the same pack. Of course, only the first one to come in is going to get\n  a freshly opened pack.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Fresh Chocolate","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Roller Coaster Scheduling: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  There are various ways to solve the Small dataset; for instance, it can be\n  reduced to a\n  <a href=\"https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem\">flow problem</a>.\n  It is also possible to find a greedy strategy or even a formula: the number\n  of rides needed is max(number of tickets for customer 1, number of tickets\n  for customer 2, number of tickets with seat 1), and the number of promotions\n  needed is max(0, (maximum among counts of i-th seat among all tickets) -\n  number of rides needed). However, these strategies are tricky to prove. The\n  rest of our analysis will shed some light on why they work.\n</p>\n<h3>Large dataset</h3>\n<p>\n  To solve the Large dataset, we can start with observations similar to those\n  in the Small case: the number of tickets held by any one person is a lower\n  bound on the number of total rides, and so is the number of tickets for position\n  1. This is because the set of tickets held by any one person, and the set of tickets\n  for position 1, share the property that no two tickets in the set can be honored\n  in the same ride, even with promotions. An extension of this is that for the set of\n  all tickets for positions 1, 2, ..., K, at most K of them can be honored by a single\n  ride (possibly using promotions). This means that, if S<sub>K</sub> is the number of\n  tickets for positions up to and including K, ceil(S<sub>K</sub> / K) is also a lower\n  bound on the final number of rides.\n</p><p>\n  It is not difficult to see this when there is only one ticket per customer: if the\n  maximum of all those lower bounds is R, for as long as there is some position P such\n  that there are more than R tickets for position P, we can promote any ticket for position\n  P to some previous position that has less than R tickets assigned, which is guaranteed\n  to exist due to the R &ge; ceiling(S<sub>P</sub> / P).\n  After that, no position is assigned more than R tickets. Since there are no repeated\n  customers, we can just grab one ticket for each position that has tickets remaining and\n  assign them to a ride until there are no more left. This will yield an assignment with\n  exactly R rides, and we proved above that there can't be less than R.\n</p><p>\n  When there are customers holding more than one ticket, our greedy assignment in the last\n  step above might fail. We can still prove that there is an assignment that works with a bit\n  of mathematical modeling. Consider a fixed ride plan. Let us define the ride plan matrix as a\n  square matrix of side S = max(<b>N</b>,<b>C</b>).\n  The first <b>C</b> rows represent customers and the first <b>N</b> columns represent positions.\n  The remaining rows or columns represent fake customers or positions, whose role will be clear\n  in a moment. For each ride in the plan, we construct a one-to-one assignment of customers\n  and positions. Customers that participate in the ride are assigned to their position on it.\n  Customers that do not are assigned to\n  empty positions or fake positions. If there are more positions than customers, each empty\n  position is assigned a fake customer. Then, the value of a given cell of the ride plan matrix\n  is the number of times the represented customer was assigned to the represented position.\n  Notice that the value is an upper bound on the number of times a customer actually rode in the\n  position, but not the exact number.\n</p><p>\n  Notice that for any ride plan consisting of R rides, its ride plan matrix will have\n  rows and columns that sum up to R. This is because for each ride, there is exactly one cell\n  per row and one cell per column that gets a 1 added to it.\n  The most interesting realization is that we can go the other way: for any matrix M such that\n  all its rows and columns add up to R, there is a ride plan consisting of R rides such that M\n  is a ride plan matrix for it. The proof is a simple variation on the\n  <a href=\"https://en.wikipedia.org/wiki/Doubly_stochastic_matrix#Birkhoff_polytope_and_Birkhoff.E2.80.93von_Neumann_theorem\">Birkhoffâ€“von Neumann theorem</a>,\n  which implies a matrix with that property can be expressed as a sum of\n  <a href=\"https://en.wikipedia.org/wiki/Permutation_matrix\">permutation matrices</a>,\n  and each permutation matrix corresponds to a possible ride.\n</p><p>\n  A given set of tickets can also be represented by a matrix of side S by having a cell contain the\n  number of tickets a given cusotmer holds for a given position. Let us say that a matrix M is\n  less than or equal to another matrix M', if and only if the cell at row i and column j in M is\n  less than or equal to that the value of the cell at row i and column j in M'. After promotions,\n  we need the matrix representing the tickets to be less than or equal to the ride plan matrix.\n</p><p>\n  Notice now that the greedy promotion algorithm presented in the second paragraph of this\n  section, actually yields a ticket matrix such that no row or column exceeds the established\n  lower bound R, even if there is more than one ticket per customer. The proof is exactly the\n  proof above. What was missing before was a way to know that set of tickets could be turned\n  into an actual ride plan in the case where there is more than one ticket per customer.\n  We now have such a way, which means the originally naive solution is actually a full solution\n  for the problem. Moreover, since we need to report the minimum number of promotions and not\n  the promotions themselves, we can just add S<sub>P</sub> - R for each position P such that\n  S<sub>P</sub> &gt; R, and we are done.\n</p>\n","id":"0000000000201845","statement":"<h3>Problem</h3>\n<p>\n  You created a new roller coaster that is about to open. Its train consists of\n  a single row of <b>N</b> seats numbered 1 through <b>N</b> from front to\n  back. Of course, seats closer to the front are more valuable. Customers have\n  already purchased opening-day tickets. Each ticket allows a specific customer\n  to take one ride on the coaster in a particular seat. Some customers may\n  have bought more than one ticket, and they expect to go on one ride for each\n  ticket.\n</p><p>\n  You need to decide how many roller coaster rides there will be on opening\n  day. On each ride, one customer can sit in each seat; some seats on a ride\n  might be left empty. You cannot assign a customer to more than one seat in\n  the same ride, nor can you put two customers on the same seat in any given\n  ride.\n</p><p>\n  You wish to minimize the number of rides required to honor all tickets, to\n  reduce operational costs. To reduce the required number of rides, you can\n  <i>promote</i> any number of tickets. Promoting a ticket means taking a\n  customer's ticket and giving that customer a new ticket for a seat closer to\n  the front of the train (that is, a seat with a lower number). You would\n  prefer to promote as few tickets as possible, since too many promotions\n  might cause customers to get greedy and ask for more promotions in the\n  future.\n</p><p>\n  Given the positions and buyers of all the tickets that have been sold, what\n  is the minimum number of rides needed to honor all tickets, using as many\n  promotions as needed and scheduling the rides optimally? And what is the\n  minimum number of ticket promotions necessary to attain that number of rides?\n  Note that promoting a given customer on a given ride from seat 4 to seat 2,\n  for example, counts as only one promotion, not two separate ones.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case starts with a single line with\n  three integers <b>N</b>, the number of seats in the roller coaster, <b>C</b>,\n  the number of potential customers, and <b>M</b>, the number of tickets sold.\n  The customers are identified with numbers between 1 and <b>C</b>. Then,\n  <b>M</b> lines follow, each containing two integers: <b>P</b><sub>i</sub>,\n  the position in the roller coaster assigned to the i-th ticket, and\n  <b>B</b><sub>i</sub>, the identifier of the buyer of that ticket.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y z</code>,\n  where <code>x</code> is the test case number (starting from 1),\n  <code>y</code> is the minimum number of rides you need to honor all tickets\n  if you use the promotions and schedule the rides optimally, and\n  <code>z</code> is the minimum number of promotions you need to make be able\n  to honor all tickets with <code>y</code> rides.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>N</b> &le; 1000.<br/>\n  1 &le; <b>M</b> &le; 1000.<br/>\n  1 &le; <b>P</b><sub>i</sub> &le; <b>N</b>.<br/>\n  1 &le; <b>B</b><sub>i</sub> &le; <b>C</b>.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  <b>C</b> = 2.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n  2 &le; <b>C</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2 2 2\n2 1\n2 2\n2 2 2\n1 1\n1 2\n2 2 2\n1 1\n2 1\n1000 1000 4\n3 2\n2 1\n3 3\n3 1\n3 3 5\n3 1\n2 2\n3 3\n2 2\n3 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1 1\nCase #2: 2 0\nCase #3: 2 0\nCase #4: 2 1\nCase #5: 2 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  Note that the last two sample cases would not appear in the Small dataset.\n</p><p>\n  In Case #1, both customers purchased a ticket for position 2. It is\n  impossible to honor both tickets with a single ride, but promoting either\n  ticket to position 1 allows you to accommodate both tickets on the same\n  round.\n</p><p>\n  Case #2 is a similar story, except both tickets are for position 1. Since you\n  cannot promote those tickets or exchange them for inferior tickets, you are\n  forced to run 2 separate rides, one per customer.\n</p><p>\n  Case #3 features the same customer purchasing both positions. Since you are\n  forced to have 2 rides for that customer, there is no reason to give out any\n  promotions.\n</p><p>\n  In Case #4, notice that there may be both customers and positions with no\n  tickets assigned. In this case, there are three tickets sold for position\n  three. If you promote customer 2 to position 2, for instance, you can have\n  one ride with customer 1 sitting in position 2 and customer 3 sitting in\n  position 3, and a second ride with customer 2 in position 2 and customer 1 in\n  position 3. Additional promotions will not allow you to decrease the number\n  of rides, because customer 1 has two tickets and you need to honor those in\n  different rides, regardless of position.\n</p><p>\n  In Case #5, one optimal solution is to promote one of the <code>3 1</code>\n  tickets to <code>1 1</code>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Roller Coaster Scheduling","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Beaming With Joy: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nThere are a lot of ways to solve the Small dataset. The most straightforward way is to use\ndynamic programming. Since the input contains no mirrors, each laser beam covers a set of non-wall\ncells that are either horizontally or vertically consecutive. Let us process the columns from left\nto right. For each row, we will keep track of its current status, which must be one of the\nfollowing:\n</p><ol>\n<li>It has an incoming beam, which originated in this row in a previously processed column and\n  was not yet blocked by a wall.</li>\n<li>It needs a beam &mdash; that is, there is at least one cell in this row from a previously\n  processed column that has not yet been covered by a beam, but could be (i.e. there is not a wall\n  in the way).</li>\n<li>It does not have nor it can receive a beam, because this would destroy a beam shooter pointing\n  vertically that we saw in this row in a previously processed column.</li>\n<li>None of the above. This means that all previous consecutive non-wall cells, if any, are\n  covered with vertical beams, so we can shoot horizontally on this row, but there is no obligation\n  yet to do so.</li>\n</ol><p>\nThere are some ways to refine this to fewer combinations, but it's not necessary. Then, we\ncan try all combinations of orientations for the beam shooters in the current column\nand see if that produces a valid status for the next column (there are more efficient\nways to do this part, but this will do). This requires a bit of casework: for each row, we have to\ncombine its incoming status with the current cell. The current cell can be one of five things: a\ncovered or uncovered empty cell, a vertical or horizontal beam shooter, or a wall.\nThen, since there are 4 possible states for each row,\nthe domain of our recursive function is of size 4<sup><b>R</b></sup> &times; <b>C</b> and\nthe calculation of each value in that domain requires checking up to 2<sup><b>R</b></sup>\ncombinations of beam shooters' orientations. Each such check requires a linear pass over the\n<b>R</b> cells, making the overall time complexity bounded by\nO(8<sup><b>R</b></sup> &times; <b>C</b> &times; <b>R</b>). It's not hard to come up with even\nsmaller bounds, given that many combinations of statuses are actually impossible.\n</p><p>\nThere is also a greedy Small solution that relies only on the absence of mirrors:\n</p><ol>\n<li>If a beam shooter can possibly destroy another, then point it the other way. If both\n  directions would destroy another beam shooter, then the case is impossible.</li>\n<li>If there are uncovered cells that can only be covered by a single non-yet-fixed shooter,\n  then point that shooter in its direction. If any remaining cells are impossible to cover\n  (because any beam shooters that may have pointed at it had to be fixed in the other direction),\n  then the case is impossible.</li>\n<li>Make all beam shooters that are not fixed yet shoot horizontally\n  (or all vertically, which also works).</li>\n</ol><p>\nThis works because if any cell remains uncovered after the first two steps, it can only be\nbecause there are exactly two remaining non-fixed beam shooters potentially pointing at it: one\nhorizontally, and one vertically. If there had been two or more beam shooters pointing at it in\nthe same direction, we would have already fixed all of them in step 1; if there had been only one\nbeam shooter in total, we would have fixed it in step 2. Then, choosing the same direction for all\nbeam shooters ensures that for all those cells, (exactly) one of the beam shooters is pointed in\nthe correct direction to cover that cell.\n</p>\n<h3>Large dataset</h3>\n<p>\nThe second solution presented above for the Small dataset hints at a possible generalization\nthat solves the Large dataset.\n</p><p>\nIn the Small, each cell is at an intersection of a horizontal line of consecutive non-wall cells,\nand a vertical line of consecutive non-wall cells. These lines of cells run between walls,\nbetween opposite grid boundaries, or between one wall and one grid boundary.\nEach of these lines of cells is characterized by having either\nno beam shooter (which forces each cell to be covered from the other direction in step 2),\none beam shooter (which leaves the cell on hold until step 3), or more than one (which forces\nall beam shooters on the line to point in the direction opposite to the line of cells in step 1).\nIn the Large, something similar happens, but instead of simple lines of cells, we have the more\ncomplicated notion of <i>paths</i>. A path is a set of pairs (c, d) where c is any\ncell that is empty or contains a beam shooter and d is either horizontal or vertical. A pair (c, d)\nand a different pair (c', d') are part of the same path if and only if a beam shooter placed\non cell c and pointing in direction d would produce a beam that, ignoring all other beam shooters,\nwould pass through cell c' in direction d'. As an example, the following picture illustrates\na grid with 9 paths.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U03oFWBEHjxCghKD6lTFPCrIgoXSONjuFIkhZm7MhEU7LN1J90uQfvcb0MnxctbpCnUm54/paths.png\"/>\n<p>\nNotice that the red and blue paths pass through the same set of empty cells,\nalthough the (cell, direction) pairs that make up those paths are different.\nAlso notice there is an orange path that passes\nthrough the same cell twice; that is, the path contains the pair (c, horizontal) and\nthe pair (c, vertical) where c is the rightmost empty cell in the bottom row.\nAlso notice how some paths may contain a single pair, like the turquoise, purple, and brown paths\nin the picture. Finally, some paths loop onto themselves, like the pink path in the picture,\nwhile other paths start and end at a wall or grid boundary. We call the former <i>loop paths</i>.\n</p><p>\nPaths that go through a number of beam shooters other than one have similar immediate consequences\nto lines of consecutive non-wall cells in the Small dataset. For convenience, let us\ndefine the opposite function o given by o(horizontal) = vertical and o(vertical) = horizontal.\n</p><ol>\n<li>If a path contains two pairs (c, d) and (c, o(d)) where c is a cell that contains a beam\n  shooter, the case is impossible, because that means that beam shooter will destroy itself when\n  pointed in either direction.</li>\n<li>If a loop path contains a pair (c, d) where c is a cell that contains a beam\n  shooter, the beam shooter must be fixed in direction o(d).</li>\n<li>If a path contains two or more pairs (c<sub>i</sub>, d<sub>i</sub>) where c<sub>i</sub>\n  contains a beam shooter, then beam shooter c<sub>i</sub> must be fixed in direction\n  o(d<sub>i</sub>).</li>\n<li>If there is no beam shooter on a path that contains\n  two pairs (c, d) and (c, o(d)) where c is an empty cell, the case is impossible\n  (as c cannot be covered).</li>\n<li>If there is no beam shooter on a path, then for each pair\n  (c<sub>i</sub>, d<sub>i</sub>) it contains: let p be the path containing\n  (c<sub>i</sub>, o(d<sub>i</sub>)). If p contains a single\n  pair (c, d) where c contains a beam shooter, then fix that beam shooter in direction d. If\n  p contains a number of beam shooters other than one, the case is impossible.\n</li>\n</ol><p>\nIf a beam shooter is required to be fixed in two different directions, by the same or different\nsteps, the case is impossible.\nThis is the generalization of steps 1 and 2 in the Small greedy solution. After applying\nthese, some cells may be left uncovered. As before, those cells are always in the intersection of\ntwo different paths, and those paths contain a single pair where the cell contains a beam shooter\neach. Unfortunately, the way to set the remaining beam shooters so that every cell is covered\nis not as simple as step 3 for the Small. This might start to look like a (non-bipartite) matching\nproblem, but it is not one!\n</p><p>\nIn the Small, after all the cases that directly fixed the direction of some beam shooter, each\nempty cell that remained uncovered could possibly be covered by two beam shooters, one on each\ndirection. The same is true in this case: for each empty cell c that remains uncovered\nthere are two different paths that contain the pairs (c, horizontal) and (c, vertical), and each\nof them passes through exactly one pair that contains a non-yet fixed beam shooter. Say those\ntwo pairs containing shooters are (s<sub>1</sub>, d<sub>1</sub>) and\n(s<sub>2</sub>, d<sub>2</sub>). Then, covering cell c requires us to either set s<sub>1</sub>\nin direction d<sub>1</sub> or s<sub>2</sub> in direction d<sub>2</sub>, or both. If it happens\nto be s<sub>1</sub> = s<sub>2</sub>, then it must be d<sub>1</sub> &ne; d<sub>2</sub>, and the\nrequirement is fullfilled by any assignment.\n</p><p>\nIf we assign logical variables to the shooters with the logical values true and false corresponding\nto the two directions, each of these restrictions is a\n<a href=\"https://en.wikipedia.org/wiki/Logical_disjunction\">disjunction</a> of two\n<a href=\"https://en.wikipedia.org/wiki/Literal_(mathematical_logic)\">literals</a>. Making all\nsuch disjunctions simulatenously true is, then, making their\n<a href=\"https://en.wikipedia.org/wiki/Logical_conjunction\">conjunction</a> true.\nFinding a truth assignment to variables to make a conjunction of disjunctions of up to two literals\neach true is a problem known as the\n<a href=\"https://en.wikipedia.org/wiki/2-satisfiability\">2-satisfiability problem</a> or 2SAT. We\ncan use known 2SAT algorithms to solve that problem and get an assignment for the variables, and\nthen translate that assignment back into an assignment of directions for the beam shooters.\n</p><p>\nThe greedy Small-only solution we presented is even simpler to prove correct under this\nlogic model: without mirrors, every disjunction has exactly one literal negated (because the\ncell requirement is for one beam shooter to be horizontal and/or some other beam shooter to be\nvertical), so assigning all variables a true value makes all disjunctions true thanks to the\nnon-negated literal, and also assigning them all a false value makes all disjunctions true\nthanks to the negated literal.\n</p><p>\nThis analysis is written in the order in which one might reason this problem step by step, without\nany huge leap at any single step. However, for some people it might be faster to have an aha\nmoment and notice that each cell yields a requirement on up to two beam shooters directly: cells\nwithout shooters imply a requirement on up to two shooters, one of each direction, to be true. If\nthere is only one of those, that can be encoded as a single-literal disjunction, or made it a\ntwo-literal disjunction by simply taking literal L and writing (L &or; L). Then, beam shooters\nthat possibly point at another beam shooter yield another single-literal disjunction forcing them\nto point the other way. This makes the first pass unnecessary and encodes all requirements\ninto the 2SAT instance, making the solution more concise.\n</p><p>\nThis problem lends itself to many greedy heuristics plus some kind of bruteforce or\nbacktracking. Notice that 2SAT itself can be solved in polynomial time by some\nbacktrackings and by a graph-theoretical algorithm that has many greedy decisions underneath (both\napproaches are mentioned in the Wikipedia article). So, many algorithms that don't explicitly use\nan algorithm for the 2SAT problem are actually correct because they are basically doing\nthe same thing without going through the modeling.\n</p>\n","id":"0000000000201876","statement":"<h3>Problem</h3>\n<p>\n  Joy is about to go on a long vacation, so she has hired technicians to\n  install a security system based on infrared laser beams. The technicians have\n  given her a diagram that represents her house as a grid of unit cells with\n  <b>R</b> rows and <b>C</b> columns. Each cell in this grid contains one of\n  the following:\n</p>\n<ul>\n  <li><code>/</code>: A two-sided mirror that runs from the cell's lower left\n    corner to its upper right corner.</li>\n  <li><code>\\</code>: A two-sided mirror that runs from the cell's upper left\n    corner to its lower right corner.</li>\n  <li><code>-</code>: A beam shooter that shoots horizontal beams out into the\n    cells (if any) to the immediate left and right of this cell.</li>\n  <li><code>|</code>: A beam shooter that shoots vertical beams out into the\n    cells (if any) immediately above and below this cell.</li>\n  <li><code>#</code>: A wall. (Note that the house is not necessarily\n    surrounded by a border of walls; this is one reason why Joy needs a\n    security system!)</li>\n  <li><code>.</code>: Nothing; the cell is empty.</li>\n</ul>\n<p>\n  Beams travel in straight lines and continue on through empty cells. When a\n  beam hits a mirror, it bounces 90 degrees off the mirror's surface and\n  continues. When a beam traveling to the right hits a <code>/</code> mirror,\n  it bounces off the mirror and starts traveling up; beams traveling up, left,\n  or down that hit a <code>/</code> mirror bounce off and travel right, down,\n  or left, respectively. The <code>\\</code> mirror behaves similarly: when a\n  beam traveling right, up, left or down hits it, it bounces off and starts\n  traveling down, left, up or right, respectively. When a beam hits a wall or\n  goes out of the bounds of the grid, it stops. It is fine for beams to cross\n  other beams, but if a beam hits any beam shooter (including, perhaps, the\n  beam shooter that originated the beam), that beam shooter will be destroyed!\n</p><p>\n  Joy wants to make sure that every empty cell in the house has at least one\n  beam passing through it, and that no beam shooters are destroyed, since that\n  would just be wasting money! Unfortunately, the technicians have already\n  installed the system, so the most Joy can do is rotate some of the existing\n  beam shooters 90 degrees. That is, for any number (including zero) of beam\n  shooters, she can turn <code>-</code> into <code>|</code> or vice versa.\n</p><p>\n  Can you find any way for Joy to achieve her goal, or determine that it is\n  impossible? Note that it is <i>not</i> required to minimize the number of\n  rotations of beam shooters.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with one line with two integers\n  <b>R</b> and <b>C</b>: the number of rows and columns in the grid\n  representing the house. Then, <b>R</b> lines of <b>C</b> characters each\n  follow; each character is <code>/</code>, <code>\\</code>, <code>-</code>,\n  <code>|</code>, <code>#</code>, or <code>.</code>, as described in the\n  statement.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is <code>IMPOSSIBLE</code> if Joy cannot accomplish her goal, or\n  <code>POSSIBLE</code> if she can. Then, if the case is possible, output the\n  same <b>R</b> lines of <b>C</b> characters each from the input grid, with\n  zero or more instances of <code>-</code> replaced by <code>|</code> or vice\n  versa.\n</p><p>\n  If there are multiple possible answers, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>C</b> &le; 50.<br/>\n  Each character in the grid is one of <code>/</code>, <code>\\</code>,\n  <code>-</code>, <code>|</code>, <code>#</code>, or <code>.</code>.<br/>\n  The number of <code>-</code> characters plus the number of <code>|</code>\n  characters (that is, the number of beam shooters) in the grid is between 1\n  and 100, inclusive.<br/>\n  There is at least 1 <code>.</code> character (that is, empty space) in the\n  grid.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  1 &le; <b>R</b> &le; 5.<br/>\n  There are no <code>/</code> or <code>\\</code> characters (that is, no\n  mirrors) in the grid.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>R</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n1 3\n-.-\n3 4\n#.##\n#--#\n####\n2 2\n-.\n#|\n4 3\n.|.\n-//\n.-.\n#\\/\n3 3\n/|\\\n\\\\/\n./#\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n#.##\n#||#\n####\nCase #3: POSSIBLE\n|.\n#|\nCase #4: POSSIBLE\n.-.\n|//\n.|.\n#\\/\nCase #5: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Note that the last 2 sample cases would not appear in the Small dataset.\n</p><p>\n  In Sample Case #1, if a beam shooter is positioned to shoot its beam into\n  the empty cell, it will necessarily destroy the other beam shooter. So the\n  case is <code>IMPOSSIBLE</code>.\n</p><p>\n  In Sample Case #2, the leftmost beam shooter must be rotated to cover the\n  empty cell. The rightmost beam shooter must also be rotated to avoid\n  destroying the leftmost beam shooter.\n</p><p>\n  In Sample Case #3, the existing beam shooters already cover all empty cells\n  with their beams and do not destroy each other, so outputting the grid from\n  the input would be acceptable. However, notice that the output that we have\n  given is also correct.\n</p><p>\n  In Sample Case #4, one acceptable solution is to rotate all three of the beam\n  shooters. However, note that the following would also be acceptable:\n</p>\n<code>\n  .-.<br/>\n  |//<br/>\n  .-.<br/>\n  #\\/<br/>\n</code>\n<p>\n  since it is not necessary for cells with mirrors to have a beam pass through\n  them. (Who would steal giant diagonal mirrors, anyway?)\n</p><p>\n  In Sample Case #5, the beam shooter would destroy itself no matter which\n  orientation Joy chooses for it, so the case is <code>IMPOSSIBLE</code>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Beaming With Joy","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Shoot the Turrets: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nThe first thing to notice is that, if a given soldier s is not the first to perform her task,\nthere is no reason for s to move at all until all soldiers that are to shoot a turret before s\nhave finished.\n</p><p>\nLet us call the output a strategy: a pairing between some soldiers and all turrets, in a specific\norder. Given a fixed strategy, we can check if it's viable with one\n<a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">BFS</a> per soldier, in order.\nWe stop with the first soldier that can't reach its assigned turret, if any, and report the\nnumber shot so far. Any strategy that shoots a maximum number of turrets can be extended to\na pairing of all soldiers to turrets, so this covers all possibilities. Besides the usual\nempty spaces and walls, we need to consider some empty spaces enterable but not exitable: the\nspaces that are in the line of sight of turrets that are to be destroyed by a soldier after the\ncurrent one. Each check takes time linear in the size of the map, so O(<b>R</b><b>C</b>) per\nsoldier.\n</p><p>\nUnfortunately, there can be too many strategies to bruteforce them. There can be up to 10! possible\npairings and 10! orderings, which means 10!<sup>2</sup> strategies, which is way too big, so we\nneed to do better. We will use precomputing to optimize the check and dynamic programming\nto optimize the strategy generation.\n</p><p>\nLet S be the number of soldiers and T the number of turrets.\nTo make the check faster, we can compute, for each soldier and each possible\nsubset of still-alive turrets, the set of reachable turrets to shoot. That requires at most\n2<sup>T</sup> &times; S BFSes like the ones mentioned above, for a total complexity of\nO(2<sup>T</sup> &times; S<b>R</b><b>C</b>), which is fine for the Small limits.\n</p><p>\nNow on to the dynamic programming: consider the function f(s, t)\nwhich finds a strategy that shoots a maximum number of turrets for a given set of remaining\nsoldiers s and a given set of remaining turrets t, or decides that there isn't one. Each of\ns and t can be represented with a binary string of up to S and T digits, respectively.\nThe domain of the function, then, is of size up to 2<sup>S+T</sup>. To compute the\nfunction, we can check every soldier against every reachable turret. Since that list is precomputed,\nthis takes at most S iterations over lists of length up to T. The overall computation of f, if\nmemoized, has a complexity of O(2<sup>S+T</sup> &times; ST), which again, finishes comfortably in\ntime under the Small limts.\n</p>\n\n<h3>Large dataset</h3>\n\n<p>\nFor the Large dataset, anything with exponential complexity seems doomed to fail, so we need to\ngo a different route. We will reuse the the BFS idea (to check out whether turrets are reachable)\nfrom the Small, but there are a lot of additional insights.\n</p><p>\nLet us build a <a href=\"https://en.wikipedia.org/wiki/Bipartite_graph\">bipartite graph</a>\nG with a node for each soldier and turret. G has an edge from\nsoldier s to turret t if and only if soldier s can destroy turret t after all other turrets have\nbeen destroyed. A single BFS starting from each soldier can build this graph.\nWe state the following: destroying R turrets is possible if and only if there is a\n<a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)\">matching</a>\nin G that covers R turrets. The only if part is trivial, as the conditions for edges in the\ngraph are a relaxation of the conditions for the pairing we need to construct as solution.\nWe concentrate on proving the if part. Moreover, we provide here a computably constructive\nproof, for which there is an efficient enough algorithm, meaning the proof is also an algorithm\nthat solves the problem.\n</p><p>\nFirst, if G is empty, the problem is solvable trivially by vacuity. For non-empty G,\nwe can use the\n<a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\">Ford-Fulkerson</a>\nalgorithm to find an initial maximum matching M of G of size R. We will further consider only\nthe soldiers present in M and ignore the others. From now on, we refer only to\nsoldiers matched by M, and we remove the unmatched soldier nodes from G.\nLet us define the graph G' with the same nodes as G, but an edge between soldier s and turret t\nonly exists in G' if s can destroy t with the other turrets active. Clearly, G' is a subgraph of G.\nThe <a href=\"https://en.wikipedia.org/wiki/Directed_graph#Indegree_and_outdegree\">outdegree</a> of\neach soldier node in M is at least 1. If an edge (s, t) in G does not exist\nin G', it is because some other turret t' is reachable by s and blocking the path to t. But then,\n(s, t') is in G'. Therefore, the outdegree of each soldier not in G' is at least 1.\n</p><p>\nConsider the graph H that is the union of G' plus the edges in M reversed.\nIf H contains an edge (s, t') where t' is a turret node not covered by M, let M' be equal to M, but\nreplacing (s, t) by (s, t'), where (s, t) was the edge covering s present in M. Of course, M' is\na maximum matching of G of the same size as M.\nIf there is no such edge in H, do the following: since H is a supergraph\nof G', the outdegree of each soldier node in H is at least 1. The inclusion of the\nreversed edges of M in H means the outdegree of all turret nodes matched in M in H is at least 1.\nTherefore, starting at any soldier and moving through edges in H, we will always encounter nodes\nwith outdegree 1 of soldiers and turrets covered by M, and eventually find a cycle of them.\nLet us call this cycle C. Notice that the edges going out of turrets in H are only the\nreversed edges from M, so C is necesarily an alternation of reversed edges from M and edges\nfrom G'. Consider a new matching M' of G consisting of the edges of M whose reverse is not in C,\nplus the edges in C whose reverse is not in M. That is, M' is M but exchanging the edges present\nin C in some direction. M' in this case is also a matching of G of the same size as M. If the cycle\nis of length 2, then M' ends up being exactly the same as M.\n</p><p>\nIn both cases, we constructed a new matching M' of the same size as M with the additional property\nthat at least one edge of M' is present in G'. Therefore, there are some\nedges in the matching that represent a number A &gt; 1 of actions that we can take now.\nSo, we can just take those A actions, remove all A used soldier nodes and A destroyed turret nodes,\nand we are left with a smaller graph which also has a maximum matching of size R - A\n(whatever is left of M'). Rinse and repeat until the graph is empty.\n</p><p>\n<b>Complexity analysis.</b> Building the original G takes time O(S<b>R</b><b>C</b>) for S BFSes,\nand the original matching takes time O((S+T)<sup>3</sup>) (there are faster algorithms for matching,\nbut Ford-Fulkerson is more widely known, simpler to code, and sufficient for this task).\nAfter that, we have at most T steps of altering the matching and removing some parts of it.\nEach of this steps requires building G', which takes time O(S<b>R</b><b>C</b>) for S BFSes,\nand after that, all steps are linear in the size of the graphs G, G' or H, which are all bounded by\nO((S+T)<sup>2</sup>). Notice that building G' is by far the slowest step, so you can use less\nefficient implementations to manipulate the graphs without altering the time complexity. This gives\nan overall complexity of O(TS<b>R</b><b>C</b> + (S+T)<sup>3</sup>). This is enough to solve the\nproblem, but it can be further refined by noticing each time we build G', the BFSes will reach the\nsame places or farther than in the previous step, so, if instead of restarting from scratch we\nremember the BFSes and continue from where we were stopped before, we can reduce the total time\nto build G' by a factor of T, down to O(S<b>R</b><b>C</b>), reducing the final complexity to\nO(S<b>R</b><b>C</b> + (S+T)<sup>3</sup>).\n</p>\n","id":"0000000000201901","statement":"<h3>Problem</h3>\n<p>\n  The fight to free the city from extraterrestrial invaders is over! People are\n  happy that love and peace have returned.\n</p><p>\n  The city is represented as a grid with <b>R</b> rows and <b>C</b> columns.\n  Some cells on the grid are buildings (through which nobody can see, nobody can\n  shoot, and nobody can walk), and some are streets (through which everybody can\n  see, shoot and walk). Unfortunately, during the war, the now-defeated\n  invaders set up automatic security turrets in the city. These turrets are only\n  in streets (not in buildings). They pose a threat to the citizens, but\n  fortunately, there are also some soldiers on the streets (not in buildings).\n  Initially, no soldier is in the same place as a turret.\n</p><p>\n  The invader turrets do not move. They are small, so they don't block sight and\n  shooting. A soldier cannot walk through an active turret's cell, but can walk\n  through it once it is destroyed. A turret can only see soldiers in the cells\n  for which it has a horizontal or vertical line of sight. If a soldier enters\n  such a cell, the turret does not fire. If a soldier attempts to exit such a\n  cell (after entering it, or after starting in that cell),\n  the turret fires. Luckily, a soldier can still shoot from that cell,\n  and the turret will not detect that as movement. It means that none of your\n  soldiers will actually die, because in the worst case they can always wait,\n  motionless, for help (perhaps for a long time). Maybe you will have a chance\n  to rescue them later.\n</p><p>\n  Each soldier can make a total of <b>M</b> unit moves. Each of these moves must\n  be one cell in a horizontal or vertical direction. Soldiers can walk through\n  each other and do not block the lines of sight of other soldiers or turrets.\n  Each soldier also has one bullet. If a soldier has a turret in her horizontal or vertical line\n  of sight, the soldier can shoot and destroy it. Each shot can only destroy one\n  turret, but the soldiers are such excellent shooters that they can even shoot\n  past one or several turrets or soldiers in their line of sight and hit another turret\n  farther away!\n</p><p>\n  You are given a map (with the soldier and turret positions marked). What is\n  the largest number of turrets that the soldiers can destroy?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test\n  cases, <b>T</b>.  <b>T</b> test cases follow. Each test case begins with a\n  line containing the integer <b>C</b> (the width of the map), <b>R</b> (the\n  height of the map) and <b>M</b> (the number of unit moves each soldier can\n  make). The next <b>R</b> lines contain <b>C</b> characters each,\n  with <code>.</code> representing a street, <code>#</code> representing a\n  building, <code>S</code> representing a soldier and <code>T</code>\n  representing a turret.\n</p>\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1)\n  and <code>y</code> is the maximum number of turrets that it is possible to\n  destroy. Then <b>y</b> lines should follow: each should contain two\n  integers <b>s_i</b> and <b>t_i</b> denoting that the <b>i</b>th thing that\n  happens should be soldier <b>s_i</b> destroying turret <b>t_i</b> (you don't\n  need to specify exactly how the soldier has to move). If multiple valid\n  strategies exist, you may output any one of them.\n</p>\n<p>\n  Soldiers are numbered from 1, reading from left to right along the top row,\n  then left to right along the next row down from the top, and so on, from top\n  to bottom.</p>\n<p>\n  Turrets use their own independent numbers, and are numbered starting from 1,\n  in the same way.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  0 &le; <b>M</b> &lt; <b>C</b> &times; <b>R</b>.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n  1 &le; <b>C</b> &le; 30.<br/>\n  1 &le; <b>R</b> &le; 30.<br/>\n  The number of <code>S</code> symbols is between 1 and 10.<br/>\n  The number of <code>T</code> symbols is between 1 and 10.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n  1 &le; <b>C</b> &le; 100.<br/>\n  1 &le; <b>R</b> &le; 100.<br/>\n  The number of <code>S</code> symbols is between 1 and 100.<br/>\n  The number of <code>T</code> symbols is between 1 and 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2 2 1\n#S\nT.\n2 6 4\n.T\n.T\n.T\nS#\nS#\nS#\n5 5 4\n.....\nSS#.T\nSS#TT\nSS#.T\n.....\n3 3 8\nS.#\n.#.\n#.T\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\n1 1\nCase #2: 3\n3 3\n1 1\n2 2\nCase #3: 3\n1 2\n2 1\n6 3\nCase #4: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Case #2, one of the possible solutions is to move soldier 3 up three\n  cells and shoot turret 3. Then soldier 1 can move up one cell and right one\n  cell (to where turret 3 was) and shoot past turret 2 to destroy turret 1.\n  Finally, soldier 2 can move up three cells and shoot turret 2.\n</p><p>\n  In Case #3, soldier 1 can move up one cell, then right three cells and\n  shoot turret 2. Then soldier 2 can move up one cell, then right three cells\n  and shoot turret 1. Finally, soldier 6 can move down one cell, then right\n  three cells and shoot turret 3. Other soldiers have insufficient move range\n  to shoot any other turrets.\n</p><p>\n  In Case #4, the soldier cannot move to within the same row or column as\n  the turret, so the turret cannot be destroyed.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Shoot the Turrets","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201900","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2017"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
