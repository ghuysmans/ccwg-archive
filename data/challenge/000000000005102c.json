{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1518888600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000005102c","is_practice_available":true,"my_user_type":0,"my_user_type__str":"NONE","recap":"<p>\n  Our 2018 I/O contest was our biggest yet! Over 800 contestants solved at least one\n  dataset and made it onto the scoreboard.\n</p><p>\n  <i>Burger Optimization</i> looked complex but turned out to have a relatively\n  straightforward solution. <i>CEO Search</i> could be solved in various ways, but\n  all of those required a key \"greedy\" insight and a sensible way to apply it.\n  <i>Centrists</i> could be solved by thinking through a small number of\n  possibilities. Our D problem is often much tougher than the others, and\n  <i>Tricky Trios</i> was no exception; it required probabilistic thinking and\n  careful casework. Only 10 contestants solved its Small dataset, which was indeed\n  tricky despite presenting only two new test cases, and only 6 solved the Large!\n</p><p>\n  <b>limli</b> was the first to reach a perfect score, around the halfway mark of\n  the contest. <b>mkirsche</b> and <b>crashethereum</b> followed up not too long\n  after that to take second and third place.\n</p><p>\n  Most contestants who made it into the top 150 did so by solving all of A, B,\n  and C with a penalty time less than 2 hours and 30 minutes. Congratulations to our\n  prize winners, and thanks to everyone for participating!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Problem A (Burger Optimization): Written by Pablo Heiber. Prepared by\n  Jonathan Irvin Gunawan.\n</p><p>\n  Problem B (CEO Search): Written by Ian Tullis. Prepared by Josef Ziegler.\n</p><p>\n  Problem C (Centrists): Written by Pablo Heiber. Prepared by Jonathan Irvin\n  Gunawan.\n</p><p>\n  Problem D (Tricky Trios): Written by Pablo Heiber. Prepared by Ian Tullis.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Lauren\n  Mancino Gallagher, Md Mahbubul Hasan, Emily Miller, Trung Thanh Nguyen,\n  Ray Robinson, and Mary Streetzel.\n</p>\n<p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Burger Optimization: Jonathan Irvin Gunawan</li>\n  <li>CEO Search, Centrists, Tricky Trios: Ian Tullis</li>\n</ul>\n","registration_gives_participant":false,"result_status":20,"result_status__str":"FULLY_VISIBLE","start_ms":1518879600000,"tasks":[{"analysis":"<h2>Burger Optimization: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  This dataset can be solved using complete search. Since <b>K</b> &le; 8, there\n  are only at most 8! = 40320 different orderings of ingredients.\n</p>\n<p>\n  Therefore, we can try all <b>K</b>! different orderings of ingredients and\n  find which ordering of ingredients has the minimum sum of squared differences\n  between each ingredient's optimal and actual distance-to-bun values. Since we\n  can calculate the sum of the squared differences between each ingredient's\n  optimal and actual distance-to-bun values for one particular ordering of\n  ingredients in O(<b>K</b>) time, this solution runs in\n  O(<b>K</b>! &times; <b>K</b>) time.\n</p>\n<h3>Large dataset</h3>\n<p>\n  We need an observation to solve this dataset. Suppose we have two ingredients\n  A and B to be placed at two positions X and Y. Let ingredients A and B have\n  optimal distance-to-bun values of D<sub>A</sub> and D<sub>B</sub>,\n  respectively, and let positions X and Y have actual distance-to-bun values of\n  D<sub>X</sub> and D<sub>Y</sub>, respectively. Suppose D<sub>A</sub> &le;\n  D<sub>B</sub> and D<sub>X</sub> &le; D<sub>Y</sub>. We claim that it is no\n  less optimal to put ingredient A at X and to put ingredient B at Y.\n</p>\n<p>\n  Why? Let us assume that D<sub>B</sub> = D<sub>A</sub> + K<sub>1</sub> and\n  D<sub>Y</sub> = D<sub>X</sub> + K<sub>2</sub> for some non-negative integers\n  K<sub>1</sub> and K<sub>2</sub>. Therefore, the cost of putting ingredient A\n  at X and putting ingredient B at Y is\n  (D<sub>A</sub> - D<sub>X</sub>)<sup>2</sup>\n  + (D<sub>B</sub> - D<sub>Y</sub>)<sup>2</sup>, and the cost of putting\n  ingredient A at Y and putting ingredient B at X is\n  (D<sub>A</sub> - D<sub>Y</sub>)<sup>2</sup>\n  + (D<sub>B</sub> - D<sub>X</sub>)<sup>2</sup>.\n</p>\n<p>\n  We can derive that\n</p>\n      [(D<sub>A</sub> - D<sub>X</sub>)<sup>2</sup>]\n      + [(D<sub>B</sub> - D<sub>Y</sub>)<sup>2</sup>]\n<br/>= [D<sub>A</sub><sup>2</sup>\n        - 2D<sub>A</sub>D<sub>X</sub>\n        + D<sub>X</sub><sup>2</sup>]\n      + [D<sub>B</sub><sup>2</sup>\n        - 2D<sub>B</sub>D<sub>Y</sub>\n        + D<sub>Y</sub><sup>2</sup>]\n<br/>= [D<sub>A</sub><sup>2</sup>\n        - 2D<sub>A</sub>D<sub>X</sub>\n        + D<sub>X</sub><sup>2</sup>]\n      + [D<sub>B</sub><sup>2</sup>\n        - 2(D<sub>A</sub> + K<sub>1</sub>)(D<sub>X</sub> + K<sub>2</sub>)\n        + D<sub>Y</sub><sup>2</sup>]\n<br/>= [D<sub>A</sub><sup>2</sup>\n        - 2D<sub>A</sub>D<sub>X</sub>\n        + D<sub>X</sub><sup>2</sup>]\n      + [D<sub>B</sub><sup>2</sup>\n        - 2D<sub>A</sub>D<sub>X</sub>\n        - 2D<sub>A</sub>K<sub>2</sub>\n        - 2K<sub>1</sub>D<sub>X</sub>\n        - 2K<sub>1</sub>K<sub>2</sub>\n        + D<sub>Y</sub><sup>2</sup>]\n<br/>= [D<sub>A</sub><sup>2</sup>\n        - 2D<sub>A</sub>D<sub>X</sub>\n        - 2D<sub>A</sub>K<sub>2</sub>\n        + D<sub>Y</sub><sup>2</sup>]\n      + [D<sub>B</sub><sup>2</sup>\n        - 2D<sub>A</sub>D<sub>X</sub>\n        - 2K<sub>1</sub>D<sub>X</sub>\n        + D<sub>X</sub><sup>2</sup>]\n      - [2K<sub>1</sub>K<sub>2</sub>]\n<br/>= [D<sub>A</sub><sup>2</sup>\n        - 2D<sub>A</sub>(D<sub>X</sub> + K<sub>2</sub>)\n        + D<sub>Y</sub><sup>2</sup>]\n      + [D<sub>B</sub><sup>2</sup>\n        - 2(D<sub>A</sub> + K<sub>1</sub>)D<sub>X</sub>\n        + D<sub>X</sub><sup>2</sup>]\n      - [2K<sub>1</sub>K<sub>2</sub>]\n<br/>= [D<sub>A</sub><sup>2</sup>\n        - 2D<sub>A</sub>D<sub>Y</sub>\n        + D<sub>Y</sub><sup>2</sup>]\n      + [D<sub>B</sub><sup>2</sup>\n        - 2D<sub>B</sub>D<sub>X</sub>\n        + D<sub>X</sub><sup>2</sup>]\n      - [2K<sub>1</sub>K<sub>2</sub>]\n<br/>= [(D<sub>A</sub> - D<sub>Y</sub>)<sup>2</sup>]\n      + [(D<sub>B</sub> - D<sub>X</sub>)<sup>2</sup>]\n      - [2K<sub>1</sub>K<sub>2</sub>]\n<p>\n  Therefore, (D<sub>A</sub> - D<sub>X</sub>)<sup>2</sup>\n  + (D<sub>B</sub> - D<sub>Y</sub>)<sup>2</sup> &le;\n  (D<sub>A</sub> - D<sub>Y</sub>)<sup>2</sup>\n  + (D<sub>B</sub> - D<sub>X</sub>)<sup>2</sup>, since\n  2K<sub>1</sub>K<sub>2</sub> is a non-negative integer. Therefore, we have\n  proved that it is no less optimal to put ingredient A at X and to put\n  ingredient B at Y. In other words, we want to put an ingredient which has\n  a smaller optimal distance-to-bun value in a position which has a smaller\n  actual distance-to-bun value.\n</p>\n<p>\n  Based on the above observation, the solution to this problem becomes simple.\n  Let D' be the list of actual distance-to-bun values for the ingredients sorted\n  in non-decreasing order (e.g. if <b>K</b> is 7, then D' =\n  {0, 0, 1, 1, 2, 2, 3}), and let D be the list of optimal distance-to-bun\n  values for the ingredients sorted in non-decreasing order. Using the\n  observation above, it is optimal to put the i-th ingredient on the list of D\n  to a position which has an actual distance-to-bun value of D'[i]. Therefore,\n  the answer is simply &Sigma; (D'[i] - D[i])<sup>2</sup>.\n</p>\n<p>\n  We can sort the ingredients in\n  O(<b>K</b> log (<b>K</b>)) time and calculate the sum of the squared\n  differences between each ingredient's optimal and actual distance-to-bun\n  values in O(<b>K</b>) time. Therefore, this solution runs in\n  O(<b>K</b> log (<b>K</b>)) time.\n</p>\n<p>\n  (For a similar approach, you might enjoy reading about the\n  <a href=\"https://en.wikipedia.org/wiki/Rearrangement_inequality\">rearrangement inequality</a>).\n</p>\n","id":"0000000000050dd4","statement":"<h3>Problem</h3>\n<p>\n  In 2017, Google learned about a serious Android bug: in the burger emoji,\n  the cheese was directly on top of the lower bun, rather than on the patty\n  itself. Really, who makes a burger that way? Sundar, our CEO, vowed to drop\n  everything and address this issue immediately.\n  </a>\n</p><p>\n  To prevent this sort of situation in the future, the Code Jam team has\n  constructed a mathematical model for understanding burgers. A burger consists\n  of a stack of <b>K</b> ingredients between two buns, with each ingredient\n  appearing exactly once. We are interested in the <i>distance-to-bun</i> value\n  of each ingredient. The distance-to-bun value of an ingredient is the minimum\n  number of other ingredients between the that ingredient and a bun:\n</p>\n<ul>\n  <li>If <b>K</b> is even, then the distance-to-bun values for the ingredients\n  (starting with the ingredient at the top of the stack) are: 0, 1, ...,\n    <b>K</b>/2 - 1, <b>K</b>/2 - 1, ..., 1, 0.</li>\n  <li>If <b>K</b> is odd, then they are: 0, 1, ..., ((<b>K</b> - 1) / 2) - 1,\n    (<b>K</b> - 1) / 2, ((<b>K</b> - 1) / 2) - 1, ..., 1, 0.</li>\n</ul>\n<p>\n  After carrying out a lot of focus group testing (and eating a lot of\n  burgers), we have determined that the i-th of each of our <b>K</b>\n  ingredients has an optimal distance-to-bun value of <b>D<sub>i</sub></b>. We\n  think our burger emoji users will be happiest if we choose an ordering for\n  our ingredients that minimizes the <i>error</i> value, which we define as\n  the sum of the squared differences between each ingredient's optimal and\n  actual distance-to-bun values.\n</p><p>\n  For example, if we have five ingredients A, B, C, D, and E with\n  optimal distance-to-bun values of 0, 2, 1, 1, and 2, and we place them\n  between the buns in that order, then the error is (0-0)<sup>2</sup> +\n  (2-1)<sup>2</sup> + (1-2)<sup>2</sup> + (1-1)<sup>2</sup> + (2-0)<sup>2</sup>\n  = 6. If we instead place them in the order C, E, B, D, A, then the error is\n  (1-0)<sup>2</sup> + (2-1)<sup>2</sup> + (2-2)<sup>2</sup> + (1-1)<sup>2</sup>\n  + (0-0)<sup>2</sup> = 2, which turns out to be the minimum possible error\n  for these ingredients.\n</p><p>\n  Given the list of optimal distance-to-bun values for our ingredients, can you\n  help us determine the smallest possible error?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>;\n  <b>T</b> test cases follow. Each begins with one line containing an integer\n  <b>K</b>: the number of ingredients in our burger. Then, there is one more\n  line containing <b>K</b> integers <b>D<sub>i</sub></b>, the optimal\n  distance-to-bun values of our ingredients.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the smallest possible error, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  0 &le; <b>D<sub>i</sub></b> &le; floor((<b>K</b>-1)/2), for all i. (Each\n    optimal distance-to-bun value is within the range of attainable\n    distance-to-bun values.)<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>K</b> &le; 8.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>K</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n5\n0 2 1 1 2\n1\n0\n6\n2 2 2 2 2 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 0\nCase #3: 10\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Sample Case #1 is the one illustrated in the problem statement.\n</p><p>\n  In Sample Case #2, there is only one ingredient in the burger; that is not\n  much of a burger, but our model has to be able to handle this base case!\n  There is no confusion over how to place the one ingredient, and the error is\n  0.\n</p><p>\n  In Sample Case #3, there are six ingredients, but all of them have an\n  optimal distance-to-bun of 2. Any way of placing them is equivalent, and the\n  error is 2<sup>2</sup> + 1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> +\n  1<sup>2</sup> + 2<sup>2</sup> = 10.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":9}],"title":"Burger Optimization","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>CEO Search: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  In the Small dataset, there are at most 10 existing employees, so one viable\n  approach is as follows. We will start by supposing that the new CEO has the\n  minimum experience level possible: one level higher than the highest level\n  among all existing employees. Then, we can check all possible assignments of\n  employees to potential managers of higher levels than those employees.\n  (Throughout this analysis, for convenience, we will use \"manager\" to mean\n  \"direct manager\"). If any of the assignments is valid &mdash; that is, nobody\n  is managing too many employees &mdash; then we have solved the problem.\n  Otherwise, we try again with a CEO of one level higher, and so on. This\n  process is bounded, since the answer cannot possibly be larger than 11; the\n  existing employees are all level 10 or lower, so a level 11 CEO could manage\n  all of them personally.\n</p><p>\n  At first, it may seem that the search space is too large. When we have one\n  employee of each level between 1 and 10, for example, and we try to add a\n  new CEO of level 11, there are 10! possible sets of assignments. (The level\n  1 employee has 10 potential managers, the level 2 employee has 9 potential\n  managers, and so on.) But the cases like this one with large search spaces\n  are also easy to solve; note that any assignment is valid in our example,\n  since it is impossible to give a manager too many employees. On the other\n  hand, when we have a case like five level 0s, four level 1s, and one level 2,\n  and we try to add a new CEO of level 3, it turns out that no set of\n  assignments is valid... but there are so few possible sets of assignments\n  that it is easy to check them all and move on to trying a new CEO of level 4.\n</p>\n<h3>Large dataset</h3>\n<p>\n  Suppose that we have chosen a new CEO of some level (which may or may not\n  turn out to work), and we have started trying to assign managers in some way;\n  not everyone necessarily has a manager yet. Suppose that an employee A of\n  level L<sub>A</sub> is managing an employee B of level L<sub>B</sub>, and\n  there is some other employee C of level L<sub>C</sub> (not managed by A) such\n  that L<sub>A</sub> &gt; L<sub>C</sub> &gt; L<sub>B</sub>. Then we can safely\n  have A manage C instead of B. If employee C previously had a manager D, that\n  manager is of a high enough level to manage employee B, so we can have D\n  manage B and we are no worse off than before. If employee C did not yet have\n  a manager, then we are better off than before. The same logic holds if\n  employee B stands for an empty space rather than an employee.\n</p><p>\n  This observation suggests a top-down approach to the problem. We can work\n  from the highest-level employees to the lowest-level ones, and apply a simple\n  rule: each employee should manage as many other employees as they can, and\n  those employees should be of the highest levels available among all remaining\n  unmanaged employees.\n</p><p>\n  We can simplify this approach by thinking in terms of levels instead of\n  employees. We will start at the top level, which has the new CEO of level\n  X; the new CEO creates X management \"slots\". Then, let us consider the next\n  highest level, which has <b>N<sub>L</sub></b> employees of level\n  <b>E<sub>L</sub></b>. If <b>N<sub>L</sub></b> &gt; X, then our plan does not\n  work and we need a CEO with a higher level. Otherwise, we have used up\n  <b>N<sub>L</sub></b> of our X slots, but the employees from this level have\n  added <b>N<sub>L</sub></b> &times; <b>E<sub>L</sub></b> more slots. We can\n  continue in this way, abandoning a plan whenever we do not have enough slots\n  to manage all of the employees at a given level.\n</p><p>\n  For the Large dataset, the CEO level may be as large as the largest possible\n  <b>N<sub>i</sub></b> value plus 1, so we may not have time to check all of\n  them. We can speed up the process by\n  <a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">binary searching</a>\n  on the level of our new CEO, with an inclusive lower bound equal to\n  <b>E<sub>L</sub></b> + 1, and an inclusive upper bound equal to the lower\n  bound or the maximum <b>N<sub>i</sub></b> allowed by the problem, whichever\n  is greater. (If there are 10<sup>12</sup> level 0 employees, for example, the\n  answer could be as large as 10<sup>12</sup>.) If we try a possible value and\n  find that it works, we can make that value our new upper bound; if a value\n  does not work, we can set the lower bound to that value plus 1. Each search\n  takes O(<b>L</b>) time, and the binary search adds another factor of\n  log(max(<b>N<sub>i</sub></b>)), so the running time is\n  O(<b>L</b> &times; log(max(<b>N<sub>i</sub></b>))).\n</p><p>\n  This is fast enough to solve the Large dataset, but we can do even better by\n  cutting out the binary search entirely! We can proceed through the levels as\n  before, but without including the new CEO or trying to guess their level.\n  Whenever we encounter employees with no possible managers, we add them to a\n  count and then move on. (This is definitely the case for every employee of\n  level <b>E<sub>L</sub></b>, and it may be true of employees at other levels\n  as well.) The final answer is then either that count (since all of those\n  unmanaged employees must be personally managed by the new CEO), or\n  <b>E<sub>L</sub></b> + 1, whichever is greater.\n</p><p>\n  It is also possible to work from the bottom up instead, using the same idea,\n  or to apply <a href=\"https://en.wikipedia.org/wiki/Hall%27s_marriage_theorem\">Hall's theorem</a> to get a closed-form expression of the solution; we leave\n  those as exercises. In any case, our running time is now O(<b>L</b>).\n</p>\n","id":"0000000000050dd5","statement":"<h3>Problem</h3>\n<p>\n  The CEO of Code Jam has just retired to spend more time with\n  <i>The Art of Computer Programming</i>, so we need your help finding a new\n  one!\n</p><p>\n  Every Code Jam employee has an <i>experience level</i> that is a nonnegative\n  integer. When we hire our new CEO, we must organize the Code Jam team as\n  follows:\n</p>\n<ul>\n  <li>Every employee other than the CEO must have a single\n    <i>direct manager</i> who is another employee with an experience level\n    greater than that employee's own experience level. (The CEO cannot have a\n    direct manager.)</li>\n  <li>An employee (including the CEO) with experience level E can be a direct\n    manager for between 0 and E other employees, inclusive. Note that if\n    employee A is the direct manager of employee B, and B is the direct manager\n    of C, A is <i>not</i> also a direct manager of C.</li>\n  <li>Because of office politics, the new CEO cannot be one of the existing\n    employees, no other new employees can be added, and no existing employees\n    can be removed.</li>\n</ul>\n<p>\n  Of course, hiring a more experienced CEO is more expensive! What is the\n  minimum possible experience level for the new CEO such that the Code Jam\n  team can be organized according to the rules above?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with an integer\n  <b>L</b>: the number of different experience levels present among the\n  existing employees. Then, <b>L</b> lines follow; the i-th of these contains\n  two integers <b>N<sub>i</sub></b> and <b>E<sub>i</sub></b>, and indicates\n  that there are <b>N<sub>i</sub></b> existing employees that have the\n  experience level <b>E<sub>i</sub></b>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the minimum possible experience level for the new CEO, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  For all i &lt; j, <b>E<sub>i</sub></b> &lt; <b>E<sub>j</sub></b>.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>L</b> &le; 10.<br/>\n  1 &le; <b>N<sub>i</sub></b> &le; 10.<br/>\n  The sum of all <b>N<sub>i</sub></b> &le; 10.\n  0 &le; <b>E<sub>i</sub></b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>L</b> &le; 1000.<br/>\n  1 &le; <b>N<sub>i</sub></b> &le; 10<sup>12</sup>.<br/>\n  0 &le; <b>E<sub>i</sub></b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\n2 0\n2 2\n1 3\n1\n5 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, there are five existing employees: one with an experience\n  level of 3, two with an experience level of 2, and two with an experience\n  level of 0. We can hire a new CEO with an experience level of 4; then, for\n  example, we can have the new CEO directly manage the level 3 and one level 0,\n  and have the level 3 directly manage the two level 2s and the other level 0.\n  (Other valid arrangements are possible.) Moreover, we know that the new CEO\n  must be at least level 4, or else there would be nobody who could directly\n  manage the existing level 3. So 4 is both an upper and lower bound, and must\n  be the correct answer.\n</p><p>\n  In Sample Case #2, all five of the existing employees have an experience\n  level of 0 and cannot directly manage other employees. The new CEO must\n  personally directly manage all of them, which requires an experience level of\n  at least 5.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":13}],"title":"CEO Search","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Centrists: Analysis</h2>\n\n<h3>Small dataset</h3>\n<p>\n  In the Small dataset, the candidates' names can only contain the letters\n  <code>A</code>, <code>B</code>, and <code>C</code>, so we can effectively\n  disregard the rest of the alphabet. That is, since there are no\n  <code>D</code>s anywhere in any of the names, for example, we do not care\n  whether <code>A</code> comes before or after <code>D</code> in an ordering of\n  the alphabet. Only the relative order of <code>A</code>, <code>B</code>, and\n  <code>C</code> matters, and there are only 3! = 6 such orders, so we can\n  check each one of them and see how the three names get sorted in each case.\n  Then, we can report <code>YES</code> for any name that appeared in the middle\n  under at least one ordering, and <code>NO</code> for any name that did not.\n</p>\n<h3>Large dataset</h3>\n<p>\n  The English alphabet has 26! possible orderings; this is close to 4 &times;\n  10<sup>26</sup>, which is far too many for us to check individually. We will\n  take another approach. Let us examine the first letter of each name. If all\n  three of those letters are the same, then they cannot influence the order in\n  which the names get sorted, so we can move on to looking at the second\n  letters, and so on. Eventually, we will find an index at which the letters\n  are not all the same; there are two ways in which this can happen.\n</p><p>\n  The first of these &mdash; all three are different &mdash; is the easiest to\n  deal with. Let L<sub>i</sub> denote the letter at that index in the i-th\n  name. Then, if we choose an alphabet ordering in which L<sub>i</sub> falls\n  somewhere between the other two letters, the i-th name will be in the middle.\n  So the answer is <code>YES</code> for all three names.\n</p><p>\n  Otherwise, two of the letters at that index are the same, and one is\n  different. Call the shared letter L<sub>s</sub> and the different letter\n  L<sub>d</sub>, and call the name with L<sub>d</sub> at that index\n  N<sub>d</sub>. We can already see that N<sub>d</sub> can never end up in the\n  middle. If L<sub>s</sub> &lt; L<sub>d</sub> (where &lt; means \"comes before\n  in the alphabet ordering\"), then the other two names will come before\n  N<sub>d</sub>. (Other differences that come later in the names do not\n  influence this.) Otherwise, N<sub>d</sub> will come before the other two\n  names.\n</p><p>\n  What about the order of the other two names? Let us scan through them,\n  starting just after our aforementioned index, looking for the earliest index\n  at which the letters of these names are different. Call the differing letters\n  at that index L<sub>1</sub> and L<sub>2</sub>, and call the names containing\n  those letters (respectively) at that index N<sub>1</sub> and N<sub>2</sub>.\n  Let us consider the various possible identities of L<sub>1</sub> and\n  L<sub>2</sub>.\n</p><p>\n  Suppose that L<sub>1</sub> = L<sub>s</sub> and L<sub>2</sub> = L<sub>d</sub>.\n  Then, if L<sub>s</sub> &lt; L<sub>d</sub>, our name order will be\n  N<sub>1</sub>, N<sub>2</sub>, N<sub>d</sub>. Otherwise, it will be\n  N<sub>d</sub>, N<sub>2</sub>, N<sub>1</sub>. So N<sub>1</sub> cannot be in\n  the middle, but N<sub>2</sub> can. A similar situation holds for\n  L<sub>1</sub> = L<sub>d</sub> and L<sub>2</sub> = L<sub>s</sub>.\n</p><p>\n  Otherwise, regardless of the identities of L<sub>1</sub> and L<sub>2</sub>,\n  either of N<sub>1</sub> and N<sub>2</sub> could be in the middle:\n</p>\n<ul>\n  <li>Suppose that L<sub>1</sub> (without loss of generality) =\n    L<sub>d</sub>. We can choose an ordering in which L<sub>d</sub> comes\n    first to get the order N<sub>d</sub>, N<sub>1</sub>, N<sub>2</sub>, or\n    we can choose an ordering in which L<sub>s</sub> &lt; L<sub>d</sub> &lt;\n    L<sub>2</sub> to get the order N<sub>1</sub>, N<sub>2</sub>,\n    N<sub>d</sub>.</li>\n  <li>Suppose that L<sub>1</sub> (without loss of generality) =\n    L<sub>s</sub>. We can choose an ordering in which L<sub>s</sub> comes\n    first to get the order N<sub>1</sub>, N<sub>2</sub>, N<sub>d</sub>, or\n    we can choose an ordering in which L<sub>d</sub> &lt; L<sub>s</sub> &lt;\n    L<sub>2</sub> to get the order N<sub>d</sub>, N<sub>1</sub>,\n    N<sub>2</sub>.</li>\n  <li>Otherwise, we can choose an ordering that begins with L<sub>d</sub>\n    (which puts N<sub>d</sub> first), and has L<sub>1</sub> and L<sub>2</sub>\n    in the order in which we want N<sub>1</sub> and N<sub>2</sub> to appear.\n  </li>\n</ul>\n","id":"0000000000050dd6","statement":"<h3>Problem</h3>\n<p>\n  Exactly three candidates are running for office. Each candidate's name is\n  a single string of length <b>L</b> that is made up only of uppercase letters\n  of the English alphabet, and no two candidates have the same name.\n</p><p>\n  This area has a law to ensure that candidates will not consistently be at an\n  advantage or disadvantage based on their names. Before each election, an\n  ordering of the English alphabet will be chosen from among all possible\n  orderings, and that ordering will be used to alphabetize the names before\n  listing them on the ballot. (To determine which of two different names comes\n  earlier in the list on the ballot, start by comparing the first letter of\n  each name. If they are different, then the name with the first letter that\n  comes earlier in the chosen ordering is the one that comes earlier in the\n  list on the ballot. If they are the same, move on to comparing the second\n  letter of each name, and so on.)\n</p><p>\n  Each of the three candidates wants to adopt a \"middle-of-the-road\" image, and\n  so they think that being in the middle of the list of three names on the\n  ballot will be advantageous. For each candidate, determine whether there is\n  at least one ordering of the English alphabet for which their name would be\n  the second of the three names on the ballot. Note that we are considering\n  each candidate independently.\n</p><p>\n  For example, suppose that our candidates are named <code>BCB</code>,\n  <code>CAB</code>, and <code>CBC</code>. Since the letters <code>D</code>\n  through <code>Z</code> are not used in these names, we will only consider the\n  relative ordering of the letters <code>A</code>, <code>B</code>, and\n  <code>C</code>. If the ordering <code>A</code>, <code>B</code>,\n  <code>C</code> is chosen, for example, then the candidates will be listed in\n  the order <code>BCB</code>, <code>CAB</code>, <code>CBC</code>; this\n  demonstrates that it is possible for <code>CAB</code> to be in the middle. If\n  the ordering <code>A</code>, <code>C</code>, <code>B</code> is chosen, then\n  the candidates will be listed in the order <code>CAB</code>, <code>CBC</code>,\n  <code>BCB</code>; this demonstrates that it is possible for <code>CBC</code>\n  to be in the middle. However, even under any of the other four possible\n  orderings, it turns out that <code>BCB</code> can never be in the middle.\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>;\n  <b>T</b> test cases follow. Each begins with one line containing one integer\n  <b>L</b>: the length of each candidate's name. Then, there is one line with\n  three different strings <b>N<sub>i</sub></b> of uppercase letters of the\n  English alphabet; the i-th of these is the name of the i-th candidate.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing\n  <code>Case #x: y1 y2 y3</code>, where <code>x</code> is the test case number\n  (starting from 1) and each <code>yi</code> is <code>YES</code> if it is\n  possible for the i-th candidate to be in the middle, as described in the\n  problem statement, and <code>NO</code> otherwise.\n</p>\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>L</b> &le; 100.<br/>\n  <b>N<sub>i</sub></b> is of length <b>L</b>, for all i.<br/>\n  <b>N<sub>i</sub></b> &ne; <b>N<sub>j</sub></b>, for all i &ne; j.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  <b>N<sub>i</sub></b> contains only uppercase letters from the set\n  {<code>A</code>, <code>B</code>, <code>C</code>}, for all i.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  <b>N<sub>i</sub></b> contains only uppercase letters from the English\n  alphabet, for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\nBCB CAB CBC\n2\nCC CA AA\n6\nMEDIAN MEDIAL MEDIAS\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: NO YES YES\nCase #2: NO YES NO\nCase #3: YES YES YES\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Note that the last sample case would not appear in the Small dataset.\n</p><p>\n  Sample Case #1 is the one described in the problem statement.\n</p><p>\n  In Sample Case #2, no matter which of the two possible relative orderings of\n  <code>A</code> and <code>C</code> is chosen, <code>CA</code> will be in the\n  middle.\n</p><p>\n  In Sample Case #3, any of the names can end up in the middle, depending on\n  which of <code>L</code>, <code>N</code>, and <code>S</code> comes second in\n  the relative order of those three letters in the ordering.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Centrists","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Tricky Trios: Analysis</h2>\n<h3>Playing the game</h3>\n<p>\n  Before we can approach either of the datasets, we need to figure out an\n  optimal strategy for the game. One important insight is that we should not\n  begin a round by flipping over a known card, unless we know where all three\n  cards in a trio are (in which case we can flip them all to remove that\n  trio).\n</p><p>\n  To see why this is, suppose that we begin by flipping the one or two known\n  cards with a certain number. Then, when we move on to flipping unknown cards,\n  we either find the one or two remaining cards we need, or we fail and learn\n  the identity of only one more card. But if we instead begin by flipping an\n  unknown card, we have exactly the same chance of encountering the cards\n  needed to remove the aforementioned trio, in which case we can end the round\n  by flipping the known ones. We also have some other advantages: we have a\n  chance of removing any of the other trios, and if we fail to do that, we\n  will learn the identities of two more cards. So, beginning with an unknown\n  card is strictly better than beginning with a known card; it leaves more\n  options open and gets us more valuable information.\n</p><p>\n  What about the parts of a round other than the beginning? There is one\n  situation in which we have some flexibility: if the unknown card revealed on\n  our first flip matches one known card, there is no harm in flipping over that\n  known card as our second action before flipping over an unknown card as our\n  third action. But it is no worse to flip over an unknown card as our second\n  action instead, since we need to find the last member of that trio either way.\n</p><p>\n  So, the following simple rule is optimal: only flip known cards when they\n  are the last ones needed to remove a trio.\n</p>\n<h3>Small dataset</h3>\n<p>\n  This is an unusual dataset for Code Jam: there are only five possible test\n  cases, and three of them are given away as samples, so we can hardcode those\n  in and only focus on solving the <b>N</b> = 3 and <b>N</b> = 4 cases.\n</p><p>\n  Notice that whenever we flip an unknown card, we have no basis for choosing\n  any particular unknown card. Without loss of generality, we can choose to\n  reveal them from left to right. With this in mind, one tempting approach is\n  to repeatedly simulate playing the game, each time choosing a random\n  left-to-right order in which to deal with the cards, and then take the\n  average number of rounds. The tight requirement of an absolute or relative\n  error of 10<sup>-6</sup> makes this challenging, though; even millions of\n  simulations might not get us close enough! We can let a simulation run for\n  quite some time and get answers before starting the 4-minute submission\n  window, but even optimized code may not be fast enough, especially in an\n  interpreted language, for example.\n</p><p>\n  Instead of simulating random left-to-right orders, can we enumerate them all,\n  play through each one, and then take the average number of rounds? For our\n  <b>N</b> = 4 case, there are a total of (12 choose 3) &times; (9 choose 3)\n  &times; (6 choose 3) &times; (3 choose 3) = 369600 orders, which is a\n  tractably small amount. Although it is not necessary, we can cut this down\n  by another factor of <b>N</b>! by noting that the numbers on the cards are\n  essentially interchangeable; an order like 111222333444 will yield the same\n  result as an order like 222333444111. This drops the number of cases to\n  15400 for <b>N</b> = 4, and 1401400 for <b>N</b> = 5. Beyond that point,\n  though, there are just too many orders to consider individually.\n</p>\n<h3>Large dataset</h3>\n<p>\n  At the start of each round of the game, for each trio that we have not\n  already removed, we know the locations of three, two, one, or zero of the\n  cards, depending on what we have flipped over on earlier rounds. Let us\n  classify trios accordingly as Three-Known, Two-Known, One-Known, or\n  Zero-Known. Then we can consider the number of trios of each type &mdash;\n  (K<sub>3</sub>, K<sub>2</sub>, K<sub>1</sub>, K<sub>0</sub>) &mdash; as a\n  <i>state</i>, and think of a round as a transition from one state to another\n  state. We begin the game at (0, 0, 0, <b>N</b>), and we want to get to\n  (0, 0, 0, 0) as efficiently as possible, but our path will depend on how\n  lucky we get when flipping over unknown cards.\n</p><p>\n  Let us use f(state) to denote the question \"how many rounds will it take,\n  on average, to finish the game when starting from this state?\" To calculate\n  f(state), we must consider all the states in which the round can end, and\n  the probabilities of reaching each of those destination states. Then\n  f(state) is a sum of the f()s for those destination states, weighted by the\n  probability of reaching each of them.\n</p><p>\n  We can simplify this model at the outset by noting that if we play according\n  to our strategy above, K<sub>3</sub> will never be larger than 1, and if it\n  is 1, we should spend the next round to immediately remove the Three-Known\n  trio. That is, f(K<sub>3</sub>, K<sub>2</sub>, K<sub>1</sub>, K<sub>0</sub>)\n  = 1 + f(K<sub>3</sub> - 1, K<sub>2</sub>, K<sub>1</sub>, K<sub>0</sub>). So\n  we can remove the K<sub>3</sub> term and work with states of the form\n  (K<sub>2</sub>, K<sub>1</sub>, K<sub>0</sub>), and add in an extra round as\n  needed to reflect removing a Three-Known trio.\n</p><p>\n  For example, suppose that we start a round in a state (1, 1, 1); this means\n  that there are six unknown cards remaining, with one from a Two-Known trio,\n  two from a One-Known trio, and three from a Zero-Known trio. (Remember that\n  there are other known cards around as well &mdash; for instance, the other\n  two cards from the Two-Known trio &mdash; but we are focusing on the unknown\n  cards.) Let us consider one possible scenario: our first draw turns out to\n  be from the One-Known trio, and then our second draw turns out to be from the\n  Two-Known trio, which ends the round. This converts our Two-Known trio into\n  a Three-Known trio and our One-Known trio into a Two-Known trio. We should\n  immediately spend the next round to remove the Three-Known trio.\n</p><p>\n  The probability of the above happening is 2/6 (the odds of drawing one of\n  the unknown cards from the One-Known trio) &times; 1/5 (the conditional odds\n  of drawing the unknown card from the Two-Known trio). So, when we write the\n  expression for f(1, 1, 1), it should include the term 2/6 &times; 1/5 &times;\n  (2 + f(1, 0, 1)). The 2 represents the current round plus the extra round\n  spent removing the Three-Known trio. Note that (1, 0, 1) reflects that we\n  have converted a One-Known trio into a Two-Known trio and lost another\n  Two-Known trio.\n</p><p>\n  The above illustrates the calculation of just one term, and our solution\n  needs to be able to handle any state; the more general version of the term\n  above would be\n  ((2 &times; K<sub>1</sub>) /\n  (K<sub>2</sub> + 2 &times; K<sub>1</sub> + 3 &times; K<sub>0</sub>))\n  &times;\n  (K<sub>2</sub> /\n  (K<sub>2</sub> + 2 &times; K<sub>1</sub> - 1 + 3 &times; K<sub>0</sub>))\n  &times;\n  (2 + f(K<sub>2</sub>, K<sub>1</sub> - 1, K<sub>0</sub>)). Setting up terms\n  like this is the heart of the problem, and there are various possible\n  pitfalls, e.g.:\n</p>\n<ul>\n  <li>If our first flip on a round reveals a card from a Zero-Known trio,\n    our second flip might reveal a card from any of the following: a Two-Known\n    trio, a One-Known trio, the same Zero-Known trio, or a different Zero-Known\n    trio. It is important to distinguish between the latter two\n    possibilities.</li>\n  <li>We must avoid considering terms that represent impossible situations;\n    we cannot draw a card from a different Zero-Known trio if there is only\n    one Zero-Known trio in our starting state.</li>\n</ul>\n<p>\n  Once we have all this nailed down, we need a way to avoid computing f() for\n  the same state more than once. We can store each result and then look it up\n  again later if we need it for a future calculation, instead of doing\n  redundant work. This is\n  <a href=\"https://en.wikipedia.org/wiki/Memoization\">memoization</a>,\n  a form of <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">dynamic programming</a>.\n  This optimization allows the entire Large dataset to be solved in seconds.\n</p>\n","id":"0000000000050fc4","statement":"<h3>Problem</h3>\n<p>\n  The game of Tricky Trios is played using a deck of 3<b>N</b> cards consisting\n  of three identical cards labeled 1, three identical cards labeled 2, and so\n  on, up to three identical cards labeled <b>N</b>. The cards are shuffled\n  (such that all possible card orderings have an equal probability of\n  appearing), and then dealt out onto a table, face down, so that all the\n  numbers are hidden.\n</p><p>\n  Each round of the game proceeds as follows:\n</p>\n<ul>\n  <li>Choose one of the cards and flip it over to reveal its number.</li>\n  <li>Choose a second card and flip it over to reveal its number. If that\n    number is not equal to the revealed number on the first card, the round is\n    over and you <u>may not flip a third card</u>. Otherwise:\n    <ul>\n      <li>Choose a third card and flip it over to reveal its number. If that\n        number is not equal to the revealed number on the second card, the\n        round is over. Otherwise, you have found a trio, and you can remove all\n        three cards from the game; then the round is over.</li>\n    </ul>\n  </li>\n  <li>Once the round is over, if there are no more cards remaining, you have\n    won the game. Otherwise, before beginning the next round, you must flip all\n    revealed cards back over to hide their numbers, but you have an amazing\n    memory and you can remember where they are for the rest of the game.\n  </li>\n</ul>\n<p>\n  Note that you may choose to flip a card even if you already know its number.\n  Also, even if you know the locations of all of the cards in a trio, you must\n  actually flip all three cards in the trio on the same round in order to\n  remove it.\n</p><p>\n  You would like to win as quickly as possible, so you will use a strategy that\n  minimizes the expected number of rounds needed to end the game. What is that\n  expected number of rounds?\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>;\n  <b>T</b> test cases follow. Each consists of one line with an integer\n  <b>N</b>, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is a rational: the minimal expected number of rounds needed to end the game,\n  as described above. <code>y</code> will be considered correct if it is within\n  an absolute or relative error of 10<sup>-6</sup> of the correct answer. See\n  the\n  <a href=\"/codejam/faq.html#floating_point\">FAQ</a> for an explanation of what\n  that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>T</b> &le; 5.<br/>\n  1 &le; <b>N</b> &le; 5.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1\n2\n5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.000000\nCase #2: 3.400000\nCase #3: 9.842024\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, all three cards have the same number, so flipping them\n  over in any order will end the game in one round.\n</p><p>\n  In Sample Case #2:\n</p>\n<ul>\n  <li>If the first two cards we flip over are different, our round ends and we\n    cannot flip over a third card. Then, we can use the next round to flip over\n    two more of the unknown cards.\n    <ul>\n      <li>If they match, then we already know where the remaining third\n        card is, and then we can use one more round to flip over the\n        remaining trio, taking three rounds total. The chances of this\n        scenario are 3/5 &times; 1/3 = 1/5.\n      </li>\n      <li>\n        Otherwise, our second round ends, but once we have flipped over\n        another unknown card on the third round, we know how to finish\n        building both trios, taking four rounds total. The chances of this\n        scenario are 3/5 &times; 2/3 = 2/5.\n      </li>\n    </ul>\n  </li>\n  <li>If the first two cards we flip over are the same, we leave the\n    details as an exercise for the solver.</li>\n</ul>\n</p><p>\n  The answer is 3 &times; 1/5 + 4 &times; 2/5 + ... = 17/5.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":27}],"title":"Tricky Trios","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000005102c","type":0,"type__str":"NONE"},"title":"Code Jam to I/O for Women 2018"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
