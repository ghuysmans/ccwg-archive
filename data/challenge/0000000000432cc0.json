{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1217700000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432cc0","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  This was another exciting round with four cute problems.\n</p>\n<ul>\n  <li>A: An easy exercise in dynamic programming.</li>\n  <li>B: A puzzle in 2d geometry.</li>\n  <li>\n    C: A problem with a beautiful picture in 3d geometry... but the judges\n    overlooked a step in the solution.\n  </li>\n  <li>\n    D: A standard dynamic programming on graphs hidden behind a clever\n    reduction.\n  </li>\n</ul>\n<p>\n  This round caused some minor trouble for the judges. All four sample solution\n  writers overlooked a key step in the reasoning, and the team had to spend a\n  whole evening rejudging the problem. Fortunately, the change did not have a\n  substantial effect on the list of advancers. This is the only time this year\n  when we had an error in the judges' solutions, and we dodged the bullet. We\n  hope to have zero mistakes in the future!\n</p><p>\n  Thanks to all the participants, especially <b>neal.wu</b>, who first suspected\n  that we had an error and pointed it out.\n</p>\n\n<hr>\n<p>\n  <b>Credits</b>\n</p><p>\n  Problem A. <i>Cheating a Boolean Tree</i>\n  Written by Xiaomin Chen. Prepared by Mark Gordon\n</p><p>\n  Problem B. <i>Triangle Areas</i>\n  Written by Petr Mitrichev and Igor Naverniouk. Prepared by Igor Naverniouk\n  and Xiaomin Chen.\n</p><p>\n  Problem C. <i>Star Wars</i>\n  Written by Cosmin Negruseri. Prepared by the Code Jam team.\n</p><p>\n  Problem D. <i>PermRLE</i>\n  Written by Petr Mitrichev. Prepared Mark Gordon.\n</p><p>\n  Contest analysis presented by Xiaomin Chen and Cosmin Negruseri.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1217692800000,"tasks":[{"analysis":"<p>\n  This problem offers a nice excursion into some basic pictures in algebra and\n  geometry, and certainly some programming basics.\n</p><p>\n  The problem is to find the smallest power Y<sub>0</sub>, such that there is a\n  position where power Y<sub>0</sub> is good enough to reach all of the ships.\n  Clearly, any power bigger than Y<sub>0</sub> is big enough, while any power\n  smaller than Y<sub>0</sub> is not. So, the first step towards the solution is\n  to use the binary search. Reduce the problem of finding the smallest Y to a\n  sequence of easier problems of deciding whether a given Y is big enough. Below\n  we can focus on the decision problem for a given Y instead of the original\n  optimization problem.\n</p><p>\n  For a given Y, we have a requirement that each ship i satisfies\n</p>\n<pre>\n(1) &nbsp;&nbsp;&nbsp; (|x<sub>i</sub> - x| + |y<sub>i</sub> - y| + |z<sub>i</sub> - z|) &le; p<sub>i</sub>Y\n</pre>\n<p>\n  Geometrically, this means that the point (x, y, z) for the cruiser must be in\n  the octahedron centered at (x<sub>i</sub>, y<sub>i</sub>, z<sub>i</sub>). Each\n  of the N ships gives one octahedron, and a good position for the cruiser\n  exists if and only if all these N octahedra intersect.\n</p><p>\n  Algebraically, (1) is equivalent to the following set of inequalities (prove\n  it!)\n</p>\n<pre>\n&nbsp;&nbsp; x + y + z &le; x<sub>i</sub> + y<sub>i</sub> + z<sub>i</sub> + p<sub>i</sub>Y\n&nbsp;&nbsp; x + y + z &ge; x<sub>i</sub> + y<sub>i</sub> + z<sub>i</sub> - p<sub>i</sub>Y\n&nbsp;&nbsp; x + y - z &le; x<sub>i</sub> + y<sub>i</sub> - z<sub>i</sub> + p<sub>i</sub>Y\n&nbsp;&nbsp; x + y - z &ge; x<sub>i</sub> + y<sub>i</sub> - z<sub>i</sub> - p<sub>i</sub>Y\n&nbsp;&nbsp; x - y + z &le; x<sub>i</sub> - y<sub>i</sub> + z<sub>i</sub> + p<sub>i</sub>Y\n&nbsp;&nbsp; x - y + z &ge; x<sub>i</sub> - y<sub>i</sub> + z<sub>i</sub> - p<sub>i</sub>Y\n&nbsp;&nbsp; -x + y + z &le; -x<sub>i</sub> + y<sub>i</sub> + z<sub>i</sub> + p<sub>i</sub>Y\n&nbsp;&nbsp; -x + y + z &ge; -x<sub>i</sub> + y<sub>i</sub> + z<sub>i</sub> - p<sub>i</sub>Y\n</pre>\n<p>\n  For the geometrically inclined, each octahedron is associated with one of the\n  four directions given by the vectors (1, 1, 1), (1, 1, -1), (1, -1, 1) and\n  (-1, 1, 1). Each pair of inequalities states that the projection (the inner\n  product) of (x, y, z) on a given direction vector must be in a certain range.\n</p><p>\n  Now we have the problem of solving a set of inequalities of the form\n</p>\n<pre>\n&nbsp;&nbsp; A &le; x + y + z &le; B\n&nbsp;&nbsp; C &le; x + y - z &le; D\n&nbsp;&nbsp; E &le; x - y + z &le; F\n&nbsp;&nbsp; G &le; -x + y + z &le; H\n</pre>\n<p>\n  where A, B, C, D, E, F, G and H are given. In general, this is a linear\n  program. But it is such a trivial one that we do not need to pull out any\n  serious linear programming algorithms.\n</p><p>\n  Certainly, for the solution to exist, we must have A &le; B, C &le; D, E &le;\n  F, and G &le; H. But these conditions are not enough. The inequalities can be\n  rewritten as\n</p>\n<pre>\n&nbsp;&nbsp; A - x &le; y + z &le; B - x\n&nbsp;&nbsp; G + x &le; y + z &le; H + x\n&nbsp;&nbsp; C - x &le; y - z &le; D - x\n&nbsp;&nbsp; -F + x &le; y - z &le; -E + x\n</pre>\n<p>\n  As long as y + z and y - z have solutions, we can get y and z. We want to see\n  whether there is an x such that the range [A - x, B - x] intersects [G + x, H\n  + x], and the range [C - x, D - x] intersects [-F + x, -E + x].\n</p><p>\n  It is easy to see that in order for the first two ranges to intersect, we must\n  have\n</p>\n<pre>\n(2) &nbsp;&nbsp;&nbsp; x in [(A - H) / 2, (B - G) / 2].\n</pre>\n<p>\n  And for the other two ranges, we must have\n</p>\n<pre>\n(3) &nbsp;&nbsp;&nbsp; x in [(C + E) / 2, (D + F) / 2].\n</pre>\n<p>\n  The last step of our solution is simply to decide whether the two intervals in\n  (2) and (3) have a non-empty intersection.\n</p>\n","id":"0000000000432a80","statement":"<h3>Problem</h3>\n<p>\n  Near the planet Mars, in a faraway galaxy eerily similar to our own, there is\n  a fight to the death between the imperial forces and the rebels. The rebel\n  army has <b>N</b> ships which we will consider as points\n  <nobr><i>(x<sub>i</sub>, y<sub>i</sub>, z<sub>i</sub>)</i></nobr>. Each ship\n  has a receiver with power <b>p<sub>i</sub></b>. The rebel army needs to be\n  able to send messages from the central cruiser to all the ships, but they are\n  tight on finances, so they cannot afford a strong transmitter.\n</p><p>\n  If the cruiser is placed at <nobr><i>(x, y, z)</i></nobr>, and one of the\n  other ships is at <nobr><i>(x<sub>i</sub>, y<sub>i</sub>,\n  z<sub>i</sub>)</i></nobr> and has a receiver of power <b>p<sub>i</sub></b>,\n  then the power of the cruiser's transmitter needs to be at least:\n</p>\n<code><pre>\n(|x<sub>i</sub> - x| + |y<sub>i</sub> - y| + |z<sub>i</sub> - z|) / p<sub>i</sub>\n</pre></code>\n<p>\n  Your task is to find the position for the cruiser that minimizes the power\n  required for its transmitter, and to output that power.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>T</b>. <b>T</b> test\n  cases follow.\n</p><p>\n  Each test case contains on the first line the integer <b>N</b>, the number of\n  ships in the test case.\n</p><p>\n  <b>N</b> lines follow, each line containing four integer numbers\n  <b>x<sub>i</sub></b>, <b>y<sub>i</sub></b>, <b>z<sub>i</sub></b>\n  and <b>p<sub>i</sub></b>, separated by single spaces. These are the\n  coordinates of the i-th ship, and the power of its receiver. There may be\n  more than one ship at the same coordinates.\n</p>\n<h3>Output</h3>\n<p>\n  For each input case, you should output:\n</p>\n<pre>Case #<b>X</b>: <b>Y</b></pre>\n<p>\n  where <b>X</b> is the number of the test case and <b>Y</b> is the minimal\n  power that is enough to reach all the fleet's ships. Answers with a relative\n  or absolute error of at most 10<sup>-6</sup> will be considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>T</b> &le; 10<br>\n  0 &le; <b>x<sub>i</sub></b>, <b>y<sub>i</sub></b>, <b>z<sub>i</sub></b>\n  &le; 10<sup>6</sup><br>\n  1 &le; <b>p<sub>i</sub></b> &le; 10<sup>6</sup>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 1000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n0 0 0 1\n1 2 0 1\n3 4 0 1\n2 1 0 1\n1\n1 1 1 1\n3\n1 0 0 1\n2 1 1 4\n3 2 3 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3.50000000\nCase #2: 0.00000000\nCase #3: 2.33333333\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In the first test case, the four ships have coordinates (0, 0, 0), (1, 2,\n  0), (3, 4, 0), (2, 1, 0) and powers 1, 1, 1, 1 respectively. We can place a\n  cruiser with the power 3.5 at the coordinates (1.5, 2, 0) which will be able\n  to reach all the ships.\n</p><p>\n  In the second case we can place the cruiser right on top of the ship, with\n  transmitter power 0.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Star Wars","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Section A. The Hamiltonian cycle in a small world</h3>\n<p>\n  A Hamilton cycle in a graph is a cycle that visits each node exactly once.\n  Given a weighted, directed, complete graph on n nodes, there are (n-1)!\n  distinct Hamiltonian cycles. It is well known that the problem of finding the\n  shortest (or longest) Hamilton cycle is NP-hard. It is also known to many\n  contestants that, for n as small as 20, dynamic programming makes a difference\n  of n*2<sup>n</sup> vs. n!, which is the difference between a second and an\n  eternity.\n</p><p>\n  Let's have a look at the n*2<sup>n</sup> DP trick, in case you have not seen\n  it before.\n</p><p>\n  Without loss of generality, we may view node 0 as the start point of the\n  cycle, as well as its end point. For any subset A of the node set V and any\n  node x in A, we define\n</p>\n<blockquote>\n  dp[A][x] := The shortest path that starts from x, visits each point in A\n  exactly once and ends up at node 0. (*)\n</blockquote>\n<p>\n  To clarify, 0 does not necessary belong to A, but we do count the length of\n  the edge from the last point to node 0. Thus the problem of finding the\n  shortest Hamilton cycle is just dp[V][0]. (Convince yourself, maybe looking at\n  (*).)\n</p><p>\n  We need to compute dp[A][x]. For the easy cases where A = {x}, the answer is\n  just the length of edge x&rarr;0. Otherwise, we focus on the first step of the\n  path. If the first step is x&rarr;y, with edge length q, then we pay\n  <nobr>dp[A - x][y] + q</nobr>. In general, dp[A][x] is\n</p>\n<ul>\n  <li>length(x&rarr;0), if A = {x}.</li>\n  <li>min { dp[A - x][y] + length(x&rarr;y) | y in A - x }, if |A|&gt;1.</li>\n</ul>\n\n<h3>Section B. Wrap everything into a small world</h3>\n<p>\n  For any string, define the <i>number of switches</i> to be the number of times\n  adjacent characters are different in the string. We want to find a permutation\n  that transforms <b>S</b> to one <b>S'</b> where the number of switches is\n  minimal. Assume the length of <b>S</b> is <b>mk</b>. Then <b>S</b> can be\n  viewed as a string with <b>m</b> blocks of length <b>k</b>.\n</p><p>\n  Now we introduce a visual aid to simplify our writing. Let us draw the string\n  <b>S</b> as <b>m</b> rows, each block on a single row. The key image is to\n  count the number of switches one <i>column</i> at a time.\n</p><p>\n  Let us take a semi-concrete example. Suppose that at one point we have decided\n  that 5 is permuted to the 7th position, and that 2 goes to the 8th position.\n  Then without knowing the rest of the permutation, we can inspect the 5th and\n  2nd characters in each block. Suppose that in Z of the blocks the 5th and the\n  2nd characters are different, then we know that in any such permutation, we\n  will have to pay the price of Z.\n</p><p>\n  The one exception is the last element of the permutation. In all cases but\n  one, we simply wrap around to the beginning because the end of each k-block\n  touches the beginning of the next k-block in the string, except for the last\n  character in the string. We can handle both cases if we fix the last element\n  of the permutation by trying all possibilities.\n</p><p>\n  Next, we reduce our problem to the one in Section A. Suppose we fix\n  <b>T</b> as the last element in the permutation. Define a weighted, directed,\n  complete graph G on <b>k</b> vertices {1, 2, ..., k}. The weight on the edge\n  x&rarr;y is\n</p>\n<ul>\n  <li>\n    the number of blocks where the x-th character is different from the y-th\n    character in the same block. (if x &ne; T)\n  </li>\n  <li>\n    the number of blocks (excluding the last one) where the x-th character is\n    different from the y-th character in the <i>next</i> block. (if x = T)\n  </li>\n</ul>\n<p>\n  It is easy to check that for any permutation, the number of switches is the\n  same as the length of the corresponding Hamiltonian cycle in G.\n</p><p>\n  We have <b>k</b> different choices for T. For each T, finding the shortest\n  Hamilton cycle takes O(2<sup>k</sup> k) time. The construction of the graph\n  takes O(k<sup>2</sup>m) = O(k |S|) time for each T; it is also easy to\n  construct in O(k<sup>2</sup>m) time the graphs for all the T's. The running\n  time of the solution is O(2<sup>k</sup> k<sup>2</sup> + k |S|).\n</p>\n","id":"0000000000432ad1","statement":"<h3>Problem</h3>\n<p>\n  You've invented a slight modification of the run-length encoding (RLE)\n  compression algorithm, called PermRLE.\n</p><p>\n  To compress a string, this algorithm chooses some permutation of integers\n  between 1 and <b>k</b>, applies this permutation to the first <b>k</b> letters\n  of the given string, then to the next block of <b>k</b> letters, and so on.\n  The length of the string must be divisible by <b>k</b>. After permuting all\n  blocks, the new string is compressed using RLE, which is described later.\n</p><p>\n  To apply the given permutation <i>p</i> to a block of <b>k</b> letters means\n  to place the <i>p[1]</i>-th of these letters in the first position, then\n  <i>p[2]</i>-th of these letters in the second position, and so on. For\n  example, applying the permutation {3,1,4,2} to the block \"abcd\" yields \"cadb\".\n  Applying it to the longer string \"abcdefghijkl\" in blocks yields\n  \"cadbgehfkilj\".\n</p><p>\n  The permuted string is then compressed using run-length encoding. To simplify,\n  we will consider the <i>compressed size</i> of the string to be the number of\n  groups of consecutive equal letters. For example, the compressed size of\n  \"aabcaaaa\" is 4; the first of the four groups is a group of two letters \"a\",\n  then two groups \"b\" and \"c\" each containing only one letter, and finally a\n  longer group of letters \"a\".\n</p><p>\n  Obviously, the compressed size may depend on the chosen permutation. Since the\n  goal of compression algorithms is to minimize the size of the compressed text,\n  it is your job to choose the permutation that yields the smallest possible\n  compressed size, and output that size.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>N</b>. <b>N</b> test\n  cases follow.\n</p><p>\n  The first line of each case will contain <b>k</b>. The second line will\n  contain <b>S</b>, the string to be compressed.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case you should output one line containing \"Case #<b>X</b>:\n  <b>Y</b>\" (quotes for clarity) where <b>X</b> is the number of the test case\n  and <b>Y</b> is the minimum compressed size of <b>S</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  <b>N</b> = 20<br>\n  <b>S</b> will contain only lowercase letters 'a' through 'z'<br>\n  The length of <b>S</b> will be divisible by <b>k</b><br>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  2 &le; <b>k</b> &le; 5<br>\n  1 &le; length of <b>S</b> &le; 1000\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  2 &le; <b>k</b> &le; 16<br>\n  1 &le; length of <b>S</b> &le; 50000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n4\nabcabcabcabc\n3\nabcabcabcabc\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 7\nCase #2: 12\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":30}],"title":"PermRLE","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This problem was originally in the form of a little puzzle: For how many\n  numbers is the area possible? The answer is that there are <b>M</b\n  ><b>N</b> such numbers, for any integer 0 &lt; <b>A</b> &le; <b>MN</b>, we can\n  find a triangle with area <b>A</b>/2 formed by integer points on the graph\n  paper.\n</p><p>\n  The following picture gives the key step in the proof, as well as a solution\n  to our problem.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0XDkDQAhmeb1Xuzjrcx9Zv7Ne85wkJfhUF32BzcYbYlTtAVxN4TGpFZBn6L9UdFR_WUaduFg/triarea.png\" />\n<p>\n  Assume the integer part of <b>A</b>/<b>M</b> is k, we have kM &le; A &le;\n  (k+1)M. Denote S(XYZ) the area of triangle &Delta;XYZ. Clearly 2S(ABC) = kM\n  and 2S(ABC') = (k+1)M. Now take a point C* from your pocket, put it on C, and\n  move it up towards C', one unit at a time. What can we say about the quantity\n  2S(ABC*)?\n</p>\n<ul>\n  <li>It starts with kM and ends with (k+1)M.</li>\n  <li>\n    It is monotone increasing because the distance from C* to AB is monotone.\n  </li>\n  <li>It is always an integer.</li>\n  <li>The journey takes exactly <b>M</b> steps.</li>\n</ul>\n<p>\n  Putting these together, the simple conclusion is that 2S(ABC*) will hit every\n  integer between kM and (k+1)M, including <b>A</b>.\n</p>\n<h3>Exercises</h3>\n<p>\n  (1) For the careful readers, there is one more thing we did not prove yet.\n  There is no way to form a triangle on the graph paper with an area bigger than\n  <b>MN</b>/2. Find a simple reason for this.\n</p><p>\n  (2) We argued that 2S(ABC*) must hit <b>A</b> because it will hit every\n  integer between kM and (k+1)M. Reason directly that, while C* is moving\n  upward, S(ABC*) will increase by 0.5 every time C* moves one unit higher.\n</p>\n","id":"0000000000432bd5","statement":"<h3>Problem</h3>\n<p>\n  Ten-year-old Tangor has just discovered how to compute the area of a triangle.\n  Being a bright boy, he is amazed by how many different ways one can compute\n  the area. He also convinced himself that, if all the points of the triangle\n  have integer coordinates, then the triangle's area is always either an integer\n  or half of an integer! Isn't that nice?\n</p><p>\n  But today Tangor is trying to go in the opposite direction. Instead of taking\n  a triangle and computing its area, he is taking an integer <b>A</b> and trying\n  to draw a triangle of area <nobr><b>A</b>/2</nobr>. He restricts himself to\n  using only the integer points on his graph paper for the triangle's vertices.\n</p><p>\n  More precisely, the sheet of graph paper is divided into an\n  <nobr><b>N</b> by <b>M</b></nobr> grid of square cells. The triangle's\n  vertices may only be placed in the corners of those cells. If you imagine a\n  coordinate system on the paper, then these points are of the form (<b>x</b>,\n  <b>y</b>), where <b>x</b> and <b>y</b> are integers such that\n  <nobr>0 &le; <b>x</b> &le; <b>N</b></nobr> and\n  <nobr>0 &le; <b>y</b> &le; <b>M</b></nobr\n  >.\n</p><p>\n  Given the integer <b>A</b>, help Tangor find three integer points on the sheet\n  of graph paper such that the area of the triangle formed by those points is\n  exactly <nobr><b>A</b>/2</nobr>, if that is possible. In case there is more\n  than one way to do this, any solution will make him happy.\n</p>\n\n<h3>Input</h3>\n<p>\n  One line containing an integer <b>C</b>, the number of test cases in the input\n  file.\n</p><p>\n  The next <b>C</b> lines will each contain three integers <b>N</b>, <b>M</b>,\n  and <b>A</b>, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line. If there is no way to satisfy the\n  condition, output\n</p>\n<pre>\nCase #k: IMPOSSIBLE\n</pre>\n<p>\n  where k is the case number, starting from 1. Otherwise, output\n</p>\n<pre>\nCase #k: x<sub>1</sub> y<sub>1</sub> x<sub>2</sub> y<sub>2</sub> x<sub>3</sub> y<sub>3</sub>\n</pre>\n<p>\n  where k is the case number and (x<sub>1</sub>, y<sub>1</sub>), (x<sub>2</sub>,\n  y<sub>2</sub>), (x<sub>3</sub>, y<sub>3</sub>) are any three integer points on\n  the graph paper that form a triangle of area <b>A</b>/2.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  0 &le; <b>C</b> &le; 1000<br>\n  1 &le; <b>A</b> &le; 10<sup>8</sup>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 50<br>\n  1 &le; <b>M</b> &le; 50\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10000<br>\n  1 &le; <b>M</b> &le; 10000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1 1 1\n1 2 64\n10 10 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 0 0 1 1 1\nCase #2: IMPOSSIBLE\nCase #3: 1 1 2 3 5 8\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Triangle Areas","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This is an easy exercise in dynamic programming.\n</p><p>\n  Let us define for each node v in the tree, <nobr>F(v, x)</nobr> to be the\n  smallest number of gates we need to flip in order to make the output of v be x\n  (0 or 1). The value F(v, x) can be computed using dynamic programming as\n  follows.<br>\n  If v is a leaf with input value 0, then F(v, 0) = 0 -- no gate needs to be\n  changed; and F(v, 1) can be assigned to -1 or some really big value to\n  indicate \"mission impossible\".<br>\n  If v has two children, u and w, and the gate at v is OR, then F(v, 0) can be\n  computed by taking the better of the following options.\n</p>\n<ol>\n  <li>Do not change the gate and use the plan for F(u, 0) and F(w, 0);</li>\n  <li>Change the gate to AND and use the plan for F(u, 0);</li>\n  <li>Change the gate to AND and use the plan for F(w, 0).</li>\n</ol>\n\n<p>\n  So\n</p>\n<blockquote>\n  F(v, 0) = min{ F(u, 0) + F(w, 0), 1 + F(u, 0), 1 + F(w, 0) }.\n</blockquote>\n<p>\n  The other cases are similar. One can compute the F values iteratively\n  bottom-up or recursively top-down.\n</p><p>\n  In addition to the solution above, we introduce some interesting observations.\n  Look closely at the formula above. Suppose we want the output 0 at the top,\n  when you start a top-down computation, you will only use values F(_, 0) and\n  never use any F(_, 1). Similarly, if the desired output at the top is 1, you\n  will never need to care about the values for F(_, 0). Furthermore, in\n  computing F(v, 1), you never want to change an OR gate to an AND gate. The\n  deep reason for these is that, when there is no negation gate involved, the\n  circuit computes a monotone function, and you will never want to change an\n  output from 1 to 0 in the middle.<br>\n  By de Morgan's law, if we interchange all the input values, change all the\n  gates to the opposite type, and change the desired output from 0 to 1 (or 1 to\n  0), we obtain a dual problem, and the minimum number of gates one needs to\n  change remains the same. So we can assume that the desired value is 1 (or 0,\n  depends on your taste), and forget about implementing half of the cases.\n</p>\n","id":"000000000043314e","statement":"<h3>Problem</h3>\n<p>\n  For this problem we will consider a type of binary tree that we will call a\n  boolean tree. In this tree, every row is completely filled, except possibly\n  the last (deepest) row, and the nodes in the last row are as far to the left\n  as possible. Additionally, every node in the tree will either have 0 or 2\n  children.\n</p><p>\n  What makes a boolean tree special is that each node has a boolean value\n  associated with it, 1 or 0. In addition, each interior node has either an\n  \"AND\" or an \"OR\" gate associated with it. The value of an \"AND\" gate node is\n  given by the logical AND of its two children's values. The value of an \"OR\"\n  gate likewise is given by the logical OR of its two children's values. The\n  value of all of the leaf nodes will be given as input so that the value of all\n  nodes can be calculated up the tree.\n</p><p>\n  The root of the tree is of particular interest to us. We would really like for\n  the root to have the value <b>V</b>, either 1 or 0. Unfortunately, this may\n  not be the value the root actually has. Luckily for us, we can cheat and\n  change the type of gate for some of the nodes; we can change an AND gate to an\n  OR gate or an OR gate to an AND gate.\n</p><p>\n  Given a description of a boolean tree and what gates can be changed, find the\n  minimum number of gates that need to be changed to make the value of the root\n  node <b>V</b>. If this is impossible, output \"IMPOSSIBLE\" (quotes for\n  clarity).\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input file contains the number of cases, <b>N</b>.\n  <b>N</b> test cases follow.\n</p><p>\n  Each case begins with <b>M</b> and <b>V</b>. <b>M</b> represents the number of\n  nodes in the tree and will be odd to ensure all nodes have 0 or 2 children.\n  <b>V</b> is the desired value for the root node, 0 or 1.\n</p><p>\n  <b>M</b> lines follow describing each of the tree's nodes. The X<sup>th</sup>\n  line will describe node X, starting with node 1 on the first line.\n</p><p>\n  The first (<b>M</b>&minus;1)/2 lines describe the interior nodes. Each line\n  contains <b>G</b> and <b>C</b>, each being either 0 or 1. If <b>G</b> is 1\n  then the gate for this node is an AND gate, otherwise it is an OR gate. If\n  <b>C</b> is 1 then the gate for this node is changeable, otherwise it is not.\n  Interior node X has nodes 2X and 2X+1 as children.\n</p><p>\n  The next (<b>M</b>+1)/2 lines describe the leaf nodes. Each line contains one\n  value <b>I</b>, 0 or 1, the value of the leaf node.\n</p><p>\n  To help visualize, here is a picture of the tree in the first sample input.<br>\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0I_63IqzkWAtwq5U4_2OSVOFqtddVFNTiGMhRnaFvVGPZoysdTV6Y7roVZ6tjGdfeGMH1GR3HtofA/booleantree.png\" />\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, you should output:\n</p>\n<pre>Case #<b>X</b>: <b>Y</b></pre>\n<p>\n  where <b>X</b> is the number of the test case and <b>Y</b> is the minimum\n  number of gates that must be changed to make the output of the root node\n  <b>V</b>, or \"IMPOSSIBLE\" (quotes for clarity) if this is impossible.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &lt; <b>N</b> &le; 20\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  2 &lt; <b>M</b> &lt; 30\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  2 &lt; <b>M</b> &lt; 10000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n9 1\n1 0\n1 1\n1 1\n0 0\n1\n0\n1\n0\n1\n5 0\n1 1\n0 0\n1\n1\n0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In case 1, we can change the gate on node 3 to an OR gate to achieve the\n  desired result at the root.<br>\n  In case 2, only the root can be changed but changing it to an OR gate does\n  not help.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Cheating a Boolean Tree","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432cc0","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
