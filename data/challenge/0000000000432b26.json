{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1252726200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432b26","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1A was the first round of Code Jam 2009 in which contestants competed simultaneously; and what a job they did!  2499 contestants submitted at least one attempt, using a total of 25 different languages and solving a total of 3543 inputs.  </p>\n<p>\nProblems A-large, B and C were all tough, and solving A-small alone in the first 45 minutes was enough to allow several contestants to advance.  Only 64 contestants successfully solved every problem in this tough set.  Congratulations to them, and to the top 1000, who advanced to Round 2!\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Multi-base happiness</i> Written by Tyler Neylon. Prepared by Xiaomin Chen and Daniel Rocha.</p>\n<p>Problem B. <i>Crossing the Road</i> Written by Mohamed Eldawy. Prepared by Bartholomew Furrow.</p>\n<p>Problem C. <i>Collecting Cards</i> Written by Derek Kisman. Prepared by Frank Chu.</p>\n<p>Contest analysis presented by Xiaomin Chen, Bartholomew Furrow, and Pablo Dal Lago.</p>\n<p>Solutions and other problem preparation provided by Marius Andrei, Tomek Czajka, Ante Derek, John Dethridge, Petr Mitrichev, F&aacute;bio Moreira, and Igor Naverniouk.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1252717200000,"tasks":[{"analysis":"<p>This problems requires some basic knowledge of probability and combinatorics. We want to calculate the expected number of packs we need to buy to obtain all C different cards.</p>\n\n<p>Let's denote by E(<i>x</i>) the expected number of packs we would need to buy if we started with <i>x</i> different cards (it doesn't matter what those cards are). The answer to the problem is the value for E(0). We also know that  E(C) = 0, because if we already have C different cards we don't need\nto buy any additional packs.</p>\n\n<p>We can derive useful equations for other values of E(<i>x</i>) by thinking about all the possible outcomes after buying one additional pack. Let's call T(<i>x</i>,<i>y</i>) the probability of ending up with <i>y</i> different cards after opening a new pack. Then we have the following equation for E(<i>x</i>):</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1nNFN-palgDaa-Leg5WvUWwqXfi1Raipv5vu6DdJxJBQfrc2tV5ha50YqNa_8eVx4/f1.png\"/>\n\n<p>We need to buy at least one new pack, so that's where the 1 comes from.\nThe expected number of packs we need to buy after that depends on how many\nnew cards we get. If we end up with <i>y</i> different cards we need\nto add the expected number of packs to reach C starting from <i>y</i>, which we called E(<i>y</i>), multiplied by the probability of this particular alternative given by T(<i>x</i>, <i>y</i>).</p>\n\n<p> All these equations put together form a system of linear equations with an upper triangular matrix which can be solved using the standard <a href=\"http://en.wikipedia.org/wiki/Back_substitution\" target=\"_blank\">back substitution</a> method.</p>\n\n<p>But we still haven't said how to calculate the entries of the matrix T (that is, the values of T(<i>x</i>, <i>y</i>) for all different <i>x</i> and <i>y</i>). We'll calculate this with the help of <a href=\"http://en.wikipedia.org/wiki/Binomial_coefficients\" target=\"_blank\">binomial coefficients</a>: the number of different possible packs is <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2xymua4DV3G0RsH3n7DGeKdy7TPy1EMo-GAIEI6RZiy7ANrLaO5sRUwgCzE98Jm44/e1.png\"/>. To end up with <i>y</i> different cards, we need to choose y-x out of C-x possible new cards, and the remaining N-(y-x) have to be chosen from the x cards we already have. The answer then is:</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1eQ2Y_SNSh708uINjTHCRE-FoJ8lmp_cORKWbcAOQ1zST6i1peAhzId4Q3bWQV904/f3.png\">\n\n<p>(For those with some knowledge of probability, this is called the\n<a href=\"http://en.wikipedia.org/wiki/Hypergeometric_distribution\" target=\"_blank\">hypergeometric distribution</a>).</p>\n\n<p>\nThe special case, where N = 1, is the well known <a href=\"http://www.google.com/search?q=coupon+collector+problem\" target=\"_blank\">coupon collector's problem</a>.\n</p>\n","id":"0000000000432bd9","statement":"<h3>Problem</h3>\n<p>\nYou've become addicted to the latest craze in collectible card games, PokeCraft: The Gathering.  You've mastered the rules!  You've crafted balanced, offensive, and defensive decks!  You argue the merits of various cards on Internet forums!  You compete in tournaments!  And now, as they just announced their huge new set of cards coming in the year 2010, you've decided you'd like to collect every last one of them!  Fortunately, the one remaining sane part of your brain is wondering: how much will this cost?\n</p>\n<p>\nThere are <b>C</b> kinds of card in the coming set.  The cards are going to be sold in \"booster packs\", each of which contains <b>N</b> cards of different kinds. There are many possible combinations for a booster pack where no card is repeated. When you pay for one pack, you will get any of the possible combinations with equal probability. You buy packs one by one, until you own all the <b>C</b> kinds. What is the expected (average) number of booster packs you will need to buy?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of input gives the number of cases, <b>T</b>.  <b>T</b> test cases follow, each consisting of a line containing <b>C</b> and <b>N</b>.<br>\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line in the form\n<pre>\nCase #x: E\n</pre>\nwhere <b>x</b> is the case number,starting from 1, and <b>E</b> is the expected number of booster packs you will need to buy. Any answer with a relative or absolute error at most 10<sup>-5</sup> will be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100<br/>\n</p>\n\n<h3>Small dataset</h3>\n<p>\n1 &le; <b>N</b> &le; <b>C</b> &le; 10<br/>\n</p>\n\n<h3>Large dataset</h3>\n<p>\n1 &le; <b>N</b> &le; <b>C</b> &le; 40<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2 1\n3 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3.0000000\nCase #2: 2.5000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Collecting Cards","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nHow can you tell if a number is unhappy?  You can tell if it enters a cycle when you apply the process described in the problem. Here is one example, in base 10:\n<pre>\n42 &rarr; 20 &rarr; 4 &rarr; 16 &rarr; 37 &rarr; 58 &rarr; 89 &rarr; 145 &rarr; 42 repeated\n</pre>\nNaturally, x &rarr; y denotes that y is the next number if we apply the process on x. Starting from any number, if you apply the process, eventually you will reach 1 or enter one of those cycles.\n</p>\n<p>\nBut is that really true? A careful reader might ask: Couldn't the process keep hitting new numbers, and never enter a cycle? Look at the cycle for 42: Before you hit 42 again, the numbers just jump around without a clear pattern.\n</p>\n<p>\nIt turns out that this can never happen: that there are only finitely many such cycles, and they're all finite in length.  In fact, in base 10, this is the only one!  All the numbers involved in such a cycle must be reasonably small. Indeed, when you start a number that is big (think about 99999..9999), applying the process will lead to numbers that become smaller and smaller very rapidly. One can easily prove that, in any base B, there is a threshold H of O(B<sup>3</sup>) such that any number larger than H will have a smaller successor.\n</p>\n<p>\nAnother question is: Given a set of bases, does there exist a number that is happy in all of them? We don't know the answer to that question, but based on our computation we know such numbers exist for all bases up to 10. On the other hand, if you intuit that the property of a number being happy is <i>somehow</i> random, and <i>somehow</i> independent across different bases, then you can believe that multi-base happiness is rare, and that the density of such numbers decreases exponentially with the number of bases. In our problem. The smallest happy number for the input (2, 3, 4, 5, 6, 7, 8, 9, 10) is 11814485; just barely affordable with a brute-force search.\n</p>\n<p>\nIn the computation, one obvious trick is to cache, for a pair (x, B), whether x is happy in base B, so we can avoid following the jumping sequence or the cycles every time. We only need to do this for small values of x -- for example all x &le; 1000 would be more than enough -- since any 32-bit integer bigger than 10000 becomes smaller than 1000 in one step.<br/>\nSince the maximum base is 10, one may realize that there are only 2<sup>9</sup> - 10 = 502 possible distinct inputs. So why don't we just calculate them all? This can actually be faster than solving the input cases one by one, if we solve the smaller sets first. For a set S of bases, we do not need to start the search from 2; we can start from the answer for any S' &sub; S, since a number happy in all bases from S is at least happy in all bases from S'.\n</p>\n<p>\nIf you think your implementation is still not fast enough. Then run your program while you are solving other problems. There are only 502 possible input cases. Solve all of them, produce the list of answers, and then start the submission process; just don't forget you also need to submit the slow program that produced the list. This is why we had a special note at the bottom of the problem statement.\n</p>\n\n<br/>\n<h3>More Information</h3>\n<p>\nWikipedia article: <a href=\"http://en.wikipedia.org/wiki/Happy_number\" target=\"_blank\">Happy Numbers</a>\n</p>\n\n\n","id":"0000000000432cc5","statement":"<h3>Problem</h3>\n\n<p>Given an integer N, replace it by the sum of the squares of its digits. A happy number is a number where, if you apply this process repeatedly, it eventually results in the number 1. For example, if you start with 82:</p>\n\n<pre>\n8*8 + 2*2       = 64 + 4    = 68,  repeat:\n6*6 + 8*8       = 36 + 64   = 100, repeat:\n1*1 + 0*0 + 0*0 = 1 + 0 + 0 = 1 (happy! :)\n</pre>\n<p>Since this process resulted in 1, 82 is a happy number.</p>\n\n<p>Notice that a number might be happy in some bases, but not happy in others. For instance, the base 10 number 82 is not a happy number when written in base 3 (as 10001).</p>\n\n<p>You are one of the world's top number detectives. Some of the bases got together (yes, they are organized!) and hired you for an important task: find out what's the smallest integer number that's greater than 1 and is happy in all the given bases.</p>\n\n<h3>Input</h3>\n\n<p>The first line of input gives the number of cases <b>T</b>. <b>T</b> test cases follow. Each case consists of a single line. Each line contains a space separated list of distinct integers, representing the bases. The list of bases is always in increasing order.\n\n<h3>Output</h3>\n\n<p>For each test case, output: <pre>Case #<b>X</b>: <b>K</b></pre> where <b>X</b> is the test case number, starting from 1, and <b>K</b> is the decimal representation of the smallest integer (greater than 1) which is happy in all of the given bases.\n\n<h3>Limits</h3>\n<p>\nTime limit: 60 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>2 &le; all possible input bases &le; 10</p>\n<h3>Small dataset</h3>\n<p>1 &le; <b>T</b> &le; 42</p>\n<p>2 &le; number of bases on each test case &le; 3</p>\n<h3>Large dataset</h3>\n<p>1 &le; <b>T</b> &le; 500</p>\n<p>2 &le; number of bases on each test case &le; 9</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 3\n2 3 7\n9 10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 143\nCase #3: 91\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Important Note</h3>\n<p>Please remember that you must submit all code used to solve the problem.</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Multi-base happiness","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nA grid of roads; a person moving from place to place; this problem has all the hallmarks of a graph problem, and a shortest path problem at that.  Our pedestrian is trying to get from one corner of the map to the opposite corner.  Some steps that she takes can be made at any time, and take 2 minutes; for others, she has to wait until the light turns green, and then take another minute.  How can we minimize the time she takes to reach her goal?\n</p>\n<p>\nTo solve this problem, we need to describe the state of the world.  The pedestrian can be in any of 2m positions in the x direction, in any of 2n positions in the y direction, and at some time t. Since the pedestrian can always just wait if she needs to, she would always prefer to be at (x, y, t) over (x, y, t+1); so an algorithm for computing the <i>earliest</i> time at which the pedestrian can arrive at (x, y) will solve this problem.\n</p>\n<p>\nThis problem differs from a standard graph problem in that, for two neighboring locations across a road from one another, the weight of the edge between them is not fixed. As it turns out this is only a minor complication, and we can use slightly modified versions of some standard shortest-path algorithms.\n</p>\n<p>\nFrom each location, the pedestrian can go north, south, east or west, unless the direction in question is off the edge of the map.  The amount of time this takes will be 2 minutes if it's along a block, or (the amount of time until the traffic light is green) + 1 minute if it's to cross a road.\n</p>\n<p>\nBellman-Ford is probably the easiest algorithm to implement for this. The longest path will take at most O(m+n) steps, so your algorithm will terminate in at most that many stages. At each stage, for each point, you'll try to update its (up to) four neighbors. The running time is O(nm(n+m)).\n</p>\n<p>\nDijkstra's algorithm is usually more efficient. With 4nm states and 4 directions in which the pedestrian can move from each state, this algorithm will complete in O(nm log(nm)) time.</p>\n<p>\nThe correctness of either algorithm can be proved in almost the same way as its standard counterpart. We leave these proofs as worthy exercises for the reader.\n</p>\n\n<h3>More information:</h3>\n<p>\n<a href=\"http://www.google.com/search?q=dijkstra's+algorithm\" target=\"_blank\">Dijkstra's algorithm</a> - \n<a href=\"http://www.google.com/search?q=bellman-ford+algorithm\" target=\"_blank\">Bellman-Ford algorithm</a>\n</p>\n","id":"0000000000433155","statement":"<h3>Problem</h3>\n\n<p>Where roads intersect, there are often traffic lights that tell pedestrians (people walking) when they should cross the street.  A clever pedestrian may try to optimize her path through a city based on when those lights turn green.</p>\n<p>The city in this problem is a grid, <b>N</b> rows tall by <b>M</b> columns wide.  Our pedestrian wants to get from the northeast corner of the southwest block to the southwest corner of the northeast block.  Your objective is to help her find her way from corner to corner in the fastest way possible.</p>\n<p>The pedestrian can cross a street in 1 minute, but only if the traffic light is green for the entire crossing.  The pedestrian can move between two streets, along one edge of a block, in 2 minutes.  The pedestrian can only move along the edges of the block; she cannot move diagonally from one corner of a block to the opposite corner.</p>\n<br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0Iza8A-InWyIZB3uq3DcPT5cb5_3h4PzTDEXyRsvqCPeYUIYtQcMpO8R4KUSLdNN12p5Xy/cross3.png\"/>\n<br/><br/><br/>\n<p>Traffic lights follow the following pattern: at intersection <i>i</i>, the north-south lights stay green for <b>S<sub>i</sub></b> minutes, while the east-west lights stay red.  Then the north-south lights turn red, the east-west lights turn green, and they stay that way for <b>W<sub>i</sub></b> minutes.  Then they start the same cycle again.  The pedestrian starts moving at t=0 minutes; traffic light i starts a cycle by turning green in the north-south direction at t=<b>T<sub>i</sub></b> minutes.  There are cycles before t=T<sub>i</sub> as well.</p>\n<p>For example, intersection 0 could have the following values:</p>\n<p><code>\nS<sub>0</sub> = 3, W<sub>0</sub> = 2, T<sub>0</sub> = 0<br/>\n</code></p>\n<p>The north-south direction turns green after 0 minutes.  That lasts 3 minutes, during which time the pedestrian can cross in the north-south direction and not the east-west direction.  Then the lights switch, and for the next 2 minutes the pedestrian can cross in the east-west direction and not the north-south direction.  Then, 5 minutes after it started, the cycle starts again.  This is exactly the same as the following configuration:\n<p><code>\nS<sub>0</sub> = 3, W<sub>0</sub> = 2, T<sub>0</sub> = 10<br/>\n</code></p>\n\n<h3>Input</h3>\n<p>The first line in the input contains the number of test cases, <b>C</b>.  This is followed by <b>C</b> test cases in the following format:</p>\n<p>A single line containing \"<b>N</b> <b>M</b>\", where <b>N</b> and <b>M</b> are the number of horizontal roads (rows) and vertical roads (columns), as above.  This is followed by <b>N</b> lines.  The <i>i</i>th of those lines contains information about intersections on the <i>i</i>th row, where the 0th row is the northmost.  Each of those lines will contain 3<b>M</b> integers, separated by spaces, in the following form:</p>\n<p><code>\nS<sub>i,0</sub> W<sub>i,0</sub> T<sub>i,0</sub> S<sub>i,1</sub> W<sub>i,1</sub> T<sub>i,1</sub>... S<sub>i,M-1</sub> W<sub>i,M-1</sub> T<sub>i,M-1</sub>\n</code></p>\n<p><b>S</b><sub>i,j</sub>, <b>W</b><sub>i,j</sub> and <b>T</b><sub>i,j</sub> all refer to the intersection in the ith row from the north and the jth column from the west.</p>\n\n<h3>Output</h3>\n<p>For each test case, output a single line containing the text \"Case #x: t\", where x is the number of the test case and t is the minimum number of minutes it takes the pedestrian to get from the southwest corner to the northeast corner.</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n</p>\n<b>C</b>, <b>N</b>, <b>M</b>, <b>S</b><sub>i,j</sub>, <b>W</b><sub>i,j</sub>, <b>T</b><sub>i,j</sub> are all non-negative integers.<br/>\n<b>C</b> &le; 100<br/>\n\n<h3>Small Input</h3>\n1 &le; <b>N</b>, <b>M</b> &le; 3<br/>\n0 &lt; <b>S</b><sub>i,j</sub>, <b>W</b><sub>i,j</sub> &le; 10<br/>\n0 &le; <b>T</b><sub>i,j</sub> &le; 20<br/>\n\n<h3>Large Input</h3>\n1 &le; <b>N</b>, <b>M</b> &le; 20<br/>\n0 &lt; <b>S</b><sub>i,j</sub>, <b>W</b><sub>i,j</sub> &le; 10<sup>7</sup><br/>\n0 &le; <b>T</b><sub>i,j</sub> &le; 10<sup>8</sup><br/>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0vu4ElFaCusobGfOnN9WC29vr2D_8qNwhdGoK-O-VjQmJO2km6W81C5sK7O9S4cbIetTxJu10GGrn6ULgWBQSBGTjNeQBcIiwzCQO6VH1f1Q/crossing_the_road_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n1 1\n3 2 10\n1 2\n1 5 3 1 5 2\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0e4e-r6kK1watfgN-l6Q6QgZs1wQFPX3COhIQ_YXIeS86buaw-_EWXJcSAWLg48wHXGsO7oNC2-G-IVSFxSxOwg5X8TlrZePS5bGNWdojWfUo/crossing_the_road_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 4\nCase #2: 7\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<h3>Explanation</h3>\n<p>The first case is described above.  The pedestrian crosses to the North (1 minute), waits 2 minutes and then crosses to the East (1 minute), for a total of 4 minutes.</p>\n<p>The second case is depicted in the diagram below.  The pedestrian crosses to the East (1 minute), waits 2 minutes and crosses to the North (1 minute).  Then she walks east a block (2 minutes) and crosses to the East (1 minute) for a total of 7 minutes.</p>\n<br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3DSmEhtIpylccmzWzy98EhTjthbdxHvtOkcRuqMj89IrfB3CUX0oAd8OtqkvBIOJ2C6lU/cross.png\"/>\n<br/><br/>\n<br/>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Crossing the Road","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432b26","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2009"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
