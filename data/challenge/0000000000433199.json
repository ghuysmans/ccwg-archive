{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1306063800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433199","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1C started off with hundreds of submissions to problem A. Soon after, solutions to C-small started pouring in. Many contestants noticed the low point value of C-small and solved it with a quick brute force solution.\n</p>\n\n<p>\nAt the 25 minute mark, solutions to problem B began appearing at the top of the scoreboard. Burunduk1 took the lead, followed by wangyongliang and anton.akhi.\n</p>\n\n<p>\nProblem C-large proved to be very difficult. It was a choice between risking a time-out with BigInteger and risking overflow with int64. After more than 100 contestants had attempted C-large unsuccessfully, meshanya was the first to solve it, 52 minutes into the contest, but had yet to start on problem B.\n</p>\n\n<p>Burunduk1 followed a minute later with the second correct C-large and retook his first place. Ten minutes later, mystic solved C-large and grabbed second place. Soon after, yuhch123 submitted the 4th correct C-large (out of over 300 attempts by that point) and took 3rd.\n</p>\n\n<p>\nThe competition for top 1000 was fierce. The minimum score to advance ended up being 40, which meant solving at least problem A and both of the other smalls with at least 30 minutes left to go.\n</p>\n\n<p>\nCongratulations to all 3000 advancers. Good luck in Round 2!\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Square Tiles</i> Written and prepared by David Arthur.</p>\n<p>Problem B. <i>Space Emergency</i> Written by Bartholomew Furrow and prepared by Jorge Bernadas Saragoza.</p>\n<p>Problem C. <i>Perfect Harmony</i> Written by Onufry Wojtaszczyk and prepared by Igor Naverniouk.</p>\n<p>Contest analysis presented by Jorge Bernadas Saragoza, Bartholomew Furrow and Onufry Wojtaszczyk.</p>\n<p>Solutions and other problem preparation by Tomek Czajka, Stephen Fulwider, John Dethridge, Luka Kalinovcic and Kuang-che Wu.\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1306054800000,"tasks":[{"analysis":"<p>\nThis problem turned out to be very, very tricky, due to a number of cases to consider and the possibility of integer overflow. Thus, we will go over the solution with some care.\n</p>\n\n<p>\nTo solve the small data set for this problem, it is enough to iterate over all notes that can be played by Jeff, and for each of them check whether it is in harmony with all the other notes. Note that there are two cases to consider for each note - either its frequency has to divide the frequency of Jeff's note, or it has to be divisible by it.\n</p>\n\n<p>\nFor the large data set, this strategy will not be sufficient - there are too many notes that Jeff can play to check.\n</p>\n\n<p>\nWe will begin by sorting all the input frequencies. Now assume that the frequency of the note that Jeff will play (let us denote it by <b>F</b>) is somewhere between frequencies <b>f<sub>k</sub></b> and <b>f<sub>k+1</sub></b>. This means, in particular, that all the frequencies <b>f<sub>1</sub></b>, <b>f<sub>2</sub></b>, up to <b>f<sub>k</sub></b> are no larger than <b>F</b>; so <b>F</b> has to be divisible by all of them. This means that <b>F</b> has to be divisible by their Least Common Multiple (which we will denote LCM(<b>f<sub>1</sub></b>, <b>f<sub>2</sub></b>, ..., <b>f<sub>k</sub></b>)). Similarly, <b>F</b> has to divide the Greatest Common Divisor of <b>f<sub>k+1</sub></b> up to <b>f<sub>N</sub></b>.\n</p>\n\n<h3> Calculating the GCDs and LCMs </h3>\n\n<p>\nTo make any use of this information, we need to calculate all the LCMs of sets <b>f<sub>1</sub></b>, ..., <b>f<sub>k</sub></b> up to any <b>k</b>, and also the GCDs of sets <b>f<sub>k+1</sub></b>, ..., <b>f<sub>N</sub></b> for any k. \n</p>\n\n<p>\nLet us recall that the GCD of two numbers <b>a</b> and <b>b</b> can be calculated using the <a href=\"http://en.wikipedia.org/wiki/Euclidean_algorithm\" target=\"_blank\">Euclidean algorithm</a> in O(log(<b>a + b</b>)) time. To calculate the LCM of two numbers, we use the formula LCM(<b>a</b>, <b>b</b>) = <b>a</b> * <b>b</b> / GCD(<b>a</b>, <b>b</b>). Using this, we can calculate all the needed GCDs and LCMs in O(<b>N</b>) GCD operations, inductively. For instance, having already calculated the first <b>k-1</b> LCMs, we calculate the <b>k</b>th as follows: LCM(<b>f<sub>1</sub></b>, ..., <b>f<sub>k</sub></b>) = LCM(LCM(<b>f<sub>1</sub></b>, ..., <b>f<sub>k-1</sub></b>), <b>f<sub>k</sub></b>), and the first of those numbers is already calculated.\n</p>\n\n<p>\nNote that one can also calculate all the GCDs and LCMs directly, in O(<b>N</b><sup>2</sup>) GCD operations. With the limit of 10<sup>4</sup> on GCD this should also run in time.\n</p>\n\n<p>\nOne final comment to make here is that when calculating the LCMs, we should be careful to avoid overflow. It may turn out that the LCM of some of the input frequencies does not fit into a 64-bit integer (in general, the LCM of 10<sup>4</sup> numbers, each up to 16 digits, can have even 160,000 digits!). However, note that Jeff cannot play notes with frequency greater than 10<sup>16</sup>, thus if the LCM of any numbers turns out to be greater than 10<sup>16</sup> (or even greater than <b>H</b>) we can safely replace it by 10<sup>16</sup> + 1 without changing the answer - Jeff will not be able to play a note with a frequency divisible by this LCM anyway. Thus, when we calculate the formula <b>a</b> * <b>b</b> / GCD(<b>a</b>, <b>b</b>) we should first divide any of the two numbers, say <b>a</b>, by the GCD, then check whether the resulting product exceeds <b>H</b> (e.g. by checking whether (<b>H</b> + 1) / <b>b</b> &ge; <b>a</b> / GCD(<b>a</b>, <b>b</b>), and perform the multiplication only if it does not.\n</p>\n\n<h3> Special cases first </h3>\n<p>\nBefore going on, we should also consider that there are two special cases when the analysis above does not apply - when <b>F</b> divides all the input frequencies, and when <b>F</b> is divisible by all of them.\n</p>\n\n<p>\nThere are a number of ways to take care of them. For the first, the easiest is to add another note with frequency 1 to the input. This will not make Jeff's task harder, as any number is divisible by 1, and on the other hand will assure that <b>F</b> is always divisible by at least one of the numbers in the input.\n</p>\n\n<p>\nFor the upper bound, no analogous trick exists (there is no number that is divisible by any <b>F</b> Jeff might choose; one might consider the LCM of all the numbers that Jeff's instrument can play, but this is usually too large. Thus, if we fail to find a solution <b>F</b> lying between any two of the input frequencies, we have to consider this case separately. Fortunately, it is not complicated - if <b>C</b> is the LCM of all the input numbers, then the result will be the smallest multiple of <b>C</b> that is greater or equal <b>L</b>, provided it is no larger than <b>H</b>.\n</p>\n\n<h3> The standard cases </h3>\n<p>\nNotice that as we are looking for the lowest frequency Jeff can play, we can investigate the possibilities one by one - first check if there is a solution between <b>f<sub>1</sub></b> and <b>f<sub>2</sub></b>, if yes - return it (recall that <b>f<sub>1</sub></b> is 1, so there is no solution smaller than <b>f<sub>1</sub></b>). If no solution was found, look between <b>f<sub>2</sub></b> and <b>f<sub>3</sub></b>, and so on. Finally, if no solution is found between <b>f<sub>N-1</sub></b> and <b>f<sub>N</sub></b>, we consider the special case analyzed above.\n</p>\n\n<p>\nNow for the crux of the problem - how can we check (quickly) whether a solution is to be found between <b>f<sub>k</sub></b> and <b>f<sub>k+1</sub></b>? Note that this interval can possibly contain up to 10<sup>16</sup> numbers, so a brute force check is unsatisfactory.\n</p>\n\n<p>\nRecall that if <b>F</b> is between <b>f<sub>k</sub></b> and <b>f<sub>k+1</sub></b>, then it has to divide GCD(<b>f<sub>k+1</sub></b>, ..., <b>f<sub>N</sub></b>) (we will denote this number by <b>D</b>), and it has to be divisible by LCM(<b>f<sub>1</sub></b>, ..., <b>f<sub>k</sub></b>) (we will denote this number by <b>C</b>). Thus, in particular, if <b>C</b> does not divide <b>D</b>, we know there is no solution in this interval.\n</p>\n\n<p>\nThere are two more easy cases to consider. If the intervals [<b>L</b>, <b>H</b>] and [<b>C</b>, <b>D</b>] are disjoint, there is obviously no solution in this interval. If <b>C</b> lies in the interval [<b>L</b>, <b>H</b>] (and divides <b>D</b>, which we already checked), it is obviously the smallest solution in this interval, so we may safely return it.\n</p>\n\n<p>\nNotice that there is at most one interval for which those easy (and in particular, constant time) checks will not suffice. Indeed, if for some <b>k</b> the intervals [<b>L</b>, <b>H</b>] and [<b>C</b>, <b>D</b>] are not disjoint, then for any subsequent interval [<b>C'</b>, <b>D'</b>] obtained for a different <b>k'</b> either <b>C'</b> lies in [<b>L</b>, <b>H</b>], or the two intervals are disjoint, as <b>L</b> &le; <b>D</b> &le; <b>f<sub>k+1</sub></b> &le; <b>C'</b>.\n</p>\n\n<p>\nFinally, we can concentrate on this one interval. We want to find the smallest number <b>F</b> in the interval [<b>L</b>, <b>H</b>] that divides <b>D</b> and is divisible by <b>C</b>. For this, it is enough to consider all the divisors of <b>D</b> and check them one-by-one. The divisors of <b>D</b> can be enumerated in time proportional to the square root of <b>D</b> - for each divisor <b>d</b>, either <b>d</b> or <b>D</b>/<b>d</b> is no larger than the square root of <b>D</b>, thus to find all the divisors we check all the numbers no larger than the square root, and if a number <b>d</b> divides <b>D</b>, we add both <b>d</b> and <b>D</b>/<b>d</b> to the list of divisors. This algorithm returns the divisors almost sorted, so it is easy to consider them in ascending order and find the first that both is divisible by <b>C</b> and falls into the interval [<b>L</b>, <b>H</b>].\n</p>\n\n<h3> Summary </h3>\n<p>\nThis was not an easy problem, and required quite a lot of care and attention. Let us enumerate the steps, to wrap it up:\n</p>\n<ul>\n<li> Sort all the input frequencies (in O(<b>N</b> log <b>N</b>) time) </li>\n<li> Add 1 to the beginning of the list of inputs (in O(1) time :) ) </li>\n<li> Calculate the prefix LCMs and suffix GCDs (in O(<b>N</b>) GCD operations, each taking O(log <b>H</b>) time (as we do not consider results greater than <b>H</b>) </li>\n<li> For each <b>k</b> from 1 to <b>N</b>-1 check whether the appropriate LCM divides the appropriate GCD (if no, proceed to next interval); if the LCM falls into [<b>L</b>, <b>H</b>] (if yes, return the LCM) and whether the intervals [LCM, GCD] and [<b>L</b>, <b>H</b>] intersect (if no, proceed to the next interval). This takes constant time for each interval, so O(<b>N</b>) time in total. </li>\n<li> If we are still analyzing this interval, find all the divisors of the GCD and check them one by one. This takes O(sqrt(<b>H</b>)) time. </li>\n<li> If no answer was found as yet, it remains to check the smallest multiple of the LCM of all the inputs that is greater or equal than <b>L</b>. This is done in constant time.</li>\n</ul>\n\n<p>\nThere are other approaches possible to this problem, too. For instance, one may analyze all the divisors of the largest input frequency, and for each of them use binary search to find the interval that contains it and (in constant time, using precalculated LCMs and GCDs) check whether it is a correct solution. We encourage you to analyze the details of this approach yourself.\n</p>\n","id":"0000000000432b82","statement":"<h3>Problem</h3>\n<p>\nJeff is a part of the great Atlantean orchestra. Each player of the orchestra has already decided what sound will he play (for the sake of simplicity we assume each player plays only one sound). We say two sounds are in harmony if the frequency of any one of them divides the frequency of the other (that's a pretty restrictive idea of harmony, but the Atlanteans are known to be very conservative in music). Jeff knows that the notes played by other players are not necessarily in harmony with each other. He wants his own note to improve the symphony, so he wants to choose his note so that it is in harmony with the notes all the other players play.</p>\n\n<p> Now, this sounds simple (as all the frequencies are positive integers, it would be enough for Jeff to play the note with frequency 1, or, from the other side, the Least Common Multiple of all the other notes), but unfortunately Jeff's instrument has only a limited range of notes available. Help Jeff find out if playing a note harmonious with all others is possible.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case is described by two lines. The first contains three numbers: <b>N</b>, <b>L</b> and <b>H</b>, denoting the number of other players, the lowest and the highest note Jeff's instrument can play. The second line contains <b>N</b> integers denoting the frequencies of notes played by the other players.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is either the string \"NO\" (if Jeff cannot play an appropriate note), or a possible frequency. If there are multiple frequencies Jeff could play, output the lowest one.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 40.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 100.<br/>\n1 &le; L &le; H &le; 10000.<br/>\nAll the frequencies are no larger than 10000.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 10<sup>4</sup>.<br/>\n1 &le; <b>L</b> &le; <b>H</b> &le; 10<sup>16</sup><br/>\nAll the frequencies are no larger than 10<sup>16</sup><br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 2 100\n3 5 7\n4 8 16\n1 20 5 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: NO\nCase #2: 10\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":35}],"title":"Perfect Harmony","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nOne solution for this problem would be to try to put red tiles in all possible ways over the blue tiles and see if at least one possibility leads to all the blue tiles being covered. However, this will not work in time because there are too many combinations to try.\n</p>\n\n<p>\nTo optimize the solution, you have to observe that if there is a solution, the top-most, left-most blue tile in the grid (that is, the left-most tile of all the blue tiles in the top row that contains any blue tiles) must be covered by the left-top corner of some red tile. This is because the tiles at its left and top are white (or non-existent), and so the red tile covering our blue tile cannot extend to the left or upwards of it. Based on this observation, we can solve the problem greedily by putting a red tile over the top-most, left-most blue tile in the only way it can be done. If for some blue tile it is impossible to cover it this way (because the red tile would cover some white tiles or extend outside the picture), then it's impossible to cover the whole board.\n</p>\n\n<p>\nNote that as we are always sure that any red tile we put down is correct (if a solution exists at all), we can just modify the board on the fly, and thus at the same time check for solution existence and retrieve the answer. To illustrate that, here is a C++ function to cover all the blue tiles in a grid and return whether it was possible or not:\n</p>\n\n<pre>\nbool CoverTiles(vector&lt;string&gt;&amp; grid) {\n  const int m = (int)grid.size(), n = (int)grid[0].size();\n  for (int i = 0; i &lt; m; ++i)\n    for (int j = 0; j &lt; n; ++j)\n      if (grid[i][j] == '#') {\n        for (int di = 0; di &lt; 2; ++di)\n          for (int dj = 0; dj &lt; 2; ++dj)\n            if (i + di &lt; m &amp;&amp; j + dj &lt; n &amp;&amp;\n                grid[i + di][j + dj] == '#')\n              grid[i + di][j + dj] = \"/\\\\\"[(di + dj) % 2];\n            else\n              return false;\n      }\n  return true;\n}\n</pre>\n\n<p> Fun fact: the solution does not change if we drop the requirement that red tiles have to cover 2x2 squares of blue tiles - it is still valid if we allow the rotation and arbitrary positioning of the red tiles; the only condition that matters is that red tiles lie only on blue tiles (do not overlap, stick outside the picture or lie on white tiles) and all the blue tiles are covered in the end.</p>","id":"0000000000432dfa","statement":"<h3>Problem</h3>\n<p>\nYou are selling beautiful geometric pictures. Each one consists of 1x1 square tiles arranged into a non-overlapping grid. For example:\n</p>\n<pre>\n    .##..\n    .####\n    .####\n    .##..\n</pre>\n<p>\nBlue tiles are represented by '#' characters, and white tiles are represented by '.' characters. You do not use other colors.\n</p>\n\n<p>\nNot everybody likes blue though, and some customers want you to replace all the blue tiles in your picture with red tiles. Unfortunately, red tiles only come in the larger 2x2 size, which makes this tricky.\n</p>\n\n<p>\nYou can cover any 2x2 square of blue tiles with a single red tile, and then repeat until finished. A red tile cannot overlap another red tile, it cannot cover white tiles, and it cannot go outside the picture. For example, you could add red tiles to the previous picture as follows:\n</p>\n<pre>\n    ./\\..\n    .\\//\\\n    ./\\\\/\n    .\\/..\n</pre>\n<p>\nEach red tile is represented here by a pair of '/' characters in the top-left and bottom-right corners, and a pair of '\\' characters in the other two corners.\n</p>\n\n<p>\nGiven a blue and white picture, can you transform it into a red and white picture in this way?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\n</p>\n\n<p>\nEach test case begins with a line containing <b>R</b> and <b>C</b>, the number of rows and columns in a picture. The next <b>R</b> lines each contain exactly <b>C</b> characters, describing the picture. As above, '#' characters represent blue tiles, and '.' characters represent white tiles.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, first output one line containing \"Case #x:\" where x is the case number (starting from 1).\n</p>\n\n<p>\nIf it is possible to cover the blue tiles with non-overlapping red tiles, output <b>R</b> lines each containing <b>C</b> characters, describing the resulting red and white picture. As above, red tiles should be represented by '/' and '\\' characters, while white tiles are represented by '.' characters. If multiple solutions are possible, you may output any of them.\n</p>\n\n<p>\nIf the task is impossible, output a single line containing the text \"Impossible\" instead.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 20.<br/>\n1 &le; <b>R</b> &le; 6.<br/>\n1 &le; <b>C</b> &le; 6.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 50.<br/>\n1 &le; <b>R</b> &le; 50.<br/>\n1 &le; <b>C</b> &le; 50.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 3\n###\n###\n1 1\n.\n4 5\n.##..\n.####\n.####\n.##..\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\nImpossible\nCase #2:\n.\nCase #3:\n./\\..\n.\\//\\\n./\\\\/\n.\\/..\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Square Tiles","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIn this problem, you have a series of edges to follow and you're given the option of shortening up to <b>L</b> of the edges by a factor of two.  There's one catch: the shortening takes some time to take effect.\n</p>\n<p>\nFortunately, all possible shortenings take the same amount of time, so we can divide our edges into three categories:\n</p>\n<ol>\n<li>Edges that your flagship will pass before any speed boosters can be built.</li>\n<li>Edges whose speed boosters would finish <b>while</b> your flagship is moving along the edge.</li>\n<li>Edges whose speed boosters can be built before your flagship gets there.</li>\n</ol>\n<p>\nGroup 2 only has zero or one members, because we know exactly where your flagship will be when the speed boosters finish building.\n</p>\n<p>\nNow we can decide how useful it is to build a speed booster on each edge. We never want to build speed boosters on group 1, because they won't help.  For each edge in group 3, the benefit is length/2.  For the edge in group 2, the benefit is (distance to the end of the edge from where your flagship will be when the speed booster finishes building)/2.\n</p>\n<p>\nWe choose the <b>L</b> most beneficial edges to build on; if there aren't <b>L</b> beneficial edges, we'll stop when we've built on all the beneficial edges.  Then we compute the total benefit, subtract it from the total time to traverse the whole path, and voil√†!  The answer.\n</p>\n<p>\nThe way in which we specify edges in this problem is periodic: if the input is very large, then there must be a lot of edges with the same lengths.  A clever solution could take advantage of the periodic nature to run very quickly, but the limits were small enough that this shouldn't be necessary; we actually specified the input in this way because it would make the input file smaller, not because we wanted to test that particular skill.\n</p>\n","id":"0000000000432fe3","statement":"<h3>Problem</h3>\n<p>\nThere's an emergency&mdash;in space!  You need to send your fleet's flagship as quickly as possible from star 0 to star <b>N</b>, traveling through the other stars in increasing numerical order along the way (0&rarr;1&rarr;...&rarr;<b>N</b>).  Your flagship normally travels at a speed of 0.5 parsecs per hour.\n</p>\n<p>\nIn addition to sending your flagship, you can order your engineers to build up to <b>L</b> speed boosters at different stars.  Building a speed booster takes <b>t</b> hours, and all <b>L</b> speed boosters can be built in parallel.  While your flagship travels from a star with a completed speed booster to the next star, its speed is 1 parsec per hour.\n</p>\n<p>\nIf a speed booster is completed at a star while your flagship is traveling from that star to the next one, your flagship will start moving faster as soon as the speed booster is completed.\n</p>\n<p>\nHow many hours does it take your flagship to get to star <b>N</b> if you build speed boosters to make it arrive as soon as possible?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each contains integers, <b>L</b>, <b>t</b>, <b>N</b> and <b>C</b>, followed by <b>C</b> integers <b>a<sub>i</sub></b>, all separated by spaces.  <b>a<sub>i</sub></b> is the number of parsecs between star <b>k*C</b>+i and star <b>k*C</b>+i+1, for all integer values of <b>k</b>.\n</p>\n<p>\nFor example, with <b>N</b>=8, <b>C</b>=3, <b>a<sub>0</sub></b>=3, <b>a<sub>1</sub></b>=5 and <b>a<sub>2</sub></b>=4, the distances between stars are [3, 5, 4, 3, 5, 4, 3, 5].\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is a single integer: the number of hours it takes to reach star <b>N</b>. The answer is guaranteed to always be an integer.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>C</b> &le; 1000.<br/>\n<b>C</b> &le; <b>N</b>.<br/>\n1 &le; <b>a<sub>i</sub></b> &le; 10<sup>4</sup>.<br/>\n0 &le; <b>t</b> &le; 10<sup>11</sup>.<br/>\n<b>t</b> is even.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.<br/>\n0 &le; <b>L</b> &le; 2.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 10<sup>6</sup>.<br/>\n0 &le; <b>L</b> &le; N.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2 20 8 2 3 5\n1 4 2 2 10 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 54\nCase #2: 20\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<h3>Explanation</h3>\n<p>\nIn the second case, we can build one speed booster.  The distances between stars are [10, 4].  We build the speed booster on the first star.  After 4 hours, our flagship has gone 2 parsecs and the speed booster is complete.  It takes our flagship another 8 hours to get to star 1, then 8 more hours to get to star 2, our destination.\n</p>\n\n<p>\n<b>Note:</b> This problem takes place in a universe where the speed of light is much higher than 1 parsec per hour, so we don't have to worry about special relativistic effects.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Space Emergency","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433199","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2011"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
