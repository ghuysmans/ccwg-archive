{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1311913800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043319a","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThe Final round turned out to be unusually difficult. Most contestants started with problem A and later realized that repeated simulation would work for E-small. Moving beyond that, however, proved to be a nearly impossible feat.\n</p>\n\n<p>\nThe winner, rng..58, ended up being the only contestant to solve the fiendishly difficult E-large. mystic took second place with B-small and D-small on top of A and E-small. meret came very close to taking the top spot, if not for a failed B-large (caused by a 32-bit int overflow). He finished in third.\n</p>\n\n<p>\nCongratulations to the winners! We hope to see everybody next year. The 2012 finals will be held in New York City!\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Runs</i> Written by Albert Mao and Bartholomew Furrow. Prepared by Jorge Bernadas Saragoza.</p>\n<p>Problem B. <i>Rains Over Atlantis</i> Written by Onufry Wojtaszczyk and Bartholomew Furrow. Prepared by Onufry Wojtaszczyk and Jorge Bernadas Saragoza.</p>\n<p>Problem C. <i>Program within a Program</i> Written by David Arthur and Jorge Bernadas Saragoza. Prepared by Jorge Bernadas Saragoza and David Arthur.</p>\n<p>Problem D. <i>Ace in the Hole</i> Written by David Arthur and Jorge Bernadas Saragoza. Prepared by Bartholomew Furrow.</p>\n<p>Problem E. <i>Google Royale</i> Written by David Arthur and Bartholomew Furrow. Prepared by Onufry Wojtaszczyk.</p>\n<p>Contest analysis by Bartholomew Furrow and David Arthur.</p>\n<p>Solutions and other problem preparation by Jorge Bernadas Saragoza, John Dethridge, Igor Naverniouk, David Arthur, Bartholomew Furrow, Tomek Czajka, and Onufry Wojtaszczyk.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1311899400000,"tasks":[{"analysis":"<p>Here at the Google Code Jam, we have always tried to encourage a variety of programming languages. But in this problem, we took things a little further by forcing you to program in the language that started them all -- the abstract <a href=\"http://www.google.com/search?q=Turing+Machine\" target=\"_blank\">Turing Machine</a>! Unfortunately, abstract Turing Machines are pretty unwieldy, and that makes even the simple task here quite difficult.</p>\n\n<p>With so few rules allowed, it is important to take advantage of the numbers you can mark onto the lampposts. The obvious approach is to write down, perhaps in binary, the number of steps you need to make, and then have the robot makes decisions based on that. Unfortunately, there is also a rather tight limit on the number of moves, which means you cannot afford to keep going back to the start to check on your number. You will need to take the data with you as you move.\n</p>\n\n<p>Here is one effective way of doing this:</p>\n<ul>\n<li>First write down the distance you want to go forward in binary, using the values 1 and 2 to represent the binary digits. This information will now be available on the starting lampposts.\n<li>Now repeat the following:\n<ul>\n<li>Trace through the number from right to left, and subtract 1 as you go.\n<li>If the number was 0, then drop the cake right now.\n<li>Otherwise trace through the number from left to right, copying everything one position to the right.\n</ul>\n</ul>\nOnce you have the high level algorithm, each piece is relatively straightforward to implement. For example, subtracting 1 comes down to formalizing the subtraction algorithm you learned in grade school:\n<ul>\n<li> Start in state 1, which we'll you use to mean you have not yet done the subtraction. If the last digit is 1, you can replace it with 0 and the subtraction is done, so switch to state 2. If the last digit is 0, replace it with 1 but you now need to borrow 1 from the previous digit, so stay in state 1. Either way, move to the previous digit.\n<li> Once you are in state 2, you are just moving left through the number without changing anything.\n<li> If you reach the left end of the number in state 1, then the number must have been 0, so you should drop the cake. Otherwise, you should move onto the copy phase.\n</ul>\n<p>And the copy phase is similar but conceptually simpler.</p>\n\n<p>\nAlmost any implementation of this algorithm should be good enough to solve the problem, but there is room for more optimization if you want a challenge! With the 30-rule limit, we were able to bring the number of steps down to about 95,000. Here is the full program to move 5,000 lampposts:</p>\n\n<pre>\n0 0 -&gt; E 1 1\n1 0 -&gt; E 2 3\n2 0 -&gt; E 3 1\n3 0 -&gt; E 4 3\n4 0 -&gt; E 5 2\n5 0 -&gt; E 6 3\n6 0 -&gt; E 7 1\n7 0 -&gt; E 8 3\n8 0 -&gt; W 9 3\n9 0 -&gt; R\n10 0 -&gt; E 11 0\n9 1 -&gt; W 9 3\n10 1 -&gt; W 10 1\n9 2 -&gt; W 10 1\n10 2 -&gt; W 10 2\n9 3 -&gt; W 10 2\n10 3 -&gt; W 10 3\n11 1 -&gt; E 12 0\n12 0 -&gt; W 9 3\n12 1 -&gt; E 12 1\n12 2 -&gt; E 13 1\n12 3 -&gt; E 14 1\n13 0 -&gt; W 10 1\n13 1 -&gt; E 12 2\n13 2 -&gt; E 13 2\n13 3 -&gt; E 14 2\n14 0 -&gt; W 10 2\n14 1 -&gt; E 12 3\n14 2 -&gt; E 13 3\n14 3 -&gt; E 14 3\n</pre>\n\n<p>Can you do better? We'd love to hear about it if so!</p>\n","id":"0000000000432b83","statement":"<h3>Problem</h3>\n<p>\nYou have a robot on an infinite east-west highway, and it has a cake to deliver. Every mile along the highway, in both directions, there is a lamppost. You want to program the robot to move exactly <b>N</b> lampposts to the east, and release the cake there. The route does not have to be direct, as long as the robot eventually releases the cake in the right place.\n</p>\n\n<p>\nUnfortunately, the robot comes equipped with only very little memory, and it is capable of no advanced logic. To control the robot you will have to give it a very simple program at the start that will get it to release the cake at the proper location. This program must be composed of one or more statements, each of which tells the robot what to do under certain conditions. These statements must be in the following format:\n</p>\n\n<pre>\n&lt;S&gt; &lt;M&gt; -&gt; &lt;action&gt;\n</pre>\n\n<p>\nwhich means that if all of the following conditions are met:\n</p>\n\n<ol>\n<li>The robot is in state <code>S</code>.</li>\n<li>The robot is at a lightpost marked with number <code>M</code>.</li>\n</ol>\n\n<p>\nthen it will perform exactly one of the following actions:\n</p>\n\n<ol>\n<li>\nMark the current post with a new number, change state and move. To do this <code>&lt;action&gt;</code> must be formatted as <code>\"&lt;D&gt; &lt;NS&gt; &lt;NM&gt;\"</code>, where <code>D</code> is the direction to move (use 'W' for west and 'E' for east), <code>NS</code> is the robot's new state and <code>NM</code> is the new mark for the current lightpost.\n</li>\n\n<li>\nRelease the cake at the current position and self-destruct. To do this <code>&lt;action&gt;</code> must be formatted as <code>\"R\"</code>.\n</li>\n</ol>\n\n<p>\nIf you output two or more statements with the same values of <code>S</code> and <code>M</code>, the robot will misbehave and destroy the cake.\n</p>\n\n<p>\nIf at any time the robot is in a state X at a lamppost marked with Y such that there is no statement with <code>S=X</code> and <code>M=Y</code>, then the robot will get confused and eat the cake.\n</p>\n\n<p>\nAll states and marks must be integers with absolute value no greater than one million (10<sup>6</sup>). Assume that initially the robot is in state zero and all lampposts are marked with zero.\n</p>\n\n<p>\nGiven <b>N</b>, write a program so the robot releases the cake in the appropriate place. Your program must use at most 30 statements, and it must terminate within <b>X</b> steps.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case consists of a single line containing an integer <b>N</b>, which indicates the lamppost where the robot must release the cake.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, first output \"Case #x: y\", where x is the number of the test case (starting with 1) and y is the number of statements you will use. Next output y lines, each of which represents a statement for the robot in the format described previously.\n</p>\n\n<p>\n<b>WARNING: Judge's response might take up to 5 seconds longer than usual to appear, because your output is run as part of the validation.</b>\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 15.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n0 &le; <b>N</b> &le; 500.<br/>\n<b>X</b> = 250,000 (2.5 &times; 10<sup>5</sup>).<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n0 &le; <b>N</b> &le; 5000.<br/>\n<b>X</b> = 150,000 (1.5 &times; 10<sup>5</sup>)<br/>\nTime limit: 60 seconds.\n</p>\n\n<!--\nExpected output has an extra line with limits that is not included in users' attempts output,\nso we display sample manually (without \n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n0\n4\n0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">30 250000 -1000000 1000000\nCase #1: 1\n0 0 -&gt; R\nCase #2: 5\n0 0 -&gt; E 1 1\n1 0 -&gt; E 2 1\n2 0 -&gt; E 3 1\n3 0 -&gt; E -1 1\n-1 0 -&gt; R\nCase #3: 3\n0 0 -&gt; E 1 1\n0 1 -&gt; R\n1 0 -&gt; W 0 1\n  </pre>\n  </td></tr></table>\n  </div>\n  ).\n-->\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<code>\n3<br/>\n0<br/>\n4<br/>\n0<br/>\n</code>\n</td>\n<td>\n<code>\nCase #1: 1<br/>\n0 0 -&gt; R<br/>\nCase #2: 5<br/>\n0 0 -&gt; E 1 1<br/>\n1 0 -&gt; E 2 1<br/>\n2 0 -&gt; E 3 1<br/>\n3 0 -&gt; E -1 1<br/>\n-1 0 -&gt; R<br/>\nCase #3: 3<br/>\n0 0 -&gt; E 1 1<br/>\n0 1 -&gt; R<br/>\n1 0 -&gt; W 0 1<br/>\n</code>\n</td></tr></table>\n</div>\n\nIn the first case, the robot is initially in state zero, and there is a zero on the lamppost.  So it executes its only statement, which is to release the cake.\n<p>\nIn the second case, the robot has five states: 0, 1, 2, 3, and -1.  The robot performs the following actions:\n<ul>\n<li>Mark the current lamppost with a 1, move east, and go to state 1.\n<li>Mark the current lamppost with a 1, move east, and go to state 2.\n<li>Mark the current lamppost with a 1, move east, and go to state 3.\n<li>Mark the current lamppost with a 1, move east, and go to state -1.\n<li>Release the cake.\n</ul>\n<p>\nIn the third case, the robot has two states, and performs the following actions:\n<ul>\n<li>Mark the current lamppost with a 1, move east, and go to state 1.\n<li>Mark the current lamppost with a 1, move west, and go to state 0.\n<li>Release the cake.\n</ul>\nNote that the robot takes different actions at the two times it is in state 0, because it sees a different mark each time.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Program within a Program","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nOn a contest made up of unconventional problems, this one stands out as being a little more \"normal\" than the rest. That doesn't make it easy though! The main techniques here are good old-fashioned dynamic programming and counting, but you need to be very good at them to stand a chance.\n</p>\n\n<p>\nThe most important observation is that you cannot afford to build strings from left to right. With 450,000 characters, there is just far too much state to keep track of. The correct approach turns out to be placing all of one character type, then all of the next, and so on. Towards that end, let's define N<sub>c</sub> to be the number of characters of type c, and define X<sub>c,r</sub> to be the number of ways of arranging all characters of type 1, 2, ..., c so that there are exactly r runs. We will compute the X values iteratively using dynamic programming.\n</p>\n\n<p>\nConsider a string S using only the first c - 1 character types, and having r<sub>0</sub> runs. Note that S has exactly M = N<sub>1</sub> + N<sub>2</sub> + ... + N<sub>c-1</sub> characters altogether. Additionally, it has a few different types of \"character boundaries\":\n<ul>\n<li> There is the boundary before the first character and the boundary after the last character. If we add a run of type-c characters in either one of these locations, the total number of runs will increase by 1.</li>\n<li> There are r<sub>0</sub> - 1 boundaries between distinct characters. If we add a run of type-c characters in any one of these locations, the total number of runs will increase by 1.</li>\n<li> There are M - r<sub>0</sub> boundaries between identical characters. If we add a run of type-c characters in any one of these locations, the total number of runs will increase by 2.</li>\n</ul>\nSo let's suppose we add x runs of type-c characters in any one of the r<sub>0</sub> + 1 boundaries from the first two groups, and we add y runs of type-c characters in any of the M - r<sub>0</sub> boundaries from the the third group. There are exactly (r<sub>0</sub> + 1 choose x) * (M - r<sub>0</sub> choose y) ways of choosing these locations, and we will end up with r<sub>0</sub> + x + 2y runs this way. Finally, we need to divide up the N<sub>c</sub> characters of type c into these x + y runs. This can be done in exactly (N<sub>c</sub> - 1 choose x + y - 1) ways. To see why, imagine placing all the runs together. Then we need to choose x + y - 1 run boundaries from N<sub>c</sub> - 1 possible locations. See <a href=\" http://en.wikipedia.org/wiki/Stars_and_bars_(probability)\" target=\"_blank\">here</a> for more information.</p>\n\n<p>\nTherefore, the number of ways of adding all N<sub>c</sub> type-c characters to S so as to get a string with exactly r runs can be calculated as follows:\n<ul>\n<li> Loop over all non-negative integers x, y such that r<sub>0</sub> + x + 2y = r.</li>\n<li> Add (r<sub>0</sub> + 1 choose x) * (M - r<sub>0</sub> choose y) * (N<sub>c</sub> - 1 choose x + y - 1) to a running total.</li>\n<li> After looping over all x, y, this running total will contain the answer we want.</li>\n</ul>\nNote that the answer here depends only on r<sub>0</sub>. Therefore, the total contribution from all strings with r<sub>0</sub> runs is exactly X<sub>c-1,r0</sub> times this quantity. Iterating over all r<sub>0</sub> gives us the recurrence we need for X!</p>\n\n<p>\nThis method is actually quite fast. We can use O(450,000 * 100) time to pre-compute all the choose values. Everything else runs in O(26 * 100<sup>3</sup>) time.\n</p>\n\n<p>\nBy the way, you probably need to calculate the choose values iteratively rather than recursively. 450,000 recursive calls will cause most programs to run out of stack space and crash! Here is a pseudo-code with a sample implementation (modulo operations removed for clarity):\n</p>\n\n<pre>\ndef CountTransitions(M, Nc, r0, r):\n  # Special case: If adding the first batch of characters the\n  # only possible result is to have one run, and there is only\n  # one way to achieve that.\n  if r0 == 0:\n    return r == 1 ? 1 : 0\n  result = 0\n  dr = r - r0\n  for (y = 0; r0 + 2 * y &lt;= r; ++y):\n    x = r - (r0 + 2 * y)\n    nways_select_x = Choose(r0 + 1, x)\n    nways_select_y = Choose(M - r0, y)\n    nways_split = Choose(Nc - 1, x + y - 1)\n    result += nways_select_x * nways_select_y * nways_split\n  return result\n\n\ndef Solve(freq, runs_goal):\n  runs_count = [0 for i in range(0, runs_goal + 1)]\n  runs_count[0] = 1\n  M = 0\n  for i, Nc in enumerate(freq):\n    if Nc &gt; 0:\n      old_runs_count = list(runs_count)\n      runs_count = [0 for i in range(0, runs_goal + 1)]\n      for (r0 = 0; r0 &lt;= runs_goal; ++r0):\n        for (int r = r0 + 1; r &lt;= runs_goal; ++r):\n          nways = CountTransitions(M, Nc, r0, r)\n          runs_count[r] += nways * old_runs_count[r0]\n      M += Nc\n  return runs_count[runs_goal]\n</pre>\n","id":"0000000000432dfb","statement":"<h3>Problem</h3>\n<p>\nI have a string <b>S</b> consisting of lower-case alphabetic characters, 'a'&nbsp;-&nbsp;'z'. Each maximal sequence of contiguous characters that are the same is called a \"run\". For example, \"bookkeeper\" has 7 runs. How many different permutations of <b>S</b> have exactly the same number of runs as <b>S</b>?\n</p>\n<p>\nTwo permutations <code>a</code> and <code>b</code> are considered different if there exists some index <code>i</code> at which they have a different character: <code>a[i]&nbsp;&ne;&nbsp;b[i]</code>.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each contains a single non-empty string of lower-case alphabetic characters, <b>S</b>, the string of interest.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of different permutations of <b>S</b> that have exactly the same number of runs as <b>S</b>, modulo 1000003.  \n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n<b>S</b> is at least 1 character long.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n<b>S</b> is at most 100 characters long.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n<b>S</b> is at most 450000 characters long.<br/>\n<b>S</b> has at most 100 runs.<br/>\nThe input file will not exceed 1 megabyte in size.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\naabcd\nbookkeeper\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 24\nCase #2: 7200\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":16}],"title":"Runs","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p> One obvious solution (which works for small input) is to simulate. \nThe trouble starts when the heights are large, and <b>M</b> is small. Thus, we need to be able to do multiple steps at once.</p>\n\n<p> Begin by noting that, given the current map of heights, we can determine the water levels (i.e., what areas are submerged and what areas are not) using a single run of Dijkstra's shortest path algorithm, in <nobr>RC log(RC)</nobr> time.</p>\n\n<p> We will have a single step procedure. What it does is: </p>\n<ol>\n<li> Calculate water levels for all fields.</li>\n<li> For each field find out if it is submerged; if not, find the lowest water level in the adjacent fields. </li>\n<li> Create a new map in which all the heights are lessened by the appropriate erosion, and increase the day counter by one. </li>\n</ol>\n<p> This is one step of the simulation, which is also needed for the naive solution.</p>\n\n<p> We will also have a multistep procedure, which tries to perform multiple single steps at once, as long as all of the following are true: </p>\n<ul>\n<li>all non-submerged fields erode at maximum speed,</li>\n<li>the water levels of all submerged fields decrease at the same speed, and</li>\n<li>no submerged field becomes un-submerged during these steps.</li>\n</ul>\n\n<p>The multistep procedure will work as follows: </p>\n<ol>\n<li> Calculate the water levels for all fields.</li>\n<li> For each field find out whether it is submerged. If not, find out how much it will erode. If this is not <b>M</b>, break the multistep. Note that we can choose to erode fields to below sea level for simplicity without changing the result. </li>\n<li> If all fields erode at speed <b>M</b>, then the water levels of all \"lakes\" also decrease at this speed. Note that each lake has at least one field on the border which is not submerged, but determines the water level of the lake, and this level will decrease by <b>M</b>. Thus, we can continue repeating steps until some field that was submerged surfaces.</li>\n<li> Thus, we find the submerged field with the smallest amount of water on top, and batch the appropriate number of steps together.</li>\n<li> If there are no submerged fields, then we increment the day counter by ceil(maxheight / M) and finish the algorithm.</li>\n</ol>\n<p>Note that in each multistep one field that was submerged becomes uncovered, and it's easy to see that a field that is not submerged will never become submerged in the future - thus there are at most RC multisteps in the algorithm (actually, fewer because the fields on the edge of the board are never submerged).</p>\n\n<p> Now we want to know how many steps are possible before we can perform a multistep. Define an auxilliary graph that has a node for each un-submerged field. For each lake we join all the fields in this lake to an arbitrary field on the boundary of the lake which defines the water level for the lake (the outlet of the lake). We define natural edges in the graph -- two nodes have an edge if any of the two fields merged into the two nodes were adjacent. For each nodes we can define its \"parent\" to be one of the nodes with the lowest level adjacent to it. Thus, we have a tree, rooted in the external sea. We define any path going upward in the tree to be \"fixed\" if all of the edges along the path have a height difference of at least <b>M</b>.\n</p>\n\n<p>We can now prove that each day either </p>\n<ul>\n<li>a submerged becomes uncovered (thus decreasing the number of multisteps available), or</li>\n<li>the number of vertices that have fixed paths to the root increases, or</li>\n<li>all vertices lie on fixed paths.</li>\n</ul>\n\n<p>If all vertices lie on fixed paths, then we can perform a multistep. As there can be at most RC increases before all vertices are on fixed paths, this means we get at most RC steps and at most one multistep before some field is uncovered, meaning at most (RC)<sup>2</sup> steps and RC multisteps in total, giving a running time of (RC)<sup>3</sup> log(RC). The constants are very small here, so this will easily run in time.</p>\n\n<p> Now consider any fixed path. We assume the node distribution remains the same (i.e. the lakes remain lakes, and nothing gets uncovered). First notice that it remains a fixed path after one day - all of the fields on the path decrease by the same amount, so the differences remain the same. Now take any vertex that is not on a fixed path, but its parent is. Note that the sea level is on a fixed path by definition, so if no such vertex exists, it means that all vertices are on a fixed path. Then after one day the height of this vertex decreases to the height of the parent, while the height of the parent decreases by <b>M</b>. So the new difference is <b>M</b>, meaning that the vertex has joined the fixed path. This ends the proof.</p>\n\n<p> Note that the upper bound can actually be (more or less) hit in the following map with M = 2: take a winding path of length that is on the order of RC, that does not touch itself, like so: </p>\n<br/>\nX X X X X X X<br/>\nP P P P P P X<br/>\nX X X X X P X<br/>\nX P P P P P X<br/>\nX P X X X X X<br/>\nX P P P P P X<br/>\nX X X X X X X<br/>\n\n<p>Where X represent very large values, and P represents the path. Thus, for the foreseeable future, the tree described above is actually the single path marked by Ps.</p>\n\n<p> Now take the following values on the path:\nA, A-2L-1, A+1, A - 4L - 1, A+1, A - 6L - 1, A+1, A - 8L - 1, etc., where L is the length of the path. It is not difficult to check that \"off by one\" changes get propagated up the path with speed one, and each change gets to be fully propagated before the next one kicks in (due to the uncovering of another lake).</p>\n","id":"0000000000432fe4","statement":"<h3>Problem</h3>\n<p>\nRains fall on the isle of Atlantis, and will erode all the land to nothingness. What you want to know, so that you can organize the evacuation, is how soon it will happen.\n</p>\n<p>\nYou have a map of Atlantis.  The map is a square grid, and each square contains the height of the land in that square, in metres, above sea level.  All squares outside the map have height 0; all squares with height 0 are water, and all squares with larger heights are land.  There are no squares with lower height.\n</p>\n<p>\nWater can <i>flow</i> from a source square to a target square if the source square and target square share an edge, and if the height of the water in the target square is lower than or equal to the height of water in the source square.\n</p>\nIt's raining very quickly, which means that if there is nowhere for the rain water in a square to flow, water in that square will accumulate until there is a square to which the rain water can flow.  Squares that are not on the map can accept any amount of flow.  For example, the following map:\n<pre>\n5 9 9 9 9 9\n0 8 9 0 2 5\n3 9 9 9 9 9\n</pre>\nWill quickly fill up with water.  We'll call the height of water in each square, plus the height of the land, the <i>water level</i>.  It will be:\n<pre>\n5 9 9 9 9 9\n0 8 9 <b>5 5</b> 5\n3 9 9 9 9 9\n</pre>\n<p>\nNote that the 0 in the middle of the land, although it's water, is not connected to the outside of the map and so just accumulates water.  The 0 on the border of the land, however, is connected to the outside of the map, and so the water from the 8 can flow through it to the outside.\n</p>\n<p>\nThe direction in which water flows is determined by the water level.  If there are multiple possible squares where water could flow from one particular source square, the water from that source will flow to the square with the lowest water level (ties don't matter, as you will see).\n</p>\n<p>\nNow the erosion begins.  Each day, a square is eroded&mdash;its height decreases&mdash;depending on how water is flowing from it.  If water is flowing from S to T, then S's height decreases by <code>min(WaterLevel(S) - WaterLevel(T), <b>M</b>)</code>.  All erosion happens at exactly the same time, at the end of the day.  For example, with <b>M</b>=5, the map above will erode to:\n</p>\n<pre>\n0 4 4 4 4 4\n0 3 5 0 2 0\n0 4 4 4 4 4\n</pre>\nAfter a day's erosion, excess water will flow away: squares with water level higher than a neighbour's water level will lose water until they are of the same height.  Water will also accumulate in the same way that it did on the first day.  After the first day, this map's water level will become:\n<pre>\n0 4 4 4 4 4\n0 3 5 <b>2</b> 2 0\n0 4 4 4 4 4\n</pre>\nAfter another day of erosion, the map will look like:\n<pre>\n0 0 0 0 0 0\n0 0 2 0 0 0\n0 0 0 0 0 0\n</pre>\n<p>\n...and the Atlanteans will need to escape in a big hurry.  Your task is to determine how many days it will take for all the heights to erode to 0.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case begins with a line containing three space-separated integers: <b>H</b>, <b>W</b> and <b>M</b>. The first two denote the size of the map, while the third is the maximum amount a square can erode in one day, as described above.  <b>H</b> lines follow, each of which contains <b>W</b> space-separated integers.  The i<sup>th</sup> integer on the j<sup>th</sup> line denotes the height of the square at (i, j).\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of days it takes to erode all the island.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 40.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>H</b>, <b>W</b> &le; 10.<br/>\n1 &le; <b>M</b> &le; 100.<br/>\n0 &le; all heights &le; 100.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>H, W</b> &le; 20.<br/>\n1 &le; <b>M</b> &le; 10<sup>15</sup>.<br/>\n0 &le; all heights &le; 10<sup>15</sup>.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 6 5\n5 9 9 9 9 9\n0 8 9 0 2 5\n3 9 9 9 9 9\n3 6 3\n3 8 10 11 10 8\n7 5 2 12 8 8\n6 9 11 9 8 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<p> In the second case, the water height looks like:\n<code><br/>\n3 8 10 11 10 8<br/>\n7 <b>7 7</b> 12 8 8<br/>\n6 9 11 9 8 4<br/>\n</code></p>\n<p>After one day the island looks as follows:\n<code><br/>\n0 5 7 8 7 5<br/>\n4 5 2 9 8 5<br/>\n3 6 8 6 5 1<br/>\n</code></p>\n<p>And after the second day:\n<code><br/>\n0 2 4 5 4 2<br/>\n1 4 2 6 5 2<br/>\n0 3 5 3 2 0<br/>\n</code></p>\n<p>And the third day:\n<code><br/>\n0 0 1 2 1 0 <br/>\n0 1 2 3 2 0 <br/>\n0 0 2 0 0 0 <br/>\n</code> </p>\n<p>After the fourth day, things are looking desperate for the Atlanteans:\n<code><br/>\n0 0 0 0 0 0 <br/>\n0 0 1 0 0 0 <br/>\n0 0 0 0 0 0 <br/>\n</code></p>\n<p> Finally, on the fifth day the last square erodes away. Atlantis lasted for five days; they probably shouldn't have built their city out of brown sugar. </p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Rains Over Atlantis","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>Google Royale is perhaps the most unapproachable problem we have ever posed for the Google Code Jam. It requires a great deal of understanding before any progress at all can be made on the large input. This is because the interaction between winning probability and starting money is rather complicated, and you cannot possibly afford to do a complete search through all 10<sup>16</sup> states. Although the scenario here might seem similar to Millionaire, a previous Code Jam problem, you simply cannot afford the kind of computation that worked there.</p>\n\n<p>First, let's try to understand a betting round. Let the initial bet be <b>y</b>. If you lose k times and then win, your total earnings will be <b>y</b> * 2<sup>k-1</sup> - <b>y</b> * 2<sup>k-2</sup> - <b>y</b> * 2<sup>k-3</sup> - ... - <b>y</b>, which equals <b>y</b> no matter what k is. If you lose, your total earnings will be negative and the exact value will depend on how many times you doubled.</p>\n\n<p>The key to the whole problem is that your <i>expected</i> winnings from a betting round is exactly 0, no matter what your initial bet is and no matter how many times you are willing to double if you keep losing. (Recall that the <i>expected</i> winnings is your \"average\" winnings -- formally it is defined as sum p<sub>i</sub> * i, where p<sub>i</sub> is the probability that you win exactly i dollars.) The expected value is 0 because at each step of each round, you have a 50% chance of winning some money, and a 50% chance of losing the same amount of money. The average winnings is always 0 in each step, and therefore 0 overall.</p>\n\n<p>Now let's think about strategy a little bit. In general, there will be several different strategies that maximize your probability of winning. For now, we will work on identifying only one of them. We will come back to the question of finding the maximum bet later.</p>\n<br/>\n\n<p><b>Observation 1:</b> If you have <b>x</b> dollars, there is no reason to start a betting round with more than <b>V</b> - <b>x</b>.\n\n<p><b>Reason:</b> If you bet more than <b>V</b> - <b>x</b>, then winning will always put you over <b>V</b>. If you decrease the bet slightly, then winning is just as good, but losing is no worse. Therefore, you might as well bet less.\n</p>\n<br/>\n\n<p>From now on, we will always restrict our attention to strategies that follow Observation 1, and therefore, we will never end up with <i>more</i> than <b>V</b> dollars, no matter how lucky or unlucky we are.</p>\n<br/>\n\n<p><b>Observation 2:</b> Fix a strategy. Let <b>P</b> be the probability of reaching <b>V</b> dollars, and let <b>L</b> be the expected number of dollars you end up with if you lose. Then <b>P</b> = 1 - (<b>V</b> - <b>A</b>) / (<b>A</b> - <b>L</b>). Since <b>V</b> and <b>A</b> are fixed, this means maximizing <b>P</b> is equivalent to minimizing <b>L</b>.</p>\n\n<p><b>Reason:</b> This follows from the fact that your expected winnings after any number of betting rounds is always equal to 0, or equivalently, your total expected money is always equal to <b>A</b>. Let's see what this tells us at the end of all betting rounds. At that point, you will have won with probability <b>P</b>, in which case your money is exactly <b>V</b> by Observation 1. Or you will have lost with probability 1 - <b>P</b>, in which case your expected money is exactly <b>L</b>. Therefore, we get:<br/>\n<b>P</b> * <b>V</b> + (1 - <b>P</b>) * <b>L</b> = <b>A</b><br/>\n=&gt; <b>P</b> * (<b>V</b> - <b>L</b>) = <b>A</b> - <b>L</b><br/>\n=&gt; <b>P</b> = 1 - (<b>V</b> - <b>A</b>) / (<b>A</b> - <b>L</b>).</p>\n<br/>\n\n<p>So now the question reduces to making <b>L</b> as small as possible. Using these ideas, we can make a couple major deductions about the optimal strategy. </p><br/>\n\n<p><b>Observation 3:</b> If you have <b>x</b> dollars, you might as well do one of two things: (1) bet exactly <b>x</b> and double until you win or until it is no longer possible to double, or (2) bet exactly 1 and do not double even if you lose.</p>\n\n<p><b>Reason:</b> An optimal strategy will bet some number <b>y</b> and double up to <b>k</b> times. If one of the betting steps results in a win, you will end up with <b>x</b> + <b>y</b> dollars. Otherwise, you will end up with some number <b>x</b> - <b>z</b> dollars. As always, your expected number of dollars is constant, and so is equal to <b>x</b>. We will show how to replace the strategy of betting <b>y</b> and doubling up to <b>k</b> times with a new strategy (possibly requiring multiple betting rounds) that follows the rules we want, and that is at least as effective at reaching <b>x</b> + <b>y</b> dollars.</p> \n\n<p><i>Case 1:</i> <b>x</b> - <b>z</b> &ge; 0. Instead of betting <b>y</b>, repeatedly bet 1 and do not double. Stop only when your total amount of money increases to <b>x</b> + <b>y</b> or decreases to <b>x</b> - <b>z</b>. Since <b>x</b> - <b>z</b> &ge; 0, it is legal to continue betting until one of these outcomes happens. Like the original strategy, this strategy will result in the same two outcomes (<b>x</b> + <b>y</b> dollars or <b>x</b> - <b>z</b> dollars), and the expected money at the end will still be <b>x</b> for the exact same reason. However, as Observation 2 shows, if two strategies have identical winning and losing outcomes and identical expected values at the end, they have identical probability of getting the better outcome. Therefore, this strategy is identical to the original strategy, and we can just do this instead.</p>\n\n<p><i>Case 2:</i> <b>x</b> - <b>z</b> &lt; 0. Instead of betting <b>y</b>, repeatedly bet 1 and do not double. Stop only when your total amount of money increases to <b>x</b> + <b>y</b> or decreases to <b>y</b>. If you end up at <b>y</b>, then bet <b>y</b>, and keep doubling until you win or go broke. If you win, go back to the first step and continue betting 1 until you reach <b>x</b> + <b>y</b> or return back down to <b>y</b>. If you end up at <b>y</b> again, bet <b>y</b>, and repeat. Like the original strategy, this will end with you having exactly <b>x</b> + <b>y</b> dollars or with you being broke. However, it is easy to check that <b>L</b> is strictly smaller here than in the original strategy while the expected money at the end, as always, stays equal to <b>x</b>. Therefore Observation 2 guarantees that this new strategy is strictly better than the original strategy.</p>\n\n<p>We have shown that any strategy can switch to betting 1 or <b>x</b> without becoming any worse, and that proves Observation 3.</p>\n<br/>\n\n<p>This is a very powerful observation, but there is still more to understand! With 10<sup>16</sup> possible money amounts, we cannot afford to try both strategies in every situation. There is one more idea that drastically cuts down the search space.</p>\n<br/>\n\n<p><b>Observation 4:</b> For each non-negative integer i, let M<sub>i</sub> be the largest integer such that M<sub>i</sub> * 2<sup>i</sup> &le; <b>M</b>. We will call these numbers \"inflection points\". Then you should never bet all your money unless the amount you have is an inflection point.\n</p>\n\n<p><b>Reason:</b> The proof here is very similar to Observation 3. Consider a strategy that bets everything for <b>x</b> satisfying M<sub>i</sub> &lt; <b>x</b> &lt; M<sub>i-1</sub>. Let <b>y</b> equal <b>x</b>/2, rounded up. Note that 2<b>y</b> &le; <b>x</b> + 1 &le; M<sub>i-1</sub>, so if we bet <b>y</b>, then we can double i times.</p>\n\n<p>The current strategy either gives you 2<b>x</b> dollars or <b>x</b> * (1 - 1 - 2 - ... - 2<sup>i-1</sup>) = -2<b>x</b> * (2<sup>i-1</sup> - 1). However, <b>y</b> / <b>x</b> &ge; 1/2 &gt; (2<sup>i-1</sup> - 1) / (2<sup>i</sup> - 1). Therefore, the losing amount of money for this strategy is more than -2<b>y</b> * (2<sup>i</sup> - 1).</p>\n\n<p>Now we consider an alternate strategy. Instead of going all in at <b>x</b>, repeatedly bet 1 and do not double. Stop only when your total amount of money increases to 2<b>x</b> or decreases to <b>y</b>. In the latter case, go all in and double up to i times, or until you win. As noted above, your bet will never exceed <b>M</b>, so this is a legal strategy. If you win, start over from the beginning. Like the original strategy, this will either leave you with 2<b>x</b> dollars or broke. However, if you are broke, you end up with <b>y</b> * (1 - 1 - 2 - ... - 2<sup>i</sup>) = -2<b>y</b> * (2<sup>i</sup> - 1). As argued above, this losing value is less than it was for the original strategy, and so Observation 2 implies the new strategy has a higher probability of reaching 2<b>x</b>. Therefore, the original strategy could not have been optimal.</p>\n<br/>\n\n<p><b>When to go All-In:</b>\nLet's say a dollar amount is an \"all-in\" point if we should bet everything when we have that amount of money. Observation 4 guarantees that all-in points are a subset of the inflection points, but it is not true that every inflection point is an all-in point.</p>\n\n<p>\nConsider the inflection points in increasing order. The smallest inflection point will be 1, and certainly that is an all-in point. Let's now consider the second smallest inflection point. Observation 2 says that our goal is to minimize <b>L</b>, so we calculate what we end up with if we go all in from this inflection point and lose. If it is our lowest total yet, we <i>should</i> go all in there. Otherwise, we can do better by betting 1 until we get to the lower inflection point. The same argument applies for the third inflection point, and then the fourth and so on. In this way, we can very quickly calculate an optimal strategy at every dollar amount.\n</p>\n\n<p>\nThere are two tricky cases to watch out for here:\n<ul>\n<li> By Observation 1, we should only consider inflection points that are at most <b>V</b> / 2.\n<li> It might be that going all-in at a point x is equally effective as betting 1 and waiting until the next all-in point. In this case, we will say x is an \"optional all-in point\". The other all-in points are called \"strict all-in points\".\n</li>\n</ul>\n</p>\n<br/>\n\n<p><b>Calculating the Winning Probability:</b> Let P<sub>x</sub> denote the probability of reaching <b>V</b> if your current amount of money is x. If x is not a strict all-in point, then one optimal strategy is to bet 1 until we reach the strict all-in point directly above x or directly below x, or until we reach <b>V</b> itself. For any x between these all-in points, we have the recurrence: P<sub>x</sub> = (P<sub>x-1</sub> + P<sub>x+1</sub>)/2, or in other words, P<sub>x</sub> - P<sub>x-1</sub> = P<sub>x+1</sub> - P<sub>x</sub>. This implies P<sub>x</sub> is linear in this range, and therefore we can calculate P<sub>x</sub> if we know the value of P at both endpoints.</p>\n\n<p>We can now calculate P by starting from the largest all-in point and working down. For example, suppose the largest all-in point is y and the probability of losing immediately from going all in there is 1 - p. Then P<sub>y</sub> = p * P<sub>2y</sub>. Also, by linearity, P<sub>2y</sub> = P<sub>y</sub> * (<b>V</b> - 2y) / (<b>V</b> - y) + 1 * y / (<b>V</b> - 2y). We know p, <b>V</b>, and y, so it is easy to calculate P<sub>y</sub> from here. Once we have P<sub>y</sub>, we can use the same trick to calculate P for the second-largest all-in point, then for the third-largest all-in point, and so on, until eventually we have calculated all probabilities.\n</p>\n<br/>\n\n<p><b>Calculating the Largest Optimal Bet:</b> It remains only to calculate the largest optimal bet. If <b>A</b> is an all-in point, either strict or optional, then certainly we can and should bet <b>A</b> there.</p>\n\n<p>Otherwise, consider a dollar amount x. If x is not a strict all-in point, then we already saw that P<sub>x</sub> - P<sub>x-1</sub> = P<sub>x+1</sub> - P<sub>x</sub>. This means P<sub>x</sub> is completely linear between strict all-in points, and so we can certainly increase the bet until either winning or losing would take us to a strict all-in point on either side. If x is equal to a strict all-in point however, then 1 is not an optimal bet, and we have P<sub>x</sub> &gt; (P<sub>x-1</sub> + P<sub>x+1</sub>) / 2, or equivalently, P<sub>x</sub> - P<sub>x-1</sub> &gt; P<sub>x+1</sub> - P<sub>x</sub>. In particular, this means that increasing the bet further would hurt us. Therefore, the largest possible bet is the distance between <b>A</b> and the nearest strict all-in point.\n</p>\n","id":"0000000000433100","statement":"<h3>Problem</h3>\n<p>\nWhile visiting the planet Theta VIII, your team of space explorers is forced to participate in the plot of a badly-written book, which takes place in a hotel/casino called the <i>Google Royale</i>.  In order to escape the Royale, you will have to make enough money from gambling that you can buy the hotel for <b>V</b> dollars and leave.\n</p>\n<p>\nYou start with <b>A</b> dollars, and you will participate in <i>betting rounds</i> until one of two conditions is met.  If you finish any betting round with &le; 0 dollars, you will lose; if you finish a betting round with &ge; <b>V</b> dollars, you will buy the hotel and leave.  Otherwise you'll keep starting new betting rounds.\n</p>\n<p>\nEach betting round consists of one or more coin flips. If you have X dollars at the start of the round, you can choose any integer <code>B</code> between 1 and <code>min(X, <b>M</b>)</code> to bet on the first coin flip.\n</p>\n<p>\nWith probability 50%, you win the coin flip, and the Royale immediately pays you <code>B</code> dollars.  You now have <code><nobr>X + B</nobr></code> dollars, and the betting round ends.\n</p>\n<p>\nWith probability 50%, you lose the coin flip and owe the Royale <code>B</code> dollars. You can now pay the <code>B</code> dollars you owe and end the round.  Or if <nobr><code>2B &le; M</code></nobr>, you can instead delay the payment and do a second coin flip with twice the bet: <code>2B</code> dollars.  If you lose again, then you owe the Royale <code>B+2B=3B</code> dollars.  You can continue doubling your bet in this way to <code>4B</code>, <code>8B</code>, etc., until either you win a coin flip, you choose to stop, or your next bet would exceed <b>M</b>. You can even continue if the total of all your bets in the current betting round exceeds <code>X</code>.\n</p>\n<p>\nOnce the round is over, you must pay the Royale for each coin flip you lost, and if you won a coin flip, the Royale pays you for that. For example, if you start with a bet of 1 dollars, lose three coin flips, and then win one, you would gain $8 - $4 - $2 - $1 = $1. If you lose three coin flips and then stopped, you would lose $4 + $2 + $1 = $7. If you are left with $0 or less after paying, then you are broke, and you have just lost the game.\n</p>\n<p>\nLuckily you have brought an android with you, and he is able to compute the probability that you will win if you follow an optimal strategy.  What is that probability,  and what is the largest possible first bet you could make to have that probability? Remember that you are not allowed to bet more than <b>M</b>!</p>\n\n<h3>Example</h3>\n<p>\nSuppose that you decide to use the following (sub-optimal) strategy. You have <b><code>A</code></b>=5 dollars; <code><b>M</b>=20</code> and <code>V=40</code>.  The following sequence of events is possible:\n<ul>\n<li>Round 1: You can start by betting 1, 2, 3, 4 or 5 dollars.  You decide to begin a betting round by betting 2 dollars.\n<ul><li>Step 1 (B=$2): You win the first coin flip.  You gain 2 dollars, and the betting round ends.  Now you have 7 dollars.</li></ul>\n</li>\n<li>Round 2: You begin a betting round by betting 5 dollars.\n<ul><li>Step 1 (B=$5): You lose the first coin flip.  Now you owe the Royale 5 dollars.  Since <code>5*2 &le; 20</code>, you may do another coin flip with a bet of <code>5*2=10</code> dollars.  You choose not to.  You lose 5 dollars, and the betting round ends.  Now you have 2 dollars.</li></ul>\n</li>\n<li>Round 3: You begin a betting round by betting 2 dollars.\n<ul>\n<li>Step 1 (B=$2): You lose.  Now you owe the Royale 2 dollars.  You choose to flip another coin with a bet of 4 dollars.</li>\n<li>Step 2 (B=$4): You lose.  Now you owe the Royale a total of 6 dollars.  That's more than you have, which is okay.  You choose to flip another coin with a bet of 8 dollars.</li>\n<li>Step 3 (B=$8): You win.  You gain 8 dollars, pay the 2+4=6 dollars you owe, and the betting round ends.  Now you have 4 dollars.</li>\n</ul>\n</li>\n<li>Round 4: You begin a betting round by betting 2 dollars.\n<ul>\n<li>Step 1 (B=$2): You lose.  Now you owe the Royale 2 dollars.  You choose to flip another coin with a bet of 4 dollars.</li>\n<li>Step 2 (B=$4): You lose.  Now you owe the Royale a total of 6 dollars.  You choose to flip another coin with a bet of 8 dollars.</li>\n<li>Step 3 (B=$8): You lose.  Now you owe the Royale a total of 14 dollars.  You choose to flip another coin with a bet of 16 dollars.</li>\n<li>Step 4 (B=$16): You lose.  Now you owe the Royale a total of 30 dollars.  Since <code>2*16&gt;<b>M</b></code>, you cannot flip another coin and you must pay what you owe.  Now you have -26 dollars; you have lost.</li>\n</ul>\n</li>\n</ul>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each line contains three integers separated by single spaces: <b>A</b>, <b>M</b> and <b>V</b>, in that order.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y z\", where <b>x</b> is the case number (starting from 1); <b>y</b> is the probability of winning if you follow an optimal strategy; and <b>z</b> is the maximum first bet you can make without reducing your probability of winning.  <b>y</b> must be correct to within an absolute or relative error of 10<sup>-6</sup>.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>M</b> &le; 20.<br/>\n1 &le; <b>A</b> &lt; <b>V</b> &le; 20.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>M</b> &le; 10<sup>16</sup>.<br/>\n1 &le; <b>A</b> &lt; <b>V</b> &le; 10<sup>16</sup>.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 1 3\n3 6 12\n4 20 15\n13 6 20\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.333333333 1\nCase #2: 0.500000000 3\nCase #3: 0.755555555 3\nCase #4: 0.730769231 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":20},{"type":2,"type__str":"HIDDEN","value":40}],"title":"Google Royale","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>This is a rather unconventional problem that requires a lot of thought up-front and relatively little implementation.</p>\n\n<p>Let's think about the problem as a competitive game. Ben chooses a card position, and then Amy chooses the value of that card. Amy is not allowed (a) to re-use values, (b) to create a decreasing subsequence of length 3, or (c) to place the 1 before the final turn. Our task it to understand what decisions Amy could have made during the game. We will present the answer first, and then prove it is correct. Define an \"adversarial strategy\" for Amy as follows:\n</p>\n\n<ul>\n<li>At any point, consider the cards that Ben has not yet looked at. Suppose they are in positions p<sub>1</sub> &lt; p<sub>2</sub> &lt; ... &lt; p<sub>m</sub>, and have values v<sub>1</sub> &lt; v<sub>2</sub> &lt; ... &lt; v<sub>m</sub>.\n<ul>\n<li>If Ben looks at the card in position p<sub>k</sub> with k &lt; m, then Amy assigns it value v<sub>k+1</sub>.\n<li>If Ben looks at the card in position p<sub>m</sub> and either (a) m &le; 2, or (b) there is a previously revealed card in position less than p<sub>m</sub> with value between v<sub>m-1</sub> and v<sub>m</sub>, then Amy assigns it value v<sub>m</sub>. Otherwise, she assigns it value <i>either</i> v<sub>m-1</sub> or v<sub>m</sub>.\n</ul>\n</ul>\n\n<p>We claim that the problem conditions are equivalent to saying that Amy chooses the deck values according to an adversarial strategy. Once that is established, it will be pretty straightforward to find the lexicographically largest solution.</p>\n<br/>\n\n<h3><b>Adversarial Strategies Cannot Be Exploited</b></h3>\n\n<p>\nThe main technical challenge is to prove that adversarial strategies really do require Ben to look at every card. On a contest of course, you would not need to make this argument quite so rigorously.\n</p>\n<br/>\n\n<p><b>Lemma:</b> If the deck values are assigned according to an adversarial strategy, then the deck contains no decreasing subsequence of length 3.\n</p>\n\n<p><b>Proof:</b> We follow along as Ben looks at the cards one at a time. At each step, we will say a card is \"safe\" if Ben has looked at it, and either (a) all cards with a higher position have also been looked at, or (b) all cards with a higher value have also been looked at. Let's suppose the remaining cards are in positions p<sub>1</sub> &lt; p<sub>2</sub> &lt; ... &lt; p<sub>m</sub>, and have values v<sub>1</sub> &lt; v<sub>2</sub> &lt; ... &lt; v<sub>m</sub>. These are the \"unsafe\" cards.</p>\n\n<p>We claim the following is true:\n<ul>\n<li>There is no way of assigning values to the remaining cards that will make a decreasing subsequence of length 3 with a safe card.\n<li>If an unsafe card in position p<sub>i</sub> has been looked at, then it has value v<sub>i+1</sub>.\n</ul>\nWe prove this claim by induction on the number of cards that Ben has looked at. Initially, all cards are unsafe and the claim obvious.\n</p>\n\n<p>Now let's suppose Ben looks at a card <i>C</i> in some position p<sub>k</sub>.\n<ul>\n\n<li> <i>Case 1:</i> k &lt; m - 1. Since Ben has not looked at the card in position p<sub>m</sub> (or else it would be safe), the value of card <i>C</i> will be set according to the first adversarial strategy rule. Specifically, if there are q cards in positions less than p<sub>k</sub> that have not been looked at, then <i>C</i> will be assigned the (q+1)<sup>th</sup> smallest unrevealed value. As all safe cards have been revealed, we can restrict our attention to unsafe cards, from which the inductive hypothesis makes it clear that the (q+1)<sup>th</sup> smallest unrevealed value is v<sub>k+1</sub>. Since k + 1 &lt; m, the set of safe cards will not change because of this step, and the inductive hypothesis will still be satisfied afterwards.<br/><br/>\n\n<li> <i>Case 2:</i> k = m - 1. By the same reasoning as in Case 1, <i>C</i> will be assigned value v<sub>m</sub>. However, the set of safe cards will change in this case. Suppose Ben has already looked at the cards in positions p<sub>u</sub>, p<sub>u+1</sub>, ..., p<sub>m-2</sub>, but he has not looked at the card in position p<sub>u-1</sub>. These cards will all be labeled as safe set because they have high values, while all other cards will remain unsafe. We need to show that they cannot be part of a decreasing subsequence of length 3. By the inductive hypothesis, we can ignore cards that had been previously marked as safe for this purpose. Now, the newly labeled safe cards are arranged in increasing order, there is only one unsafe card positioned after them, and no preceding unsafe card can have higher value, so indeed, they cannot be part of a decreasing subsequence of length 3. Therefore, the inductive hypothesis is once again satisfied.<br/><br/>\n\n<li> <i>Case 3:</i> k = m. Suppose <i>C</i> is assigned value v<sub>t</sub>. We know Ben has not looked at the card with value v<sub>m</sub>, or else that card would already be safe. If Ben has also looked at the card with value v<sub>m-1</sub>, then the adversarial condition forbids <i>C</i> from having value less than v<sub>m-1</sub>. Otherwise, v<sub>m-1</sub> and v<sub>m</sub> are both still unrevealed, and the adversarial condition demands that <i>C</i> have value v<sub>m-1</sub> or v<sub>m</sub>.<br/>\n\n<ul>\n<li>\nIf t = m-1, then <i>C</i> will be marked as safe but no other cards will. (Ben cannot have looked at the card in position p<sub>m-1</sub> because it would have value v<sub>m</sub>, and would therefore be safe already.) Furthermore, it cannot be part of a length-3 decreasing subsequence because no unsafe card has a larger position and at most one unsafe card can have higher value.<br/>\n<li>\nIf t = m, then some additional cards p<sub>u</sub>, p<sub>u+1</sub>, ..., p<sub>m-2</sub> might also get marked safe. The newly labeled safe cards are arranged in increasing order, there is only one unsafe card positioned after any of them, and no preceding unsafe card can have higher value, so no decreasing subsequence of length 3 can include these cards. Therefore, the inductive hypothesis is once again satisfied.\n</ul>\n</ul>\n\n<p>In any case, the inductive hypothesis holds at each step, and therefore the lemma is proven.</p>\n<br/>\n\n<p>It now follows immediately that Ben requires all N guesses if the cards are assigned according to an adversarial strategy. No matter what cards Ben looks at, Amy can continue her adversarial strategy and avoid revealing either a decreasing subsequence of length 3 or the card with value 1. In particular, Ben can never finish early.</p>\n<br/>\n\n<h3><b>Non-Adversarial Orders Can Be Exploited</b></h3>\n\n<p>The previous argument is important from a technical perspective, but in practice, you would begin solving this problem from the other side: first showing how Ben can exploit poor strategies. Towards that end, we show that if Amy ever deviates from an adversarial strategy, then Ben can find the 1-card without requiring all N turns.</p>\n\n<p>Let's begin by focusing on the first card Ben looks at.</p><br/>\n\n<p><b>Observation 1:</b> Suppose Ben looks at card i &lt; N. Then Amy must assign it value i + 1.</p>\n\n<p><b>Reason:</b> Suppose he sees value j &ne; i + 1. We claim that the value-1 card cannot be in position N. Indeed, if it was in that position, then the condition that the deck has no decreasing subsequence of length 3 implies that (a) all cards with position less than i have value in the range [2, j-1], and (b) all cards with position between i + 1 and N - 1 have value in the range [j+1, N]. If j &lt; i + 1, then there are not enough cards in the range [2, j-1] for this to be possible, and if j &gt; i + 1, then there are not enough cards in the range [j+1, N] to be possible.</p>\n\n<p>Therefore, if Amy assigns this card a value other than i + 1, then Ben need never look at card N. But we know he did indeed have to look at all the cards, so it must be that Amy assigned value i + 1.\n</p>\n<br/>\n\n<p><b>Observation 2:</b> Suppose Ben looks at card N. Then Amy must assign it value N - 1 or N.</p>\n\n<p><b>Reason:</b> Suppose he sees value j &lt; N - 1. If N = 3, then Ben just found the value-1 card, which is an immediate contradiction. Otherwise, N &ge; 4, and we show that Ben can find the 1-value card in less than N - 1 further card checks, which is another contradiction.</p>\n\n<p>Forgetting the information Ben has already obtained, we know the remaining N - 1 card values are placed in the N - 1 preceding positions. By Observation 1, if Ben checks the card in position i, then it must have the (i+1)<sup>th</sup> smallest value of the remaining cards. (Otherwise, we already know he can find the 1-value card without checking everything.) So if Ben checks the cards in all positions except N - 3 and N - 1, he must see the following values:</p>\n\n<p>2, 3, ..., j-1, j+1, j+2, ..., N-2, ???, N, ???, j.</p>\n\n<p>The two unknown cards have value 1 and N - 1 in some order. However, we know the second-last card cannot have value N - 1, or we would have a decreasing subsequence: N, N - 1, j. Therefore, the 1 must be in that position, and so Ben never needs to check the fourth-last card, and the proof is complete.</p><br/>\n\n<p>There is only one tricky case left. At a given point, let the remaining unrevealed cards be in positions p<sub>1</sub> &lt; p<sub>2</sub> &lt; ... &lt; p<sub>m</sub>, and have values v<sub>1</sub> &lt; v<sub>2</sub> &lt; ... &lt; v<sub>m</sub>. Suppose that there is a previously revealed card in position less than p<sub>m</sub> with value between v<sub>m-1</sub> and v<sub>m</sub>. We need to show that if Ben looks at the card in position p<sub>m</sub>, then Amy must assign it value v<sub>m</sub>.\n\n<p><b>Reason:</b> Suppose Amy does not do this. Consider the first time where she does not. Let <i>C</i> be the card in position p<sub>m</sub>, and let <i>C'</i> be the revealed card that is positioned before <i>C</i> and that has value between v<sub>m-1</sub> and v<sub>m</sub>.</p>\n\n<p>Up until this point, Amy has followed an adversarial strategy, so we can use the inductive statement proven in our first lemma to divide the deck into safe and unsafe cards. We know there is an unrevealed card positioned after <i>C'</i> (namely <i>C</i>) and there is an unrevealed card value that is higher than the value of <i>C'</i> (namely v<sub>m</sub>), so <i>C'</i> must be an unsafe card.</p>\n\n<p>Let the unsafe cards have positions q<sub>1</sub>, q<sub>2</sub>, ..., q<sub>r</sub> and values w<sub>1</sub>, w<sub>2</sub>, ..., w<sub>r</sub>. Since\nv<sub>m-1</sub> is an unrevealed value, it belongs to an unsafe card and we have v<sub>m-1</sub> = w<sub>u</sub> for some u. Also <i>C'</i> has value w<sub>t</sub> for some t &gt; u and position p<sub>t-1</sub>.</p>\n\n<p>Now suppose Amy assigns <i>C</i> a value of v<sub>m-1</sub> = w<sub>u</sub>. Then the card in position q<sub>u-1</sub> must be unrevealed, or it would have had the same value. Also, as argued earlier, the card in position q<sub>r-1</sub> must be unrevealed or it would have value w<sub>r</sub> and therefore be safe already. Ben can now exploit Amy's strategy by looking at every card other than q<sub>u-1</sub> and q<sub>r-1</sub>. It is easy to check this will leave only the values 1 and w<sub>u+1</sub>. But the card in position q<sub>r-1</sub> cannot have value w<sub>u+1</sub> or we would get a decreasing subsequence: w<sub>t</sub>, w<sub>u+1</sub>, w<sub>u</sub>. Therefore, this card must have value 1, and Ben can avoid checking the card with position q<sub>u-1</sub>. This proves the final part!</p><br/>\n\n\n<h3><b>Finding The Lexicographically Largest Solution</b></h3>\n\n<p>\nWe are now finally ready to discuss the solution. At each step, Amy's strategy is almost completely determined. The only question is whether she should assign v<sub>m</sub> or v<sub>m-1</sub> to the card in position p<sub>m</sub> when she has the choice. In fact, the two choices lead to identical deck orderings except with v<sub>m</sub> and v<sub>m-1</sub> swapped. In order to make the ordering as large lexicographically as possible, we want v<sub>m</sub> early on, and so we should always prefer using v<sub>m-1</sub>.\n</p>\n\n<p>\nThat's it! We just need to implement the adversarial strategy, always preferring v<sub>m-1</sub> over v<sub>m</sub>. But of course it took a lot of reasoning to get to this stage!\n</p>","id":"0000000000433334","statement":"<h3>Problem</h3>\n<p>\nAmy has a deck of <b>N</b> cards with values 1 through <b>N</b>. She arranges the deck so that the values of the cards have no decreasing subsequence of length 3. For example, 1, 5, 4, 6, 3, 2 would be an illegal ordering because 5, 3, 2 is decreasing.\n</p>\n\n<p>\nAmy now gives the deck of cards to Ben. Ben knows that the deck has no decreasing subsequence of length 3, but he does not know the exact ordering. He wants to find the card with value 1. He does this by choosing an arbitrary card, picking it up to observe its value, and then repeating until he has found the card with value 1. At each step, Ben chooses a card that will minimize the worst-case number of cards he has to examine.\n</p>\n\n<p>\nBen later tells you that he got unlucky and had to examine all <b>N</b> cards before finding the card with value 1. Given the order in which he examined the cards of the deck, what value did each card have? If there are multiple possibilities, choose the lexicographically greatest one.\n</p>\n\n<p>\nA deck <code>A</code> is lexicographically greater than a deck <code>B</code> if and only if, at the first index at which they differ, the card in <code>A</code> has a value greater than the value of the card in <code>B</code>.\n</p>\n\n<p>\n<i>Example:</i> <b>N</b> = 3, and Ben tried the cards in order 2, 1, 3 (the indices are 1-based).  The values of the cards must have been: 2, 3, 1.\n</p>\n\n<p>\n<i>Explanation:</i> If card #2 had value 1, then Ben would have stopped immediately. If card #2 had value 2, then Ben would have known the first card must have been the 1, because the ordering (3, 2, 1) is a decreasing subsequence of length 3, and thus could not have been the ordering. In either case, Ben would not have needed 3 guesses. Therefore, we can deduce card #2 have had value 3. Similarly, card #1 could not have had value 1, or Ben could have stopped early. Therefore, the card values must have been 2, 3, 1.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case begins with a line containing one integer <b>N</b>, the number of cards in the deck. The next line will contain <b>N</b> integers separated by single spaces, describing the order in which Ben examined the deck: the first integer denotes the 1-based position of the first card he examined, the second integer denotes the 1-based position of the second card he examined, and so on.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the sequence of cards' values, separated by spaces.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100<br/>\nFor the provided sequence of guesses, there will be at least one deck that meets all the constraints of the problem, including the constraint that Ben's strategy required him to look at <b>N</b> cards.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 8<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 300<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n2 1 3\n1\n1\n3\n3 2 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2 3 1\nCase #2: 1\nCase #3: 1 3 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":20},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Ace in the Hole","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043319a","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2011"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
