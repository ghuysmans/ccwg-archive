{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1616310000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000436140","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>Thank you for participating in Kick Start 2021 Round A!</p>\r\n\r\n<hr>\r\n<p>\r\n<b>Cast</b>\r\n</p>\r\n\r\n<p>K-Goodness String: Written by Sudarsan Srinivasan and prepared by Bryan (Seunghyun) Jo.</p>\r\n<p>L Shaped Plots: Written by Vipin Singh and prepared by Bryan (Seunghyun) Jo.</p>\r\n<p>Rabbit House: Written by Changyu Zhu and prepared by Wajeb Saab.</p>\r\n<p>Checksum: Written by Changyu Zhu and prepared by Frederick Chyan.</p>\r\n<p>Solutions, other problem preparation, reviews and contest monitoring by\r\nAbhishek Saini, Akul Siddalingaswamy, Amr Aboelkher, Anurag Singh,\r\n  Bartosz Kostka, Bir Bahadur Khatri, Bohdan Pryshchenko,\r\n  Bryan (Seunghyun) Jo, Cem Birler, Changyu Zhu, Cristhian Bonilha,\r\n  Darpan Shah, Deeksha Kaurav, Fahim Ferdous Neerjhor, Frederick Chyan,\r\n  Gagan Madan, Harsh Lal, Hsin-cheng Hou, Jared Gillespie, Kashish Bansal,\r\n  Krists Boitmanis, Lizzie Sapiro Santor, Luwei Ge, Mo Luo, Nghia Le, Phil Sun,\r\n  Rahul Goswami, Rishabh Shukla, Ruoyu Zhang, Sai Surya Upadrasta,\r\n  Shantam Agarwal, Shweta Karwa, Sudarsan Srinivasan, Swapnil Gupta, Swapnil Mahajan,\r\n  Teja Vardhan Reddy Dasannagari, Vipin Singh, Viplav Kadam, Wajeb Saab, and Zhitao Li.</p>\r\n<p>Analysis authors:</p><ul>\r\n<li>K-Goodness String: Sai Surya Upadrasta</li>\r\n<li>L Shaped Plots: Swapnil Gupta</li>\r\n<li>Rabbit House: Wajeb Saab</li>\r\n<li>Checksum: Krists Boitmanis</li>\r\n</ul>","registration_gives_participant":true,"result_status":30,"result_status__str":"FINALIZED","start_ms":1616299200000,"tasks":[{"analysis":"<p>\n  Suppose we know a subset $$$S$$$ of elements of the matrix $$$\\mathbf{A}$$$ because they are either given in\n  the input or revealed by Edsger. Can we restore the remaining elements? If there is only\n  one unknown element in some row or column, we can recover its true value from the known elements\n  in that row or column and the respective checksum. We can apply such an element recovery step\n  until all elements are known or we end up with a matrix where each row and column has at least two\n  unknown elements (aside from fully reconstructed rows and columns). It will be shown later that\n  the whole matrix can be restored using this simple strategy or the subset $$$S$$$ does not provide\n  enough information to do so.\n</p>\n\n<h3>\nTest Set 1\n</h3>\n\n<p>\n  For the small test set, we can examine every potential subset $$$S$$$ of matrix elements and check\n  if $$$S$$$ is sufficient to restore the whole matrix. Among all sufficient subsets $$$S$$$, we\n  pick the smallest in terms of hours as our answer.\n</p>\n\n<p>\n  Given a subset $$$S$$$ of known elements, the above matrix recovery strategy can be implemented in\n  $$$O(\\mathbf{N}^2)$$$ time. For example, we can use a BFS-like algorithm iterating over a queue of\n  elements that are the only unknown elements in their rows or columns and calculating their true\n  values one by one. For the sake of efficiency, we also need to maintain the XOR values of\n  currently known elements for each row and column as well as the number of unknown elements per\n  each row and column. As soon as the number of unknown elements for a row or column becomes\n  $$$1$$$, we add that element to the queue.\n</p>\n\n<p>\n  There are $$$O(2^{\\mathbf{N}^2})$$$ subsets of elements. Consequently, the overall\n  time complexity of this brute-force algorithm is $$$O(2^{\\mathbf{N}^2} \\times \\mathbf{N}^2)$$$.\n</p>\n\n<h3>\nTest Set 2\n</h3>\n\n<p>\n  Let us look at our problem from graphs perspective. Namely, we construct a weighted bipartite\n  graph $$$G$$$, where the rows and columns of the matrix $$$\\mathbf{A}$$$ are represented by nodes in $$$G$$$,\n  and there is an edge of weight $$$\\mathbf{B_{i,j}}$$$ between $$$i$$$-th row and $$$j$$$-th column if and\n  only if $$$\\mathbf{A_{i,j}} = -1$$$. Please see the below example to make the construction more clear.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2yAe30KYGi8z2pDiBflYD53N44X6oPZ4B8gXRSIEYb0F2DRDa42g9MpdpG94ahNE_LlqhNAdHh5xgBDDYC/checksum.png\" width=\"60%\" />\n<p>\n  An isolated node represents a row or column with all its elements known. We can safely disregard\n  such nodes. A leaf node with exactly one incident edge represents a row or column with precisely\n  one unknown element. Note that the process outlined in the first paragraph corresponds to repeated\n  removal of leaves from the graph. If we end up with an empty graph in this way, it means that the\n  original graph must have been a forest without any cycles and we can recover the full matrix\n  without spending any time.\n</p>\n<p>\n  So what if the graph $$$G$$$ does contain a cycle? Given any assignment of binary values to the\n  elements of the matrix, we can flip the values of elements corresponding to the edges of a cycle,\n  and this operation would not change the XOR checksum of any row or column. Consequently, we cannot\n  tell the true value of elements on a cycle unless we reveal at least one of them, and effectivelly\n  break the cycle by removing the edge from the graph and paying a delicious price. In other words,\n  in order to be able to recover the whole matrix, it is necessary to break all cycles by revealing\n  and removing some edges. It is also sufficient &mdash; once all cycles have been broken, what\n  remains is a forest of edges, and the true value of all remaining edges can be determined\n  unambiguously.\n</p>\n<p>\n  Thus we have reduced the original problem to finding a minimum weight subset of edges that breaks\n  all cycles. An intuitive greedy approach involves iterating over the edges in a non-decreasing\n  order of weights and removing the current edge from the graph if it is part of a cycle. An edge\n  is part of a cycle if there is a simple path between its end-nodes other than the edge\n  itself &mdash; a condition that can be tested by, say, running a\n  <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">depth-first search</a> from one of\n  the end-nodes.\n</p>\n<p>\n  In our example above, once we remove the cheapest edge of cost $$$1$$$ (the red edge), what\n  remains is a tree, so no other edges will be removed.\n</p>\n<p>\n  Since there can be up to $$$\\mathbf{N}^2$$$ edges, the above steps are repeated $$$O(\\mathbf{N}^2)$$$ times.\n  One run of the depth-first search costs $$$O(\\mathbf{N}^2)$$$ time as well, so the overall time\n  complexity of this approach is $$$O(\\mathbf{N}^4)$$$.\n</p>\n<p>\n  But what about the correctness of this greedy approach? The proof is very similar to that of\n  <a href=\"https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\">Kruskal's</a> algorithm. Consider\n  the first edge $$$e$$$ that is removed by the algorithm, so it has the smallest weight among all\n  edges on cycles. In particular, suppose that $$$e$$$ is part of a cycle $$$C$$$. Now, consider\n  any cycle breaking set of edges $$$X$$$ that does not include $$$e$$$. Since the cycle $$$C$$$\n  must be broken, $$$X$$$ must contain an edge $$$f \\neq e$$$ that is also part of the cycle\n  $$$C$$$. The set of edges $$$Y = X - f + e$$$ has a total weight no larger than the weight of\n  $$$X$$$ and it is cycle breaking as well. To prove the second claim, assume the contrary that\n  the graph $$$G - Y$$$ contains a cycle $$$C'$$$, which necessarily includes the edge $$$f$$$ and\n  does not include the edge $$$e$$$. But then we can combine the paths $$$P = C - f$$$ and\n  $$$P' = C' - f$$$ to form a cycle in $$$G - X$$$, which contradicts the fact that $$$X$$$ was\n  cycle breaking. It follows that the edge $$$e$$$ is part of some optimal solution and our greedy\n  choice was valid.\n</p>\n\n<h3>\nTest Set 3\n</h3>\n\n<p>\n  Of course, the problem of finding a minimum weight cycle breaking edge set is equivalent to the\n  well known problem of finding a <a href=\"https://en.wikipedia.org/wiki/Minimum_spanning_tree\">\n  maximum weight spanning forest</a> of $$$G$$$, except that we would\n  build the complement set of edges to keep rather than the set of edges to remove. In the example\n  above, the edges of the maximum weight spanning forest are rendered green. It would cost Grace one\n  hour (the red edge) to reconstruct the whole matrix.\n</p>\n<p>\n  The graph may potentially have up to $$$\\mathbf{N}^2$$$ edges, therefore, a\n  <a href=\"https://cp-algorithms.com/graph/mst_prim.html#toc-tgt-5\">simple implementation</a> of\n  Prim's algorithm without maintaining a priority queue data structure would achieve an\n  $$$O(\\mathbf{N}^2)$$$ time complexity. Note that because of the high density of the graph,\n  Prim's algorithm is a better choice than Kruskal's algorithm, as the\n  later would need $$$O(\\mathbf{N}^2 \\times \\log \\mathbf{N})$$$ time for sorting the edges.\n</p>\n<p>\n  It is interesting to note that we never use the actual checksums in the graph construction nor\n  the maximum spanning forest algorithm, therefore, the input values $$$\\mathbf{R_i}$$$ and $$$\\mathbf{C_i}$$$ can be safely\n  ignored.\n</p>\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0BKnDeBC5tMoj-1Qmg7YA3ysV2vB84bro2zAu6Rh8cW0Uw44spVHFSacRYkZAXB9SFgi68IVXj/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"000000000068c2c3","statement":"<h3>Problem</h3>\n<p>\nGrace and Edsger are constructing a $$$\\mathbf{N} \\times \\mathbf{N}$$$ boolean matrix $$$\\mathbf{A}$$$. The element in $$$i$$$-th row and $$$j$$$-th column is represented by $$$\\mathbf{A_{i,j}}$$$.\n They decide to note down the checksum (defined as bitwise XOR of given list of elements) along each row and column.\n Checksum of $$$i$$$-th row is represented as $$$\\mathbf{R_i}$$$.\n Checksum of $$$j$$$-th column is represented as $$$\\mathbf{C_j}$$$.\n</p>\n<p>\n  For example, if $$$\\mathbf{N} = 2$$$, $$$\\mathbf{A} = \\begin{bmatrix}\n  1 & 0 \\\\\n  1 & 1\n  \\end{bmatrix}$$$, then $$$\\mathbf{R} = \\begin{bmatrix} 1 & 0 \\end{bmatrix}$$$\n  and $$$\\mathbf{C} = \\begin{bmatrix} 0 & 1 \\end{bmatrix}$$$.\n</p>\n<p>\n  Once they finished the matrix, Edsger stores the matrix in his computer.\n  However, due to a virus, some of the elements in matrix $$$\\mathbf{A}$$$ are replaced with $$$-1$$$ in Edsger's computer.\n  Luckily, Edsger still remembers the checksum values. He would like to restore the matrix, and reaches out to Grace for help.\n  After some investigation, it will take $$$\\mathbf{B_{i,j}}$$$ hours for Grace to recover the original value of $$$\\mathbf{A_{i,j}}$$$ from the disk.\n  Given the  final matrix $$$\\mathbf{A}$$$, cost matrix $$$\\mathbf{B}$$$, and checksums along each row ($$$\\mathbf{R}$$$) and column ($$$\\mathbf{C}$$$),\n  can you help Grace decide on the minimum total number of hours needed in order to restore the original matrix $$$\\mathbf{A}$$$?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\n</p>\n<p>\nThe first line of each test case contains a single integer $$$\\mathbf{N}$$$.\n</p>\n<p>\n  The next $$$\\mathbf{N}$$$ lines each contain $$$\\mathbf{N}$$$  integers representing the matrix $$$\\mathbf{A}$$$. $$$j$$$-th element on the $$$i$$$-th line represents\n  $$$\\mathbf{A_{i,j}}$$$.\n</p>\n<p>\n  The next $$$\\mathbf{N}$$$ lines each contain $$$\\mathbf{N}$$$  integers representing the matrix $$$\\mathbf{B}$$$. $$$j$$$-th element on the $$$i$$$-th line represents\n  $$$\\mathbf{B_{i,j}}$$$.\n</p>\n<p>\n  The next line contains $$$\\mathbf{N}$$$ integers representing the checksum of the rows. $$$i$$$-th element represents $$$\\mathbf{R_i}$$$.\n</p>\n<p>\n  The next line contains $$$\\mathbf{N}$$$ integers representing the checksum of the columns. $$$j$$$-th element represents $$$\\mathbf{C_j}$$$.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is the minimum number of hours to restore matrix $$$\\mathbf{A}$$$.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n  $$$-1 \\le \\mathbf{A_{i,j}} \\le 1$$$, for all $$$i,j$$$.<br/>\n  $$$1 \\le \\mathbf{B_{i,j}} \\le 1000$$$, for $$$i,j$$$ where $$$\\mathbf{A_{i,j}} = -1$$$, otherwise $$$\\mathbf{B_{i,j}} = 0$$$.<br/>\n  $$$0 \\le \\mathbf{R_i} \\le 1$$$, for all $$$i$$$.<br/>\n  $$$0 \\le \\mathbf{C_j} \\le 1$$$, for all $$$j$$$.<br/>\n  It is guaranteed that there exist at least one way to replace $$$-1$$$ in $$$\\mathbf{A}$$$ with $$$0$$$ or $$$1$$$ such that $$$\\mathbf{R}$$$ and $$$\\mathbf{C}$$$ as satisfied.\n</p>\n\n<h4>Test Set 1</h4>\n<p>\nTime limit: 20 seconds.<br/>\n\n  $$$1 \\le \\mathbf{N} \\le 4$$$.<br/>\n</p>\n\n<h4>Test Set 2</h4>\n<p>\nTime limit: 35 seconds.<br/>\n\n$$$1 \\le \\mathbf{N} \\le 40$$$.<br/>\n</p>\n\n<h4>Test Set 3</h4>\n<p>\nTime limit: 35 seconds.<br/>\n\n$$$1 \\le \\mathbf{N} \\le 500$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2wI2VT7lIDCLa2jJ_Qaf2zRFTrj7Ep07ApnGgnrxZXMrI2irK2lozueilh7fnt-7fbcLUiL00dzby3eoAr1wplVgbCgLT-lw/checksum_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n3\n1 -1 0\n0 1 0\n1 1 1\n0 1 0\n0 0 0\n0 0 0\n1 1 1\n0 0 1\n2\n-1 -1\n-1 -1\n1 10\n100 1000\n1 0\n0 1\n3\n-1 -1 -1\n-1 -1 -1\n0 0 0\n1 1 3\n5 1 4\n0 0 0\n0 0 0\n0 0 0\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1cleD3MlDXDhX2jeM2PPR1yjvedNTWWVSlWD4IiAjnUsc4o7z4l0BY2u8h8oHJM6tmjGmZHHQjTJ9X_G3oXUANiqLTVdn7bGs/checksum_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 0\nCase #2: 1\nCase #3: 2\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<p>\n  In Sample Case #1, $$$\\mathbf{A_{1,2}}$$$ can be restored using the checksum of either 1-st row or 2-nd column.\n  Hence, Grace can restore the matrix without spending any time to recover the data.\n</p>\n<p>\n  In Sample Case #2, Grace spends one hour to recover $$$\\mathbf{A_{1,1}}$$$. After that, she can use checksums of 1-st row and\n  1-st column to restore $$$\\mathbf{A_{1,2}}$$$ and $$$\\mathbf{A_{2,1}}$$$ respectively. And then she can use checksum of 2-nd row to restore $$$\\mathbf{A_{2,2}}$$$.\n  Hence, Grace can restore the matrix by spending one hour.\n</p>\n<p>\n  In Sample Case #3, Grace can spend one hour to recover $$$\\mathbf{A_{1,1}}$$$ and another hour to recover $$$\\mathbf{A_{2,2}}$$$. After that, she\n  can use checksum to restore the rest of the matrix. Hence, Grace can restore the matrix by spending two hours in total.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":1,"type__str":"VISIBLE","value":17},{"type":1,"type__str":"VISIBLE","value":17}],"title":"Checksum","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n\n<p>\n  In order to verify that a segment is good, we need to check whether all the cells in that segment\n  contain $$$1$$$ or not.\n\n  To check whether all the cells in a segment contain $$$1$$$ or not, we can calculate prefix sum of\n  the matrix and then check whether sum of cells on this segment is equal to the length of the\n  segment or not. Let $$$query(a,b,c,d)$$$ denote the sum of cells in submatrix with $$$(a,b)$$$ as top left corner\n  and $$$(c,d)$$$ as bottom right corner. We can calculate\n  this sum in $$$O(1)$$$ using the prefix sum matrix. For more details on using prefix sum to calculate sum\n  of cells on a submatrix, please refer\n  <a href=\"https://www.geeksforgeeks.org/submatrix-sum-queries/\">this</a>.\n  In order to get the sum of cells on segment from $$$(i,j)$$$ to $$$(i,l)$$$, we can simply check if $$$query(i,j,i,l) = |j-l|+1$$$.\n</p>\n\n<p>\n  L-shape comprises of two segments which meet at a common point.\n  Except the common point, consider the other end point of one segment as $$$(i,j)$$$ and the end point of the other segment as $$$(k,l)$$$. Now\n  these end points could meet at either $$$(i,l)$$$ or $$$(k,j)$$$ to\n  form an L-shape. So, if we know the end points of each segment, we can figure out the common point\n  where segments would meet.\n</p>\n\n<p>\n   For each pair of end points $$$(i,j)$$$ and $$$(k,l)$$$ of segments of L-shape, we already saw that there could be $$$2$$$ possible meeting points.\n  <ul>\n    <li>\n      For segments meeting at $$$(i,l)$$$, check that\n      $$$query(i,j,i,l) = |j-l|+1$$$ and $$$query(k,l,i,l) = |i-k|+1$$$.\n      Besides, either $$$|j-l|+1 = 2 \\times (|i-k|+1)$$$ or $$$|i-k|+1= 2 \\times (|j-l|+1)$$$ should be true.\n      If these conditions are satisfied, increase the answer by $$$1$$$.\n    </li>\n    <li>\n      For segments meeting at $$$(k,j)$$$, check that\n      $$$query(i,j,k,j) = |i-k|+1$$$ and $$$query(k,l,k,j) = |j-l|+1$$$.\n      Besides, either $$$|i-k|+1 = 2 \\times (|j-l|+1)$$$ or $$$|j-l|+1= 2 \\times (|i-k|+1)$$$ should be true.\n      If these conditions are satisfied, increase the answer by $$$1$$$.\n    </li>\n  </ul>\n</p>\n\n<p>\n  We can iterate over all possible end points of these two segments L-shape because there\n  are $$$O(\\mathbf{R}^{2} \\times \\mathbf{C}^{2})$$$ such possible combinations. We can calculate the number of possible L-shapes with these end points in $$$O(1)$$$. Hence, the overall complexity of the solution is $$$O(\\mathbf{R}^{2} \\times \\mathbf{C}^{2})$$$.\n</p>\n\n<h3>Test set 2</h3>\n<p>\n  We cannot iterate over all possible end points of the segments for this test set as the solution\n  would time out. If for each cell, we can quickly calculate how many L-shapes are such that both of its segments\nmeet at this cell, we can iterate over each cell of the matrix only once and calculate our answer. We can safely ignore those cells that\nhave value 0 as they cannot be part of any L-shape.\n</p>\n\n<p>\nConsider a cell $$$(i,j)$$$.\nThere can be 4 types of L-shapes that have both of its segments meet this cell.\n<ul>\n  <li>Type 1: One of the segments is to top of $$$(i,j)$$$, and other segment is to the right of $$$(i,j)$$$.</li>\n  <li>Type 2: One of the segments is to top of $$$(i,j)$$$, and other segment is to the left of $$$(i,j)$$$.</li>\n  <li>Type 3: One of the segments is to bottom of $$$(i,j)$$$, and other segment is to the right of $$$(i,j)$$$.</li>\n  <li>Type 4: One of the segments is to bottom of $$$(i,j)$$$, and other segment is to the left of $$$(i,j)$$$.</li>\n</ul>\n\n</p>\n\n<p>\n  Let $$$Count(x,y)$$$ be the number of L-shapes with both its segments meeting at a particular point of which the length of the segment\n  parallel to one axis is $$$x$$$\n  and the length of the segment parallel to the other axis is $$$y$$$. Number of L-shapes with longer segment as part of the segment with length $$$x$$$ are\n  $$$min(\\frac{x}{2},y) - 1$$$. Similarly, number of L-shapes with longer segment as part of the segment with length $$$y$$$ are\n  $$$min(\\frac{y}{2},x) - 1$$$. Hence, $$$Count(x,y) = min(\\frac{x}{2},y) + min(\\frac{y}{2},x) - 2$$$.\n</p>\n\n<p>\nIf we can calculate number of consecutive cells that have value 1 in each side of $$$(i,j)$$$, we can calculate number of L-shapes of each type with this cell as the common endpoint of the segments using the $$$Count()$$$ function above.\nLet $$$top(i,j)$$$ denote the number of consecutive cells that have value 1 including $$$(i,j)$$$ and cells above it. For cells with value 0,\n  $$$top(i,j) = 0$$$.\nFormally for cells with value 1, $$$top(i,j) = i - k + 1$$$ where\n$$$1 \\le k \\le i$$$ and k is least possible value such that all cells from $$$(k,j)$$$ to $$$(i,j)$$$ have value 1.\nSimilarly, we can define $$$bottom(i,j)$$$, $$$left(i,j)$$$ and $$$right(i,j)$$$ denoting maximum number\nof consecutive cells on bottom, left and right of $$$(i,j)$$$ respectively.\n</p>\n\n<p>\n  We can calculate $$$top(i,j)$$$ and $$$left(i,j)$$$ by iterating from the starting of the matrix and updating their values. Refer to the code\n  below to calculate these values.\n</p>\n\n<pre><code class=\"language-cpp\">\n  for(<var>int</var> i = 1; i <= R; i++) {\n    for(<var>int</var> j = 1; j <= C; j++) {\n       if (matrix[i][j] == 0) continue;\n       top[i][j] = top[i - 1][j] + 1;\n       left[i][j] = left[i][j - 1] + 1;\n    }\n }\n\n</code></pre>\n\n<p>\n  Similarly, we can calculate $$$bottom(i,j)$$$ and $$$right(i,j)$$$ by iterating from the end of\n  the matrix. After knowing these values, we can calculate number of L-shapes of each type for\n  cell $$$(i,j)$$$. $$$Count(top(i,j), right(i,j))$$$, $$$Count(top(i,j), left(i,j))$$$,\n  $$$Count(bottom(i,j), right(i,j))$$$ and $$$Count(bottom(i,j), left(i,j))$$$ denote the number of L-shapes of type 1, 2, 3 and 4\n  respectively. Thus, for each cell we can add $$$Count(top(i,j), left(i,j)) + Count(top(i,j), right(i,j))\n  + Count(bottom(i,j), left(i,j)) + Count(bottom(i,j), right(i,j))$$$ to the answer.\n</p>\n\n<p>\n  $$$top(i,j)$$$, $$$bottom(i,j)$$$, $$$left(i,j)$$$ and $$$right(i,j)$$$ can be calculated in $$$O(\\mathbf{R} \\times \\mathbf{C})$$$ time complexity.\n  $$$Count(i,j)$$$ can be calculate in $$$O(\\mathbf{R} \\times \\mathbf{C})$$$ time complexity. Finally, we need to iterate over each cell of the matrix, and we\n  can update the answer in $$$O(1)$$$ for each cell. Thus, the overall complexity of the solution is $$$O(\\mathbf{R} \\times \\mathbf{C})$$$.\n</p>\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2YbSck4bRnyYubaf5iR5eD5BfftZhJqKbeJ1onhtNRl8120fD6emSF1oh4_jb5xIWfEFjjHZix/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"000000000068c509","statement":"<h3>Problem</h3>\n\n<p>Given a grid of $$$\\mathbf{R}$$$ rows and $$$\\mathbf{C}$$$ columns each cell in the grid is either $$$0$$$ or $$$1$$$.\n<p>A segment is a nonempty sequence of consecutive cells such that all cells are in the same row or\n  the same column. We define the length of a segment as number of cells in the sequence.\n<p>A segment is called \"good\" if all the cells in the segment contain only $$$1$$$s.\n<p>An \"L-shape\" is defined as an unordered pair of segments, which has all the following properties:\n\n<ul>\n<li> Each of the segments must be a \"good\" segment.\n<li> The two segments must be perpendicular to each other.\n<li> The segments must share one cell that is an endpoint of both segments.\n<li> Segments must have length at least $$$2$$$.\n<li> The length of the longer segment is twice the length of the shorter segment.\n</ul>\n\n<p>We need to count the number of L-shapes in the grid.</p>\n\n<p>\n  Below you can find two examples of correct L-shapes,\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2V0Y08G3c0X6HK0aMSGlM_mt1chJNcQLvbajhH8KXOrO2Krt8CS18xaceZ_sSxx6lAhXmdjQPNZsjy2ylt0o4OLLl_oaA/examples_correct.png\" alt=\"Examples of valid L-shapes.\">\n\n<p>\n  and three examples of <strong>invalid</strong> L-shapes.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0tX_b8Fh06NGJjQSParVY20wr2XEKSfs2upNaL2gs80jZfZ0ols5Hy-jAeGCsCMaOZbIlCwSTMJv_zqEdn0F6OotnFFUWqiQ/examples_incorrect.png\" alt=\"Examples of invalid L-shapes.\">\n\n<p>\n  Note that in the shape on the left, two segments do not share a common endpoint.\n  The next two shapes do not meet the last requirement, as in the middle shape both\n  segments have the same length, and in the last shape the longer segment is longer than twice the\n  length of the shorter one.\n</p>\n\n\n<h3>Input</h3>\n\n  <p>The first line of the input contains the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\n  <p>The first line of each testcase contains two integers $$$\\mathbf{R}$$$ and $$$\\mathbf{C}$$$.\n  <p>Then, $$$\\mathbf{R}$$$ lines follow, each line with $$$\\mathbf{C}$$$ integers representing the cells of the grid.\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>, where $$$x$$$ is\n  the test case number (starting from 1) and $$$y$$$ is the number of L-shapes.\n</p>\n\n\n<h3>Limits</h3>\n<p>\nTime limit: 60 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n  $$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n  Grid consists of $$$0$$$s and $$$1$$$s only.<br/>\n</p>\n\n<h4>Test Set 1</h4>\n<p>\n\n  $$$1 \\le \\mathbf{R} \\le 40$$$.<br/>\n  $$$1 \\le \\mathbf{C} \\le 40$$$.<br/>\n</p>\n\n<h4>Test Set 2</h4>\n<p>\n\n  $$$1 \\le \\mathbf{R} \\le 1000$$$ and $$$1 \\le \\mathbf{C} \\le 1000$$$ for at most $$$5$$$ test cases.<br/>\n  For the remaining cases, $$$1 \\le \\mathbf{R} \\le 40$$$ and $$$1 \\le \\mathbf{C} \\le 40$$$. <br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3y7nZ1MoWFU6M7082gn8bKzT8obuDBsX8wOvvyTShOu-lhoEDWnoHG09X0AorHQL3ZxQlCQ_hobIDxdVJy3DxS-ptlAg5KFBaRA4PuMw/l_shaped_plots_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n4 3\n1 0 0\n1 0 1\n1 0 0\n1 1 0\n6 4\n1 0 0 0\n1 0 0 1\n1 1 1 1\n1 0 1 0\n1 0 1 0\n1 1 1 0\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U39axc0zGlRAJ8o7HaqS7Tm4STDx5wzjfo7TNWKgb_j60Sg-Ip1hWmLHzxSY3UcmAozUZlNVLXRchA5xMphRf9o8TOHb-zDh3Km2x_HaeI/l_shaped_plots_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 1\nCase #2: 9\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>In Sample Case #1, there is one L-shape.\n<ul>\n<li>The first one is formed by using cells: $$$(1,1)$$$, $$$(2,1)$$$, $$$(3,1)$$$, $$$(4,1)$$$, $$$(4,2)$$$\n</ul>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1h09KEFom_snkof7xJU8paYR0zqOhSwLt3PcF0htF6ugpdSsJDOKkRV_b4L4ryRempj02azy5btcXrxFs/sample1.png\" alt=\"Visualization for the first sample case, showing one L-shape.\">\n<p>\nIn Sample Case #2, there are nine L-shapes.\n<ul>\n<li>The first one is formed by using cells: $$$(1,1)$$$, $$$(2,1)$$$, $$$(3,1)$$$, $$$(4,1)$$$, $$$(5,1)$$$, $$$(6,1)$$$, $$$(6,2)$$$, $$$(6,3)$$$\n<li>The second one is formed by using cells: $$$(3,1)$$$, $$$(4,1)$$$, $$$(5,1)$$$, $$$(6,1)$$$, $$$(6,2)$$$\n<li>The third one is formed by using cells: $$$(6,1)$$$, $$$(5,1)$$$, $$$(4,1)$$$, $$$(3,1)$$$, $$$(3,2)$$$\n<li>The fourth one is formed by using cells: $$$(3,3)$$$, $$$(4,3)$$$, $$$(5,3)$$$, $$$(6,3)$$$, $$$(6,2)$$$\n<li>The fifth one is formed by using cells: $$$(6,3)$$$, $$$(5,3)$$$, $$$(4,3)$$$, $$$(3,3)$$$, $$$(3,2)$$$\n<li>The sixth one is formed by using cells: $$$(3,1)$$$, $$$(3,2)$$$, $$$(3,3)$$$, $$$(3,4)$$$, $$$(2,4)$$$\n<li>The seventh one is formed by using cells: $$$(3,4)$$$, $$$(3,3)$$$, $$$(3,2)$$$, $$$(3,1)$$$, $$$(2,1)$$$\n<li>The eighth one is formed by using cells: $$$(3,4)$$$, $$$(3,3)$$$, $$$(3,2)$$$, $$$(3,1)$$$, $$$(4,1)$$$\n<li>The ninth one is formed by using cells: $$$(6,3)$$$, $$$(5,3)$$$, $$$(4,3)$$$, $$$(3,3)$$$, $$$(3,4)$$$\n</ul>\n\nThe first three L-shapes are shown on the picture below.\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U13rSuWy_58d0nOW85xhLYewXeHRkwpFdqbHK-v2q3DId_Eza4tF79dLvgllFNTIOfgWpxob8gBvfud6AI/sample2.png\" alt=\"Visualization for the second sample case, showing first three L-shapes.\">\n\n\n\n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":8},{"type":1,"type__str":"VISIBLE","value":12}],"title":"L Shaped Plots","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  Barbara is given a 2D grid with $$$\\mathbf{R}$$$ rows and $$$\\mathbf{C}$$$ columns. Her goal is to create a grid\n  such that no two adjacent cells have an absolute difference in height greater than $$$1$$$. Moreover,\n  she is only allowed to increase the height of cells.\n</p>\n<p>\n  We notice that the cell initially with the largest height ($$$H$$$) never requires increasing.\n  Furthermore, Barbara can update its neighbor cells to have a height of $$$H - 1$$$ (unless they\n  already have a height of $$$H$$$). Afterwards, she can repeat the process for the cell with the\n  next largest height, until she visits all the cells.\n</p>\n<p>\n  One thing to be careful of in this problem is that the final result can be larger than the limits\n  of a 32-bit integer. Using 64-bit integers avoids WAs due to overflow.\n</p>\n\n<h3>Test set 1</h3>\n<p>\n  For this test set, Barbara sees that $$$1 \\le \\mathbf{R}, \\mathbf{C} \\le 50$$$. Therefore, she performs a\n  linear scan over the grid to find the cell with the largest height. Then, she updates the height\n  of its neighbors, and increments the result to account for the increase in height.\n</p>\n<p>\n  Finally, she marks this cell as visited, which can be done via a secondary 2D grid of booleans.\n  She repeats the above process until all cells have been visited, and return the result.\n</p>\n<p>\n  The linear scan can be done in $$$O(\\mathbf{R} \\cdot \\mathbf{C})$$$, and Barbara visits each cell exactly once, so she\n  performs the linear scan $$$O(\\mathbf{R} \\cdot \\mathbf{C})$$$ times. The overall time complexity is therefore\n  $$$O((\\mathbf{R} \\cdot \\mathbf{C})^2)$$$. This fits within the limits of the small test set.<br/>\n  The additional space complexity is $$$O(\\mathbf{R} \\cdot \\mathbf{C})$$$ due to the secondary 2D grid of\n  booleans.\n</p>\n\n<h3>Test set 2</h3>\n<p>\n  For this test set, $$$1 \\le \\mathbf{R}, \\mathbf{C} \\le 300$$$. A time complexity of $$$O((\\mathbf{R} \\cdot \\mathbf{C})^2)$$$\n  will not satisfy the time limits.\n</p>\n<p>\n  Barbara still needs to visit the unvisited cell with the largest height in each iteration. However, this\n  can be done in $$$O(\\log(\\mathbf{R} \\cdot \\mathbf{C}))$$$ using a priority queue. In each iteration, she pops the\n  cell with the largest height, updates the height of its neighbors in the priority queue, and\n  increments the result.\n</p>\n<p>\n  The time complexity of the above solution is $$$O(\\mathbf{R} \\cdot \\mathbf{C} \\cdot \\log(\\mathbf{R} \\cdot \\mathbf{C}))$$$. The\n  additional space complexity is still $$$O(\\mathbf{R} \\cdot \\mathbf{C})$$$, since initially the priority queue\n  contains all the cells.\n</p>\n<p>\n  Note that, depending on the implementation, updating a non-top element in the priority queue might\n  not be an $$$O(1)$$$ operation. In such cases, one trick would be to insert a new element into the\n  queue with the new height, and update the height in the grid. On processing any element, check\n  whether the height in the queue corresponds to the height in the grid, and ignore the element\n  otherwise. This does not change the worst-case time and space complexity, since the maximum number\n  of times a cell can be added to the queue is $$$4$$$.\n</p>\n\n<h3>Further Improvements</h3>\n<p>\n  While not necessary to pass the time limits, the time complexity can be reduced further.\n</p>\n<p>\n  One approach is to replace the priority queue with a list of buckets, each bucket containing a set\n  of cells with a given height. With this approach, Barbara can iterate over the buckets in decreasing\n  order of height in order to visit each cell, then apply the same algorithm as above: update the\n  neighbors (by placing them in their new buckets according to their new height), and remove the\n  visited cells from the list.\n</p>\n<p>\n  By using a hashset for each bucket, insertion and removal becomes an $$$O(1)$$$ operation. She can\n  also use a vector. However, the trick from Test Set 2 is needed to maintain an $$$O(1)$$$\n  insertion/removal in that case. Iterating over the buckets is linear in the number of buckets, and\n  she will visit at most $$$O(\\mathbf{R} \\cdot \\mathbf{C})$$$ cells.\n</p>\n<p>\n  Let $$$G = \\max(\\mathbf{G_{i,j}})$$$. Since no cell has an initial height larger than $$$G$$$, and she\n  will never increase the height of the cell with the largest height, she observes that the number of\n  buckets is at most $$$G$$$. This leads to a time complexity of $$$O(\\mathbf{R} \\cdot \\mathbf{C} + G)$$$.\n</p>\n<p>\n  Barbara can improve this further. Notice that all cells in the final grid will have a height of at\n  least $$$G - \\mathbf{R} - \\mathbf{C} + 2$$$. She achieves this value by decreasing the height by 1 with each step\n  away from the highest cell. The maximum number of steps occurs when the highest cell is in a\n  corner of the grid: the opposite corner is $$$\\mathbf{R} + \\mathbf{C} - 2$$$ steps away.\n</p>\n<p>\n  Now, she can first increase the height of all cells to $$$G - \\mathbf{R} - \\mathbf{C} + 2$$$, then apply the same\n  bucketing approach. Except, now the number of buckets is $$$\\mathbf{R} + \\mathbf{C} - 2$$$, leading to a time\n  complexity of $$$O(\\mathbf{R} \\cdot \\mathbf{C} + \\mathbf{R} + \\mathbf{C}) = O(\\mathbf{R} \\cdot \\mathbf{C})$$$.\n</p>\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U14mKEtA1oYwE_xyLsQlwdsLAxxeHUEvjh2I5Pd02870yDu0Kq95bfHrudb8XoFfy7QhLmxSOmS/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"000000000068cb14","statement":"<h3>Problem</h3>\n<p>\n  Barbara got really good grades in school last year,\n  so her parents decided to gift her with a pet rabbit.\n  She was so excited that she built a house for the rabbit,\n  which can be seen as a 2D grid with $$$\\mathbf{R}$$$ rows and $$$\\mathbf{C}$$$ columns.\n</p>\n<p>\n  Rabbits love to jump, so Barbara stacked several boxes on several cells of the grid.\n  Each box is a cube with equal dimensions,\n  which match exactly the dimensions of a cell of the grid.\n</p>\n<p>\n  However, Barbara soon realizes that it may be dangerous for the rabbit to make jumps of height\n  greater than $$$1$$$ box, so she decides to avoid that by making some adjustments to the house.\n  For every pair of adjacent cells, Barbara would like that their absolute difference in height\n  be at most $$$1$$$ box. Two cells are considered adjacent if they share a common side.\n</p>\n<p>\n  As all the boxes are superglued, Barbara cannot remove any boxes that are there initially, however\n  she can add boxes on top of them. She can add as many boxes as she wants, to as many cells as she\n  wants (which may be zero). Help her determine what is the minimum total number of boxes to be\n  added so that the rabbit's house is safe.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\n</p>\n<p>\n  Each test case begins with a line containing two integers $$$\\mathbf{R}$$$ and $$$\\mathbf{C}$$$.\n</p>\n<p>\n  Then, $$$\\mathbf{R}$$$ lines follow, each with $$$\\mathbf{C}$$$ integers.\n  The $$$j$$$-th integer on $$$i$$$-th line, $$$\\mathbf{G_{i,j}}$$$,\n  represents how many boxes are there initially on the cell located\n  at the $$$i$$$-th row and $$$j$$$-th column of the grid.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\n  where $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is the minimum number\n  of boxes to be added so that the rabbit's house is safe.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n  $$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n  $$$0 \\le \\mathbf{G_{i,j}} \\le 2 \\cdot 10^6$$$, for all $$$i$$$, $$$j$$$.<br/>\n</p>\n\n<h4>Test Set 1</h4>\n<p>\nTime limit: 20 seconds.<br/>\n\n  $$$1 \\le \\mathbf{R}, \\mathbf{C} \\le 50$$$.<br/>\n</p>\n\n<h4>Test Set 2</h4>\n<p>\nTime limit: 40 seconds.<br/>\n\n  $$$1 \\le \\mathbf{R}, \\mathbf{C} \\le 300$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U18Y7cBMZkOTpZInUIcQSmiEPlP2BRtRLW7r0LEIrI5-6emnWN9uGWLt9Q1CHb1QdLWNUuOuaZ8G_ocCOqiQ4uPfLma4j9038mxy3k/rabbit_house_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n1 3\n3 4 3\n1 3\n3 0 0\n3 3\n0 0 0\n0 2 0\n0 0 0\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1pcQMXXtSH3OkwZJit_3jV1kA739R30b-MGNIcrSZC6P1PeYyJjyXgfU-JCxWU4op2tTbPFWeaMlU1HTn6Q10I-fvmAtfu3VQLFoqK/rabbit_house_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 0\nCase #2: 3\nCase #3: 4\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<p>\n  In Sample Case #1, the absolute difference in height for every pair of adjacent cells is already\n  at most $$$1$$$ box, so there is no need to add any extra boxes.\n</p>\n<p>\n  In Sample Case #2, the absolute difference in height of the left-most cell and the middle cell\n  is $$$3$$$ boxes. To fix that, we can add $$$2$$$ boxes to the middle cell. But then, the absolute difference\n  of the middle cell and the right-most cell will be $$$2$$$ boxes, so Barbara can fix that by adding $$$1$$$ box\n  to the right-most cell. After adding these $$$3$$$ boxes, the safety condition is satisfied.\n</p>\n<p>\n  In Sample Case #3, the cell in the middle of the grid has an absolute difference in height of $$$2$$$\n  boxes with all of its four adjacent cells. One solution is to add exactly $$$1$$$ box to all of the\n  middle's adjacent cells, so that the absolute difference between any pair of adjacent cells will\n  be at most $$$1$$$ box. That requires $$$4$$$ boxes in total.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":1,"type__str":"VISIBLE","value":15}],"title":"Rabbit House","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n    As per the given definition of operation, Ada can only change the goodness score by one in a\n    single move. Therefore to get a string with the required goodness score in the minimum number of\n    operations Ada can either increase or decrease the goodness score by one in each step. Let us assume\n    there are $$$X$$$ indices($$$\\le \\mathbf{N}/2$$$ ($$$1$$$-indexed)) $$$i$$$ in the given string $$$\\mathbf{S}$$$ such that\n    $$$\\mathbf{S}_i \\neq \\mathbf{S}_{\\mathbf{N}-i+1}$$$. We have 3 cases now.\n</p>\n\n<ul>\n    <li>\n        Case 1: $$$X &equals; \\mathbf{K}$$$,<br/>\n        In this case, Ada already has the string which has a goodness score of $$$\\mathbf{K}$$$. Therefore\n        number of operations required is $$$0$$$.\n    </li>\n    <li>\n        Case 2: $$$X > \\mathbf{K}$$$,<br/>\n        In this case, Ada can change $$$(X-\\mathbf{K})$$$ letters at indices $$$i$$$ ($$$1 &le; i &le; \\mathbf{N}/2$$$ ($$$1$$$-indexed))\n        that satisfy $$$\\mathbf{S}_i \\neq \\mathbf{S}_{\\mathbf{N}-i+1}$$$ to the letter at $$$\\mathbf{S}_{\\mathbf{N}-i+1}$$$.\n        Then she will have a string with a goodness score of $$$\\mathbf{K}$$$. Therefore the minimum number of\n        operations is $$$(X-\\mathbf{K})$$$.\n    </li>\n    <li>\n        Case 3: $$$X &lt; \\mathbf{K}$$$,<br/>\n        In this case, Ada can change $$$(\\mathbf{K}-X)$$$ letters at indices $$$i$$$ ($$$1 &le; i &le; \\mathbf{N}/2$$$ ($$$1$$$-indexed))\n        that satisfy $$$\\mathbf{S}_i = \\mathbf{S}_{\\mathbf{N}-i+1}$$$ to any other uppercase letter other than\n        the one at $$$\\mathbf{S}_{\\mathbf{N}-i+1}$$$. As a result, she will have a string with a goodness score of $$$\\mathbf{K}$$$.\n        Therefore the minimum number of operations is $$$(\\mathbf{K}-X)$$$.\n</li>\n</ul>\n\n<p>\n    All the above described operations can be done in $$$O(\\mathbf{N})$$$ complexity. Therefore the overall\n    complexity is $$$O(\\mathbf{N})$$$.\n</p>\n\n<h5>Sample Code (C++)</h5>\n<pre><code class=\"language-cpp\">\n<var>int</var> kGoodnessString(string s, int k) {\n  <var>int</var> minOperations = 0, x = 0;\n  for(<var>int</var> i = 0; i < s.size() / 2; i++) {\n     if(s[i] != s[s.size() - i - 1]) {\n         x++;\n     }\n  }\n\n  if(x == k) {\n      minOperations = 0;\n  }\n  else if(x > k) {\n      minOperations = x - k;\n  }\n  else {\n      minOperations = k - x;\n  }\n  return minOperations;\n}\n</code></pre>\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3Q6XNH6snqTOtb52ocvcoryqJC17-GnnpmO-4LgowJZlNhE9GQ2DkonDZxP_ozrRg1MQ49YPeS/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"000000000068cca3","statement":"<h3>Problem</h3>\n<p>\n    Charles defines the goodness score of a string as the number of indices $$$i$$$ such that\n    $$$\\mathbf{S}_i\\ne\\mathbf{S}_{\\mathbf{N}-i+1}$$$ where $$$1 \\le i \\le \\mathbf{N}/2$$$ ($$$1$$$-indexed).\n    For example, the string <code>CABABC</code> has a goodness score of $$$2$$$ since\n    $$$\\mathbf{S}_2 \\ne \\mathbf{S}_5$$$ and $$$\\mathbf{S}_3 \\ne \\mathbf{S}_4$$$.\n</p>\n<p>\n    Charles gave Ada a string $$$\\mathbf{S}$$$ of length $$$\\mathbf{N}$$$, consisting of uppercase letters and asked her to\n    convert it into a string with a goodness score of $$$\\mathbf{K}$$$.\n    In one operation, Ada can change any character in the string to any uppercase letter.\n    Could you help Ada find the <i>minimum</i> number of operations required to transform the given\n    string into a string with goodness score equal to $$$\\mathbf{K}$$$?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\n</p>\n<p>\n  The first line of each test case contains two integers $$$\\mathbf{N}$$$ and $$$\\mathbf{K}$$$. The second line of each test\n    case contains a string $$$\\mathbf{S}$$$ of length $$$\\mathbf{N}$$$, consisting of uppercase letters.\n</p>\n\n<h3>Output</h3>\n<p>\n    For each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\n    where $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is the minimum number of\n    operations required to transform the given string $$$\\mathbf{S}$$$ into a string with goodness score equal\n    to $$$\\mathbf{K}$$$.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n$$$0 \\le \\mathbf{K} \\le \\mathbf{N}/2$$$.<br/>\n</p>\n\n<h4>Test Set 1</h4>\n<p>\nTime limit: 20 seconds.<br/>\n\n$$$1 \\le \\mathbf{N} \\le 100$$$.<br/>\n</p>\n\n<h4>Test Set 2</h4>\n<p>\nTime limit: 40 seconds.<br/>\n\n$$$1 \\le \\mathbf{N} \\le 2 \\times 10^5$$$ for at most $$$10$$$ test cases.<br/>\nFor the remaining cases, $$$1 \\le \\mathbf{N} \\le 100$$$. <br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1t1RfDyLGXnFrTwLOWexuMOC00b5khUikMwfA6kU56wymDxD-WjQLdk5nc_QBT-ZqwEUB-nYqoI2beeppAijWvI1d4Xpiw-w8x6GxcI2nDAQ/k-goodness_string_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n5 1\nABCAA\n4 2\nABAA\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3AMIGIyFc2fN27US9kjq73JfeUSv2A5RXSdDQ0ZDX0GhcVUV1EDfB8h_rJq8rkEh_OXGsLUPtZk9GLMMpG_jgSA9jxnYr9xJiOyB-tG4hQT_E/k-goodness_string_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 0\nCase #2: 1\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n    In Sample Case #1, the given string already has a goodness score of $$$1$$$. Therefore\n    the minimum number of operations required is $$$0$$$.\n</p>\n<p>\n    In Sample Case #2, one option is to change the character at index $$$1$$$ to <code>B</code> in\n    order to have a goodness score of $$$2$$$. Therefore, the minimum number of operations required\n    is $$$1$$$.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":7}],"title":"K-Goodness String","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000436140","type":1,"type__str":"SPECTATOR"},"title":"Round A 2021"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
