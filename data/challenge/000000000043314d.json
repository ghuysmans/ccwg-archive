{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1217156400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043314d","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  In this last sub-round of Google Code Jam 2008 Round 1, 2240 contestants\n  solved at least one dataset, 17 among them got the perfect score of 100\n  points.\n</p><p>\n  The first problem was the easiest one among the 9 Round 1 problems. It is\n  interesting to note that there were contestants from the first page of the\n  scoreboard who solved all of the datasets, except for A-large.\n</p><p>\n  In the second problem, dynamic programming, a common topic in programming\n  contests, made its first appearance in this tournament. We intended this to be\n  an easy dynamic programming problem with a little trick in number theory. From\n  the scoreboard we can tell that this is not a trivial problem.\n</p><p>\n  The last problem, with a nice story, can be regarded as an exercise in data\n  structures. In fact, the small dataset can be solved using standard dynamic\n  programming. For the large dataset, one needs a way to speed it up. In this\n  analysis we introduce an implementation that uses a binary indexed tree.\n</p>\n\n<hr>\n<p>\n  <b>Credits</b>\n</p><p>\n  Problem A. <i>Text Messaging Outrage</i>\n  Written by Mohamed Eldawy. Prepared by Marius Andrei\n</p><p>\n  Problem B. <i>Ugly Numbers</i>\n  Written and prepared Xiaomin Chen.\n</p><p>\n  Problem C. <i>Increasing Speed Limits</i>\n  Written by Petr Mitrichev. Prepared by Mark Gordon.\n</p><p>\n  Contest analysis presented by Cosmin Negruseri, Xiaomin Chen, and Mark Gordon.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1217149200000,"tasks":[{"analysis":"<p>\n  As the problem clearly states, there are 3<sup>D-1</sup> ways you need to\n  consider. When <b>D</b> is no larger than 13, as it is in the small dataset,\n  one may simply generate all the possible combinations and calculate each of\n  them. However, with <b>D</b> as large as 40, brute force is clearly too slow.\n</p><p>\n  As you might expect from a programming contest, the magic term is\n  <a href=\"http://en.wikipedia.org/wiki/Dynamic_programming\" target=\"_blank\">dynamic programming</a>.\n  This is the first problem in Google Code Jam 2008 that falls into the\n  standard dynamic programming (DP) category; and one can be assured that there\n  are more to come.\n</p><p>\n  As in any DP problem, the first task is to structure the problem in a good way\n  so there are not too many numbers to compute, and each number can be computed\n  easily from previous ones. If you observe the solutions of the top scorers in\n  this sub-round, you will see, although their algorithms vary to some degre,\n  they all contain the following magic number\n</p>\n<pre>\n2 &middot; 3 &middot; 5 &middot; 7 = 210.\n</pre>\n<p>\n  Let us say we have two numbers, x and y, knowing the ugliness of x and y is\n  not enough to decide whether <nobr>x + y</nobr> and <nobr>x - y</nobr> are\n  ugly. On the other hand, we do not need the exact value of x and y. Knowing\n  <nobr>x % 210</nobr> and <nobr>y % 210</nobr> is enough for us to decide if,\n  say, <nobr>x + y</nobr> is ugly or not.\n</p><p>\n  For those who prefer mathematical terms, we are using the\n  <a href=\"http://en.wikipedia.org/wiki/Chinese_remainder_theorem\" target=\"_blank\">Chinese remainder theorem</a>.\n  Our problem can be viewed as arithmetics on the cyclic group\n  <nobr>(Z<sub>210</sub>, +)</nobr>.\n</p><p>\n  So, let us outline the most central step of our dynamic programming solution.\n  We want to compute\n</p>\n<pre>\ndyn[i][x] := number of ways we get an expression evaluating \n          to x (mod 210) if we only consider the first i\n          characters of the string. (*)\n</pre>\n<p>\n  So, we have only 40&middot;210 numbers to consider. For each dyn[i][x], we try\n  all possible positions for inserting the last '+' or '-' sign. If the last\n  sign was a '+' before position j (j&lt;i), and the number formed by digits\n  from position j to position i is d, then we want to know\n  <nobr>dyn[j-1][(x-d)%210]</nobr>. On the other hand, if the sign inserted was\n  a '-', then we want to look at <nobr>dyn[j-1][(x+d)%210]</nobr>.\n</p><p>\n  Here is a masterful implementation from our own Derek Kisman. His complete C++\n  solution follows the idea above, with a little twist and some nice programming\n  tricks.\n</p>\n<pre>\n#define MOD (2*3*5*7)\nstring s;\nlong long dyn[41][MOD];\n\nmain() {\n  int N, prob=1;\n  for (cin &gt;&gt; N; N--;) {\n    cin &gt;&gt; s;\n    memset(dyn, 0, sizeof(dyn));\n    dyn[0][0] = 1;\n    for (int i = 0; i &lt; s.size(); i++)\n    for (int sgn = (i==0) ? 1 : -1; sgn &lt;= 1; sgn += 2) {\n      int cur = 0;\n      for (int j = i; j &lt; s.size(); j++) {\n        cur = (cur*10 + s[j]-'0')%MOD;\n        for (int x = 0; x &lt; MOD; x++)\n          dyn[j+1][(x+sgn*cur+MOD)%MOD] += dyn[i][x];\n      }\n    }\n    long long ret = 0;\n    for (int x = 0; x &lt; MOD; x++)\n      if (x%2 == 0 || x%3 == 0 || x%5 == 0 || x%7 == 0)\n        ret += dyn[s.size()][x];\n    cout &lt;&lt; \"Case #\" &lt;&lt; prob++ &lt;&lt; \": \" &lt;&lt; ret &lt;&lt; endl;\n  }\n}\n</pre>\n\n<h3>More information:</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=dynamic+programming\" target=\"_blank\">Dynamic programming</a> -\n  <a href=\"http://www.google.com/search?q=chinese+remainder+theorem\" target=\"_blank\">Chinese remainder theorem</a>\n</p>\n","id":"0000000000432a7f","statement":"<h3>Problem</h3>\n<p>\n  Once upon a time in a strange situation, people called a number <i>ugly</i> if\n  it was divisible by any of the one-digit primes (2, 3, 5 or 7). Thus, 14 is\n  ugly, but 13 is fine. 39 is ugly, but 121 is not. Note that 0 is ugly. Also\n  note that negative numbers can also be ugly; -14 and -39 are examples of such\n  numbers.\n</p><p>\n  One day on your free time, you are gazing at a string of digits, something\n  like:\n</p>\n<pre>\n123456\n</pre>\n<p>\n  You are amused by how many possibilities there are if you are allowed to\n  insert <i>plus</i> or <i>minus</i> signs between the digits. For example you\n  can make\n</p>\n<pre>\n1 + 234 - 5 + 6 = 236\n</pre>\n<p>\n  which is ugly. Or\n</p>\n<pre>\n123 + 4 - 56 = 71\n</pre>\n<p>\n  which is not ugly.\n</p><p>\n  It is easy to count the number of different ways you can play with the digits:\n  Between each two adjacent digits you may choose put a plus sign, a minus sign,\n  or nothing. Therefore, if you start with D digits there are 3<sup>D-1</sup>\n  expressions you can make.\n</p><p>\n  Note that it is fine to have leading zeros for a number. If the string is\n  \"01023\", then \"01023\", \"0+1-02+3\" and \"01-023\" are legal expressions.\n</p><p>\n  Your task is simple: Among the 3<sup>D-1</sup> expressions, count how many of\n  them evaluate to an ugly number.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input file contains the number of cases, <b>N</b>. Each\n  test case will be a single line containing a non-empty string of decimal\n  digits.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, you should output a line\n</p>\n<pre>Case #<b>X</b>: <b>Y</b></pre>\n<p>\n  where <b>X</b> is the case number, starting from 1, and <b>Y</b> is the\n  number of expressions that evaluate to an ugly number.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  0 &le; <b>N</b> &le; 100.<br>\n  The string in each test case will be non-empty and will contain only\n  characters '0' through '9'.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  Each string is no more than 13 characters long.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  Each string is no more than 40 characters long.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1\n9\n011\n12345\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 1\nCase #3: 6\nCase #4: 64\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Ugly Numbers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This was the hard problem for round 1C, with 398 people solving the small i/o\n  set and 49 people solving the large i/o set during the contest.\n</p><p>\n  The problem asks us to count the number of strictly increasing subsequences\n  of the original sequence.  This lends itself nicely to a dynamic programming\n  solution for the small input.\n</p><p>\n  Let f(x) be the number of strictly increasing subsequences that start with\n  node x and S[x] be the value of the sequence at position x.  At any node x we\n  can either end the subsequence at x or connect it to any of the following\n  nodes that are strictly greater than node x.  Therefore, you could do\n  something like this to find out how many strictly increasing subsequences\n  start at each index.\n</p>\n<pre><code>\nf(x) = 1\nfor i = n to 1\n  f(i) = 1\n  for j = i + 1 to n\n    if S[i] &lt; S[j]\n      f(i) = f(i) + f(j)\n</code></pre>\n<p>\n  After doing that, solving the original problem is just a matter of summing\n  the number of ways you make a strictly increasing subsequence starting at\n  each position.\n</p><p>\n  The key to solving the large i/o set is to realize we can make the inner loop\n  run much faster.  What we really want to do is sum all of the previous f(j)s\n  for which <nobr>S[j] &gt; S[i]</nobr>.  This is a classic tree problem.\n  There are a number of tree data structures you could use including a binary\n  indexed tree, a segment tree, or a binary search tree, to name a few, that\n  will allow you to solve the problem in O(n log n) time per case.\n</p><p>\n  The first two types of trees are fairly easy to implement although they add a\n  complication since they use an amount of memory proportional to the maximum\n  value in the sequence.  Fortunately this can be worked around by normalizing\n  S to contain only values between 0 and n-1 without changing the the\n  <nobr>S[i] &lt; S[j]</nobr> property for any i and j.  This can be done by\n  transforming S[i] to be the first occurrence of S[i] in a sorted list of S.\n</p><p>\n  Here is an implementation of these ideas in C++.\n</p>\n<pre><code>\n#define MAXN (1&lt;&lt;20)\nint sum_bit[MAXN];\n\nint sum_bit_get(int x)\n{\n  int ret = 0;\n  for(int i = x | MAXN; i &lt; 2 * MAXN; i += i &amp; -i)\n    ret = (ret + sum_bit[i ^ MAXN]) % 1000000007;\n  return ret;\n}\n\nvoid sum_bit_add(int x, int v)\n{\n  for(int i = x | MAXN; i; i &amp;= i - 1)\n    sum_bit[i ^ MAXN] = (sum_bit[i ^ MAXN] + v) % 1000000007;\n}\n\nint S[1000000];\nint S2[1000000];\n\nint main()\n{\n  int T; cin &gt;&gt; T;\n  long long X, Y, Z, A[100];\n  for(int t = 1; t &lt;= T; t++) {\n    int n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; X &gt;&gt; Y &gt;&gt; Z;\n    for(int i = 0; i &lt; m; i++) cin &gt;&gt; A[i];\n\n    // Generate S\n    for(int i = 0; i &lt; n; i++) {\n      S[i] = A[i % m];\n      A[i % m] = (X * A[i % m] + Y * (i + 1)) % Z;\n    }\n\n    // Normalize S\n    memcpy(S2, S, sizeof(S));\n    sort(S2, S2+n);\n    for(int i = 0; i &lt; n; i++)\n      S[i] = lower_bound(S2, S2+n, S[i]) - S2;\n\n    // Calculate f(i) and sum them in to result.\n    int result = 0;\n    memset(sum_bit, 0, sizeof(sum_bit));\n    for(int i = n - 1; i &gt;= 0; i--) {\n      int add = 1 + sum_bit_get(S[i] + 1);\n      sum_bit_add(S[i], add);\n      result = (result + add) % 1000000007;\n    }\n    \n    cout &lt;&lt; \"Case #\" &lt;&lt; t &lt;&lt; \": \" &lt;&lt; result &lt;&lt; endl;\n  }\n  return 0;\n}\n</code></pre>\n<p>\n  In addition to trees, there was a \"hacker's\" <nobr>O(n &radic;n)</nobr>\n  solution.  The idea behind it is similar to the idea mentioned in solution 1\n  of the Mousetrap editorial (from Round 1B) where, in addition to maintaining\n  the value at each position, we maintain sums for ranges of length &radic;N.\n  These tables can be maintained in constant time and take &radic;n time to\n  query.\n</p><p>\n  More Information:<br>\n  <a href=\"http://www.google.com/search?q=binary+indexed+tree\" target=\"_blank\">Binary Indexed Tree</a>\n</p>\n","id":"0000000000432ad0","statement":"<h3>Problem</h3>\n<p>\n  You were driving along a highway when you got caught by the road police for\n  speeding. It turns out that they've been following you, and they were amazed\n  by the fact that you were accelerating the whole time without using the\n  brakes! And now you desperately need an excuse to explain that.\n</p><p>\n  You've decided that it would be reasonable to say \"all the speed limit signs I\n  saw were in increasing order, that's why I've been accelerating\". The police\n  officer laughs in reply, and tells you all the signs that are placed along the\n  segment of highway you drove, and says that's unlikely that you were so lucky\n  just to see some part of these signs that were in increasing order.\n</p><p>\n  Now you need to estimate that likelihood, or, in other words, find out how\n  many different subsequences of the given sequence are strictly increasing. The\n  empty subsequence does not count since that would imply you didn't look at any\n  speed limits signs at all!\n</p><p>\n  For example, (1, 2, 5) is an increasing subsequence of (1, 4, 2, 3, 5, 5), and\n  we count it twice because there are two ways to select (1, 2, 5) from the\n  list.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>N</b>. <b>N</b> test\n  cases follow. The first line of each case contains <b>n</b>, <b>m</b>,\n  <b>X</b>, <b>Y</b> and <b>Z</b> each separated by a space. <b>n</b> will be\n  the length of the sequence of speed limits. <b>m</b> will be the length of the\n  generating array A. The next <b>m</b> lines will contain the <b>m</b> elements\n  of A, one integer per line (from A[0] to A[<b>m</b>-1]).\n</p><p>\n  Using A, <b>X</b>, <b>Y</b> and <b>Z</b>, the following pseudocode will\n  <i>print</i> the speed limit sequence in order. mod indicates the remainder\n  operation.\n  <code><pre>\nfor i = 0 to n-1\n  <i>print</i> A[i mod <b>m</b>]\n  A[i mod <b>m</b>] = (<b>X</b> * A[i mod <b>m</b>] + <b>Y</b> * (i + 1)) mod <b>Z</b>\n  </pre></code>\n</p><p>\n  Note: The way that the input is generated has nothing to do with the intended\n  solution and exists solely to keep the size of the input files low.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case you should output one line containing \"Case #<b>T</b>:\n  <b>S</b>\" (quotes for clarity) where <b>T</b> is the number of the test case\n  and <b>S</b> is the number of non-empty increasing subsequences mod\n  1<sub>&nbsp;</sub>000<sub>&nbsp;</sub>000<sub>&nbsp;</sub>007.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 60 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>N</b> &le; 20<br>\n  1 &le; <b>m</b> &le; 100<br>\n  0 &le; <b>X</b> &le; 10<sup>9</sup><br>\n  0 &le; <b>Y</b> &le; 10<sup>9</sup><br>\n  1 &le; <b>Z</b> &le; 10<sup>9</sup><br>\n  0 &le; <b>A[i]</b> &lt; <b>Z</b><br>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>m</b> &le; <b>n</b> &le; 1000\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>m</b> &le; <b>n</b> &le; 500000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5 5 0 0 5\n1\n2\n1\n2\n3\n6 2 2 1000000000 6\n1\n2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 15\nCase #2: 13\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  The sequence of speed limit signs for case 2 should be 1, 2, 0, 0, 0, 4.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":35}],"title":"Increasing Speed Limits","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This was the one of the easiest problems of Round 1. We simply need to fill\n  the cell phone keyboard greedily. We put the <b>K</b> most frequent letters in\n  the first positions of the <b>K</b> keys, the next <b>K</b> most frequent\n  letters in the second positions, and so on. Any optimal solution will have\n  this structure because if it does not, then it can be improved by swapping a\n  more frequent character from a higher indexed position of some key with a less\n  frequent character from a lower indexed position, thus decreasing the number\n  of key presses.\n</p><p>\n  Here is code that implements this solution:\n</p>\n<pre>\nlong long A[1000];\n\nint main() {\n  int N;\n  cin &gt;&gt; N;\n  for(int t = 1; t &lt;= N; t++) {\n    long long result = 0;\n    int P, K, L;\n    cin &gt;&gt; P &gt;&gt; K &gt;&gt; L;\n    for(int i = 0; i &lt; L; i++) cin &gt;&gt; A[i];\n    sort(A, A+L);\n    reverse(A, A+L);\n\n    for(int i = 0; i &lt; L; i++)\n      result += (1 + i / K) * A[i];\n\n    cout &lt;&lt; \"Case #\" &lt;&lt; t &lt;&lt; \": \" &lt;&lt; result &lt;&lt; endl;\n  }\n}\n</pre>\n","id":"0000000000432bd3","statement":"<h3>The story</h3>\n<p>\n  Professor Loony, a dear friend of mine, stormed into my office. His face was\n  red and he looked very angry. The first thing that came out of his mouth was\n  \"Damn those phone manufacturers. I was trying to send a text message, and it\n  took me more than ten minutes to type a one-line message.\" I tried to calm him\n  down. \"But what is wrong? Why did it take you so long?\" He continued, \"Don't\n  you see?! Their placement of the letters is so messed up? Why is 's' the 4th\n  letter on its key? and 'e'? Why is it not the first letter on its key? I have\n  to press '7' FOUR times to type an 's'? This is lunacy!\"\n</p><p>\n  \"Calm down, my friend,\" I said, \"This scheme has been in use for so long, even\n  before text messaging was invented. They had to keep it that way.\"\n</p><p>\n  \"That's not an excuse,\" his face growing redder and redder. \"It is time to\n  change all this. It was a stupid idea to start with. And while we are at it,\n  how come they only put letters on 8 keys? Why not use all 12? And why do they\n  have to be consecutive?\"\n</p><p>\n  \"Umm... I... don't... know,\" I replied.\n</p><p>\n  \"Ok, that's it. Those people are clearly incompetent. I am sure someone can\n  come up with a better scheme.\"\n</p><p>\n  He was one of <i>those</i> people, I could see. People who complain about the\n  problem, but never actually try to solve it.\n</p><p>\n  In this problem, you are required to come up with the best letter placement of\n  keys to minimize the number of key presses required to type a message. You\n  will be given the number of keys, the maximum number of letters we can put on\n  every key, the total number of letters in the alphabet, and the frequency of\n  every letter in the message. Letters can be placed anywhere on the keys and in\n  any order. Each letter can only appear on one key. Also, the alphabet can have\n  more than 26 letters (it is not English).\n</p><p>For reference, the current phone keypad looks like this<br></p>\n<pre>\nkey 2: abc\nkey 3: def\nkey 4: ghi\nkey 5: jkl\nkey 6: mno\nkey 7: pqrs\nkey 8: tuv\nkey 9: wxyz\n</pre>\n<p>\n  The first press of a key types the first letter. Each subsequent press\n  advances to the next letter. For example, to type the word \"snow\", you need to\n  press \"7\" four times, followed by \"6\" twice, followed by \"6\" three times,\n  followed by \"9\" once. The total number of key presses is 10.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line in the input file contains the number of test cases <b>N</b>.\n  This is followed by <b>N</b> cases. Each case consists of two lines. On the\n  first line we have the maximum number of letters to place on a key (<b>P</b>),\n  the number of keys available (<b>K</b>) and the number of letters in our\n  alphabet (<b>L</b>) all separated by single spaces. The second line has\n  <b>L</b> non-negative integers. Each number represents the frequency of a\n  certain letter. The first number is how many times the first letter is used,\n  the second number is how many times the second letter is used, and so on.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each case, you should output the following\n</p>\n<pre>\nCase #x: [minimum number of keypad presses]\n</pre>\n<p>\n  indicating the number of keypad presses to type the message for the optimal\n  layout.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  <b>P</b> * <b>K</b> &ge; <b>L</b> <br>\n  0 &le; The frequency of each letter &le; 1000000\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10<br>\n  1 &le; <b>P</b> &le; 10<br>\n  1 &le; <b>K</b> &le; 12<br>\n  1 &le; <b>L</b> &le; 100<br>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 100<br>\n  1 &le; <b>P</b> &le; 1&nbsp;000<br>\n  1 &le; <b>K</b> &le; 1&nbsp;000<br>\n  1 &le; <b>L</b> &le; 1&nbsp;000<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 2 6\n8 2 5 2 4 9\n3 9 26\n1 1 1 100 100 1 1 1 1 1 1 1 1 1 1 1 1 10 11 11 11 11 1 1 1 100\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: 47\nCase #2: 397\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Text Messaging Outrage","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043314d","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
