{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1276360200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043315b","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 3 was definitely the most difficult round of this year's Code Jam so far. Only the top 25 advanced to the Finals, and the problems were hellishly hard. Last year's winner, ACRush, struggled to stay in the top 25 after an incorrect submission of his B-large. Of course, none of the contestants knew that his submission was incorrect, as he stayed in the top spot on the scoreboard until the end of the round, when he dropped down to 24th place.\n</p>\n<p>\nThe last 20 minutes of the contest were a race among RAVEman, Gennady.Korotkevich and Burunduk1 to finish their last remaining problems. nika, winger and pashka joined the race to first place, each having 78 points with 5 minutes to go. With less than one minute to go, winger pulled out ahead with a full 100 points -- a clear win. Amazingly, just a few seconds later, Burunduk1 and Eryx joined him, having solved their last remaining problems as well. Burunduk1 ended up winning the round with 2 incorrect submissions over winger's 3.\n</p>\n<p>\nCongratulations to all participants, and good luck to the top 25, who will compete in person at the World Finals in Google's Dublin office.\n</p>\n\n<h3>Cast</h3>\n<p>Problem A. <i>De-RNG-ed</i> Written by Igor Naverniouk. Prepared by Ante Derek and Igor Naverniouk</p>\n<p>Problem B. <i>Fence</i> Written by David Arthur.  Prepared by Xiaomin Chen and David Arthur.</p>\n<p>Problem C. <i>Hot Dog Proliferation</i> Written and prepared by David Arthur.</p>\n<p>Problem D. <i>Different Sum</i> Written and prepared by Petr Mitrichev.</p>\n<p>Contest analysis presented by David Arthur, Xiaomin Chen, Petr Mitrichev, and Igor Naverniouk.</p>\n<p>Solutions and other problem preparation provided by Marius Andrei, Xiaomin Chen, John Dethridge, and Bartholomew Furrow.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1276351200000,"tasks":[{"analysis":"<p>\nThe basic scenario here is very similar to the traditional change-making problem, except that the input can be (and actually is guaranteed to be) very large. A condition on the minimum size of the input is very unusual for a programming contest problem, and we didn't add it just for fun. Our solution really, truly does require that the fence length be at least 10^10.\n</p>\n\n<h3>Small Input</h3>\n\n<p>\nBefore getting into the real solution though, let's discuss a simpler approach that at least solves the small input. Let's suppose the longest board is of length <code>A &le; 100</code>. The key idea is that we should never use more than <code>A</code> boards of any size less than <code>A</code>. If we did, we could replace <code>A</code> of those boards with a smaller number of length-<code>A</code> boards. And that would of course be a better solution.\n</p>\n\n<p>\nIn particular, this means the total length of all shorter boards is at most <code>N * A * A &le; 1000000</code>. Using a breadth-first search, we can find the optimal way of choosing these boards to get each length in that range. The cost of completing the fence using length-<code>A</code> boards can then be computed with a simple division.\n</p>\n\n<p>\nBy the way, you can actually replace <code>N * A * A</code> with just <code>A * A</code> in the above solution. Hopefully you will see why after reading the rest of the solution!\n</p>\n\n<h3>Large Input</h3>\n\n<p>\nThe small-input solution does not actually take advantage of the minimum length of the fence. So the big question is: how could we possibly do that?\n</p>\n\n<p>\nWell, the previous solution offers a bit of a hint. For a really long fence, it makes sense that in the end, we are going to want to make heavy use of the longest board just to cover up as much length as possible. So let's suppose the longest board has length <code>A</code>, and that <b>L</b> is equal to <code>p*A + q</code> for integers <code>p</code>, <code>q</code> with <code>q &lt; A</code>. (Note that the problem statement guarantees <code>p &ge; A</code>.) Then we need to do one of the following things:\n<ul>\n<li> Use a number <code>T<sub>0,q</sub></code> of shorter boards to create a fence of length <code>0*A + q</code>, then use <code>p</code> boards of length <code>A</code> to cover the rest.</li>\n<li> Use a number <code>T<sub>1,q</sub></code> of shorter boards to create a fence of length <code>1*A + q</code>, then use <code>p-1</code> boards of length <code>A</code> to cover the rest.</li>\n<li> ...\n<li> Use a number <code>T<sub>p,q</sub></code> of shorter boards to create a fence of length <code>p*A + q</code>, then use <code>0</code> boards of length <code>A</code> to cover the rest.</li>\n</ul>\n</p>\n\n<p>\nSo we need to calculate <code>p + S<sub>p,q</sub></code> where <code>S<sub>p,q</sub></code> is defined to be <code>min(T<sub>0,q</sub> - 0, T<sub>1,q</sub> - 1, ..., T<sub>p,q</sub> - p)</code>. Intuitively, <code>S<sub>p,q</sub></code> can be thought of as measuring the minimal number of boards required to get a fence length of <code>q</code> mod <code>A</code>, subject to two modifications:\n<ul>\n<li>Every time the length increases by <code>A</code>, it means one less max-length board in the future, so you can subtract one from the total count.\n<li>The total length is not allowed to go over <code>p*A + q</code>.\n</ul>\nAnd now, we can make concrete how the condition that <b>L</b> is very large simplifies things:\n</p>\n\n<p>\n<b>Lemma:</b> The second condition in the definition of <code>S<sub>p,q</sub></code> is unnecessary.\n</p>\n\n<p>\n<i>Proof:</i> We claim that <code>T<sub>i,q</sub> - i</code> is minimized when <i>i &le; p</i>, which will prove the lemma. So let's consider a minimal <code>T<sub>i,q</sub> - i</code>. Then we have a set of boards <code>b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub></code> making a length of <code>i*A + q</code>. If <code>i &gt; p</code>, then <code>m &gt; p &ge; A</code>. But then, the set <code>{b<sub>1</sub>, b<sub>1</sub> + b<sub>2</sub>, ..., b<sub>1</sub> + b<sub>2</sub> + ... b<sub>m</sub>}</code> contains at least <code>A+1</code> numbers, so two of these numbers are congruent modulo <code>A</code>. Subtracting them, we can find a non-empty subset of <code>{b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>m</sub>}</code> whose sum is a multiple of <code>A</code>. Therefore, we can replace that subset with boards of length <code>A</code> to get a strictly better solution, implying <code>T<sub>i,q</sub> - i</code> could not have been optimal in the first place!\n</p>\n\n<p>\nOkay, that's all very nice, but what's the solution? Well the previous lemma implies we need to calculate the minimum number of boards required to get a fence of length <code>q</code> mod <code>A</code>, subject to the fact that each time the total goes up by <code>A</code>, we will need one fewer board in the future. (For shorter fences, this approach just does not work. Our algorithm would make a very long fence with length correct modulo <code>A</code>, and then try to subtract length-<code>A</code> boards, which of course is not allowed!)\n</p>\n\n<p>\nAnyway, once the problem has been reduced in this way, it can be done pretty straightforwardly with a breadth-first search. Our graph has one vertex for each residue modulo <code>A</code>. From each vertex, we add an edge for each possible board length. If adding that board involves wrapping past <code>A</code>, then it has weight 0. Otherwise, it has weight 1. So the final algorithm is: calculate the minimum distance in this graph to vertex <code>q</code> to get <code>S<sub>p,q</sub></code>, and finally add <code>p</code>.\n</p>\n","id":"0000000000432a85","statement":"<h3>Problem</h3>\n\n<p>\nWe are looking into building a very long fence. We have already found a nice place to build it, and all that remains is to collect the materials.\n</p>\n\n<p>\nFrom local hardware stores, we can buy unlimited numbers of wooden boards, each of which can come in a variety of different lengths. To avoid waste, we want to make sure that the total length of these boards is <i>exactly</i> equal to the length of the fence we are trying to build.\n</p>\n\n<p>Given the length of the fence, and the possible board lengths that we can use, what is the minimum number of boards that we need to purchase in order to get exactly the right length?</p>\n\n<p><i>Beware:</i> the fence is going to be very long!</p>\n\n<h3>Input</h3>\n\n<p>\nThe first line of the input file contains the number of cases, <b>T</b>. <b>T</b> test cases follow.\n</p>\n\n<p>\nEach test case consists of two lines. The first line contains space-separated integers <b>L</b> and <b>N</b>. These represent the total length of the fence, and the number of different board lengths that can be purchased. The second line contains <b>N</b> space-separated integers <b>B<sub>1</sub></b>, <b>B<sub>2</sub></b>, ..., <b>B<sub>N</sub></b>, representing all the possible board lengths.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: M\", where x is the case number (starting from 1) and M is as follows:\n<ul>\n<li> If it is possible to purchase one or more boards so that their total length is exactly equal to <b>L</b>, then M should be the minimum number of boards required to do this.\n<li> Otherwise, M should be the string \"IMPOSSIBLE\".\n</ul>\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n10<sup>10</sup> &le; <b>L</b> &le; 10<sup>18</sup>.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n<h3>Small dataset (Test set 1 - Visible)</h3>\n<p>\n1 &le; <b>B<sub>i</sub></b> &le; 100.<br/>\n</p>\n\n<h3>Large dataset (Test set 2 - Hidden)</h3>\n<p>\n1 &le; <b>B<sub>i</sub></b> &le; 100000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n10000000001 3\n23 51 100\n10000000001 3\n100 52 22\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 100000004\nCase #2: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Explanation</h3>\n\n<p>In the first example, the optimal strategy is to use 2 boards of length 23, 5 boards of length 51, and 99999997 boards of length 100. Of course, you could use just 100000001 boards of length 100 to get a total <i>greater</i> than <b>L</b>, but that is not allowed.</p>\n\n<p>In the second example, it is only possible to get even lengths.</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Fence","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Background</h3>\n<p>\nThis analysis will have nothing to do with hot dogs. Instead of a long street with billions of corners, let's think of the line of integers; instead of vendors, let's think of chips -- after all, chips are much easier to maneuver than real people with hot dog stands!</p>\n\n<p>\nWe denote the number of total chips by <code>n</code>. Also, let's call a configuration <i>stable</i> if no two chips occupy the same integer point.\n</p>\n<p>\nIf you play around with the game for a while or if you have good (and brave!) intuition, you might realize that the problem statement is a little misleading. It turns out that no matter which move you do at each step, the final configuration, as well as the total number of moves you need to perform, will always be the same.\n</p>\n<p>\nIndeed, this is a famous theorem for \"chip-firing games\", and our scenario is a special kind of chip-firing game. Intuitively, the reason why your choices don't matter is that (a) if you ignore a move now, you will still have to do it later, and (b) one move will not change the effect of another move down the line. This means that while you can control the <i>order</i> of moves, you will always do the same set of moves in the end, and they will always have the same effect.\n</p>\n<p>\nThis observation is enough to solve the small input. Just keep doing moves until the configuration stabilizes, and count how long it took. For the large input though, more insight is required. A configuration might require over 10^13 moves to stabilize, so simulating them one at a time is out of the question. The obvious optimization is to do several moves at once for very large piles. Surprisingly however, this does not help very much.\n</p>\n<p>\nThere are a few different ways to proceed, and we will discuss two of them.\n</p>\n\n<h3>Preliminary Observations</h3>\n<p>\nOne very useful way of understanding this game is in terms of <i>invariants</i>. The first of these is pretty obvious, but the other requires either some special insight or some experience to see. In each move, we take two chips at some position <code>x</code> and send them to positions <code>x-1</code> and <code>x+1</code>. Notice that:\n<blockquote>\n(x-1) + (x+1) = x + x <br/>\n(x-1)<sup>2</sup> + (x+1)<sup>2</sup> = x<sup>2</sup> + x<sup>2</sup> + 2.\n</blockquote>\nThis immediately leads to the following two observations:\n</p>\n<p>\n<b>Observation 1.</b> The sum of the positions of all the chips never changes.\n</p>\n<b>Observation 2.</b> The sum of the squared positions of all the chips increases by 2 during each move.\n</p>\n<p>\nSo how do we use these observations? They aren't <i>necessary</i>, but they will have their uses as you will see. The former one will help us quickly construct a configuration with certain known properties from the initial configuration (more on this later). And with the latter observation, computing the number of steps becomes the same task as constructing the final configuration. For example, using Observation 2, we can easily estimate that the number of steps could be on the order of <code>n<sup>3</sup></code>, thereby verifying that straightforward simulation really is hopeless.\n</p>\n\n<h3>Adding one chip</h3>\n<p>\nOne good approach is to add chips one at a time, at each step doing enough moves to completely stabilize the configuration. The question is: how do we do this last part efficiently? So let's consider adding a chip to a stable configuration.\n</p>\n<p>\nIf the new chip arrives at a position where there was no chip before, we are done. Otherwise, it lands on a segment, and the picture looks something like this:\n<pre>\n             *\n?????????.***************.????????\n</pre>\nThe two \"<code>.</code>\"s represents empty positions. If you play around with a couple examples, you should be able to see that the ending result will always be two segments, one starting from the position of the left \".\" in the picture, and the other ending at the position of the right \".\". We might also view the result as a single segment with a hole. Furthermore, you might also realize that if there were <code>A</code> points to the left of our new chip in the original configuration, and <code>B</code> points to the right, then the two new segments will have lengths <code>B+1</code> and <code>A+1</code> respectively, and the total number of moves required will be <code>(A+1)*(B+1)</code>.\n</p>\n\n<p>\nWe could also have computed the position of the hole using Observation 1. The sum of the positions in the initial configuration is (1+2+...+15)+4, and we know in the new configuration that the sum is (0+1+...+16)-H, where H is the position of the hole. Therefore, H must be 12. The final picture is\n<pre>\n?????????************.****????????\n</pre>\nWe could then use Observation 2 to easily determine how many moves were required to get here.\n</p>\n\n<p>\nSo here is one possible solution to the problem. Add the chips one by one. At each stage, we have up to <code>n</code> disjoint segments. If the new chip lands on an unoccupied position, it forms a segment unto itself; otherwise, it transforms one segment into two as described above. In either case, the new segments might touch the ones to their left and/or right, and we merge them if that happens.\n</p>\n\n<p>\nAll that's left is to figure out how to store these segments in your program. If you are clever, you might realize that if we add the chips from left to right, then each new chip will always be on or next to one of the last two segments. You could then use a stack to store all the segments -- all the operations will be on the top two elements of the stack. This approach gives an <code>O(n)</code> solution. If you missed this last insight, you could also use a binary search tree (e.g. an STL set) to get an <code>O(n log n)</code> solution.\n</p>\n\n<h3>Adding one pile</h3>\n<p>\nIn our problem, we have <code>C</code> piles of chips, and usually <code>C</code> is much smaller than <code>n</code>. We now sketch a lightning-fast solution that runs in <code>O(C)</code> time. This level of insight is not necessary to solve the problem, but it's still pretty interesting. As you will see, it is essential to understand the details of the above <code>O(n)</code> solution.\n</p>\n<p>\nInstead of adding one chip at a time, we will try to process all the chips from a single position at the same time.\n</p>\n<p>\nFirst let's resolve the case when there is only one pile of <code>n</code> chips at position <code>x</code>. By symmetry and the discussions in the previous section, it is easy to see that the stable configuration is a segment centered at <code>x</code> if <code>n</code> is odd; and a segment centered at <code>x</code> with a hole in the center if <code>n</code> is even.\n</p>\n<p>\nLet's define an <i>H-segment</i> to be a segment with a hole. It is a tuple <code>(x, y, z)</code>, where <code>x &lt; y &le; z</code>, representing a segment of chips from position <code>x</code> to position <code>z</code>, inclusive, but with position <code>y</code> empty. Note that, when <code>y = z</code>, the hole is at the very end, and it is actually a normal segment.\n</p>\n<p>\nOur solution adds the piles one by one. And we keep a stack of existing H-segments from the left to the right. When a new pile comes, it is transformed into a new H-segment. If the H-segment does not overlap with any existing H-segments, we are done. Otherwise, it overlaps with the topmost H-segment in the stack; that is, it creates some positions with two chips. But using the observations from the last section, we know that if we resolve the conflicts one at a time, we will always have at most one hole. That means the result will be another H-segment. If the new one overlaps with the current top H-segment in the stack, we continue with the same resolving process. We do this until the stack is empty, or the H-segment is disjoint from the top of the stack. Then we push the new one and proceed to the next pile.\n</p>\n<p>\nIt remains only to explain how to compute a new H-segment quickly. And the answer is: just use Observation 1 again! When resolving two H-segments, we know <code>S</code> -- the sum of the positions in them; we also know the total number of chips <code>K</code>, so (remember the hole), <code>z = x+K</code>. We need to decide the start position <code>x</code>. Depending on <code>y</code>, the sum <code>S</code> satisfies \n<blockquote>\n<code>K(2x + K - 1) / 2 &le; S &lt; K(2x + K + 1) / 2</code>\n</blockquote>\nThere is a unique <code>x</code> satisfying this, and it can be solved in constant time. We can then find <code>y</code> exactly like we did in the <code>O(n)</code> solution.\n</p>\n<br/>\n<br/>\n\n<h3>More Information</h3>\n<p>\nIf you liked this problem, you might also enjoy reading the following classical paper on chip-firing games:<br/>\n- Anders Bj&#246;rner, L&#225;szl&#243; Lov&#225;sz, and Peter Shor <i>Chip-firing games on graphs</i>. European Journal of Combinatorics, Volume 12 ,  Issue 4 (July 1991).\n</p>\n","id":"0000000000432ad8","statement":"<h3>Problem</h3>\n\n<p>A number of hot dog vendors have started selling hot dogs at corners (intersections) along a very long east-west street. The problem is that multiple vendors might be selling at the same corner, and then they will take each other's business. All is not lost though! The hot dog vendors have a plan.</p>\n\n<p>If there are ever two or more vendors at the same corner, then exactly two of the vendors can perform a <b>move</b>, which means:\n<ul>\n<li> One vendor moves one corner further to the east along the street.\n<li> The other vendor moves one corner further to the west along the street.\n</ul>\nRemember that the street is really long, so there is no danger of running out of corners. Given the starting positions of all hot dog vendors, you should find the minimum number of moves they need to perform before the vendors are all separated (meaning they are all on different corners).</p>\n\n<p>For example, suppose the street begins with the following number of hot dog vendors on each corner, listed in order from west to east:\n<pre>\n... 0 0 2 1 2 0 0 ...\n</pre>\nThen the vendors can be separated in three moves, as shown below:\n<pre>\n... 0 0 2 1 2 0 0 ...\n        |\n        +--- Do a move here\n\n... 0 1 0 2 2 0 0 ...\n          |\n          +--- Do a move here\n\n... 0 1 1 0 3 0 0 ...\n            |\n            +--- Do a move here\n\n... 0 1 1 1 1 1 0 ...\n</pre>\n</p>\n\n<h3>Input</h3>\n\n<p>\nEach street corner is labeled with an integer, positive or negative. For each <code>i</code>, corner <code>i+1</code> refers to the next corner to the east from corner <code>i</code>. We will use this labeling system to describe corners in the input file.\n</p>\n\n<p>\nThe first line of the input file contains the number of cases, <b>T</b>. <b>T</b> test cases follow. Each case begins with the number of corners <b>C</b> that have at least one hot dog vendor in the starting configuration. The next <b>C</b> lines each contain a pair of space-separated integers <b>P</b>, <b>V</b>, indicating that there are <b>V</b> vendors at corner <b>P</b>.</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: M\", where x is the case number (starting from 1) and M is the minimum number of moves that need to be performed before the vendors all end up at different corners from each other.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n1 &le; <b>C</b> &le; 200.<br/>\nAll <b>P</b> values are in the range [-1000000, 1000000].<br/>\nWithin each test case, all <b>P</b> values are distinct and listed in increasing order.<br/>\nAll <b>V</b> values are positive integers. The limit on the sum of all <b>V</b> values is listed below. <br/>\nIt will always be possible to separate the hot dog vendors in a finite number of moves.\n</p>\n\n<h3>Small dataset (Test set 1 - Visible)</h3>\n<p>\nThe total number of hot dog vendors in each test case is at most 200.\n</p>\n\n<h3>Large dataset (Test set 2 - Hidden)</h3>\n<p>\nThe total number of hot dog vendors in each test case is at most 100000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\n-1 2\n0 1\n1 2\n2\n-1000 1\n2000 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Hot Dog Proliferation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"Finding the next integer in the sequence means figuring out the values of <b>A</b>, <b>B</b> and <b>P</b> that fit the given numbers and using them to generate the next number.\n\n<p>\nThis problem has a few special cases. In all of them, it is important to note that the value of <b>P</b> must always be larger than every element of the \"randomly\" generated sequence. (8 can never be a remainder after dividing by 7.) Also, the problem statement requires that <b>P</b> be no larger than 10<sup><b>D</b></sup>. Let's call all primes that satisfy both of these bounds \"valid primes\". Now, let's look at the special cases.\n</p>\n\n<h3><b>K = 1</b></h3>\n<p>\nFirst of all, when <b>K</b> is 1, the answer is always \"I don't know.\" This is because we can pick any valid prime <b>P</b>, set <b>A</b> to 0 and <b>B</b> to 0 or 1. This will give us two different answers.\n</p>\n\n<h3><b>K = 2 and the two sequence elements are the same</b></h3>\n<p>\nIn this case, the answer is unique because the next element of the sequence depends only on the current element. If two consecutive elements are the same, then the entire sequence consists of a single repeated number.\n</p>\n\n<h3><b>K &gt; 2 and all the sequence elements are the same</b></h3>\n<p>\nSimilarly, the next element must be the same as all other elements.\n</p>\n\n<h3><b>K = 2 and the two sequence elements are different</b></h3>\n<p>\nHere, the answer is always \"I don't know.\" To see that, pick any valid prime and consider the cases <b>A</b>=0 and <b>A</b>=1. If we call the first element of the sequence <b>x</b> and the second element <b>y</b>, we can express <b>y</b> as a function of <b>x</b>, <b>A</b>, <b>B</b> and <b>P</b>:\n<nobr><b>y</b> = (<b>A*x</b> + <b>B</b>) % <b>P</b>.</nobr> In both cases, we can solve this equation for <b>B</b>. The next element, <b>z</b> is then\n<nobr><b>z</b> = (<b>A*y</b> + <b>B</b>) % <b>P</b>,</nobr> and it must be different in the two cases (<b>A</b>=0 and <b>A</b>=1) as long as <b>x</b> is different from <b>y</b>.\n</p>\n\n<h3><b>K = 3</b></h3>\n<p>\nWe are going to brute force all valid primes and solve for <b>A</b> and <b>B</b>. We will then use these values to generate the next element of the sequence. If all the values we get this way are the same, then the answer is unique. If we get different valid answers, then the answer is \"I don't know.\"\n</p>\n\n<p>\nLet's call the 3 elements <b>x</b>, <b>y</b> and <b>z</b>. By writing <b>y</b> as a function of <b>x</b> and <b>z</b> as a function of <b>y</b> and subtracting <b>y</b> from <b>z</b>, we get<br>\n<b>z</b> - <b>y</b> = (<b>A*y</b> + <b>B</b>) - (<b>A*x</b> + <b>B</b>)\n= <b>A</b>*(<b>y</b> - <b>x</b>) (mod <b>P</b>).\n</p>\n\n<p>\nWe have already dealt with the case when <b>x</b> equals <b>y</b>, so we can assume that <b>x</b> and <b>y</b> are different, so we can divide by their difference. This lets us solve for <b>A</b>.<br>\n<b>A</b> = (<b>z</b> - <b>y</b>)*(<b>y</b> - <b>x</b>)<sup>-1</sup> (mod <b>P</b>).<br>\nComputing the inverse of <nobr>(<b>y</b> - <b>x</b>)</nobr> can be done using the <a href=\"http://www.google.com/search?q=euclidean+algorithm\" target=\"_blank\">Euclidean algorithm</a>, which runs in O(log(<b>P</b>)) time.\n</p>\n\n<p>\nOnce we have <b>A</b>, solving for <b>B</b> is easy:<br>\n<b>B</b> = <b>y</b> - <b>A*x</b>.\n</p>\n\n<p>\nThe answer is then <b>A*z</b> + <b>B</b>.\n</p>\n\n<h3><b>K &gt; 3</b></h3>\n<p>\nIn this case, we brute force <b>P</b>, use the first 3 elements of the sequence to solve for <b>A</b> and <b>B</b>, and check whether the remaining elements fit the sequence generated with these parameters.\n</p>","id":"0000000000432be1","statement":"<h3>Problem</h3>\n<p>\nI want to make an online poker website. A very important component of such a system is the random number generator. It needs to be fast and random enough. Here is a compromise I came up with. I need a way to generate random numbers of length at most <b>D</b>. My plan is to select a prime number <nobr><b>P</b> &le; 10<sup><b>D</b></sup></nobr>. I am also going to pick non-negative integers <b>A</b> and <b>B</b>. Finally, I'm going to pick an integer seed <b>S</b> between 0 and <nobr><b>P</b>-1</nobr>, inclusive.\n</p>\n\n<p>\nTo output my sequence of pseudo-random numbers, I'm going to first output <b>S</b> and then compute the new value of <b>S</b> like this:<br>\n<code><b>S</b> := (<b>A</b>*<b>S</b> + <b>B</b>) mod <b>P</b>.</code>\n</p>\n\n<p>\nThen I will output the new value of <b>S</b> as the next number in the sequence and update <B>S</b> again by using the same formula. I can repeat this as many times as I want.\n</p>\n\n<p>\nDo you think that this is a good random number generator? Can you write a program that takes <b>K</b> consecutive elements of a sequence that was generated by my random number generator, and prints the next element of the sequence?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one starts with a line containing <b>D</b> and <b>K</b>. The next line contains <b>K</b> consecutive elements generated by a random number generator of the kind described above.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is either the next number in the sequence, or the string \"I don't know.\" if the answer is ambiguous.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br>\n1 &le; <b>K</b> &le; 10.<br>\nThe <b>K</b> integers will be consecutive elements of\na sequence generated by a random number generator of\nthe type described above.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>D</b> &le; 4.<br>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>D</b> &le; 6.<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 10\n0 1 2 3 4 5 6 7 8 9\n3 1\n13\n1 5\n6 6 6 6 6\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 10\nCase #2: I don&#39;t know.\nCase #3: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":10}],"title":"De-RNG-ed","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>The small input</h3>\n<p>The solution for the small input of this problem was quite straightforward. One could iterate over all possible ways to partition <b>N</b> into a sum of positive integers, and verify that each column has distinct digits.</p>\n<p>Since there are 190569292 partitions of 100 into a sum of positive integers, this algorithm might not run fast enough. However, we can optimize it with an easy observation: the summands must be distinct. That brings the total number of partitions of 100 down to just 444793, which is small enough for our needs.</p>\n<p>But if you want to cut the search space down even further, you can use <i>backtracking</i>. This is a general technique that works as follows in this problem: as you're generating the partition, you can check if there's a column that has two equal digits after adding each number, not just in the end. That way, many bad partitions get filtered out early and you have even less possibilities to check.</p>\n<h3>The large input</h3>\n<p>In order to approach the large input, we need to rotate ourselves 90 degrees. In the above solution, we've generated our cryptarithm from top to bottom. Now, we will generate it from right to left.</p>\n<p>First, we check all possibilities for the digits in the rightmost (least significant) column such that the last digit of their sum matches the required one. Then, we continue with the digits for the next-to-rightmost column, and so on.</p>\n<p>Suppose we have already filled a few rightmost columns. We can note that the things that are relevant for us now is the value <b>V</b> of carry from the already filled columns to the next one, the amount <b>K</b> of summands in the column that was just filled, and the boolean flag <b>F</b> indicating whether there has been a zero in the column that was just filled (this flag is important since it affects whether we can terminate the corresponding number now). When we know the values of <b>V</b>, <b>K</b> and <b>F</b>, the actual digits in the already filled columns don't affect the further execution of the algorithm.</p>\n<p>This observation logically leads us to the following <i>Dynamic Programming</i> solution: let's calculate <b>Count</b>[<b>i</b>, <b>V</b>, <b>K</b>, <b>F</b>] which is defined as the number of ways to place the digits in the last <b>i</b> columns in such a way that the sum in those columns matches <b>N</b>, there's a carry of <b>V</b>, the number of summands that have at least <b>i</b> digits is <b>K</b>, and <b>F</b> is 1 when there's a summand that starts with zero, 0 otherwise.</p>\n<p>In order to calculate <b>Count</b>[<b>i</b>+1,...] given <b>Count</b>[<b>i</b>,...], we need to consider all possible ways to place up to <b>K</b> digits in the <b>i</b>+1-th rightmost column. <b>K</b> is up to <b>B</b> (since all digits in one column are different, the number of summands doesn't exceed the number of different digits), which can be up to 100 in the large input. From the first glance, this gives us at least 100! (factorial of 100) possibilities, rendering our idea still useless.</p>\n<p>But now's when another Dynamic Programming idea comes into play! One can notice that we don't need to know exactly all digits of the <b>i</b>+1-th column. The important thing for us is the amount of those digits, the sum of those digits, and whether one of them is zero. When we know those, we can multiply our answer by an appropriate number (which will be a product of binomial coefficients and factorials) to account for various ways to attach those digits to the already formed numbers in the first <b>i</b> columns.</p>\n<p>So we run a separate Dynamic Programming that calculates <b>Count2</b>[<b>K</b>, <b>S</b>, <b>F</b>] which is defined as the number of ways to place <b>K</b> distinct digits in a column such that their sum is <b>S</b> and <b>F</b> denotes whether one of them is zero. <b>K</b> is up to <b>B</b>, <b>S</b> is O(<b>B</b><sup>2</sup>), meaning we get O(<b>B</b><sup>3</sup>) states, which is small enough.</p>\n<p>The main Dynamic Programming has O(<b>B</b><sup>2</sup>*<b>number_of_digits</b>) states, and using the <b>Count2</b> table each state can be processed in O(<b>B</b><sup>2</sup>) by looking at the number of digits in the <b>i</b>+1-th column and the carry to the <b>i</b>+2-th column (the required sum in the <b>i</b>+1-th column is uniquely determined by the carry to it, the carry from it, and the corresponding digit of <b>N</b>). The total runtime of this solution is thus O(<b>B</b><sup>4</sup>*<b>number_of_digits</b>).\n","id":"0000000000433087","statement":"<h3>Problem</h3>\n<p>\nWe have come up with a wonderful problem for Google Code Jam 2010 that involves contestants solving a cryptarithm. But we need your help in creating testcases for the problem; more precisely, we're concerned with addition equations that are good enough (in the sense defined below) for conversion into cryptarithms. \n</p>\n<p>\nYou don't need to know what a cryptarithm is to solve this problem, as we'll provide all required definitions. We define a <i>cryptarithm equation</i> to be an addition equation written in such a way that all summands (numbers being added) and the sum are aligned to the same right border like this:\n</p>\n<pre>124\n 31\n 25\n---\n180</pre>\n<p>Additionally, for each column of a cryptarithm equation, all digits of the summands in that column must be different. Note that we don't include the sum in this constraint. So for example in the above equation the first column contains only digit 1, the second column contains digits 2,3 and 2, and the third column contains digits 4, 1 and 5. This equation is not a cryptarithm equation since the second column contains two 2's. However, it would be a cryptarithm equation if we replaced the last summand with 15 (and the sum with 170).</p>\n<p>Note that summands in a cryptarithm equation are always positive and written without leading zeros. The order of summands is not important (in other words, two equations which differ only in the order of the summands are considered the same).</p>\n<p>The example above was in base 10, but we're also interested in cryptarithm equations in other bases. Note that a \"digit\" in base b could mean any integer between 0 and b-1. Here is a cryptarithm equation in base 23:</p>\n<pre> I7B\n JJJ\n----\n1F47\n</pre>\n<p>In this example, \"I\" stands for digit 18, \"B\" stands for digit 11, \"J\" stands for digit 19, and \"F\" stands for digit 15. In decimal notation, the two summands are 18*23<sup>2</sup> + 7*23 + 11 = 9694 and 19*23<sup>2</sup> + 19*23 + 19 = 10507, and the sum is 1*23<sup>3</sup> + 15*23<sup>2</sup>  + 4*23 + 7 = 20201. Please note that denoting digits of 10 and more with letters was done purely for the clarity of the example; it doesn't really matter in this problem how exactly we denote such digits in writing.</p>\n<p>How many cryptarithm equations are there with the given sum <b>N</b> in the given base <b>B</b>?</p>\n<p>Since the answer might be very large, please output it modulo 1000000007.</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each contains two positive integers <b>N</b> and <b>B</b>. All input numbers are given in base 10.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of different cryptarithm equations with the given sum. Since this number can be very big, please output it modulo 1000000007. Of course, the output itself should be in base 10.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 20.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\n2 &le; <b>B</b> &le; 10.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 10<sup>18</sup>.<br/>\n2 &le; <b>B</b> &le; 70.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n6 10\n8 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Explanation</h3>\n<p>\nHere are the 4 cryptarithm equations with sum 6:\n</p>\n<pre>\n6   1   2   1\n-   5   4   2\n6   -   -   3\n    6   6   -\n            6\n</pre>\n<p>\nAnd here are the 4 cryptarithm equations in base 4 with sum 8=20<sub>4</sub>:\n</p>\n<pre>\n20   11   13   10\n--    3    1    3\n20   --   --    1\n     20   20   --\n               20\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Different Sum","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043315b","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2010"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
