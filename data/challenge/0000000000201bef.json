{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1462707000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201bef","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nIn another Code Jam first, all three of the problems in this round allowed\nmultiple answers per test case. <i>Senate Evacuation</i> was the easiest of the\ntrio; many greedy approaches were possible. The other two were tougher, and\neven the Smalls required some insights on top of pure brute force.\n<i>Slides!</i> gave you nearly free rein to construct a graph with certain\nproperties, and <i>Fashion Police</i> was set in New York, in a nod to our\nupcoming World Finals venue.\n</p><p>\nContestant artberryx grabbed the first place slot with six correct submissions in 38 minutes and 49 seconds, and there were 144 perfect scores. To advance, you needed at least 52 points and some speed. Contestants who didn't solve the Slides! large quickly enough had to contend with Fashion Police, a problem in which the tempting greedy solution doesn't work.\n<p>\nWe'll see our 3000 advancers &mdash; 1000 each from Rounds 1A, 1B, and 1C\n&mdash; in Round 2 and Distributed Round 1 on\nMay 28 and 29. If\nyou didn't advance in Round 1, thanks for participating, and we hope to see you\nagain in the 2017 contest!\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>Senate Evacuation</i>): Written by Pablo Heiber. Prepared by\nPablo Heiber and Yerzhan Utkelbayev.\n</p><p>\nProblem B (<i>Slides!</i>): Written by Pablo Heiber. Prepared by Pablo Heiber\nand Ian Tullis.\n</p><p>\nProblem C (<i>Fashion Police</i>): Written by Ian Tullis. Prepared by Jackson\nGatenby and Ian Tullis.\n</p><p>\nSolutions and other problem preparation and review by Shane Carr, Taman\n(Muhammed) Islam, Yiming Li, Igor Naverniouk, Patrick Nguyen, Nathan Pinsker,\nKarol Pokorski, Steve Thomas, and Yerzhan Utkelbayev.\n</p><p>\nAnalysis authors:\n</p>\n<ul>\n<li>Senate Evacuation: Ian Tullis</li>\n<li>Slides!: Nathan Pinsker</li>\n<li>Fashion Police: Pablo Heiber, Steve Thomas, and Ian Tullis</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1462698000000,"tasks":[{"analysis":"<h2>Fashion Police: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nLet us denote the number of possible outfits by <i>W</i>; <i>W</i> &equals;\n<b>J</b> * <b>P</b> * <b>S</b>. A viable brute force approach is to produce all\n2<sup><i>W</i></sup> subsets of the set of possible outfits, check them for\nviolations, and take one of the largest sets with no violation. We can check\na set of outfits without worrying about what order they are worn in; if some\noutfits in that set create a fashion violation, it will eventually happen no\nmatter what order those outfits (and any other outfits) are worn in. Another\nhelpful observation is that if <b>S</b> &le; <b>K</b>, then the answer is\ntrivial: simply return every possible outfit.\n</p><p>\nThis approach works for most of the Small cases, but not all of them. For\nthe cases <code>3 3 3 1</code> and <code>3 3 3 2</code>, there are\n2<sup>27</sup> possible sets of outfits, and that is over 100 million. One\napproach is to just solve these \"problem cases\" before downloading a dataset.\nYou can notice a pattern in the other answers (more on this later) and infer\nthat the maximum numbers of outfits you can wear are 9 and 18, respectively.\nIt is more tractable to find a set of outfits of a particular size than to\nfind the set of outfits of maximum size. If you are pretty sure that that size\nis 18, for instance, you can check all sets of size 18 until you find a working\none, and maybe even check all sets of size 19 to confirm that none of them\nwork. This is much faster than checking every size between 1 and 19, especially\nsince 27 choose 18 is much smaller than 27 choose 13 and 27 choose 14, for\nexample.\n</p><p>\nIn fact, there are only 100 possible test cases that fall within the limits of\nthe Small dataset, so you can compute the answer to any possible input before\neven downloading the dataset!\n</p>\n<h3>Large dataset</h3>\n<p>\nAgain, if <b>S</b> &le; <b>K</b>, we can return every possible outfit.\nOtherwise, a key insight is that that the\n<a href=\"https://en.wikipedia.org/wiki/Pigeonhole_principle\">pigeonhole\nprinciple</a> tells us that a maximum solution can have no more than\nmin(<b>J</b> &times; <b>P</b> &times; <b>K</b>, <b>P</b> &times; <b>S</b>\n&times; <b>K</b>, <b>J</b> &times; <b>S</b> &times; <b>K</b>) different\noutfits. Since <b>J</b> &le; <b>P</b> &le; <b>S</b>, this puts an upper bound\nof <b>J</b> &times; <b>P</b> &times; <b>K</b> on our solution. You can also\ninfer this from the output of a brute force solution.\n</p><p>\nOne pitfall to watch out for in this problem is that there exist sets of\noutfits that are <i>maximal</i> &mdash; that is, you cannot add any new outfit\nto such a set without going to jail &mdash; but are not the largest possible.\nThat is, they are maxim<i>al</i> but not maxim<i>um</i>.\n</p><p>\nFor instance, for an input of <b>J</b> &equals; 1, <b>P</b> &equals; 3,\n<b>S</b> &equals; 3, <b>K</b> &equals; 2, the following is a maximal set of\noutfits that is not maximum (the maximum size is 6): <code>1 1 1</code>,\n<code>1 1 2</code>, <code>1 2 2</code>, <code>1 2 1</code>, <code>1 3 3</code>.\n</p><p>\nSo, if we just randomly choose outfits without violating the law, we are in\ndanger of being trapped in a locally maximal set.\n</p><p>\nFortunately, there are several greedy approaches to achieve a set of size\n<b>J</b> &times; <b>P</b> &times; <b>K</b> outfits without angering the Fashion\nPolice. As argued above, we know that <b>J</b> &times; <b>P</b> &times;\n<b>K</b> is the maximum possible size, so if we can find a set of that size, we\nare done!\n</p><p>\nWe cannot use a jacket-pants combination more than <b>K</b> times, so if we\nwant to produce <b>J</b> &times; <b>P</b> &times; <b>K</b> outfits we are\nforced to use each combination exactly <b>K</b> times. To simplify the math, we\nuse jacket, pants and shirt numbers between 0 and the appropriate total minus\n1. We just need to remember to add 1 to every identifier when we print it to\nthe output.\n</p><p>\nLet us fix a combination with jacket number <i>j</i> and pants number <i>p</i>.\nOur proposal is assign to it shirts (<i>j</i> + <i>p</i>) % <b>S</b>,\n(<i>j</i> + <i>p</i> + 1) % <b>S</b>, ..., (<i>j</i> + <i>p</i> + <b>K</b> - 1)\n% <b>S</b>, where % stands for the\n<a href=\"https://en.wikipedia.org/wiki/Modulo_operation\">modulo operation</a>.\nSince <b>S</b> &gt; <b>K</b>, these are all different, and by construction, the\ncombination of jacket and pants is used exactly <b>K</b> times, as desired.\n</p><p>\nWhat about jacket-shirt and pants-shirt combinations? Let us fix a jacket\nnumber <i>j</i> and a shirt number <i>s</i>. If the outfit (<i>j</i>, <i>p</i>,\n<i>s</i>) appears in the constructed set, then <i>s</i> &equals; (<i>j</i> +\n<i>p</i> + <i>d</i>) % <b>S</b> for some <i>d</i> between 0 and <b>K</b> - 1,\ninclusive. Then, by modular arithmetic, and noticing that <i>j</i> % <b>S</b>\n&equals; <i>j</i>, <i>p</i> % <b>S</b> &equals; <i>p</i>, and <i>s</i> %\n<b>S</b> &equals; <i>s</i>, it turns out that <i>p</i> &equals; (<i>s</i> -\n<i>j</i> - <i>d</i>) % <b>S</b>. Then, each choice of <i>d</i> uniquely\ndetermines <i>p</i>, so there cannot be more <i>p</i>s to go with a given\ncombination of <i>j</i> and <i>s</i> than choices of <i>d</i>, and there are\n<b>K</b> choices of <i>d</i>, which means the combination of <i>j</i> and\n<i>s</i> does not exceed the maximum.\n</p><p>\nSince this is valid for any <i>j</i> and <i>s</i>, and a symmetrical proof is\nvalid for each pants-shirt combination, we have proven that the proposed set of\noutfits does not break any of the rules of the Fashion Police.\n</p>\n<h3>Another way of thinking about it</h3>\n<p>\nThe problem is equivalent to trying to select as many cells as possible in a\n3-D <b>J</b> by <b>P</b> by <b>S</b> grid such that no line of three cells in\nthe x, y, or z direction includes more than <b>K</b> selected cells. Each\noutfit corresponds to one such cell.\n</p><p>\nHere is an illustration of this approach for two cases. The left-right axis\ncorresponds to shirts, the up-down axis corresponds to pants, and the layers\n(imagine them stacked up) correspond to jackets. Each <code>*</code> represents\na selected outfit, and each <code>.</code> represents an unused outfit.\n<p>\n<b>J</b> &equals; 2, <b>P</b> &equals; 3, <b>S</b> &equals; 4, <b>K</b>\n&equals; 1:\n</p><p>\n<code>\n*... .*..<br>\n.*.. ..*.<br>\n..*. ...*<br>\n</code>\n</p><p>\nOutfits: <code>1 1 1</code>, <code>1 2 2</code>, <code>1 3 3</code>,\n<code>2 1 2</code>, <code>2 2 3</code>, <code>2 3 4</code>.\n</p><p>\n<b>J</b> &equals; 2, <b>P</b> &equals; 3, <b>S</b> &equals; 4, <b>K</b>\n&equals; 2:\n</p><p>\n<code>\n**.. .**.<br>\n.**. ..**<br>\n..** *..*<br>\n</code>\n</p><p>\nOutfits: <code>1 1 1</code>, <code>1 1 2</code>, <code>1 2 2</code>,\n<code>1 2 3</code>, <code>1 3 3</code>, <code>1 3 1</code>, <code>2 1 2</code>,\n<code>2 1 3</code>, <code>2 2 3</code>, <code>2 2 4</code>, <code>2 3 4</code>,\n<code>2 3 1</code>.\n</p><p>\nObserve that:\n</p><ul>\n<li>In both cases, the second layer (jacket 2) is the first layer (jacket 1)\nshifted one unit to the right (and wrapping around).</li>\n<li>We can get the answer to the second case from the answer to the first case\njust by adding a <code>*</code> to the right of every existing <code>*</code>\n(and wrapping around).</li>\n<li>By construction, the first layer does not have more than <b>K</b>\n<code>*</code>s in any row or column. This is also true of each additional\nlayer, since they are all rotations of the first layer. Moreover, no line of\ncells parallel to the jacket axis (that is, across layers) can possibly have\nmore than <b>K</b> <code>*</code>s; considering how the layers are constructed,\nthat would directly imply more than <b>K</b> <code>*</code>s in one row of the\nfirst layer.\n</ul>\n<p>\nThis construction works for any set of <b>J</b>, <b>P</b>, and <b>S</b> values.\nIt takes advantage of the <b>J</b> &le; <b>P</b> &le; <b>S</b> condition in\nthe problem statement. We put that condition in to save you the trouble of\nadding a bunch of case-based logic to try to figure out which dimension was\nlargest; the fashion-conscious GCJ staff is well aware that some closets have\nmore pants than shirts!\n</p>\n","id":"0000000000201b6e","statement":"<h3>Problem</h3>\n<p>\nYou are so excited about the 2016 Code Jam World Finals that you just moved to\nNew York. You have brought along <b>J</b> different jackets (numbered 1 through\n<b>J</b>), <b>P</b> different pairs of pants (numbered 1 through <b>P</b>), and\n<b>S</b> different shirts (numbered 1 through <b>S</b>). You have at least as\nmany shirts as pairs of pants, and at least as many pairs of pants as jackets.\n(<b>J</b> &le; <b>P</b> &le; <b>S</b>.)\n</p><p>\nEvery day, you will pick one jacket, one pair of pants, and one shirt to wear\nas an <i>outfit</i>. You wash all of your garments every night so all of your\ngarments are available to use each day.\n</p><p>\nIn New York, the Fashion Police officers are always watching and keeping track\nof what everyone wears every day. If they find out that you have worn the exact\nsame outfit twice, you will immediately be taken to the Fashion Jail on 5th\nAvenue for a mandatory makeover; you definitely want to avoid that! You will\nalso immediately be taken to Fashion Jail if they find out that you have worn\nthe same two-garment <i>combination</i> more than <b>K</b> times in total. A\ncombination consists of a particular jacket worn with a particular pair of\npants, a particular jacket worn with a particular shirt, or a particular pair\nof pants worn with a particular shirt. For example, in the set of outfits\n(jacket 1, pants 2, shirt 3) and (jacket 1, pants 1, shirt 3), the combination\n(jacket 1, shirt 3) appears twice, whereas the combination (pants 1, shirt 3)\nonly appears once.\n</p><p>\nYou will wear one outfit per day. Can you figure out the largest possible\nnumber of days you can avoid being taken to Fashion Jail and produce a list of\noutfits to use each day?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow; each consists of one line with four integers <b>J</b>,\n<b>P</b>, <b>S</b>, and <b>K</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nan integer: the maximum number of days you will be able to avoid being taken to\nFashion Jail. Then output <code>y</code> more lines, each of which consists of\nthree integers: the numbers of the jacket, pants, and shirt (in that order) for\none day's outfit. The list of outfits can be in any order, but the outfits must\nnot cause you to go to Fashion Jail as described in the statement above.\n</p><p>\nIf multiple answers are possible, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>J</b> &le; <b>P</b> &le; <b>S</b>.<br/>\n1 &le; <b>K</b> &le; 10.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n<b>S</b> &le; 3.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n<b>S</b> &le; 10.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 1 1 10\n1 2 3 2\n1 1 3 2\n1 2 3 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\n1 1 1\nCase #2: 4\n1 1 2\n1 2 3\n1 2 1\n1 1 1\nCase #3: 2\n1 1 2\n1 1 1\nCase #4: 2\n1 1 3\n1 2 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe sample output displays one set of answers to the sample cases. Other\nanswers may be possible.\n</p><p>\nIn Case #1, even though the Fashion Police officers have set a lenient <b>K</b>\nvalue of 10, there is only one possible outfit that you can form, so you can\nonly avoid Fashion Jail for one day.\n</p><p>\nIn Case #2, adding any other outfit would cause you to go to Fashion Jail:\n<ul>\n<li>Adding <code>1 1 3</code> would use the combination (jacket 1, pants 1)\nmore than 2 times.</li>\n<li>Adding <code>1 2 2</code> would use the combination (jacket 1, pants 2)\nmore than 2 times.</li>\n</ul>\n<p>\nIn this case, any set of 5 outfits would include at least one fashion\nviolation.\n</p><p>\nNote that the numbers of the jacket, pants, and shirt within an individual\noutfit do not have to be in nondecreasing order in the same way that <b>J</b>,\n<b>P</b>, and <b>S</b> do.\n</p><p>\nIn Case #3, you have only one jacket + pants combination which you must keep\nreusing, so no matter which shirts you wear, you cannot form more than <b>K</b>\n= 2 different outfits.\n</p><p>\nIn Case #4, another possible maximally large set of outfits is:<br>\n<code>\n1 2 2<br>\n1 1 1<br>\n</code>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":34}],"title":"Fashion Police","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\nWith at most three parties and at most nine senators, various brute force\napproaches will work. One exhaustive strategy is to generate all possible\ndifferent evacuation orders, treating senators from the same party as\ninterchangeable, and then try all possible different ways of chopping those\ninto groups of one or two senators.\n</p><p>\nAnother, simpler strategy is to keep randomly choosing and trying one of the\nnine possible evacuations (A, B, C, AA, AB, AC, BB, BC, CC) as long as the\nchosen senator(s) exist and the evacuation will not cause a new absolute\nmajority. You may worry that this strategy could get stuck, but the outcome of\nany legal evacuation will just be another possible test case for the problem,\nand the statement guarantees that every test case has a solution! With more\nparties and senators, though, this strategy might bog down in the details of\nchecking the legality of evacuations, so we should come up with a more\nefficient approach.\n</p>\n<h3>Test set 2</h3>\n<p>\nIntuitively, it is safest to remove one senator at a time, and to always draw\nfrom whichever party has the most remaining senators (or any such largest\nparty, if there is a tie). But this strategy won't always work! For example,\nif we have two senators from party A and two from party B, and no others,\nwhich is a valid test case, then removing one senator from either party will\ngive the other party an absolute majority.\n</p><p>\nHowever, this strategy <i>is</i> always safe whenever there are more than two\nparties present. Suppose that party 1 is currently the largest, or tied for the\nlargest, of at least three parties, and that we remove a single senator from\nparty 1. Clearly, making party 1 smaller cannot give it an absolute majority\nthat it didn't have before. But could some other party acquire an absolute\nmajority as a result? Suppose that the removal of a senator from party 1 were\nto cause party 2, which currently has X senators, to have an absolute majority.\nBut since party 1 was the largest, or tied for the largest, before a senator\nwas removed, party 1 must still have at least X-1 senators. Moreover, since at\nleast one more party is present, there is at least 1 other senator who is not\nfrom party 1 or 2. So there are a total of at least X remaining senators who\nare not from party 2, which means the X senators of party 2 are not enough to\ngive it an absolute majority, so we have a contradiction.\n</p><p>\nIf we start with three or more parties and keep evacuating a single senator\nfrom the largest party in this way, then at some point, we must reach a step\nin which we go from three parties to two parties. These two remaining parties\nmust have only one senator each. Since we just removed the one remaining\nsenator from the third party, it must have been a largest party, so the other\ntwo can be no larger. So we can remove this last pair of senators in a single\nevacuation as a final step.\n</p><p>\nWhat if we start with two parties? Since the problem statement guarantees that\nno party begins with a majority, these parties must have equal numbers of\nsenators. So, we can evacuate them in pairs, one from each party, until the\nevacuation is complete.\n</p><p>\nThis approach takes more steps than are needed &mdash; most of those single\nevacuations can be paired up &mdash; but it gets the job done.\n</p>\n","id":"0000000000201c8b","statement":"<h3>Problem</h3>\n<p>\nA small fire started in the senate room, and it needs to be evacuated!\n</p><p>\nThere are some senators in the senate room, each of whom belongs to of one of\n<b>N</b> political parties. Those parties are named after the first <b>N</b>\n(uppercase) letters of the English alphabet.\n</p><p>\nThe emergency door is wide enough for up to two senators, so in each step of\nthe evacuation, you may choose to remove either one or two senators from the\nroom.\n</p><p>\nThe senate rules indicate the senators in the room may vote on any bill at any\ntime, even in the middle of an evacuation! So, the senators must be evacuated\nin a way that ensures that no party ever has an absolute majority. That is, it\ncan never be the case after any evacuation step that more than half of the\nsenators in the senate room belong to the same party.\n</p><p>\nCan you construct an evacuation plan? The senate is counting on you!\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow.  Each test case consists of two lines. The first line\ncontains a single integer <b>N</b>, the number of parties. The second line\ncontains <b>N</b> integers, <b>P<sub>1</sub></b>, <b>P<sub>2</sub></b>, ...,\n<b>P<sub>N</sub></b>, where <b>P<sub>i</sub></b> represents the number of\nsenators of the party named after the i-th letter of the alphabet.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe evacuation plan. The plan must be a space-separated list of instructions,\nin the order in which they are to be carried out, where each instruction is\neither one or two characters, representing the parties of the senators to\nevacuate in each step.\n</p><p>\nIt is guaranteed that at least one valid evacuation plan will exist. If\nmultiple evacuation plans are valid, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\nNo party will have an absolute majority before the start of the evacuation.<br/>\n1 &le; <b>P<sub>i</sub></b> &le; 1000, for all i.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 3.<br/>\nsum of all <b>P<sub>i</sub></b> &le; 9.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 26.<br/>\nsum of all <b>P<sub>i</sub></b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2\n2 2\n3\n3 2 2\n3\n1 1 2\n3\n2 3 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: AB BA\nCase #2: AA BC C BA\nCase #3: C C AB\nCase #4: BA BB CA\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe sample output displays one set of answers to the sample cases. Other\nanswers may be possible.\n</p><p>\nIn Case #1, there are two senators from each of the parties A and B. If we\nremove one from each party every time, the perfect balance is maintained until\nevacuation is complete.\n</p><p>\nCase #2 proceeds as follows:\n</p><p>\nInitially in the room: 3 A, 2 B, 2 C.<br>\nEvacuate AA. Still in the room: 1 A, 2 B, 2 C.<br>\nEvacuate BC. Still in the room: 1 A, 1 B, 1 C.<br>\nEvacuate C. Still in the room: 1 A, 1 B.<br>\nEvacuate AB. Evacuation complete!<br>\n</p><p>\nNote that it would not be valid to begin the evacuation with BC, which would\nleave 3 A, 1 B, and 1 C in the room; party A would have an absolute majority (3\nout of 5 = 60%).\n</p><p>\nFor Case #3, note that <code>CC AB</code> would also be a valid answer, and\n<code>C C AB</code> is also valid even though it requires three evacuation\nsteps instead of two.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Senate Evacuation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Slides!: Analysis!</h2>\n<h3>Small dataset</h3>\n<p>\nThe Small dataset has bounds that suggest we can construct all possible sets of\nslides, but this turns out to be overly optimistic. We represent a set of\nslides as a directed graph <i>G</i>, with each node representing a building,\nand a directed edge from node <i>i</i> to node <i>j</i> representing a slide\nleading from building <i>i</i> to building <i>j</i>. The most straightforward\nconstruction tries either including or not including each of the <b>B</b> *\n(<b>B</b>-1) possible slides, for a total of 2<sup><b>B</b> *\n(<b>B</b>-1)</sup> possible sets of slides. Unfortunately, even for <b>B</b> =\n6, this is too many: there are approximately 2<sup>30</sup> sets to check, or\nabout a billion.\n</p><p>\nHowever, one observation allows us to dramatically cut down the number of sets\nwe have to examine. Notice that there can never be a cycle as part of any valid\npath from building 1 to building <b>B</b>. If there were a cycle, then we could\ngenerate new, valid paths by traversing that cycle arbitrarily many times\nbefore continuing to our destination, meaning that the number of valid paths\nwould be infinite. (The <i>G</i> that we use can still contain a cycle that is\nnot on any valid path; however, removing that cycle would not affect the number\nof valid paths, and thus we only need to consider graphs <i>G</i> with no\ncycles at all.)\n</p><p>\nThis means that any valid path from building 1 to building <b>B</b> cannot\nvisit the same building twice, so each path can have length at most <b>B</b>.\nAs a result, running a depth-first search on <i>G</i> starting from node 1 will\ntake O(<b>B</b>) time for each path found. If we find more than <b>M</b> paths,\nthen we can terminate our search immediately, since this set of slides cannot\nbe valid. This means that our worst-case running time to test any given set of\nslides is O(<b>M</b>*<b>B</b>). We can also calculate a smaller upper bound on\nthe number of sets we have to examine: for each pair of slides <i>i</i> and\n<i>j</i>, exactly one of three possibilities must be true:\n</p>\n<ul>\n<li>There is a slide from <i>i</i> to <i>j</i>.</li>\n<li>There is a slide from <i>j</i> to <i>i</i>.</li>\n<li>There is no slide from <i>i</i> to <i>j</i> and no slide from <i>j</i> to\n<i>i</i>.</li>\n</ul>\n<p>\nSince there are <b>B</b> * (<b>B</b>-1) / 2 different pairs of slides, this\ngives us an upper bound of 3<sup><b>B</b> * (<b>B</b>-1) / 2</sup> possible\nsets of slides. For <b>B</b> = 6, this number is around fourteen million, which\nis a manageable number of sets to check.\n</p><p>\nAnother helpful observation that makes the small even more tractable is that\nsince our graph has no cycles, it is a directed acyclic graph, and so it has a\ntopological sorting. So, for any correct solution, we could renumber the\nbuildings (other than 1 and <b>B</b>) such that every slide's end building has\na larger number than its start building. Since this is true, we only need to\nconsider slides that go from lower to higher building numbers.\n</p>\n<h3>Large dataset</h3>\n<p> The Large dataset requires a more efficient approach. A natural first\nquestion to ask is: what is the maximum number of paths from building 1 to\nbuilding <b>B</b> that we can possibly construct? One straightforward\nconstruction that seems to yield a large number of paths is to construct a\nslide from building <i>i</i> to building <i>j</i> for every pair of positive\nintegers <i>i</i>, <i>j</i> with 1 &le; <i>i</i> &lt; <i>j</i> &le; <b>B</b>.\nTo compute the number of paths for this set of slides, notice that every path\nfrom building 1 to building <b>B</b> corresponds uniquely to a set of distinct\nintegers from the set {2, ..., <b>B</b>-1} representing the buildings visited\nalong that path. For example, if <b>B</b> = 5, then the set {2, 4} would\ncorrespond to the path 1 -> 2 -> 4 -> 5, and the empty set would correspond to\nthe path 1 -> 5. Since there are <b>B</b>-2 integers strictly between 1 and\n<b>B</b>, each of which can be either absent or present in a set, there are\n2<sup><b>B</b>-2</sup> unique sets that can be constructed, and thus\n2<sup><b>B</b>-2</sup> possible paths from 1 to <b>B</b>.\n</p><p>\nBut is this the largest possible number of paths we can construct? It turns out\nthat it is. We can show this by the pigeonhole principle. We assume that there\nexists some set of slides that yields some number <b>M</b> &gt;\n2<sup><b>B</b>-2</sup> paths, and derive a contradiction. Each path corresponds\nto some set of distinct integers {2, ..., <b>B</b>-1} representing the\nbuildings visited along that path, and since there are 2<sup><b>B</b>-2</sup>\ndistinct such sets, it follows that two paths of slides must visit the exact\nsame buildings. This means there is some pair of buildings <i>i</i> and\n<i>j</i> such that <i>i</i> is visited before <i>j</i> on one of these paths,\nbut is visited after <i>j</i> on the other path. (If there were no such pair,\nthen these two paths would be exactly the same, since no building can ever be\nvisited twice.) Since we can reach building <i>i</i> from building <i>j</i> and\nvice versa, it follows that there is a cycle between the two buildings. This\ncontradicts what we showed earlier, meaning that we cannot construct a set of\nslides with exactly <b>M</b> paths for <b>M</b> &gt; 2<sup><b>B</b>-2</sup>.\n</p><p>\nNow we show how to extend the ideas above to handle the case where <b>M</b>\n&lt; 2<sup><b>B</b>-2</sup>. We start by constructing all possible slides from\nbuilding <i>i</i> to building <i>j</i> for every pair of positive integers\n<i>i</i>, <i>j</i> with 2 &le; <i>i</i> &lt; <i>j</i> &le; <b>B</b>. Notice\nthat there are exactly 2<sup><b>B</b>-1-i</sup> ways to get from building\n<i>i</i> to building <b>B</b>. Each path from building <i>i</i> to building\n<b>B</b> maps uniquely to a subset of distinct integers from the set {i + 1,\n..., <b>B</b>-1}. This set contains <b>B</b>-1-i integers, so there are\n2<sup><b>B</b>-1-i</sup> possible subsets that we can choose. If we build a\nslide from building 1 to building <i>i</i> for <i>i</i> strictly between 1 and\n<b>B</b>, then this increases the number of ways to get from 1 to <b>B</b> by\nexactly 2<sup><b>B</b>-1-i</sup>, since there are that many ways to get from\nbuilding <i>i</i> to building <b>B</b>. This suggests a method for generating a\nnetwork with exactly <b>M</b> slides. We start by writing <b>M</b> in binary.\nIf the <i>i</i>-th digit of <b>M</b> (counting from the right, starting from 1)\nis a 1, then we add a path between building 1 and building <b>B</b>-i. This\nwill add 2<sup>i-1</sup> new paths to our slide network. If we repeat this\nprocess for each value of <i>i</i>, then we will end up with a network with a\nnumber of paths from 1 to <b>B</b> exactly equal to <b>M</b>. This process will\nwork if <b>M</b> has at most <b>B</b>-2 digits, meaning <b>M</b> &le;\n2<sup><b>B</b>-2</sup>-1. Since <b>M</b> = 2<sup><b>B</b>-2</sup> is the\nlargest value we are able to construct, this gives us a method for constructing\nall values of <b>M</b> between 1 and 2<sup><b>B</b>-2</sup>. We have previously\nshown a construction for <b>M</b> = 2<sup><b>B</b>-2</sup>, which is equivalent\nto the solution for <b>M</b> = 2<sup><b>B</b>-2</sup> - 1 with an additional\npath from building 1 to building <b>B</b>.\n</p><p>\nThis means that a sequence of slides is therefore possible to construct if, and\nonly if, <b>M</b> &le; 2<sup><b>B</b>-2</sup>, and the above construction works\nfor any such <b>M</b>. The sequence itself is computed by the construction\nabove.\n</p><p>\nTo illustrate the above method, here are valid answers for all cases with\n<b>B</b> = 5, and <b>M</b> = 1 through 8:\n</p><p>\n<code>\n<b>M</b> = 1 <b>M</b> = 2 <b>M</b> = 3 <b>M</b> = 4 <b>M</b> = 5 <b>M</b> = 6\n<b>M</b> = 7 <b>M</b> = 8<br/>\n<br>\n00010 00100 00110 01000 01010 01100 01110 01111<br/>\n00111 00111 00111 00111 00111 00111 00111 00111<br/>\n00011 00011 00011 00011 00011 00011 00011 00011<br/>\n00001 00001 00001 00001 00001 00001 00001 00001<br/>\n00000 00000 00000 00000 00000 00000 00000 00000<br/>\n</code>\n<p>\nObserve that the solutions only differ in their first lines. The first lines of\nthe solutions for <b>M</b> = 1 through 7 are 1, 2, ..., 7 in binary plus an\nextra 0 at the end. The first line of the solution for <b>M</b> = 8 is 7 in\nbinary, plus an extra 1 at the end: the direct connection from building 1 to\nbuilding 5 that brings the total to 8. For <b>M</b> &ge; 9, the answer is\n<code>IMPOSSIBLE</code>.\n</p>\n","id":"0000000000201d18","statement":"<h3>Problem</h3>\n<p>\nGooli is a huge company that owns <b>B</b> buildings in a hilly area. The\nbuildings are numbered from 1 to <b>B</b>.\n</p><p>\nThe CEO wants to build a set of slides between buildings that she can use to\ntravel from her office in building 1 to her favorite cafe in building <b>B</b>.\nSlides, of course, are one-way only, but the buildings are tall and have\nelevators, so a slide can start in any building and end in any other building,\nand can go in either direction. Specifically, for any two buildings x and y,\nyou can build either zero or one slides from x to y, and you can build either\nzero or one slides from y to x. The exception is that no slides are allowed to\noriginate in building <b>B</b>, since once the CEO reaches that building, there\nis no need for her to do any more sliding.\n</p><p>\nIn honor of Gooli becoming exactly <b>M</b> milliseconds old, the design must\nensure that the CEO has <i>exactly</i> <b>M</b> different ways to travel from\nbuilding 1 to building <b>B</b> using the new slides. A way is a sequence of\nbuildings that starts with building 1, ends with building <b>B</b>, and has the\nproperty that for each pair of consecutive buildings x and y in the sequence, a\nslide exists from x to y. Note that the CEO is <i>not</i> requiring that any\nbuilding be reachable from any other building via slides.\n</p><p>\nCan you come up with any set of one or more slides that satisfies the CEO's\nrequirements, or determine that it is impossible?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\nlines follow; each consists of one line with two integers <b>B</b> and\n<b>M</b>, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe word <code>POSSIBLE</code> or <code>IMPOSSIBLE</code>, depending on whether\nthe CEO's requirements can be fulfilled or not. If it is possible, output an\nadditional <b>B</b> lines containing <b>B</b> characters each, representing a\nmatrix describing a valid way to build slides according to the requirements.\nThe j-th character of the i-th of these lines (with both i and j counting\nstarting from 1) should be <code>1</code> if a slide should be built going from\nbuilding i to building j, and <code>0</code> otherwise. The i-th character of\nthe i-th line should always be <code>0</code>, and every character of the last\nline should be <code>0</code>.\n</p><p>\nIf multiple solutions are possible, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n2 &le; <b>B</b> &le; 6.<br/>\n1 &le; <b>M</b> &le; 20.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n2 &le; <b>B</b> &le; 50.<br/>\n1 &le; <b>M</b> &le; 10<sup>18</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n5 4\n2 1\n4 20\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: POSSIBLE\n01001\n00110\n00001\n00101\n00000\nCase #2: POSSIBLE\n01\n00\nCase #3: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe sample outputs show one possible way to fulfill the specifications for each\ncase. Other valid answers may exist.\n</p>\n<p>\nHere is an illustration of the sample answer for Case #1:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U10BTD2UwFl50im1aL2_zU1zni3-GEuzKQk5JbGb0ad62hSi-4o6G-LB92p0xtheRhUrHuJ1D3hXaBY/slides_case1.png\">\n<p>\nThe four ways to get from building 1 to building 5 are:\n</p>\n<ul>\n<li>1 to 5</li>\n<li>1 to 2 to 3 to 5</li>\n<li>1 to 2 to 4 to 5</li>\n<li>1 to 2 to 4 to 3 to 5</li>\n</ul>\n<p>\nIn Case #3, building slides from 1 to 2, 2 to 3, 3 to 1, and 1 to 4 would\ncreate infinitely many ways for the CEO to reach building 4 (she could go\ndirectly to 4, or go around the loop once and then go to 4, or go around the\nloop twice...), but the CEO requested <i>exactly</i> 20 ways.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Slides!","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201bef","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2016"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
