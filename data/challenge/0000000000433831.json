{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1439595000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433831","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nOur 2015 finals problems were tough enough that no contestant attempted all\nsix. The scoreboard was a churning battlefield, and we saw all kinds of\nsolution approaches, such as simulated annealing, in play! Problems C, D, and\nE in particular posed a race of insight rather than coding speed, and few\ncontestants were able to attempt the Large dataset for more than one of them.\n</p><p>\nAt the end of the contest, bmerry was the only contestant who had attempted\nthe Large dataset of the very challenging Crane Truck problem, and he appeared\nto be in the lead... but when the dust settled, it was Gennady.Korotkevich\nwho emerged on top for the second year in a row. rng..58 came in second; he\nhad reached the same number of points as Gennady (but with a higher time\npenalty) five minutes before the end of the contest, only to have Gennady pull\neven farther away less than a minute later! bmerry took third place with the only\nother triple-digit score.\n</p><p>\nCongratulations to all of our finalists and to everyone who participated in\nthe 2015 Code Jam!\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>Costly Binary Search</i>): Written by Petr Mitrichev. Prepared\nby Ahmed Aly.\n</p><p>\nProblem B (<i>Campinatorics</i>): Written by David Gómez Cermeño. Prepared by\nJohn Dethridge.\n</p><p>\nProblem C (<i>Pretty Good Proportion</i>): Written by David Arthur. Prepared\nby Igor Naverniouk.\n</p><p>\nProblem D (<i>Taking Over The World</i>): Written by David Arthur. Prepared\nby Igor Naverniouk.\n</p><p>\nProblem E (<i>Merlin QA</i>): Written by David Arthur. Prepared by Ahmed Aly.\n</p><p>\nProblem F (<i>Crane Truck</i>): Written and prepared by John Dethridge.\n</p><p>\nSolutions and other problem preparation and review by Ahmed Aly, John\nDethridge, Sumudu Fernando, Jonathan Gunawan, Felix Halim, Adrian Kuegel,\nPetr Mitrichev, Igor Naverniouk, Anton Raichuk, Jonathan Shen, Ian Tullis,\nJonathan Wills, and Onufry Wojtaszczyk.\n</p><p>\nAnalyses by John Dethridge, Jonathan Gunawan, Felix Halim, Pablo Heiber, Risan,\nand Onufry Wojtaszczyk.\n</p>\n\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1439580600000,"tasks":[{"analysis":"<p>\nEvery spell in the spell-testing procedure can be interpreted as an <b>M</b>-dimensional vector, and the current state of Edythe’s inventory is also an <b>M</b>-dimensional vector (initially an all-zero vector). Casting a spell is equivalent to adding the vector describing the spell to the vector describing Edythe’s inventory, and then changing all the negative values in Edythe’s inventory to zero (this corresponds to retrieving the exact necessary amount from Merlin’s storehouse). Edythe is aiming to maximize the sum of all the coordinates at the end.\n</p><p>\nNote that even if we allowed Edythe to zero a coordinate of the vector describing her inventory at any time, it would never be advantageous to zero it when it is positive, and it would never be disadvantageous to zero it when it is negative - so the final answer will not change if we give Edythe full freedom over when and which coordinates of her inventory get zeroed. We will solve this less constrained problem from now on.\n</p><p>\nNotice that it never makes sense to zero a given coordinate more than once, since the last zeroing will make the previous ones irrelevant anyway.  So from now on, we will solve an equivalent problem &mdash; given a list of spells, and the opportunity to zero each coordinate of the accumulated sum <i>exactly once, at any point of the summation</i>, maximize the final sum of all the coordinates. Thus, a solution candidate can be equivalently described as a permutation of the <b>N</b> spells, plus the moments in time at which we zero each coordinate.\n</p><p>\nLet’s fix the order in which coordinates get zeroed (we will later iterate over all <b>M</b>! possible orderings), and look at one particular spell. We will try to figure out the best time to cast it. If we cast it before any coordinate is zeroed, then the result will be the same as if we had not cast it at all &mdash; every coordinate will eventually be reset to zero after casting the spell anyway. Now assume we cast it when <i>k</i> coordinates have already been zeroed, and the others have not. Compared to the situation when we don’t cast it at all, the end result is that the values of the spell on the <i>k</i> already-zeroed coordinates will be added to the final values of these coordinates, and so the sum of these values will be added to Edythe’s final result.\nSo, for every spell, we check each of the <b>M</b>+1 possibilities for k, and choose the one which will give the largest contribution to the final result.\n</p><p>\nSo a solution can work as follows: take every possible ordering <b>P</b> of the <b>M</b> dimensions. For each ordering P, iterate over all the spells, and for each spell find which of the <b>M</b>+1 values for k will cause the spell to contribute the most to the final result. The sum of all these contributions for all the spells is the best possible score for this ordering <b>P</b>; the maximum score over all orderings is the answer. The runtime is O((<b>M</b>+1)! <b>N</b>), which will easily run in time for <b>N</b> = 100 and <b>M</b> = 8.\n</p>","id":"000000000043360e","statement":"<h3>Problem</h3>\n<p>\nEdythe is a young sorceress working in the quality assurance department of Merlin, Inc. -- a magic spell factory. Her job is to test the magic spells that Merlin himself invents. Each spell requires precise amounts of certain ingredients and transforms them into other amounts of other ingredients. Edythe's job is to cast each spell exactly once in order to verify that the spell works correctly.\n</p>\n\n<p>\nShe can cast a spell only if she has the required amount of each ingredient. If she has already created ingredients of the right type from previous spells, Edythe must use those first. However, if she still needs more ingredients, she is allowed to take them from Merlin's storehouse. She has no ingredients to start with, but at the end, she gets to keep all the extra ingredients that she created and didn't use.\n</p>\n\n<p>\nEdythe wants to make as much profit as possible from her apprenticeship! She has to cast each of the <b>N</b> given spells exactly once, but she is free to do so in any order. Assuming that each spell works as expected, which ordering lets her earn the most money in the end?\n</p>\n\n<p>\nFor example, imagine that the test plan contains the following 3 spells:\n<ol>\n  <li>Inputs: $7 worth of gold. Outputs: $5 worth of sulfur.\n  <li>Inputs: nothing. Outputs: $10 worth of gold, $10 worth of sulfur.\n  <li>Inputs: $3 worth of gold, $20 worth of sulfur. Outputs: $2 worth of toads.\n</ol>\nNote that the first spell converts gold into sulfur, the second spell conjures up gold and sulfur from nothing, and the third spell converts gold and sulfur into toads.\n</p>\n\n<p>\nIf Edythe were to cast these spells in the order 1, 2, 3, then she would start by fetching $7 worth of gold from the storehouse for spell #1. That would let her cast spells #1 and #2, giving her $10 worth of gold and $15 worth of sulfur. For the final spell, she would need $3 worth of gold and $20 worth of sulfur. She would have to use all of the sulfur she created so far, $3 worth of gold, and $5 more worth of sulfur that she fetched from the storehouse. This would leave her with $9 worth of ingredients at the end ($7 worth of gold and $2 worth of toads).\n</p>\n\n<p>\nBut there is a better plan. If she cast the spells in the order 3, 1, 2, she would have $27 worth of ingredients at the end ($10 worth of gold, $15 worth of sulfur, and $2 worth of toads).\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one starts with a line containing <b>N</b> and <b>M</b>. <b>M</b> is the number of kinds of ingredients in the world. Each of the next <b>N</b> lines contains <b>M</b> integers describing a spell. Each integer is the value (or cost) of the corresponding ingredient. Negative integers are the dollar costs of the input ingredients; positive integers are the dollar values of the output ingredients; and zeros denote ingredients that are neither produced nor consumed by the spell. This also implies that no spell can simultaneously consume and produce the same ingredient.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the largest value of ingredients Edythe can have at the end.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\n-100 &le; Each integer in each spell &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>M</b> &le; 2.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>M</b> &le; 8.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 1\n1\n0\n-1\n3 3\n-7 5 0\n10 10 0\n3 -20 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 27\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Merlin QA","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nA brute force O(<b>N</b><sup>2</sup>) strategy will work for the Small dataset: for each position, compute the cumulative number of ones seen so far, and then check every possible pair of start and end points in the sequence. But <b>N</b> can be up to half a million in the Large dataset!\n</p><p>\nWe will read the string from left to right and keep track of the number of ones O<sub>i</sub> seen after reading the first i digits. We will examine each i between 0 and <b>N</b>, inclusive, so that we consider both the empty prefix and the full string. We will maintain an initially empty set of points, and for each i, we will add p<sub>i</sub> = (i, <b>F</b> &times; i - O<sub>i</sub>) to the set. Notice that the fraction of ones in the substring starting at position i+1 and ending at position j is (O<sub>j</sub> - O<sub>i</sub>) / (j - i), and the difference from <b>F</b> is \n<b>F</b> - (O<sub>j</sub> - O<sub>i</sub>) / (j - i) = (<b>F</b>(j - i) - O<sub>j</sub> + O<sub>i</sub>) / (j - i), which is the slope between p<sub>i</sub> and p<sub>j</sub>. Finding the p<sub>i</sub> and p<sub>j</sub> that minimize the absolute value of this slope is equivalent to solving the problem.\n</p><p>\nIt is hard to see (but easy to prove) that the slope with minimal absolute value occurs between two points that are consecutive in sorted order by y coordinate: if there is a point r that has a y coordinate between the y coordinates of two other points p and q, the slope between p and q (call it s) is the weighted average of the slope between p and r and the slope between q and r; either those two slopes are equal to s, or one of them must be less than s. A more visual way to see this is to draw the segment p-q and place r on it. That makes all three slopes equal. Moving r horizontally clearly makes the slope of one of the segments pr and qr increase and the slope of the other one decrease.\n</p><p>\nThis insight saves us from checking all pairs of points, and reduces the time complexity of the problem to O(<b>N</b> log <b>N</b>), which is imposed by the single sorting operation.\n</p>\n","id":"00000000004336f3","statement":"<h3>Problem</h3>\n\n<p>\nI have a sequence of <b>N</b> binary digits. I am looking for a substring with just the right proportion of 0s and 1s, but it may not exist, so I will settle for something that's just pretty good.\n</p>\n\n<p>\nCan you find a substring where the fraction of 1s is as close as possible to the given fraction <b>F</b>? Output the earliest possible index at which such a substring starts.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one starts with a line containing <b>N</b> and <b>F</b>. <b>F</b> will be a decimal fraction between 0 and 1 inclusive, with exactly 6 digits after the decimal point. The next line contains <b>N</b> digits, each being either 0 or 1.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the 0-based index of the start of the substring with the fraction of 1s that is as close as possible to <b>F</b>. If there are multiple possible answers, output the smallest correct value.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &le; <b>F</b> &le; 1<br/>\n<b>F</b> will have exactly 6 digits after the decimal point.\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>N</b> &le; 500,000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1U2LDkNv_O8hZyNSez4wosvvvQzGzD6vyWPh8-SWVmcmU9b3H_o_71uqeB5Yhb_SIRgPbzqSs3vncZ_vcYjYHwjk2m2J4vBpniA-lebIw4qdNzOEOS/pretty_good_proportion_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">5\n12 0.666667\n001001010111\n11 0.400000\n10000100011\n9 0.000000\n111110111\n5 1.000000\n00000\n15 0.333333\n000000000011000\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3gqHMJNdz-ASqIQUXTvmb-bovv5rQ3s5FUoWwbG22puYFAq7_DmcDjkKcLPB291gea22E8-HxSAIfUPVhJLMYgkL89PX34nE-InGtcE0E3_e19b-lcHQ/pretty_good_proportion_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 5\nCase #2: 5\nCase #3: 5\nCase #4: 0\nCase #5: 6\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\nIn Case #1, there is no substring that has exactly a 1-proportion of exactly <nobr>666667/1000000</nobr>. The closest we can get is <nobr>2/3</nobr>. The input string has 5 substrings that achieve it -- 3 substrings of length 3 that start at indices 5, 7, and 8 (101, 101, and 011); as well as two substrings of length 6 that start at indices 5 and 6 (101011 and 010111). The smallest of these indices is 5.\n</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Pretty Good Proportion","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nLet G be the graph, s be the entrance node, and t be the node with the secret weapon.\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3orfvRWixS8DBl0d7TwoMGw7SI-n0b5rz7ez43RIdTUstPWhakEkE9SGy30hNpnIH8uuw/graph.png\">\n</p><p>\nFor the small input, we start by finding the shortest distance through the graph from s to t using, e.g., \n<a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\" target=\"_blank\">Dijkstra’s algorithm</a>.  Call this distance <b>L</b>.\nIf <b>K</b>=0, we cannot obstruct anything, so the answer is simply <b>L</b>.\n</p><p>\nNow assume <b>K</b> &gt; 0. It is always advantageous to obstruct s, so let’s begin by doing this: reduce <b>K</b> by one, and increase <b>L</b> by 1.  Next we want to find if we can increase L one more by obstructing other nodes.  This means that every shortest path from s to t must have another obstructed node in it (other than s).  We can turn this into a standard graph problem in the following way -- take the subgraph of G which contains all the edges and nodes in a shortest path from s to t.  Make each edge directed, pointing in the direction of the path it belongs to.\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1WlXv_CZKd-3JhaHt-AFfOtAoetcuF7rG1R2mpG2ZysJkhFRdRiKqnOcP5c76FO6vXW4RWRIlD1yBl/graph_grayed.png\">\n</p><p>\nNow, if there is a set of up to K nodes we can obstruct that covers all the paths, for example a and d in the diagram above, then removing those nodes cuts the graph, separating s and t.  So we need to solve the minimum vertex cut problem on this graph and check if the cut has size at most K.  To do this, we convert it to an edge cut problem by changing the graph so that each vertex except s and t is split into two nodes, with an edge of capacity 1 between them. The original edges are converted to infinite-capacity edges, as in the diagram below:\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3ck6czGq7_FGCuzWVF5W7oU3-Q4TcFNHWXn6V-P4J8_6vRbIhS3ZDqcWjnfihHLumSEKrlQM4KAAWUH-E/graph_expanded.png\">\n</p><p>\nA vertex cut of <b>K</b> vertices in the earlier graph will correspond to an edge cut of capacity <b>K</b> in this new graph.  In the example above, cutting the edges between the pairs of nodes for a and d cuts the graph.  Now we have a minimum edge cut problem, and we can apply the <a href=\"https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem\" target=\"_blank\">max flow / min cut theorem</a> &mdash; the size of the minimum edge cut is the size of the maximum flow &mdash; and use one of the standard algorithms for finding the maximum flow. If there exists a flow that is larger than <b>K</b>, then the answer is <b>L</b>, otherwise the answer is <b>L</b>+1.\n</p><p>\nNow for the large input.  We will check, for successive values of X starting at 1, whether it is possible to obstruct up to K nodes in order to stop the guards traveling from node s to node t in time &le; X.  We call this proposition P(X).  The first value of X where P(X) is false is the answer.\n</p><p>\nTo determine the truth of P(X) for a specific X, we construct a new graph G', which has a node for each triplet (v, x, b) where v is a vertex in G, x is an integer between 0 and X, and b is true or false. Node (v, x, b) represents that the guards can reach node v in time x if b is false, or reach node v and surpass the obstruction in time x, if b is true. We add the following edges:\n</p><ol>\n<li>(v, x, false) to (v, x, true), for each v and x. (This means a free pass through an obstruction; removing one of these is equivalent to not adding an obstruction at v, if you remove the one for the appropriate x.)</li>\n<li>(v, x, false) to (v, x+1, true), for each v and x &lt; X-1.  (a non-free pass through an obstruction)\n(v, x, false) to (v, x+1, false), for each v and x &lt; X;  (Stay put for 1 time unit.)</li>\n<li>(v, x, true) to (w, x+1, false), for each x &lt; X and each edge vw in G.  (Transverse an edge in 1 time unit).</li>\n</ol>\n</p><p>\nLet &sigma; be the node (s, 0, false), and &tau; be the node (t, X, false).  Assuming no nodes are obstructed, we can see that the following properties hold for G':</p><ul>\n<li>There is a path from &sigma; to (v, x, false) if and only if the guards can arrive at node v at a time &le;x.</li>\n<li>There is a path from &sigma; to (v, x, true) if and only if the guards can leave node v at a time &le;x.</li>\n<li>There is a path from &sigma; to &tau; if and only if it is possible for the guards to travel from s to t in G in time &le; X.</li>\n</ul><p>\nIf some nodes in G are obstructed, the properties above still hold if we delete all the edges in set 1 of the four sets above, where the corresponding v is one of the obstructed nodes.  So P(X) is equivalent to a graph cut problem -- determining whether we can disconnect &sigma; and &tau; by cutting the set 1 edges for up to K nodes of G.\n</p><p>\nIn G, after we choose the nodes to obstruct, for each node v, all of the optimal paths from s to t that pass through v do so at the same time, so the ability to obstruct v was only \"useful\" at a given time time.  So if our ability to obstruct a node were changed to an ability to obstruct a node at just one particular time, the result would be no different.  Similarly, in G', after removing a set of edges, for each v, there will only be at most one x for which it was \"useful\" to cut the edge from (v, x, false) to (v, x, true).\n</p><p>\nWe can prove this more formally: let A be a set of edges from set 1 that have been removed to disconnect &sigma; and &tau;, and say that it contains the edges from (v, x<sub>0</sub>, false) to (v, x<sub>0</sub>, true) and from (v, x<sub>1</sub>, false) to (v, x<sub>1</sub>, true) for some v and x0 &lt; x<sub>1</sub>.  If both edges are necessary, then there must be paths from &sigma; to (v, x<sub>0</sub>, false) and (v, x<sub>1</sub>, false), and paths from (v, x<sub>0</sub>, true) and (v, x<sub>1</sub>, true) to &tau;.  But now there is a path from &sigma; to &tau; via (v, t<sub>0</sub>, false), (v, t<sub>1</sub>-1, false), and (v, t<sub>1</sub>, true), so &sigma; and &tau; are not disconnected at all!  So for any set of edges A which disconnect &sigma; and &tau;, there is a subset of A which disconnects &sigma; and &tau; and has at most one edge cut for any node in G.\n</p><p>\nThis means that P(X) is equivalent to being able to disconnect &sigma; and &tau; by cutting up to K edges from set 1.  As with the small input, this is equivalent to a max flow problem, with unit capacity on the set 1 edges and infinite capacity on the others.\n</p><p>\nWe can solve all these flow problems quite quickly, since we do not need to recompute the maximum flow from scratch each time we increase X &mdash; we just add one more \"layer\" of nodes and edges for the new X value, and update the flow.\n</p>","id":"000000000043379b","statement":"<h3>Problem</h3>\n<p>\nYou and your friend Pinky have a plan to take over the world. But first you need to disable a certain secret weapon.\n</p>\n\n<p>\nIt is hidden inside a twisted maze of passages (a graph) with one entrance. Pinky is going to be at the vertex with the secret weapon, disabling it.  Meanwhile, a security team at the graph entrance will be alerted, and will run through the graph to try to get to Pinky in time to stop him.  You are going to be slowing down the security team to give Pinky as much time as possible. It takes one unit of time to traverse any edge of the graph, but you can additionally \"obstruct\" up to <b>K</b> vertices. It takes one additional unit of time to traverse an obstructed vertex.  You will choose to obstruct a set of vertices that slows down the security team by as much as possible.\n</p>\n\n<p>\nIf the security team will be starting at the graph entrance and is trying to get to the secret weapon vertex, how much time will it take them to get there? \nNote that you have to commit all your obstructions before the security guards start their journey, and the security guards will know which vertices you have obstructed and will choose an optimal path based on that information.\n</p>\n\n<p>\nObstructing the secret weapon vertex is not useful because that will not delay the guards any further after they have already caught Pinky. Obstructing the entrance, on the other hand, is obviously a good idea.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one starts with a line containing <b>N</b>, <b>M</b>, and <b>K</b>. The next <b>M</b> lines each contain a pair of vertices connected by an edge. Vertices are numbered from 0 (the entrance) to <nobr><b>N</b> - 1</nobr> (the secret weapon room). The first vertex will always be smaller than the second vertex, and no pair of vertices will appear more than once in the same test case. Edges are bi-directional -- the guards can travel along any edge in either direction.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the time it will take the security guards to get from the entrance to the secret weapon room.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n2 &le; <b>N</b> &le; 100.<br/>\n1 &le; <b>M</b> &le; <b>N</b> * (<b>N</b> - 1) / 2.<br/>\n1 &le; <b>K</b> &le; <b>N</b>.<br/>\nThere will always be a path from room 0 to room <nobr><b>N</b> - 1</nobr>.\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\nIt will not be possible to delay the guards by more than 2 time units, compared to the shortest unobstructed path length (using the given <b>K</b>).\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\nNo extra restrictions.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n3 2 1\n0 1\n1 2\n3 2 2\n0 1\n1 2\n3 2 3\n0 1\n1 2\n4 4 2\n0 1\n0 2\n1 3\n2 3\n7 11 3\n0 1\n0 2\n0 3\n1 4\n1 5\n2 4\n2 5\n3 4\n3 5\n4 6\n5 6\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 4\nCase #3: 4\nCase #4: 3\nCase #5: 5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":29}],"title":"Taking Over The World","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nLet us call the length of the input sequence N.\nThere are N+1 possible \"slots\" in which the new element can end up &mdash; we number them from 0 to N, where 0 is the slot before the first element of <b>a</b>, and N is the slot after the last element of <b>a</b>.\n</p><p>\nAt any point in our search, we will have narrowed down the possible location of the correct slot to an interval of possible slots.  We then want to find out which slot in that interval is the correct one; we call this \"solving\" the interval.\n</p><p>\nFor a given cost C and position X, we want to compute the largest possible interval of slots, beginning at X, which we can solve in cost C or less.  Call the rightmost slot of that interval f(C,X).  We will compute f using dynamic programming.\n</p><p>\nClearly if C=0, then f(C,X)=X and the interval is empty. (Since each comparison costs at least 1, we cannot make any comparisons.)\n</p><p>\nOtherwise, assume we have an interval [X,Y], where X &lt; Y, that we can solve at a cost no greater than C.\nThe solution must involve an initial comparison at an index i, where i is in [X,Y-1], which costs a<sub>i</sub>.\nThen we will have narrowed down the correct slot to either the interval of slots to the left of index i, which is [X,i]; or the interval of slots to the right of index i, which is [i+1,Y].\n</p><p>\nEach of these intervals must be solvable with a cost no greater than C-a<sub>i</sub>, i.e., f(C-a<sub>i</sub>, X) &ge; i, and f(C-a<sub>i</sub>, i+1) &ge; Y.\n</p><p>\nWe want to find the largest Y for which the above statements hold.\nTo limit the number of possible choices for i and Y, we always use Y=f(C-a<sub>i</sub>, i+1), since by definition this is the largest possible Y for a given choice of X and i.\nAlso, instead of trying every value of i in [X, f(C-a<sub>i</sub>, X)], we iterate through each possible value of a<sub>i</sub> from 1 to 9, and try the largest index i in [X, f(C-a<sub>i</sub>, X)] with that value.  (Smaller indices i with the same value of a<sub>i</sub> could not produce a larger Y).\nIf there are no usable values of i (because C is too small, or X=N) then f(C,X)=X.\n</p><p>\nWe compute f(C,X) in this way for increasing values of C, until we find the minimal C such that f(C,0)=N. This C is the answer.\n</p><p>\nThe maximum value for the resulting C occurs when every array value is 9, in which case we can't do better than a standard binary search, which takes O(log N) comparisons of cost 9 each. That means computing f(C,X) over a domain of size 9 log N &times; N. Since the computation at each position takes constant time (we try 9 things), the overall algorithm takes O(N log N) time, with a somewhat large constant because of the two factors of 9 mentioned previously.\n</p>","id":"0000000000433a69","statement":"<h3>Problem</h3>\n<p>\nYou were asked to implement arguably the most important algorithm of all: binary search. More precisely, you have a sorted array of objects, and a new object that you want to insert into the array. In order to find the insertion position, you can compare your object with the objects in the array. Each comparison can return either \"greater\", meaning that your object should be inserted to the right of the compared object, or \"less\", meaning that your object should be inserted to the left of the compared object. For simplicity, comparisons never return \"equal\" in this problem. It is guaranteed that when your object is greater than some object in the array, it is also greater than all objects to the left of that object; similarly, when your object is less than some object of the array, it is also less than all objects to the right of that object. If the array has <b>n</b> elements, there are <b>n</b>+1 possible outcomes for your algorithm.\n</p>\n\n<p>\nIn this problem, not all comparisons have the same cost. More precisely, comparing your object with <b>i</b>-th object in the array costs <b>a</b><sub><b>i</b></sub>, an integer between 1 and 9, inclusive.\n</p>\n\n<p>\nWhat will be the total cost, in the worst case, of your binary search? Assume you follow an optimal strategy and try to minimize the total cost in the worst case.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each of those lines contains one sequence of digits describing the comparison costs <b>a</b><sub><b>i</b></sub> for one testcase. The size of the array <b>n</b> is given by the length of this sequence.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>x</b>: <b>y</b>\", where <b>x</b> is the test case number (starting from 1) and <b>y</b> is the total binary search cost in the worst case.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\nAll digits are between 1 and 9, inclusive.<br/>\nThere are no spaces between digits on one line.\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>n</b> &le; 10<sup>4</sup>.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>n</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n111\n1111\n1111111\n1111119\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 3\nCase #3: 3\nCase #4: 10\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Costly Binary Search","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0enV8K7Pz_-Mhu_FX8DteNirQoVga5USJKsRRLl_5_mLQREhCfgVpHh41ITUZqbPoitsIyOLI/matrices.png\"/>\n<p>\nLet <b>N</b> be the size of the grid, and K be the number of 3-family tents.  We can decompose the problem of counting the number of arrangements for given values of <b>N</b> and K by noting that we can first choose a set of K rows and K columns to contain the 3-family tents, and the remaining set of <b>N</b>-K rows and <b>N</b>-K columns will contain the 2-family and 1-family tents.  (See the diagram above.)  The number of arrangements is then the product of the following:\n</p>\n<ul>\n<li>\n<b>The number of ways to choose the sets of rows and columns.</b>  \nThere are C(<b>N</b>,K)^2 ways of choosing the K rows and columns, where C(<b>N</b>,K) is a <a href=\"https://www.google.com/search?q=binomial+coeffinent\" target=\"_blank\">binomial coefficient</a>.</li>\n<li>\n<b>The number of ways to assign the 3-family tents to (row, column) pairs.</b>  We can do this assignment by taking a permutation of the columns, and assigning the i<sup>th</sup> column in the permutation to the i<sup>th</sup> row in the set of K rows.  There are <a href=\"https://www.google.com/search?q=factorial\" target=\"_blank\">K!</a> such permutations.</li>\n<li>\n<b>The number of ways to assign the 2-family tents to (row, column) pairs.</b>  Similarly to the 3-family tents, there are (<b>N</b>-K)! ways to do this.</li>\n<li>\n<b>The number of ways to assign the 1-family tents to (row, column) pairs.</b>  Not all of the (<b>N</b>-K)! permutations of columns can be used, since we have the additional requirement that we can't use a (row, column) pair in which we've already placed a 2-family tent.\nTo deal with this, we reformulate what we need to do here: for each row X in the set of <b>N</b>-K rows, we need to choose a unique row Y from the same set, find the column C such that there is a 2-family tent at (Y,C), and place a 1-family tent at (X,C).  The space at row X, column C is guaranteed not to already have a tent.\n\nSo we need a permutation of the <b>N</b>-K rows, with the additional requirement that no row is unchanged by the permutation &ndash; that is, for each row X, we choose a row <i>different to X</i> as the corresponding row Y in the permutation.  Such a permutation is called a <a href=\"https://www.google.com/search?q=derangement\" target=\"_blank\">derangement</a>.  The number of derangements of size N-K is written !(N-K).</li>\n</ul><p>\nNow, the product of all these terms is:\n</p><p>\nC(<b>N</b>,K)^2 &times; K! &times; (<b>N</b>-K)! &times; !(<b>N</b>-K)\n= <b>N</b>!^2 / (K! &times; (<b>N</b>-K)!) &times; !(<b>N</b>-K).\n</p><p>\nWe get the answer to the problem by summing this value (mod 10^9 + 7) for all values of K from X to <b>N</b>.\n</p><p>\nWe can do that efficiently by precomputing K!, 1/K!, and !K mod 10^9 + 7 for all values of K up to <b>N</b>.\nFactorials can be computed with the obvious recurrence.\n1/K! mod 10^9+7 can be computed from K! with the <a href=\"https://www.google.com/search?q=extended+euclidean+algorithm\" target=\"_blank\">extended Euclidean algorithm</a> or using <a href=\"https://www.google.com/search?q=fermat%27s+little+theorem\" target=\"_blank\">Fermat's little theorem</a>.\n!K can be computed with the recurrence:\n</p><p>\n!1 = 0, !2 = 1, !X=(X-1)(!(X-1)+!(X-2)).\n</p>","id":"0000000000433c8d","statement":"<h3>Problem</h3>\n<p>\n\"Summer is finally here: time to relax, have some fun, go outside and enjoy the\nnice weather!\" says Alice, a very dedicated Ranger working in a popular National Park. During the summer, lots of families take some time\noff to camp there and have a good time, and it is Alice's job to accommodate\nthe visitors.<br/>\n<br/>\nAlice is in charge of one of the many camps around the park. The camp can be\ndescribed as a matrix of size <b>N</b> x <b>N</b>, where each cell has\nenough space for at most one tent. In order to arrange the families in the camp,\nthere are several regulations that Alice needs to follow:<br/>\n<ul>\n <li>Only families with <b>1, 2 or 3</b> members are allowed in the\ncamp. Also, each tent can contain members of only one family, and families cannot be split across multiple tents.</li>\n <li>For security reasons, Alice doesn't want the rows or columns to be too\ncrowded or too empty, so she wants exactly <b>3</b> members in each row and \ncolumn.</li>\n <li>Also, according to the park's safety policies, there shouldn't be more than\n<b>2</b> tents in any row or column.</li>\n</ul>\n<br/>\nAdditionally, Alice knows in advance that at least <b>X</b> three-member\nfamilies will be visiting the camp, and that there will be enough one- or two-member\nfamilies to fill the rest of the camp.<br>\n<br/>\nFor example, these are valid arrangements for N = 3 and X = 0:<br/>\n<pre>\n1  2  0  |  3  0  0\n0  1  2  |  0  1  2\n2  0  1  |  0  2  1\n</pre>\n\nThese are not valid arrangements for N = 3 and X = 1:\n<pre>\n1  2  0  |  0  3  0  |  1  2  0  |  1  1  1\n0  1  2  |  3  0  0  |  0  2  0  |  1  1  1\n2  0  1  |  0  0  0  |  2  0  1  |  1  1  1\n</pre>\n\n<ul>\n <li>The first one is not valid because there should be at least one \nthree-member family.</li>\n <li>The second example is not valid because the number of persons in the third\nrow (and column) is not three.</li>\n <li>The third one is invalid because there are more than three members in the\nsecond column (and fewer than three in the second row).</li>\n <li>The last example contains more than two tents per row or column.</li>\n</ul>\n\nFinally, Alice likes to keep things interesting. She would like to know how many\ndifferent arrangements are possible given <b>N</b> and <b>X</b>.\n<br/>\n<br/>\nTwo arrangements A and B are considered different, if a cell in one arrangement contains a tent, but the same cell in the other arrangement doesn't; or if there is a tent in the \nsame cell of both arrangements, but the number of members in that cell in A is\ndifferent than the number of members in the same cell in B.<br/>\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input contains <b>T</b>, the number of test cases.  <b>T</b> test cases follow.  Each test case consists of exactly one line with two integers <b>N</b> and <b>X</b> corresponding to the number of rows (and columns) in Alice's camp and the minimum number of three-member families, respectively.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #X: Y\", where X is the test case number (starting from 1) and Y is the number of possible arrangements.<br/>\n<br/>\nThe answer may be huge, so output the answer <b>modulo 10<sup>9</sup> + 7</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 200.<br/>\n0 &le; <b>X</b> &le; N.<br/>\n</p>\n\n<h4>Small dataset</h4>\nTime limit: 240 seconds.<br/>\n1 &le; <b>N</b> &le; 20.<br/>\n\n<h4>Large dataset</h4>\nTime limit: 480 seconds.<br/>\n1 &le; <b>N</b> &le; 10<sup>6</sup>.<br/>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 2\n3 1\n15 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 24\nCase #3: 738721209\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn case #1, you have two different valid arrangements:\n<pre>\n0 3  |  3 0\n3 0  |  0 3\n</pre>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Campinatorics","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIn this problem, we are given a version of a small <a href=\"https://en.wikipedia.org/wiki/Brainfuck\" target=\"_blank\">programming language</a>, and we are required to track the number of operations executed as a program runs. The memory is a circular array of 2<sup>40</sup> positions, and all values are considered modulo 256 (for convenience, we shift values one position to make them go [0,255]). The program can run for a really long time, so our approach is to simulate it efficiently by bundling together many of those operations. The actual code is long and complicated &mdash; this is the last problem in a finals round, after all &mdash; so we just present an overview of the main idea.\n</p><p>\nThe program can be factorized into 5 parts: A(B)C(D)E. Some of these may be empty; in particular, in the Small dataset, D and E are always empty. Each sequence of simple instructions can be translated, via simulation, into a complex instruction of the form:\n<ol>\n<li>Let i be the current position of the truck.</li>\n<li>Add some x<sub>j</sub> to position i+j for j in [-2000, 2000].  (2000 is the maximum length of each part.)</li>\n<li>Move the current position to i+k, where k is also in [-2000, 2000].</li>\n</ol>\n<p><b>Running A</b><br/>\nAfter executing A, only values within 2000 of the starting position can be modified. Let us call the area within 2000 of the starting position the \"red\" area.\n</p><p><b>Running (B)</b><br/>\nAfter running B several times, we can either finish or move out of the red area. After several more runs outside, the memory outside the red area will start to look periodic with period |k| and we are going to keep moving the current position according to B's k in the 3rd step until we come back to the red area on the other side, completing a full circle. So, we bundle together all the instructions required to complete the circle and we represent the non-red area as a repetition of a period with length at most 4001 (the range of j's in step 2). We can keep doing this in this way until the loop finishes (which is guaranteed). Notice that after at most 4001 complete circles around the memory, we are going to repeat the initial positions inside the red area. And once we've done that, we are going to start repeating the values there, so we can't do more than 4001 &times; 256 loops without it being an infinite loop (which is forbidden by input constraints).\n</p><p><b>Running C</b><br/>\nAfter that, we can simulate C, which can modify the range [-4000, 4000] because the previous loop finished within 2000 of the starting point. Let us call that the \"green\" area.\n</p><p><b>Running (D)</b><br/>\nWhen running D, something similar to running B happens, but the memory outside the green area is now the sum of two periodic things with period of size at most 4001, so it can have a period of up to 4001<sup>2</sup>. Luckily, this is still small enough to simulate, and other than that, we can proceed with the same idea as we did for B. \n</p><p><b>Running E</b><br/>\nFor E, we proceed again in the same fashion. In this case, the non-periodic area's size can increase to a couple of millions due to the quadratic size of the last period, but that is still well under the memory limits.\n</p>","id":"0000000000433d47","statement":"<h3>Problem</h3>\n<p>\nYou are in a large storage facility, with 2<sup>40</sup> storage locations arranged in a circle.\n</p>\n<p>\nA truck with a crane on it moves along the circle of storage locations, picking up or putting down crates according to a program. (The truck has an unlimited supply of crates on board, so it can always put more crates down.)\n</p>\n<p>\nThe program consists of a sequence of these instructions:\n<ul>\n<li><code>b</code> : move back one location\n<li><code>f</code> : move forward one location\n<li><code>u</code> : pick up one crate at the current location\n<li><code>d</code> : put down one crate at the current location\n<li><code>(</code> : do nothing\n<li><code>)</code> : if there is more than one crate at the current location, move back to the most recent ( in the sequence of instructions, and continue the program from there.  (This doesn't move the truck.)\n</ul>\n\n( and ) instructions in the program will always come in pairs: a ( will be followed later by a matching ).  There will be at most two such pairs in the program, and if there are two pairs, they will not be nested &ndash; that is, there will be either:\n<ul>\n<li>no ( or ) instructions;\n<li>one ( instruction somewhere in the program, followed later by one ) instruction;\n<li>a ( instruction, followed later by a ) instruction, followed later by another (, and again later by another ).\n</ul>\n</p>\n<p>\n\nThe sample cases contain examples of each of these.\n</p>\n<p>\nEach storage location begins with one crate, before the crane truck starts running its program.\n</p>\n<p>\nMysteriously, if the truck picks up the last crate at a location, another truck instantly comes along and puts down 256 crates there!  Similarly, if the truck puts down a crate at a location, and that location then has 257 crates, another truck instantly drives past and picks up 256 of the crates, leaving one behind!  So every location always has between 1 and 256 crates.\n</p>\n<p>\n\nHow many times will the truck move forward or backward before reaching the end of its program?\n\n</p>\n<p>\n\n<h3>Input</h3>\n<p>\nOne line containing an integer <b>T</b>, the number of test cases in the program.\n</p>\n<p>\n<b>T</b> lines, each containing a crane truck program with up to 2000 characters.\n</p>\n\n<h3>Output</h3>\n<p>\nT lines, one for each test case, containing \"Case #<b>X</b>: <b>Y</b>\" where <b>X</b> is the test case number, and <b>Y</b> is the number of times the truck moves.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n1 &le; the length of the program &le; 2000.<br/>\nThe program is guaranteed to terminate.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\nThe program will contain at most one pair of ( and ) instructions.\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\nThe program will contain at most two pairs of ( and ) instructions.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\nufffdddbbbdd\ndddd(fdbu)fff\ndddd(fdddddbu)f(fdddddbu)\nbf\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 6\nCase #2: 11\nCase #3: 49\nCase #4: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":37}],"title":"Crane Truck","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433831","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2015"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
