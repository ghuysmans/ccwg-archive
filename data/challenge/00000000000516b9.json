{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1556969400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000000516b9","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Round 1C continued this year's Round 1 pattern of one \"easier\" regular\n  problem, one \"medium\" interactive problem, and one hard regular problem.\n  <i>Robot Programming Strategy</i> laid out a tournament structure that might\n  have seemed hopelessly complicated at first, but the details turned out to\n  be mostly unimportant &mdash; your robot just had to be able to win against\n  any opponent! Like Draupnir in Round 1B, <i>Power Arrangers</i> made you\n  infer some missing information after making careful choices. Finally,\n  <i>Bacterial Tactics</i> could be approached with a useful tool for solving\n  problems about two-player games.\n</p><p>\n  By the 25 minute mark, every problem had been fully solved by at least one\n  contestant, and the race was on to get that first 100 score! <b>Rafbill</b>\n  initially appeared to come out on top with a penalty time of 50:57, but\n  later resubmitted and slipped to an overall third place, with a penalty time\n  of 1:07:44. <b>logicmachine</b> &mdash; now that sounds like someone who\n  knows a thing or two about robot programming strategy! &mdash; moved up to\n  win with a penalty time of 54:07. <b>Joisino</b> took the silver with\n  58:48. There were 91 perfect scores overall. \n</p><p>\n  We will be in touch sometime next week to confirm the 1C results; the cutoff\n  for rank 1500 appears to be 42 points plus sufficient speed. Solving just the\n  first or second problem was unfortunately not quite enough. To those of you\n  who did not qualify for Round 2, don't lose heart &mdash; it's tough. Keep\n  practicing, and we hope to see you again next year. To the 4500 qualifiers\n  from the three Round 1s: get ready, since Round 2 is even tougher! Best of\n  luck in winning a T-shirt and advancing to Round 3... and perhaps even the\n  World Finals!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Robot Programming Strategy: Written by Tim Lambert. Prepared by Jonathan\n    Irvin Gunawan.\n</p><p>\n  Power Arrangers: Written by Ian Tullis. Prepared by Pi-Hsun Shih.\n</p><p>\n  Bacterial Tactics: Written by Guillaume Aubian. Prepared by Shane Carr.\n</p><p>\n  Solutions and other problem preparation and review by Patrick Au, Liang Bai,\n  Darcy Best, John Dethridge, Jackson Gatenby, Jonathan Irvin Gunawan,\n  Md Mahbubul Hasan, Pablo Heiber, Andy Huang, Pi-Hsun Shih, Micah Stairs, and\n  Kevin Tran.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Robot Programming Strategy: Ian Tullis</li>\n  <li>Power Arrangers: Ian Tullis</li>\n  <li>Bacterial Tactics: Shane Carr and Ian Tullis</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1556960400000,"tasks":[{"analysis":"<p>\n  With <b>A</b> competitors, there are <b>A</b>! possible initial setups for\n  the tournament bracket, and <b>A</b> is itself exponential in the number\n  of rounds of the tournament. A factorial of an exponential is terrifying\n  enough, and we haven't even started the tournament yet!\n</p><p>\n  Fortunately, we can ignore almost everything about the structure of the\n  tournament. For any opponent, there is at least one possible initial setup in\n  which we will play our first match against that opponent. Since we have to\n  guarantee that we will win the tournament regardless of the initial setup,\n  we must be able to defeat <i>every</i> opponent. We cannot tie an opponent,\n  since that coin flip might not come up in our favor!\n</p><p>\n  So all we have to do is find a program that beats every opponent's program.\n  To check a program, we can just check it against each opponent, without\n  worrying about the tournament setup.\n</p>\n<h3>Test set 1</h3>\n<p>\n  In test set 1, there are at most 7 opponents, and their programs can be at\n  most 5 characters long. Our program can be longer than that if need be, but\n  how long does it need to be? We can observe that an optimal winning program\n  should never waste a turn by tying with all remaining opponents, since then\n  it could have instead chosen the move that would have beaten all of them;\n  therefore, it should eliminate at least one opponent per move. So in test set\n  1, if there is a winning program, it is at most 7 moves long. We can\n  comfortably check all 3<sup>7</sup> + 3<sup>6</sup> ... + 3 possible programs\n  of length up to 7.\n</p><p>\n  When simulating a match, we cannot wait around for a googol of moves; by the\n  same argument above, an optimal winning program should take no more than 7\n  moves to defeat all opponents, so we only need to simulate at most 7 moves.\n  If we are still tied with the opponent at that point, we can safely give up\n  on that program.\n</p><p>\n  If we find that no program of length at most 7 beats every opponent's\n  program, then we can declare that the case is <code>IMPOSSIBLE</code>.\n</p>\n<h3>Test set 2</h3>\n<p>\n  In test set 2, there can be up to 255 opponents, and we cannot generate and\n  check all programs of length up to 255. We must find a way to construct a\n  winning program if it exists.\n</p><p>\n  Let's imagine playing against all opponents at once. How do we choose our\n  program's first move? We must win or tie against every opponent, so we will\n  consider the set of their first moves. If it includes all three possible\n  moves, we are doomed; no matter what we pick, at least one opponent\n  will defeat us. If it includes only one move (e.g. every opponent starts\n  with <code>R</code>), then we can pick the move that defeats that move\n  (in this case, <code>P</code>) and instantly defeat everyone. Otherwise,\n  the set includes two of the possible moves, and we should pick the move that\n  ties one and beats the other. For example, if the opponents all lead off with\n  <code>S</code> or <code>P</code>, we should pick <code>S</code>.\n</p><p>\n  Eliminating any defeated opponents and proceeding to the next move of this\n  combined \"match\", we can apply the same strategy, but considering the set of\n  remaining opponents' second moves (looping through their programs as needed),\n  and so on. We will eliminate at least one opponent with each move, so after\n  <b>A</b> moves, we will either have our winning program or know that\n  the case is <code>IMPOSSIBLE</code>. Notice that this limit holds regardless\n  of the lengths of the opponents' programs.\n</p>\n","id":"0000000000134c90","statement":"<h3>Problem</h3>\n<p>\n  After many sleepless nights, you have finally finished teaching a robotic arm\n  to make the hand gestures required for the Rock-Paper-Scissors game. Now you\n  just need to program it to compete in the upcoming robot tournament!\n</p><p>\n  In this tournament, each robot uses a program that is a series of moves, each\n  of which must be one of the following: <code>R</code> (for \"Rock\"),\n  <code>P</code> (for \"Paper\"), or <code>S</code> (for \"Scissors\"). Paper\n  beats Rock and loses to Scissors; Rock beats Scissors and loses to Paper;\n  Scissors beats Paper and loses to Rock.\n</p><p>\n  When two robots face off in a match, the first robot to play a winning\n  move wins. To start, each robot plays the first move of its program. If the\n  two moves are different, one of the moves beats the other and thus one of the\n  robots wins the match. If the moves are the same, each robot plays the next\n  move in its program, and so on.\n</p><p>\n  Whenever a robot has reached the end of its program and needs its next move,\n  it returns to the start of its program. So, for example, the fifth move of a\n  robot with the program <code>RSSP</code> would be <code>R</code>. If a match\n  goes on for over a googol (10<sup>100</sup>) of moves, the judges flip a fair\n  coin to determine the winner.\n</p><p>\n  Once a match is over, the winning robot resets, so it has no memory of the\n  that match. In its next match, it starts by playing the first move of its\n  program, and so on.\n</p><p>\n  The tournament is played in K rounds and has a single-elimination \"bracket\"\n  structure. There are N = 2<sup>K</sup> robots in total, numbered 0 through\n  N - 1. In the first round, robot 0 plays a match against robot 1, robot 2\n  plays a match against robot 3, and so on, up to robots N - 2 and N - 1. The\n  losers of those matches are eliminated from the tournament. In the second\n  round, the winner of the 0-1 match faces off against the winner of the 2-3\n  match, and so on. Once we get to the K-th round, there is only one match, and\n  it determines the overall winner of the tournament.\n</p><p>\n  All of the other contestants are so confident that they have already publicly\n  posted their robots' programs online. However, the robots have not yet been\n  assigned numbers, so nobody knows in advance who their opponents will be.\n  Knowing all of the other programs, is it possible for you to write a program\n  that is <i>guaranteed</i> to win the tournament, no matter how the robot\n  numbers are assigned?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>;\n  <b>T</b> test cases follow. Each test case begins with one line containing\n  an integer <b>A</b>: the number of adversaries (other robots) in the\n  tournament. Then, there are <b>A</b> more lines; the i-th of these contains\n  a string <b>C<sub>i</sub></b> of uppercase letters that represent the program\n  of the i-th opponent's robot.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>. If\n  there is a string of between 1 and 500 characters that is guaranteed to\n  win the tournament, as described above, then <code>y</code> should be the\n  string of uppercase letters representing that program. Otherwise,\n  <code>y</code> should be <code>IMPOSSIBLE</code>, in uppercase letters.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  Each character in <b>C<sub>i</sub></b> is uppercase <code>R</code>,\n  <code>P</code>, or <code>S</code>, for all i.<br/>\n  <b>A</b> = 2<sup>K</sup> - 1 for some integer K &ge; 1.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>A</b> &le; 7.<br/>\n  <b>C<sub>i</sub></b> is between 1 and 5 characters long, for all i.\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>A</b> &le; 255.<br/>\n  <b>C<sub>i</sub></b> is between 1 and 500 characters long, for all i.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1\nRS\n3\nR\nP\nS\n7\nRS\nRS\nRS\nRS\nRS\nRS\nRS\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: RSRSRSP\nCase #2: IMPOSSIBLE\nCase #3: P\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Note: Although all the opponents in each of these sample cases have programs\n  of the same length, this is not necessarily the case. Opponents within a\n  test case might have programs of different lengths.\n</p><p>\n  In Sample Case #1, there is only one opponent, with the program\n  <code>RS</code>. Our answer matches the opponent's moves for a while, and\n  the opponent loops through its program several times. As is starts its fourth\n  pass through its program, we beat it with <code>P</code>. Other valid\n  solutions exist, like <code>P</code>, <code>RR</code>, and <code>R</code>.\n</p><p>\n  In Sample Case #2, there are three opponents, with the programs\n  <code>R</code>, <code>P</code>, and <code>S</code>. It is up to you to figure\n  out why this case is <code>IMPOSSIBLE</code>!\n</p><p>\n  In Sample Case #3, all seven opponents use the same program. Using the\n  program <code>P</code>, for example, guarantees that you will win. Remember\n  that each robot begins at the start of its program at the start of each match\n  against a new opponent.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Robot Programming Strategy","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  On a player's turn, the grid will be in some <i>state</i>, according to\n  whether any bacteria have already been placed, and how they have spread. We\n  can determine whether a state is <i>losing</i> via the following recursive\n  definition:\n</p>\n<ul>\n  <li>the player has no moves because there are no empty cells</li>\n  <li>any of the player's moves would either cause a mutation, or give the\n    opponent a <i>winning</i> state.\n    <ul>\n      <li>A winning state is a state that has at least one <i>winning move</i>\n        &mdash; that is, a move that would leave the other player in a losing\n        state.</li>\n    </ul>\n  </li>\n</ul>\n<p>\n  Observe that if a state is not losing, it must be winning, since it has at\n  least one move that does not cause a mutation and does not give the opponent\n  a winning state.\n</p><p>\n  To find the number of winning opening moves (if any) for Becca, we can check\n  each move to see whether it is a winning move. Of course, to do this, we\n  have to investigate the resulting state recursively per the above definition.\n  However, since there are up to two moves per empty cell per state, the\n  naive implementation that recursively counts the number of winning moves for\n  each state may not be fast enough to handle even\n  the 4 &times; 4 grids in test set 1, so we should optimize it.\n</p><p>\n  Notice that whether a state is winning or losing does not depend on who the\n  player is or on any previous moves. Since the same state may come up multiple\n  times, we should consider memoizing our findings about each state to use in\n  the future. It may be daunting that the number of possible states is intractably\n  large. However,\n  for any given case, there can be at most 16 initially empty cells, each of\n  which can be either filled in by bacteria or not. (After a colony has been\n  placed and has spread, it no longer matters what type it was.) So, we can put\n  an upper bound of 2<sup>16</sup> on the number of states per case. In\n  practice, there will be even fewer because not all states are reachable.\n</p><p>\n  Moreover, we can save some time by not computing the exact number of winning\n  moves for every state we examine. We only care about this value for an\n  initial state; for every other state, it suffices to determine whether it is\n  winning or losing. If we are investigating a non-initial state's moves and we\n  find a winning move, we can declare the state to be winning, and stop. This\n  optimization alone may be enough to solve test set 1.\n</p>\n<h3>Test set 2</h3>\n<p>\n  When a player makes a legal move, the bacteria spread across the entire width\n  or length of the row or column, up until the line of bacteria reaches reaches\n  the edge of the grid or a cell that is already infected. Therefore, each move\n  creates up to two subproblems that are independent in the sense that a move\n  in one subproblem does not affect the state of the other.\n</p>\n<p>\n  Each subproblem can be expressed as a rectangle contained within the full\n  grid. There are therefore at most O(<b>R</b><sup>2</sup><b>C</b><sup>2</sup>)\n  subproblems. How can we use the results of these subproblems to determine the\n  overall winner of the game?\n</p>\n<p>\n  The goal of the game is to force the opponent into a situation in which\n  there is no move they can make that leads them down a path to victory. The\n  game is <em>impartial</em>: both players have access to the same set of\n  moves. It is therefore apt to draw a comparison between Bacterial Tactics\n  and the ancient game <a href=\"https://en.wikipedia.org/wiki/Nim\">Nim</a>, an\n  impartial game with similar types of decisions. The mathematics of Nim are\n  well-studied. A discovery particularly useful to us is the\n  <a href=\"https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem\">Sprague–Grundy Theorem</a>,\n  which says that any impartial game can be mapped to a state of Nim.\n  Every state in Nim corresponds to a non-negative <em>Grundy number</em>, or\n  <a href=\"https://en.wikipedia.org/wiki/Nimber\"><em>nimber</em></a>, where any\n  nonzero nimber indicates a winnable game.\n</p>\n<p>\n  According to nimber addition, the nimber of a game state after we place a\n  colony is equal to the <em>XOR</em> of the two subproblems. The nimber of a\n  game state before we place a colony is the\n  <a href=\"https://en.wikipedia.org/wiki/Mex_(mathematics)\"><em>minimum excludant</em></a>,\n  or <em>MEX</em>, of the set of possible nimbers after placing colonies. We\n  can therefore solve Bacterial Tactics recursively using the following\n  pseudocode:\n</p>\n<pre>\nlet solve(state) be a function:\n  let s = Ø\n  for each legal colony placement:\n    add [solve(first subproblem) XOR solve(second subproblem)] to s\n  return MEX(s)\n</pre>\n<p>\n  Given this general framework, we can now optimize our implementation.\n</p>\n<p>\n  First, as in test set 1, we can memoize the game states, which are now\n  defined using rectangles of various sizes within the original grid. Note that\n  it is not possible to have bacteria from previous moves in a subproblem,\n  because we always cut the rectangle along the row or column of cells infected\n  by a colony placement. We may also want to pre-compute the nimbers of all\n  sizes of an empty rectangle (no radioactive cells), which is information that\n  can be shared across all test cases.\n</p>\n<p>\n  Second, observe that if it is legal to place a V colony in a cell, then it is\n  also legal to place a V colony in any cell in that column, and similarly for\n  H colonies in a row, within the boundary of the current subproblem's\n  rectangle. We therefore need to check only the rows and columns for legal\n  colony placements, not each individual cell.\n</p>\n<p>\n  Third, we can construct a data structure that allows us to determine\n  whether a colony placement is legal for any row or column in a given\n  rectangle in O(1) time, allowing us to evaluate any game state in\n  O(<b>R</b>+<b>C</b>) operations. For each row and column in the full grid,\n  create an array. Check the cells in the row or column in ascending order,\n  appending the 1-indexed position of the most recently seen radioactive cell,\n  or 0 if a radioactive cell has not been encountered yet. For example, for the\n  row <code>.#..#</code>, the array would be [0, 2, 2, 2, 5]. Suppose we have a\n  rectangle that includes the third and fourth cells of that row. The fourth\n  entry of the array is a 2. Since cell 2 is not in our rectangle (we have\n  cells 3 and 4 only), we can conclude that it is safe to place an H colony in\n  this row of our rectangle. This data structure can be pre-computed for each\n  test case in O(<b>R</b><b>C</b>) time.\n</p>\n<p>\n  To summarize, there are O(<b>R</b><sup>2</sup><b>C</b><sup>2</sup>)\n  subproblems, and each subproblem takes O(<b>R</b>+<b>C</b>) operations.\n  If we let N be <em>max</em>(<b>R</b>, <b>C</b>), this leads to\n  O(N<sup>5</sup>) total time complexity, sufficient for test set 2. Less\n  efficient solutions might still pass, depending on their implementations.\n</p>\n","id":"0000000000134cdf","statement":"<h3>Problem</h3>\n<p>\n  Becca and Terry are microbiologists who have a friendly rivalry. When they\n  need a break from their research, they like to play a game together. The game\n  is played on a matrix of unit cells with <b>R</b> rows and <b>C</b> columns.\n  Initially, each cell is either empty, or contains radioactive material.\n</p><p>\n  On each player's turn, if there are no empty cells in the matrix, that player\n  loses the game. Otherwise, they choose an empty cell and place a colony of\n  bacteria there. Bacteria colonies come in two types: H (for \"horizontal\") and\n  V (for \"vertical\").\n</p>\n<ul>\n  <li>When a type H colony is placed into an empty cell, it occupies that cell\n    (making it non-empty), and also tries to spread into the cell immediately\n    to the west (if there is one) and the cell immediately to the east (if\n    there is one).</li>\n  <li>When a type V colony is placed into an empty cell, it occupies that cell\n    (making it non-empty), and also tries to spread into the cell immediately\n    to the south (if there is one) and the cell immediately to the north (if\n    there is one).</li>\n</ul>\n<p>\n  Whenever a colony (of either type) tries to spread into a cell:\n</p>\n<ul>\n  <li>If the cell contains radioactive material, the colony mutates and\n    the player who placed the colony loses the game.</li>\n  <li>If that cell is empty, the colony occupies that cell\n    (making it non-empty), and then the rule above is triggered again (i.e. the\n    colony will try to spread further).</li>\n  <li>If the cell already contains bacteria (of any type), the colony does\n    not spread into that cell.</li>\n</ul>\n<p>\n  Notice that it may be possible that all of a player's available moves would\n  cause them to lose the game, and so they are doomed. See the sample case\n  explanations below for examples of how the game works.\n</p><p>\n  Becca makes the first move, and then the two players alternate moves\n  until one of them loses the game. If both players play optimally, who will\n  win? And, if Becca will win, how many distinct winning opening moves does she\n  have? (Two opening moves are distinct if and only if they either use\n  different cells, or different kinds of colony, or both.)\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with one line containing two\n  integers <b>R</b> and <b>C</b>: the number of rows and columns, respectively,\n  in the matrix. Then, there are <b>R</b> more rows of <b>C</b> characters\n  each. The j-th character on the i-th of these lines represents the j-th\n  column of the i-th row of the matrix. Each character is either\n  <code>.</code> (an empty cell) or <code>#</code> (a cell with radioactive\n  material).\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1), and <code>y</code>\n  is an integer: either <code>0</code> if Becca will not win, or, if Becca will\n  win, the number of distinct winning opening moves she can make, as described\n  above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>R</b> &le; 4.<br/>\n  1 &le; <b>C</b> &le; 4.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>R</b> &le; 15.<br/>\n  1 &le; <b>C</b> &le; 15.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2 2\n..\n.#\n4 4\n.#..\n..#.\n#...\n...#\n3 4\n#.##\n....\n#.##\n1 1\n.\n1 2\n##\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 0\nCase #3: 7\nCase #4: 2\nCase #5: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, Becca cannot place an H colony in the southwest empty cell\n  or a V colony in the northeast empty cell, because those would spread onto\n  a radioactive cell and Becca would lose. She has only two possible strategies\n  that do not cause her to lose immediately:\n</p>\n<ol>\n  <li>Place an H colony in the northwest or northeast empty cells. The colony\n    will also spread to the other of those two cells.</li>\n  <li>Place a V colony in the northwest or southwest empty cell. The colony\n    will also spread to the other of those two cells.</li>\n</ol>\n<p>\n  If Becca chooses strategy 1, Terry can place a V colony in the southwest\n  empty cell. If Becca chooses strategy 2, Terry can place an H colony in the\n  northeast empty cell. Either way, Becca has no empty cells to choose from on\n  her next turn, so she loses and Terry wins.\n</p><p>\n  In Sample Case #2, any of Becca's opening moves would cause a mutation.\n</p><p>\n  In Sample Case #3, five of Becca's possible opening moves would cause a\n  mutation, but the other seven are winning. She can place an H colony in any\n  of the cells of the second row, or she can place a V colony in any of the\n  cells of the second column. In either case, she leaves two disconnected sets\n  of 1 or 2 cells each. In each of those sets, only one type of colony can be\n  played, and playing it consumes all of the empty cells in that set. So,\n  whichever of those sets Terry chooses to consume, Becca can consume the other,\n  leaving Terry with no moves.\n</p><p>\n  In Sample Case #4, both of Becca's two distinct possible opening moves are\n  winning.\n</p><p>\n  In Sample Case #5, Becca has no possible opening moves.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Bacterial Tactics","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  We can look at up to 475 figures in Test set 1, but there are 595 figures, so\n  we cannot check them all individually. We can observe that when we\n  investigate any particular set, we only need to look at any four of the\n  figures (say, the first four), since we can infer the identity of the fifth.\n  For example, if the first four figures in a set are D, E, A, and B, then we\n  already know that the last figure in that set is C. This reduces our required\n  number of guesses to 4 &times; 119 = 476. But that is still one more guess\n  than we are allowed!\n</p><p>\n  Observe that once we have determined the orders in all but one of our sets,\n  there are only two sets remaining: the one we have not inspected, and the one\n  we are missing. These two sets must have different figures for at least two\n  indexes, and we can look at any such index to know which set we have. For\n  example, if we know the last two possible sets are CADEB and CDEAB, we can\n  look at the second index; if we see an A, we have the first set, and if we\n  see a D, we have the second set. So, by the time we get to the 119th set on\n  our shelf, we only need to look at one of its figures (but which one to look\n  at will depend on what we learned earlier). After that, we will know which\n  119 sets we have, and therefore we will also know which set we lack.\n</p><p>\n  Combining these insights, we can guarantee that we will use at most 4 &times;\n  118 + 1 = 473 guesses.\n</p>\n<h3>Test set 2</h3>\n<p>\n  In Test set 2, we only have 150 guesses, which is not much more than one\n  guess per set! How can we possibly succeed?\n</p><p>\n  We need to take further advantage of the fact that we are missing only one of\n  the possible sets / permutations. We can start by checking the first figure\n  in each set, using 119 guesses. When we do this, we will find that four out\n  of five of the letters occur 24 times each, and the other one occurs only\n  23 times. That letter must be the one on the first figure in our missing set!\n</p><p>\n  Now we can restrict our search to only our 23 sets that begin with that\n  letter, and look at the second figure in each of those; this uses 23 guesses.\n  One of those letters will appear only 5 times compared to 6 for the others;\n  then we can narrow our search to those 5 out of the 23 sets, and use 5\n  guesses to look at the third figures of those. We will find one unique third\n  letter, and then we only need to check the fourth figure in that set to learn\n  what the other, missing set is. This uses a total of (5! - 1) + (4! - 1) +\n  (3! - 1) + (2! - 1) = 119 + 23 + 5 + 1 = 148 guesses, which fits within the\n  limit of 150.\n</p>\n","id":"0000000000134e91","statement":"<h3>Problem</h3>\n<p>\n  Go, go, Power Arrangers! Everyone loves this team of five superhero high\n  school students who wear the letters A, B, C, D, and E. When they stand side\n  by side to confront evil monsters, they arrange their team in one of 120\n  possible different left-to-right orders, giving them various different\n  tactical superpowers. They are even more popular than the Teenage Permutant\n  Ninja Turtles!\n</p><p>\n  Some critics of the show claim that the team only has its arrangment gimmick\n  so that the owners of the show can sell 120 separate sets of 5 action figures,\n  each of which features the team in a different left-to-right order, glued to\n  a base so that the set cannot be rearranged. As an avid Power Arrangers fan,\n  you have collected 119 of these sets, but you do not remember which set you\n  are missing. Your 119 sets are lined up horizontally along a shelf, such that\n  there are a total of 119 &times; 5 = 595 action figures in left-to-right\n  order. You do not remember how the sets are arranged, but you know that\n  the permutation of the sets is selected uniformly at random from all possible\n  permutations, and independently for each case.\n</p><p>\n  You do not want to waste any time figuring out which set you are missing, so\n  you plan to look at the letters on at most <b>F</b> figures on the shelf. For\n  instance, you might choose to look at the letter on the eighth figure from\n  the left, which would be the third figure from the left in the second set\n  from the left. When looking at a figure, you only get the letter from that\n  one figure; the letters are hard to see, and the different team members look\n  very similar otherwise!\n</p><p>\n  After checking at most <b>F</b> figures, you must figure out which of the\n  sets is missing, so you can complete your collection and be ready to face any\n  possible evil threat!\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the\n  information in the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\">Interactive Problems section</a>\n  of our FAQ.\n</p><p>\n  Initially, your program should read a single line containing two integers\n  <b>T</b>, the number of test cases, and <b>F</b>, the number of figures you\n  are allowed to inspect per test case. Then, you need to process <b>T</b> test\n  cases.\n</p><p>\n  Within each test case, the missing set of figures is chosen uniformly at\n  random from all possible sets, and the order of the remaining sets is chosen\n  uniformly at random from all possible orders as well. Every choice is made\n  independently of all other choices and of your inputs.\n</p><p>\n  In each test case, your program will process up to <b>F</b> + 1 exchanges\n  with our judge. You may make up to <b>F</b> exchanges of the following form:\n</p>\n<ul>\n  <li>Your program outputs one line containing a single integer between 1 and\n    595, inclusive, indicating which figure (in left-to-right order along the\n    shelf) you wish to look at. As a further example, 589 would represent the\n    fourth figure from the left in the second set from the right.\n  </li>\n  <li>The judge responds with one line containing a single uppercase letter\n    <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, or\n    <code>E</code>, indicating the letter on that figure. If you sent invalid\n    data (e.g., a number out of range, or a malformed line), the judge will\n    instead respond with one line containing the single uppercase letter\n    <code>N</code>.\n  </li>\n</ul>\n<p>\n  Then, after you have made as many of the <b>F</b> exchanges above as you\n  want, you must make one more exchange of the following form:\n</p>\n<ul>\n  <li>Your program outputs one line containing a single string of five\n    uppercase letters: the permutation corresponding to the missing set\n    (e.g., <code>CADBE</code>).\n  </li>\n  <li>\n    The judge responds with one line containing a single uppercase letter:\n    <code>Y</code> if your answer was correct, and <code>N</code> if it was not\n    (or you provided a malformed line). If you receive <code>Y</code>, you\n    should begin the next test case, or stop sending input if there are no\n    more test cases.\n  </li>\n</ul>\n<p>\n  After the judge sends <code>N</code> to your input stream (because of either\n  invalid data or an incorrect answer), it will not send any other output.\n  If your program continues to wait for the judge after receiving\n  <code>N</code>, your program will time out, resulting in a Time Limit\n  Exceeded error. Notice that it is your responsibility to have your program\n  exit in time to receive a Wrong Answer judgment instead of a Time Limit\n  Exceeded error. As usual, if the memory limit is exceeded, or your program\n  gets a runtime error, you will receive the appropriate judgment.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 50.<br/>\n  Time limit: 40 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  The missing set, and the order of the remaining sets, are chosen uniformly\n  and independently at random.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>F</b> = 475.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>F</b> = 150.<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1ACeKh-NxkBGoHGAgqEbp0hLBBqogZb85bzjGhWgmaH3KaEVOfXegnXNr5DgPQMWJLVajGt-nI8OoYgg2p/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n<p>\n  This interaction corresponds to Test set 1.\n</p>\n<pre>\n  t, f = readline_int_list()   // Reads 50 into t and 475 into f\n  printline 10 to stdout       // Looks at the last figure in the second set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Ooh, team member B! They may\n                               // not have the leadership ability of A, or the\n                               // technical skill of C, but they entertain the\n                               // team with clever quips!\n  printline 11 to stdout       // Looks at the first figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads B into n. Notice that B is at the start\n                               // of the third set, whereas they were at the\n                               // end of the second set.\n  printline 14 to stdout       // Looks at the fourth figure in the third set\n                               // from the left\n  flush stdout\n  n = readline_string()        // Reads D into n. Silent and brooding, team\n                               // member D nonetheless fights fiercely to\n                               // protect their friends... and the world!\n  printline ABCDE to stdout    // We foolishly make a wild guess even though we\n                               // could have looked at up to 472 more figures.\n  flush stdout\n  verdict = readline_string()  // Reads N into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Power Arrangers","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"}],"ticket":{"challenge_id":"00000000000516b9","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2019"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
