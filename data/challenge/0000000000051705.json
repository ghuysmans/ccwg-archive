{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1554602400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000051705","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  The Code Jam 2019 Qualification Round presented a new interface, some new\n  features (in particular, test runs), and, as usual, four new problems!\n  <i>Foregone Solution</i> and <i>You Can Go Your Own Way</i> each had two\n  Visible test sets and one Hidden test set; solving all of the Visible sets of\n  both was enough to earn the 30 points needed to qualify for Round 1, but both\n  problems were fully solvable via very short and simple algorithms, if you\n  could find them! We wonder how many of you now have lyrics like \"you can\n  call it another lonely day\" stuck in your head.\n</p><p>\n  As is often the case in the Qual Round, the two later problems were much more\n  difficult and unusual. (In fact, such problems often end up in the Qual\n  Round precisely because there is more time to think about them, and they are\n  mostly optional for advancement.) <i>Cryptopangrams</i> asked you to\n  understand a strange new cryptosystem, and it presented a seemingly\n  impossible factoring challenge that could be sidestepped in the right way.\n  <i>Dat Bae</i> was this season's first interactive problem; like many of our\n  interactive problems, it required you to design a clever strategy for getting\n  as much information as possible out of a few queries. These problems got\n  far fewer solutions than the first two, but we applaud those of you who\n  attempted them!\n</p><p>\n  This was our biggest Qual Round ever, by a wide margin. We had almost 74000\n  registrants &mdash; we've finally achieved our dream of overflowing an\n  unsigned 16-bit variable! Over 35500 contestants made at least one attempt,\n  over 31500 had a positive score, and over 1000 had perfect scores. Every\n  language was used in at least one full solution.\n</p><p>\n  Over 27500 contestants earned at least 30 points and thereby advanced to\n  Round 1; the competition in Rounds 1A, 1B, and 1C for those 4500 Round 2\n  slots will be intense! If you did not qualify this year, there's always next\n  year, and we will soon offer more opportunities to practice with past\n  problems on the new platform.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Foregone Solution: Written and prepared by Pablo Heiber.\n</p><p>\n  You Can Go Your Own Way: Written by Ian Tullis. Prepared by Micah Stairs and\n  Ian Tullis.\n</p><p>\n  Cryptopangrams: Written by Ian Tullis. Prepared by Erick Wong.\n</p><p>\n  Dat Bae: Written and prepared by Kevin Tran.\n</p><p>\n  Solutions and other problem preparation and review by Patrick Au, Liang Bai,\n  Jonathan Irvin Gunawan, Md Mahbubul Hasan, Andy Huang, Pi-Hsun Shih,\n  Anubhav Srivastava, Erick Wong, and Adilet Zhaxybay.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Foregone Solution: Ian Tullis</li>\n  <li>You Can Go Your Own Way: Adilet Zhaxybay</li>\n  <li>Cryptopangrams: Ian Tullis</li>\n  <li>Dat Bae: Adilet Zhaxybay</li>\n</ul>\n","registration_gives_participant":true,"result_status":30,"result_status__str":"FINALIZED","start_ms":1554505200000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  In the first test set, we can construct all possible paths from the northwest\n  cell of the maze to the southeast cell using\n  <a href=\"https://en.wikipedia.org/wiki/Backtracking\">backtracking</a>, and see\n  which of them satisfy our requirements (we know from the Output section that at\n  least one answer exists). When we find one that works, we\n  output it as an answer for the test and stop looking any furthter.\n</p>\n<h3>Test set 2</h3>\n<p>\n  Let's assess the number of possible paths from the northwest cell to the\n  southeast cell. For a maze of size <b>N</b> by <b>N</b>, every possible valid\n  path makes <b>N</b> - 1 moves to the east and <b>N</b> - 1 moves to the south.\n  Notice that the order in which these moves are made does not matter &ndash;\n  we will always arrive at the southeast cell after making all of them and we\n  are guaranteed not to leave the maze in the process.\n</p>\n<p>\n  So we need to make 2<b>N</b> - 2 moves total, out of which <b>N</b> - 1 are to\n  the east and <b>N</b> - 1 are to the south, and the order does not matter.\n  Using <a href=\"https://en.wikipedia.org/wiki/Combination\">\n  combinations</a>, we can see that there are\n  <code>C(2<b>N</b> - 2, <b>N</b> - 1)</code> possible options. For <b>N</b>\n  &le; 10 in the test set 1 there are at most 48620 available paths\n  that we need to check. For test set 2, however, in which <b>N</b> = 100, there are\n  <code>22750883079422934966181954039568885395604168260154104734000</code>\n  (or approximately 2.28 &times; 10<sup>58</sup>)\n  possible paths to take. This is too much to process in the time limit, so\n  let's think of an alternative solution.\n</p>\n<p>\n  We can think of a maze as a <a\n    href=\"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)\">graph</a>,\n  where the unit cells are nodes and there is an edge between every pair of\n  nodes that represent neighboring cells. Now instead of moving between two\n  neighboring cells, we will move between the corresponding nodes along the\n  edge connecting them. Because we cannot reuse Lydia's moves, the edges that\n  she used before are no longer available to us, and we remove them from the\n  graph. After that, our problem of finding a valid path reduces to the problem\n  of finding <i>any</i> path from the node representing the northwest cell to\n  the node representing the southeast cell. This is a standard graph problem\n  that can be solved using either\n  <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">Depth-first\n    search</a> or\n  <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-first\n    search</a> in <code>O(<b>N</b><sup>2</sup>)</code> time, which is fast\n  enough to pass this test set.\n</p>\n<h3>Test set 3</h3>\n<p>\n  With <b>N</b> &le; 50000 now, we must think of a different approach to the\n  problem.\n</p>\n<p>\n  To solve this test set, let's just invert all of the moves in Lydia's path.\n  That is, every time she moves east, let's move south, and every time she moves\n  south, let's move east. For example, if Lydia's path is <code>EESSSESE</code>,\n  then our path will be <code>SSEEESES</code>.\n</p>\n<p>\n  Let's understand why this inverted path is a correct answer to the problem.\n</p>\n<p>\n  First, notice that we still make <b>N</b> - 1 moves to the east and\n  <b>N</b> - 1 moves to the south, so we will arrive at the southeast cell in\n  the end as required, and we will not step out of the bounds of the maze.\n</p>\n<p>\n  Now let's see why we will not reuse any of Lydia's moves. Suppose this is not\n  the case, and we reuse a move from the position that is <code>X</code> moves\n  to the east and <code>Y</code> moves to the south in some order from the\n  northwest cell. Recall that the order of moves does not matter, and there may\n  be many ways to get to this position, but all of them will require exactly\n  <code>X</code> moves to the east and <code>Y</code> moves to the south. What\n  will be the next move? We know that Lydia's next move is the <code>(X + Y +\n  1)</code>-th symbol in the string representing her path (with indexing\n  starting from one), and our next move is the <code>(X + Y + 1)</code>-th symbol in\n  the string representing our path. But since our path string is an inverted\n  version of Lydia's path string, we know that <code>(X + Y + 1)</code>-th\n  symbols of the two strings will be different, which contradicts our assumption\n  that we will have the same next move. By the same logic, we can see that the\n  two paths will not reuse any other moves along the way.\n</p>\n","id":"00000000000881da","statement":"<h3>Problem</h3>\n<p>\n  You have just entered the world's easiest maze. You start in the northwest\n  cell of an <b>N</b> by <b>N</b> grid of unit cells, and you must reach the\n  southeast cell. You have only two types of moves available: a unit move to\n  the east, and a unit move to the south. You can move into any cell, but you\n  may not make a move that would cause you to leave the grid.\n</p><p>\n  You are excited to be the first in the world to solve the maze, but then\n  you see footprints. Your rival, Labyrinth Lydia, has already solved the maze\n  before you, using the same rules described above!\n</p><p>\n  As an original thinker, you do not want to reuse any of Lydia's moves.\n  Specifically, if her path includes a unit move from some cell A to some\n  adjacent cell B, your path cannot also include a move from A to B.\n  (However, in that case, it is OK for your path to visit A or visit B, as long\n  as you do not go from A to B.) Please find such a path.\n</p><p>\n  In the following picture, Lydia's path is indicated in blue, and one\n  possible valid path for you is indicated in orange:\n</p>\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"400px\" height=\"400px\" viewBox=\"0 0 502 502\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"All\" transform=\"translate(1.000000, 1.000000)\">\n            <g id=\"All-without-circles\">\n                <g id=\"Back\" stroke-width=\"2\" stroke=\"#000000\">\n                    <g id=\"Group\">\n                        <rect id=\"Rectangle-2\" x=\"0\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"100\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"200\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"300\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"400\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                    </g>\n                    <g id=\"Group\" transform=\"translate(0.000000, 100.000000)\">\n                        <rect id=\"Rectangle-2\" x=\"0\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"100\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"200\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"300\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"400\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                    </g>\n                    <g id=\"Group\" transform=\"translate(0.000000, 200.000000)\">\n                        <rect id=\"Rectangle-2\" x=\"0\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"100\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"200\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"300\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"400\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                    </g>\n                    <g id=\"Group\" transform=\"translate(0.000000, 300.000000)\">\n                        <rect id=\"Rectangle-2\" x=\"0\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"100\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"200\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"300\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"400\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                    </g>\n                    <g id=\"Group\" transform=\"translate(0.000000, 400.000000)\">\n                        <rect id=\"Rectangle-2\" x=\"0\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"100\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"200\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"300\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                        <rect id=\"Rectangle-2\" x=\"400\" y=\"0\" width=\"100\" height=\"100\"></rect>\n                    </g>\n                </g>\n                <g id=\"Group-5\" transform=\"translate(60.000000, 40.000000)\">\n                    <path d=\"M0,10 L80,10\" id=\"Line\" stroke=\"#4990E2\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <polygon id=\"Triangle-2\" fill=\"#4990E2\" transform=\"translate(78.000000, 10.000000) rotate(-270.000000) translate(-78.000000, -10.000000) \" points=\"78 0 88 20 68 20\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#4990E2\" transform=\"translate(190.000000, 98.000000) rotate(-180.000000) translate(-190.000000, -98.000000) \" points=\"190 88 200 108 180 108\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#4990E2\" transform=\"translate(190.000000, 198.000000) rotate(-180.000000) translate(-190.000000, -198.000000) \" points=\"190 188 200 208 180 208\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#4990E2\" transform=\"translate(190.000000, 298.000000) rotate(-180.000000) translate(-190.000000, -298.000000) \" points=\"190 288 200 308 180 308\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#4990E2\" transform=\"translate(290.000000, 398.000000) rotate(-180.000000) translate(-290.000000, -398.000000) \" points=\"290 388 300 408 280 408\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#4990E2\" transform=\"translate(178.000000, 10.000000) rotate(-270.000000) translate(-178.000000, -10.000000) \" points=\"178 0 188 20 168 20\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#4990E2\" transform=\"translate(278.000000, 310.000000) rotate(-270.000000) translate(-278.000000, -310.000000) \" points=\"278 300 288 320 268 320\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#4990E2\" transform=\"translate(378.000000, 410.000000) rotate(-270.000000) translate(-378.000000, -410.000000) \" points=\"378 400 388 420 368 420\"></polygon>\n                    <path d=\"M100,10 L180,10\" id=\"Line\" stroke=\"#4990E2\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M200,310 L280,310\" id=\"Line\" stroke=\"#4990E2\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M300,410 L380,410\" id=\"Line\" stroke=\"#4990E2\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M190,20 L190,100\" id=\"Line\" stroke=\"#4990E2\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M190,120 L190,200\" id=\"Line\" stroke=\"#4990E2\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M190,220 L190,300\" id=\"Line\" stroke=\"#4990E2\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M290,320 L290,400\" id=\"Line\" stroke=\"#4990E2\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                </g>\n                <g id=\"Group-5\" transform=\"translate(40.000000, 60.000000)\" stroke=\"#F6A623\">\n                    <path d=\"M20,90 L100,90\" id=\"Line\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <polygon id=\"Triangle-2\" fill=\"#F6A623\" transform=\"translate(98.000000, 90.000000) rotate(-270.000000) translate(-98.000000, -90.000000) \" points=\"98 80 108 100 88 100\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#F6A623\" transform=\"translate(10.000000, 77.000000) rotate(-180.000000) translate(-10.000000, -77.000000) \" points=\"10 67 20 87 0 87\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#F6A623\" transform=\"translate(310.000000, 177.000000) rotate(-180.000000) translate(-310.000000, -177.000000) \" points=\"310 167 320 187 300 187\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#F6A623\" transform=\"translate(310.000000, 277.000000) rotate(-180.000000) translate(-310.000000, -277.000000) \" points=\"310 267 320 287 300 287\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#F6A623\" transform=\"translate(410.000000, 377.000000) rotate(-180.000000) translate(-410.000000, -377.000000) \" points=\"410 367 420 387 400 387\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#F6A623\" transform=\"translate(198.000000, 90.000000) rotate(-270.000000) translate(-198.000000, -90.000000) \" points=\"198 80 208 100 188 100\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#F6A623\" transform=\"translate(398.000000, 290.000000) rotate(-270.000000) translate(-398.000000, -290.000000) \" points=\"398 280 408 300 388 300\"></polygon>\n                    <polygon id=\"Triangle-2\" fill=\"#F6A623\" transform=\"translate(298.000000, 90.000000) rotate(-270.000000) translate(-298.000000, -90.000000) \" points=\"298 80 308 100 288 100\"></polygon>\n                    <path d=\"M120,90 L200,90\" id=\"Line\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M220,90 L300,90\" id=\"Line\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M320,290 L400,290\" id=\"Line\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M10,0 L10,80\" id=\"Line\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M310,100 L310,180\" id=\"Line\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M310,200 L310,280\" id=\"Line\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                    <path d=\"M410,300 L410,380\" id=\"Line\" stroke-width=\"5\" stroke-linecap=\"square\"></path>\n                </g>\n            </g>\n        </g>\n    </g>\n</svg>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each case consists of two lines. The first line\n  contains one integer <b>N</b>, giving the dimensions of the maze, as\n  described above. The second line contains a string <b>P</b> of 2<b>N</b> - 2\n  characters, each of which is either uppercase <code>E</code> (for east) or\n  uppercase <code>S</code> (for south), representing Lydia's valid path\n  through the maze.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is a string of 2<b>N</b> - 2 characters each of which is either uppercase\n  <code>E</code> (for east) or uppercase <code>S</code> (for south),\n  representing your valid path through the maze that does not conflict with\n  Lydia's path, as described above. It is guaranteed that at least one\n  answer exists.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 15 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  <b>P</b> contains exactly <b>N</b> - 1 <code>E</code> characters and exactly\n    <b>N</b> - 1 <code>S</code> characters.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  2 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 2 (Visible)</h4>\n<p>\n  2 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n<h4>Test set 3 (Hidden)</h4>\n<p>\n  For at most 10 cases, 2 &le; <b>N</b> &le; 50000.<br/>\n  For all other cases, 2 &le; <b>N</b> &le; 10000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2\nSE\n5\nEESSSESE\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: ES\nCase #2: SEEESSES\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the maze is so small that there is only one valid\n  solution left for us.\n</p><p>\n  Sample Case #2 corresponds to the picture above. Notice that it is acceptable\n  for the paths to cross.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":10}],"title":"You Can Go Your Own Way","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  In this problem, we need to somehow identify which workers are not returning\n  the bits that we send to them. Let's see how strings of bits change when some\n  of the data is lost.\n</p>\n<p>\n  Imagine that we have ten workers, and we send them the following five random\n  strings of bits (the <i>i</i>-th bit in each string is sent to the <i>i-th</i> worker):\n</p>\n<pre>\n  0101010110\n  0101010101\n  0010100100\n  0110110101\n  0100100100\n</pre>\n<p>\n  Also, imagine that workers 3 and 6 are broken. In this case, we will lose the\n  following bits (highlighed in bold):\n</p>\n<pre>\n  010<b>1</b>01<b>0</b>110\n  010<b>1</b>01<b>0</b>101\n  001<b>0</b>10<b>0</b>100\n  011<b>0</b>11<b>0</b>101\n  010<b>0</b>10<b>0</b>100\n</pre>\n<p>\n  In the result, we will receive the following bit strings:\n</p>\n<pre>\n  01001110\n  01001101\n  00110100\n  01111101\n  01010100\n</pre>\n<p>\n  Notice, how in this representation, we lost <i>columns</i> of bits because of\n  the broken workers. It would be nice to be able to tell which columns we\n  lost &ndash; then we will be able to determine which workers did not return the\n  data!\n</p>\n<p>\n  Let's see if we can make all the columns different &ndash; then it will be\n  easy to tell which ones are missing. In test set 1 we have up to <b>N</b>\n  = 1024 workers, so we will need up to 1024 different columns. We can\n  send up to <b>F</b> = 10 bit strings, which means our columns will consist\n  of up to 10 bits.\n</p>\n<p>\n  Fortunately for us, 2<sup>10</sup> = 1024, so we can make each column represent a unique\n  number in the range from 0 to 1023. For example, we could make the <i>i</i>-th\n  column represent the number <i>i</i>, in which case the first five columns, that\n  represent numbers from 0 to 4, could look like this:\n</p>\n<pre>\n  01010...\n  00110...\n  00001...\n  00000...\n  00000...\n  00000...\n  00000...\n  00000...\n  00000...\n  00000...\n</pre>\n<p>\n  Now we can use a construction like this to see which workers are broken. If\n  the <i>i</i>-th worker is broken, the bit column representing the number\n  <i>i</i> will be missing in the result we receive.\n</p>\n<h3>Test set 2</h3>\n<p>\n  In the second test set, we can only send up to <b>F</b> = 5 bit strings, which\n  means our columns will consist of only up to 5 bits. 2<sup>5</sup> = 32, so we\n  can no longer use a previous approach of making each column unique.\n</p>\n<p>\n  Notice how we also know that <b>B</b> &le; min(15, <b>N</b>-1), even though we\n  have not used this fact in our solution so far. How does this additional constraint change the\n  problem? The first thing to notice is that only a small fraction of columns will be missing\n  when <b>N</b> = 1024, but these columns can still be in any positions.\n</p>\n<p>\n  Let's see what we can do with 32 numbers that we can represent with 5 bits. If\n  we put these numbers in an order, that is\n</p>\n<p>\n  <code>0, 1, ..., 31</code>\n</p>\n<p>\n  we can notice that since <b>B</b>, which is less than 15, is also less than 32,\n  this whole block of\n  32 numbers will never disappear completely. Let's see how we can make further use of this fact.\n  If we have several blocks like this:\n</p>\n<p>\n  <code>0, 1, ..., 31, 0, 1, ..., 31, 0, 1, ..., 31,...</code>\n</p>\n<p>\n  none of the blocks of numbers from 0 to 31 will disappear completely, and for\n  each the remaining numbers, we will always be able to identify which block it is\n  from.\n</p>\n<p>\n  Let's examine this in more detail. Numbers inside each block are in an increasing\n  order. Notice that even after some numbers disappear, when one block ends\n  and the next one starts, numbers go down:\n</p>\n<p>\n  <code>0, 1, ..., 31, 0, 1, ..., <b> 27, 5 </b>, ..., 31,...</code>\n  (numbers between 27 and 5 disappeared, but 27 is still bigger than 5)\n</p>\n<p>\n  Assume this is not the case, and\n  after some number <code>X</code> from one block goes a number\n  <code>Y</code> from the next block such that <code>X</code> &le; <code>Y</code>.\n  But this is impossible since there were at least 31 numbers between any such <code>X</code>\n  and <code>Y</code>, and these numbers could not disappear altogether.\n</p>\n<p>\n  With these observations at hand, we are ready for a final solution. Let the bit\n  columns of the strings we send to the database represent repeating blocks of numbers from 0 to 31:\n</p>\n<p>\n  <code>0, 1, ..., 31, 0, 1, ..., 31, 0, 1, ..., 31, ...</code> (<b>N</b> numbers total)\n</p>\n<p>\n  After we receive the responses from the database, we can iterate through the\n  remaining numbers, noting that the new block starts when the current number is\n  smaller than the previous one, and keeping track of how many blocks we have\n  seen so far. Knowing the position of the numbers inside the block and the\n  number of blocks we have seen, we can uniquely identify all the numbers we see:\n  for example number 16 in the fifth block is <code>(5 - 1) * 32 + 17 = 145-th</code>\n  number in the whole sequence. And if we know which numbers we have\n  seen in the whole sequence, we can find out which numbers are missing, and\n  output them as the numbers of the missing workers.\n</p><p>\n  Finally, we used the fact that <b>B</b> &lt; 2<sup>5</sup> to make the approach above\n  work. But <b>B</b> &lt; 2<sup>4</sup> too! That means we can use the same approach with only\n  four strings. In this case, it is possible that two consecutive numbers from different\n  blocks are equal, since there are 2<sup>4</sup> - 1 = 15 other numbers in between them, which\n  might all get deleted. Therefore, to detect block changes, we must use &ge; instead of &gt;\n  between consecutive numbers.\n</p>\n","id":"00000000000881de","statement":"<h3>Problem</h3>\n<p>\n  A research consortium has built a new database system for their new\n  data center. The database is made up of one master computer and <b>N</b>\n  worker computers, which are given IDs from 0 to <b>N</b>-1. Each worker\n  stores exactly one bit of information... which seems rather wasteful, but\n  this is very important data!\n</p><p>\n  You have been hired to evaluate the following instruction for the database:\n</p><ul>\n    <li><code>TEST_STORE</code> &lt;bits&gt;: The master reads in &lt;bits&gt;,\n      which is a string of <b>N</b> bits, and sends the i-th bit to the i-th\n      worker for storage. The master will then read the bits back from the\n      workers and return them to the user, in the same order in which they were\n      read in.\n    </li>\n  </ul>\n<p>\n  During normal operation, <code>TEST_STORE</code> should return the same\n  string of bits that it read in, but unfortunately, <b>B</b> of the workers\n  are broken!\n</p><p>\n  The broken workers are correctly able to store the bits given to them,\n  but whenever the master tries to read from a broken worker, no bit is\n  returned.\n\n  This causes the <code>TEST_STORE</code> operation to return only\n  <b>N</b>-<b>B</b> bits, which are the bits stored on the non-broken workers\n  (in ascending order of their IDs).\n\n  For example, suppose <b>N</b> = 5 and the 0th and 3rd workers are broken\n  (so <b>B</b> = 2). Then:\n</p><ul>\n    <li><code>TEST_STORE 01101</code> returns <code>111</code>.</li>\n    <li><code>TEST_STORE 00110</code> returns <code>010</code>.</li>\n    <li><code>TEST_STORE 01010</code> returns <code>100</code>.</li>\n    <li><code>TEST_STORE 11010</code> also returns <code>100</code>.</li>\n  </ul>\n<p>\n  For security reasons, the database is hidden in an underground mountain\n  vault, so calls to <code>TEST_STORE</code> take a very long time.\n\n  You have been tasked with working out which workers are broken using at most\n  <b>F</b> calls to <code>TEST_STORE</code>.\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the information in\n  the Interactive Problems section of our\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\">FAQ</a>.\n</p><p>\n  Initially, your program should read a single line containing a single integer\n  <b>T</b> indicating the number of test cases. Then, you need to process\n  <b>T</b> test cases.\n</p><p>\n  For each test case, your program will first read a single line containing three\n  integers <b>N</b>, <b>B</b>, and <b>F</b>, indicating the number of workers,\n  the number of broken workers, and the number of lines you may send (as\n  described below).\n</p><p>\n  Then you may send the judge up to <b>F</b> lines, each containing a string of\n  exactly <b>N</b> characters, each either <code>0</code> or <code>1</code>.\n  Each time you send a line, the judge will check that you have not made more\n  than <b>F</b> calls. If you have, the judge will send you a single line\n  containing a single <code>-1</code>, and then finish all communication and\n  wait for your program to finish. Otherwise, the judge will send a string of\n  length <b>N</b>-<b>B</b>: the string returned by <code>TEST_STORE</code>, as\n  described above.\n</p><p>\n  Once your program knows the index of the <b>B</b> broken workers, it can\n  finish the test case by sending <b>B</b> space-separated integers: the IDs of\n  the broken workers, in sorted order. This does not count as one of your\n  <b>F</b> calls.\n</p><p>\n  If the <b>B</b> integers are not exactly the IDs of the <b>B</b> broken\n  workers, you will receive a Wrong Answer verdict, and the judge will send a\n  single line containing <code>-1</code>, and then no additional communication.\n  If your answer was correct, the judge will send a single line with\n  <code>1</code>, followed by the line that begins the next test case (or exit,\n  if that was the last test case).\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>N</b> &le; 1024.<br/>\n  1 &le; <b>B</b> &le; min(15, <b>N</b>-1).<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>F</b> = 10.<br/>\n</ p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>F</b> = 5.<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2JzOFSKs6ioRi-GKwcdvazIyAgP23fDPCv9R4AJhWNXL3FMGCWGZe9XiO3A9hOEe9ISMF9BWRYnG1O0hmr/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n\n<p>\n  The following interaction meets the limits for Test set 1.\n</p>\n\n<pre>\n  t = readline_int()           // Reads 2 into t\n  n, b, f = readline_int_list()  // Reads 5, 2, 10 into n, b, f\n  printline 01101 to stdout    // The next four outputs match the example in\n                               // the problem statement.\n  flush stdout\n  response = readline_str()    // Reads 111 into response. (At this point, we\n                               // could determine the answer; the remaining\n                               // queries are just examples!)\n  printline 00110 to stdout\n  flush stdout\n  response = readline_str()    // Reads 010 into response\n  printline 01010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 11010 to stdout\n  flush stdout\n  response = readline_str()    // Reads 100 into response\n  printline 0 3 to stdout      // Guesses the answer. Notice that we were\n                               // not required to use all 10 of our allowed\n                               // queries.\n  flush stdout\n  verdict = readline_int()     // Reads 1 into verdict. We got that test case\n                               // right!\n  n, b, f = readline_int_list()  // Reads 2, 1, 10 into n, b, f.\n  printline 01 to stdout       // 01 is a query, not a guess at the final\n                               // answer (if we wanted to guess that just\n                               // worker 1 were broken, we would have to\n                               // send 1 as we do below)\n  flush stdout\n  response = readline_str()    // Reads 1 into response.\n  printline 1 to stdout        // Makes a (bad) wild guess.\n  verdict = readline_str()     // Reads -1 into verdict.\n  exit                         // exits to avoid an ambiguous TLE error\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Dat Bae","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<p>\n  There are at least three different approaches to this problem, and they\n  will have different degrees of success!\n</p>\n<h3>Brute force</h3>\n<p>\n  In test set 1, <b>N</b> is less than 100000, so if we want to find two\n  numbers A and B such that A + B = <b>N</b>, there are fewer than 100000\n  possible choices for A. (Once we choose a candidate value for A, we know that\n  B = <b>N</b> - A.) We can try all possible choices of A until we find one for\n  which neither A nor B contains a 4. However, we cannot apply this strategy\n  to test set 2, in which we might have to check almost 10<sup>9</sup> values!\n</p>\n<h3>Randomized</h3>\n<p>\n  We can repeatedly choose a candidate value of A uniformly at random from the\n  inclusive range [1, <b>N</b>-1], and check whether both it and\n  B = <b>N</b> - A are free of the dreaded 4s. But will this randomized\n  approach find a solution fast enough?\n</p><p>\n  How many numbers less than 10<sup>9</sup> do not contain a 4? Consider the\n  set of all 9-digit numbers, with leading zeroes allowed; notice that this set\n  therefore includes all 8-digit, etc. numbers. If we choose a number at random\n  from this set, the probability that it lacks a 4 is the probability that its\n  first digit is not a 4, times the probability that its second digit is not a\n  4, and so on. Since the probability is 9/10 for any one digit, and the\n  probabilities for different digits are independent, we have an overall\n  probability of (9/10)<sup>9</sup>, which is about 0.387. In practice,\n  depending on the actual value of <b>N</b>, we might have fewer valid choices,\n  but the size of this answer should give us some hope that we can find our A\n  and B quickly. If we presume that the probability that A has no 4s is not too\n  much smaller than our estimate, and that A not having a 4 does not\n  substantially increase the odds that B has a 4, there should be many working\n  values of A out there to find.\n</p><p>\n  We can argue more rigorously. Let D be the number of digits in <b>N</b>; we\n  will consider the set of all D-digit numbers less than <b>N</b>, with leading\n  zeroes allowed. Suppose that we choose A randomly from that set, and let\n  B = <b>N</b> - A, padding with leading zeroes as needed to bring A and B up\n  to D digits.\n</p><p>\n  Consider the last digit of A. If it is a 4, or if it is (<b>N</b> - 4) mod 10\n  (which means that the last digit of B is a 4), then we have failed. But at\n  least 8 of the 10 possible values for the last digit are OK. Then, assuming\n  we have not yet failed, consider the next-to-last digit of A. There is at\n  most one value for that digit that would imply that the next-to-last digit of\n  B is a 4, so at least 8 of the 10 possible values for the next-to-last digit\n  of A are OK. Notice that even though the value of the last digit of A might\n  determine which <i>particular</i> value for the next-to-last digit of A\n  would imply that the next-to-last digit of B is a 4, we can still be sure\n  that there exist at least 8 OK values.\n</p><p>\n  And so on, for all D-1 digits up to the first. We only need to worry about\n  the first digit of A or B being a 4 if the first digit of <b>N</b> is at\n  least 4, in which case there are certainly at least five possible values for\n  the first digit of A, of which (just as before) at most two can be bad. So\n  the overall probability that a randomly chosen A is OK is no smaller than\n  (8/10)<sup>D-1</sup> &times; (3/5). For D = 9, this is around 0.1, so our\n  randomized approach should only need an expected 10 or so tries to find an\n  answer, and the probability that it will fail to find one after e.g. 1000\n  tries is vanishingly small (around 10<sup>-46</sup>).\n</p><p>\n  If you check all values with D digits for some small D, you will find that\n  the worst case (i.e. the one with the fewest solutions) is a 4 followed by\n  D-1 9s. For <b>N</b> = 49999999, the fraction of possible choices that will\n  work is around 0.1258, so our bound of 0.1 was not particularly conservative!\n</p><p>\n  However, this approach is highly unlikely to work for test set 3, in which\n  <b>N</b> can be on the order of 10<sup>100</sup>. Our lower bound on the\n  probability that a randomly chosen solution is correct becomes\n  (8/10)<sup>99</sup> &times; (3/5), which is about 1.5 &times;\n  10<sup>-10</sup>. Even if we try a more clever randomized approach in which\n  we build a random A (less than <b>N</b>) out of non-4 digits and then check\n  the corresponding B, which would change those 8/10 factors to 9/10, that\n  bound would be on the order of 10<sup>-5</sup>, which seems too low to work\n  well on 100 test cases. Can we find a deterministic solution?\n</p>\n<h3>Constructive</h3>\n<p>\n  Observe that we can write <b>N</b> in terms of a sum of powers of 10 times\n  its digits. For example, 4837 = 4 &times; 1000 + 8 &times; 100 +\n  3 &times; 10 + 7 &times; 1.\n</p><p>\n  Notice that every digit can be written as a sum of two non-4 digits. In\n  particular, we can write 4 = 2 + 2, and for any other digit X, we can write\n  X = 0 + X.\n</p><p>\n  We can apply these observations to solve our problem digit by digit! In the\n  above example, we can decompose 4 &times; 1000 into 2 &times 1000; and\n  2 &times; 1000; 8 &times; 100 into 0 &times; 100 and 8 &times; 100, and so\n  on. In this way, we are building up the digits of our desired A and B; A\n  is 2 &times; 1000 + 0 &times; 100... = 2000, and B is 2 &times; 1000 +\n  8 &times; 100... = 2837.\n</p><p>\n  In summary, we can set A to be the same as <b>N</b> with every 4 replaced\n  with a 2, and every non-4 replaced with a 0. B is simply <b>N</b> with every\n  4 replaced with a 2. Even though we would normally need a \"big integer\"\n  implementation to handle numbers as large as a googol, in this case we can\n  implement the solution using only strings!\n</p>\n","id":"0000000000088231","statement":"<h3>Problem</h3>\n<p>\n  Someone just won the Code Jam lottery, and we owe them <b>N</b> jamcoins!\n  However, when we tried to print out an oversized check, we encountered a\n  problem. The value of <b>N</b>, which is an integer, includes at least one\n  digit that is a <code>4</code>... and the <code>4</code> key on the keyboard\n  of our oversized check printer is broken.\n</p><p>\n  Fortunately, we have a workaround: we will send our winner two checks for\n  positive integer amounts A and B, such that neither A nor B contains any\n  digit that is a <code>4</code>, and A + B = <b>N</b>. Please help us find any\n  pair of values A and B that satisfy these conditions.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each consists of one line with an integer\n  <b>N</b>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: A B</code>,\n  where <code>x</code> is the test case number (starting from 1), and\n  <code>A</code> and <code>B</code> are positive integers as described above.\n</p><p>\n  It is guaranteed that at least one solution exists. If there are multiple\n  solutions, you may output any one of them. (See\n  \"What if a test case has multiple correct solutions?\" in the Competing\n  section of the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\">FAQ</a>. This\n  information about multiple solutions will not be explicitly stated in the\n  remainder of the 2019 contest.)\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 10 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  At least one of the digits of <b>N</b> is a 4.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &lt; <b>N</b> &lt; 10<sup>5</sup>.<br/>\n</p>\n\n<h4>Test set 2 (Visible)</h4>\n<p>\n  1 &lt; <b>N</b> &lt; 10<sup>9</sup>.<br/>\n</p>\n\n<p>\nSolving the first two test sets for this problem should get you a long way toward advancing.\nThe third test set is worth only 1 extra point, for extra fun and bragging rights!\n</p>\n\n<h4>Test set 3 (Hidden)</h4>\n<p>\n  1 &lt; <b>N</b> &lt; 10<sup>100</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n940\n4444\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2 2\nCase #2: 852 88\nCase #3: 667 3777\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, notice that A and B can be the same. The only other\n  possible answers are <code>1 3</code> and <code>3 1</code>.\n</p>\n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":6},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":1}],"title":"Foregone Solution","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Yeah, but what about <i>de</i>crypting?</h3>\n<p>\n  The statement tells us how the plaintext is encrypted, but it says nothing\n  about the decryption mechanism! Figuring that out is part of the problem.\n  Since this is a Qualification Round problem, there is slightly less time\n  pressure and competitive urgency, and you have some extra time to think\n  about how this cryptosystem is supposed to be used.\n</p><p>\n  Suppose that Cameron and Jamie are members of the Code Jam team who know\n  the secret list of 26 primes, and suppose that Cameron has just sent the\n  ciphertext to Jamie. Each value in the ciphertext is the product of two\n  of those primes, so Jamie can try dividing each value by each known prime\n  to find the value's factors. (Notice that a value in the ciphertext might be\n  the square of a prime, if the plaintext has the same letter twice in a row.)\n</p><p>\n  After getting the list of factored ciphertext values, how should Jamie\n  recover the plaintext? We might be tempted to say that the second letter of\n  the plaintext is the one whose prime appears as factors of both the first\n  and second ciphertext values, the third letter is the one whose prime\n  appears as factors of both the second and third ciphertext values, and so\n  on. Then the remaining factors in the first and last ciphertext values give\n  us the first and last letters of the plaintext.\n</p><p>\n  This is almost correct, but we (and Jamie) would have to deal with one\n  significant annoyance. If the plaintext starts with something like\n  <code>ABABA</code>..., for example, then the first, second, third, and\n  fourth ciphertext values will all be the same, being the product of the same\n  two factors (the primes corresponding to <code>A</code> and <code>B</code>).\n  In particular, the start of <code>BABAB</code>... looks just the same as\n  the start of <code>ABABA</code>...! The good news is that we know that this\n  kind of pattern must terminate somewhere in the message; eventually, either\n  we will get the same letter twice in a row, or (since the plaintext uses\n  more than two different letters) three consecutive different letters. As soon\n  as either of these things happens, we have a \"break-in point\", and we\n  know which factors of a particular ciphertext value go with which of the\n  two letters of the plaintext that it encodes. Then, we can \"unzip\" the rest\n  of the plaintext from there, working backwards and forwards.\n</p><p>\n  For instance, if the plaintext starts with <code>ABABAABAB</code>, the first\n  four ciphertext values will all be the same: the product of the prime\n  corresponding to <code>A</code> and the prime corresponding to\n  <code>B</code>. The fifth ciphertext value will represent the square of\n  <code>A</code>, so we will know that the fifth and sixth plaintext letters\n  are both <code>A</code>. We can then reason that the fourth plaintext letter\n  must be the fourth ciphertext value divided by the prime corresponding to\n  <code>A</code>, the third plaintext letter must be the third ciphertext\n  value divided by the prime corresponding to <code>B</code>, and so on going\n  backwards. We can also determine that the seventh plaintext letter is the\n  sixth ciphertext value divided by the prime corresponding to <code>A</code>,\n  and so on going forwards.\n</p><p>\n  Similarly, if the plaintext starts with <code>ABABCBABA</code>, when we\n  inspect the third and fourth ciphertext values, we will see that they are\n  different, but both have the prime corresponding to <code>B</code> as a\n  factor. Then we can unzip from there, as above.\n</p><p>\n  However, we must remember that Jamie has an advantage that we do not have:\n  we do not know the 26 secret primes! We need to find a way to get them.\n</p>\n<h3>Test set 1</h3>\n<p>\n  In test set 1, the ciphertext values are products of small primes. Each\n  prime is less than 10<sup>4</sup>, so each ciphertext value is no larger than\n  10<sup>8</sup>. It is straightforward to factor these values by testing\n  every possible (prime) factor between 2 and 10<sup>4</sup>. Once we have all\n  of the factors, we will have our set of 26 primes, since each prime will be\n  represented in at least one factor of one ciphertext value. We can assign\n  them in increasing order to the letters <code>A</code> through <code>Z</code>.\n</p><p>\n  Then, to recover the plaintext, we can use a bit of brute force to sidestep\n  the need to unzip as described before. Consider the two factors that\n  contribute to the first ciphertext value; arbitrarily choose one of them. Let\n  us first assume that that factor corresponds to the first letter of the\n  plaintext, and the other corresponds to the second. Then we can take the\n  remaining factor and try to divide the second ciphertext value by that\n  factor. If we cannot, we have a contradiction, and we should go back and make\n  the other factor correspond to the first letter of the plaintext. Otherwise,\n  the quotient is the factor corresponding to the third letter of the\n  plaintext, and so on. For one of our choices, this method will work and will\n  give us the correct plaintext; for the other choice, we will reach a\n  contradiction, since (as described above) it is guaranteed that there is\n  only one possible decryption.\n</p>\n<h3>Test set 2</h3>\n<p>\n  In test set 2, the primes can be enormous (as large as a googol), and the\n  product of two such primes can be even more enormous. We should realize that\n  it is hopeless to try to factor such a product. If we could do that, we\n  could also break modern cryptosystems that depend on the assumption that\n  factoring large numbers is intractable! The Code Jam servers do not run on\n  quantum computers (yet...), so there is no way for us to try to use a\n  quantum algorithm, either.\n</p><p>\n  To solve this seemingly impossible test set, we need to find a different\n  vulnerability of this cryptosystem. The key insight is that any two\n  consecutive values in the ciphertext have at least one factor in common.\n  Factoring very large numbers may be intractable, but we <i>do</i> know how to\n  efficiently find the greatest common divisor of two very large numbers! A\n  method like <a href=\"https://en.wikipedia.org/wiki/Euclidean_algorithm\">Euclid's algorithm</a>\n  will be <a href=\"https://en.wikipedia.org/wiki/Euclidean_algorithm#Algorithmic_efficiency\">fast enough</a>.\n</p><p>\n  Notice that if we have a plaintext like <code>ABABC</code>..., it is\n  possible that the prime corresponding to <code>A</code> will not appear in\n  any of the pairwise GCD values. So, we should compute GCDs of consecutive\n  ciphertext values until we get a value that is not 1; at least one such\n  value must exist, as described in the introduction to the problem. At that\n  point, we can unzip the rest of the ciphertext, as described previously,\n  finding all of the primes as we go. Then we can proceed as above. And we do\n  not even have to know a bevy of DP flux algorithms, whatever those are!\n</p>\n<h3>A note on language choice</h3>\n<p>\n  An essential skill in Code Jam is picking the right tool (language) for the\n  right job. For some problems, a fast language such as C++ may be needed to\n  obtain a solution within the time limits. For this problem, it is probably\n  better to choose a language like Python that can handle very large numbers\n  without any extra hassle, even at the cost of some speed, or a language like\n  Java that has a built-in \"big integer\" implementation.\n</p>\n","id":"000000000008830b","statement":"<h3>Problem</h3>\n<p>\n  On the Code Jam team, we enjoy sending each other <i>pangrams</i>, which are\n  phrases that use each letter of the English alphabet at least once. One\n  common example of a pangram is \"the quick brown fox jumps over the lazy dog\".\n  Sometimes our pangrams contain confidential information &mdash; for example,\n  <code>CJ QUIZ: KNOW BEVY OF DP FLUX ALGORITHMS</code> &mdash; so we need to\n  keep them secure.\n</p><p>\n  We looked through a cryptography textbook for a few minutes, and we learned\n  that it is very hard to factor products of two large prime numbers, so we\n  devised an encryption scheme based on that fact. First, we made some\n  preparations:\n</p>\n<ul>\n  <li>We chose 26 different prime numbers, none of which is larger than some\n    integer <b>N</b>.</li>\n  <li>We sorted those primes in increasing order. Then, we assigned the\n    smallest prime to the letter <code>A</code>, the second smallest prime to\n    the letter <code>B</code>, and so on.</li>\n  <li>Everyone on the team memorized this list.</li>\n</ul>\n<p>\n  Now, whenever we want to send a pangram as a message, we first remove all\n  spacing to form a plaintext message. Then we write down the product of the\n  prime for the first letter of the plaintext and the prime for the second\n  letter of the plaintext. Then we write down the product of the primes for the\n  second and third plaintext letters, and so on, ending with the product of the\n  primes for the next-to-last and last plaintext letters. This new list of\n  values is our ciphertext. The number of values is one smaller than the number\n  of characters in the plaintext message.\n</p><p>\n  For example, suppose that <b>N</b> = 103 and we chose to use the first 26 odd\n  prime numbers, because we worry that it is too easy to factor even numbers.\n  Then <code>A</code> = 3, <code>B</code> = 5, <code>C</code> = 7,\n  <code>D</code> = 11, and so on, up to <code>Z</code> = 103. Also suppose that\n  we want to encrypt the <code>CJ QUIZ</code>... pangram above, so our\n  plaintext is <code>CJQUIZKNOWBEVYOFDPFLUXALGORITHMS</code>. Then the first\n  value in our ciphertext is 7 (the prime for <code>C</code>) times 31 (the\n  prime for <code>J</code>) = <code>217</code>; the next value is\n  <code>1891</code>, and so on, ending with <code>3053</code>.\n</p><p>\n  We will give you a ciphertext message and the value of <b>N</b> that we used.\n  We will not tell you which primes we used, or how to decrypt the ciphertext.\n  Do you think you can recover the plaintext anyway?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each test case consists of two lines. The\n  first line contains two integers: <b>N</b>, as described above, and <b>L</b>,\n  the length of the list of values in the ciphertext. The second line contains\n  <b>L</b> integers: the list of values in the ciphertext.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is a string of <b>L</b> + 1 uppercase English alphabet letters: the\n  plaintext.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1 GB.<br/>\n  25 &le; <b>L</b> &le; 100.<br/>\n  The plaintext contains each English alphabet letter at least once.\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  101 &le; <b>N</b> &le; 10000.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  101 &le; <b>N</b> &le; 10<sup>100</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n103 31\n217 1891 4819 2291 2987 3811 1739 2491 4717 445 65 1079 8383 5353 901 187 649 1003 697 3239 7663 291 123 779 1007 3551 1943 2117 1679 989 3053\n10000 25\n3292937 175597 18779 50429 375469 1651121 2102 3722 2376497 611683 489059 2328901 3150061 829981 421301 76409 38477 291931 730241 959821 1664197 3057407 4267589 4729181 5335543\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: CJQUIZKNOWBEVYOFDPFLUXALGORITHMS\nCase #2: SUBDERMATOGLYPHICFJKNQVWXZ\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Cryptopangrams","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000051705","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2019"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
