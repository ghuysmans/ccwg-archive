{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1223292180000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000436d8a","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\r\n  The Europe, Middle East and Asia regional semifinal round turned out to be the\r\n  easiest of the three semifinals, with seven contestants solving all four\r\n  problems. The top three spots went to <b>bmerry</b>, <b>dzhulgakov</b> and\r\n  <b>gawry</b>. Coders from Eastern Europe dominated by taking 9 of the top 10\r\n  spots. The competition was fierce, and the bar of advancing to the finals\r\n  ended up at an unprecedented 50 points. For most of the top 43 contestants,\r\n  that meant solving at least problems A, B and D-small. The problem set was a\r\n  mix of different flavours of linear algebra and dynamic programming.\r\n</p>\r\n\r\n<hr>\r\n<p>\r\n  <b>Credits</b>\r\n</p><p>\r\n  Problem A. <i>Scaled Triangle</i>\r\n  Written and prepared by Cosmin Negruseri.\r\n</p><p>\r\n  Problem B. <i>Painting a Fence</i>\r\n  Written by John Dethridge. Prepared by Bartholomew Furrow and Daniel Rocha.\r\n</p><p>\r\n  Problem C. <i>Rainbow Trees</i>\r\n  Written by Petr Mitrichev. Prepared by Frank Chu and Xiaomin Chen.\r\n</p><p>\r\n  Problem D. <i>Bus Stops</i>\r\n  Written and prepared by Marius Andrei.\r\n</p><p>\r\n  Contest analysis presented by Cosmin Negruseri, Igor Naverniouk, Xiaomin Chen,\r\n  and Marius Andrei.\r\n</p>\r\n","registration_gives_participant":false,"result_status":20,"result_status__str":"FULLY_VISIBLE","start_ms":1223284980000,"tasks":[{"analysis":"<p>\n  Pick any vertex <b>r</b>. We view the tree as rooted at <b>r</b>, and -- as\n  usual -- draw the tree with the root at the top, and draw the nodes of depth\n  <b>d</b> at the same level, <b>d</b> units below the root.\n</p><p>\n  By a <i>partial coloring</i> on a subset of edges we mean the assignment of\n  colors to the edges in the subset so that the \"rainbow coloring\" constraint is\n  satisfied on that subset. We do not care about the coloring of the edges that\n  are not in the subset.<br>\n  For each node <b>x</b>, we define the value\n</p>\n<blockquote>\n  f(x) := number of ways to color the subtree rooted at <b>x</b>, given any\n  partial coloring for the set of edges that are incident to the parent of\n  <b>x</b>.\n</blockquote>\n<p>\n  It is not at all obvious that f(x) is well defined. (Why would the number\n  always be the same for any given partial coloring?). To see that f(x) is\n  indeed well defined, let's look at an algorithm for computing it.\n</p><p>\n  Suppose <b>z</b> is the parent of <b>x</b>, and the degree of <b>z</b> is\n  <b>D</b>. Note that the rainbow constraint is a very local condition -- the\n  color of any edge other than those incident to <b>z</b> does not affect the\n  coloring for the subtree rooted at <b>x</b>.\n</p><p>\n  Assume that <b>x</b> has <b>t</b> children -- <b>y</b><sub>1</sub>, <b>y</b\n  ><sub>2</sub>, ..., <b>y</b><sub>t</sub>. To color all the edges in the\n  subtree rooted at <b>x</b>, we do the following.\n</p>\n<ul>\n  <li>\n    Color the edge <b>x y</b><sub>1</sub>. There are <b>k</b> -\n    <b>D</b> choices, since this edge cannot have the same color as any of the\n    <b>D</b> edges incident to <b>z</b>, and no other edge in the partial\n    coloring puts any constraint on it.\n  </li>\n  <li>\n    Color the edge <b>x y</b><sub>2</sub>. There are <b>k</b> - <b>D</b> - 1\n    choices, since this edge cannot have the same color as any of the\n    <b>D</b> edges as above, nor the same color as <b>x y</b><sub>1</sub>.\n  </li>\n  <li>...</li>\n  <li>\n    Color the edge <b>x y</b><sub>t</sub>. There are <b>k</b> - <b>D</b> - t + 1\n    choices.\n  </li>\n  <li>\n    Now we have a partial coloring where all the edges incident to <b>x</b> are\n    colored. We color the subtree rooted at <b>y</b><sub>1</sub>. There are\n    f(y<sub>1</sub>) ways.\n  </li>\n  <li>...</li>\n  <li>\n    There are f(y<sub>t</sub>) ways to color the subtree rooted at <b>y</b\n    ><sub>t</sub>.\n  </li>\n</ul>\n<p>\n  Indeed, the computation only depends on <b>D</b>, the degree of the parent of\n  <b>x</b>. f(x) is the product of the numbers above.\n</p><p>\n  There is nothing very special about the root <b>r</b>, except that we need to\n  agree <b>D</b> = 0 in that case. And the solution to our problem is just f(r).\n</p>\n","id":"00000000004365f9","statement":"<h3>Problem</h3>\n<p>\n  In graph theory, a <i>tree</i> is a connected, undirected simple graph with no\n  cycles. A tree with <b>n</b> nodes always has <b>n</b> - 1 edges.\n</p><p>\n  A <i>path</i> in a tree is a sequence of distinct edges which are connected\n  (each pair of consecutive edges in the path share a vertex).\n</p><p>\n  Consider a tree with <b>n</b> vertices and <b>n</b>-1 edges. You can color\n  each edge in one of <b>k</b> colors.\n</p><p>\n  An assignment of colors to edges is a <i>rainbow coloring</i> if in every path\n  of 2 or 3 edges, the colors of the edges are different. (i.e., every two\n  consecutive edges have different colors, and every three consecutive edges\n  have different colors).\n</p><p>\n  Given a tree and the number of colors <b>k</b>, find the number of rainbow\n  colorings modulo 1000000009.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of test cases, <b>C</b>. Then for\n  each of the <b>C</b> cases, there will be:\n</p>\n<ul>\n  <li>\n    One line containing two integers in the format \"<b>n k</b>\". <b>n</b> is the\n    number of nodes in the tree, and <b>k</b> is the number of colors available.\n  </li>\n  <li>\n    <b>n</b> - 1 lines, one for each edge, containing two integers \"<b>x y</b>\",\n    indicating that the edge is between node <b>x</b> and node <b>y</b>. Nodes\n    are numbered from 1 to <b>n</b>.\n  </li>\n</ul>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line. That line should contain \"Case #<b>X</b>:\n  <b>Y</b>\", where <b>X</b> is 1-based number of the case, and <b>Y</b> is the\n  answer for that test case.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>k</b> &le; 1000000000<br>\n  All the node numbers are between 1 and <b>n</b>, inclusive.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>C</b> &le; 100 <br>\n  2 &le; <b>n</b> &le; 20\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>C</b> &le; 40 <br>\n  2 &le; <b>n</b> &le; 500\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n4 10\n1 2\n1 3\n1 4\n5 3\n1 2\n2 3\n3 4\n4 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 720\nCase #2: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In the first case, the tree has four nodes. There are edges from one node to\n  each of the other three. Each pair of these edges are adjacent, so for there\n  to be a rainbow coloring, all the edges must have different colors. There\n  are therefore 10 x 9 x 8 = 720 rainbow colorings.\n</p><p>\n  In the second case, the tree itself is a path of 4 edges, and there are 3\n  colors. The first three edges must all have different colors, so there are 3\n  x 2 x 1 colorings for these, and then there is only one choice for the\n  fourth edge, so there are 6 rainbow colorings.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Rainbow Trees","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This was meant to be the easiest problem in the match. A straightforward brute\n  force solution suffices.\n</p><p>\n  Step 1. Pick a set <b>C</b> of (up to) three colors to be used. There are\n  <b>N</b> different colors, so O(N<sup>3</sup>) such choices.\n</p><p>\n  Step 2. From the offers, filter out the ones where the color is not in the set\n  <b>C</b>. We want to figure out whether the remaining offers can cover the\n  whole fence, and if so, what the minimum required number of offers is.\n</p><p>\n  Step 2 is a classical problem with a greedy scanline solution. We sort the\n  offers (intervals) by their left endpoint, and scan from left to right,\n  considering the offers one by one. At any moment, if we have covered the fence\n  from section 1 to <b>k</b>, we always pick the next offer so that it starts\n  before <b>k</b> and ends as far to the right as possible.\n</p><p>\n  If we sort all the offers by their left endpoing in the beginning, then step 2\n  takes time O(N), and the whole algorithm runs in time O(N<sup>4</sup>).\n</p>\n","id":"0000000000436bad","statement":"<h3>Problem</h3>\n<p>\n  You need to hire some people to paint a fence. The fence is composed of 10000\n  contiguous sections, numbered from 1 to 10000.\n</p><p>\n  You get some offers from painters to help paint the fence. Each painter offers\n  to paint a contiguous subset of fence sections in a particular color. You need\n  to accept a set of the offers, such that:\n</p>\n<ul>\n  <li>Each section of the fence is painted.</li>\n  <li>At most 3 colors are used to paint the fence.</li>\n</ul>\n<p>\n  If it is possible to satisfy these two requirements, find the minimum number\n  of offers that you must accept.\n</p>\n\n<h3>Input</h3>\n<ul>\n  <li>\n    One line containing an integer <b>T</b>, the number of test cases in the\n    input file.\n  </li>\n</ul>\n<p>\n  For each test case, there will be:\n</p>\n<ul>\n  <li>One line containing an integer <b>N</b>, the number of offers.</li>\n  <li>\n    <b>N</b> lines, one for each offer, each containing \"<b>C</b> <b>A</b>\n    <b>B</b>\" where <b>C</b> is the color, which is an uppercase string of up to\n    10 letters, <b>A</b> is the first section and <b>B</b> is the last section\n    to be painted. 1 &le; <b>A</b> &le; <b>B</b> &le; 10000.\n  </li>\n</ul>\n\n<h3>Output</h3>\n<ul>\n  <li>\n    <b>T</b> lines, one for each test case in the order they occur in the input\n    file, each containing the string \"Case #<b>X</b>: <b>Y</b>\", where\n    <b>X</b> is the case number, and <b>Y</b> is the number of offers that need\n    to be accepted, or \"Case #<b>X</b>: IMPOSSIBLE\" if there is no acceptable\n    set of offers.\n  </li>\n</ul>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>T</b> &le; 50\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 300\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3FbUUuL8jIz0WHgNm3ay3fFxp57ulLQBF-tyGFoUh5OblUEi18zBUc1SFYCmiDzq1gIXjtYQ__d7A2SQe-Ax3yGa6qmLD8gNcAOD8wD3Gk/painting_a_fence_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">5\n2\nBLUE 1 5000\nRED 5001 10000\n3\nBLUE 1 6000\nRED 2000 8000\nWHITE 7000 10000\n4\nBLUE 1 3000\nRED 2000 5000\nORANGE 4000 8000\nGREEN 7000 10000\n2\nBLUE 1 4000\nRED 4002 10000\n3\nBLUE 1 6000\nRED 4000 10000\nORANGE 3000 8000\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0toQ7cKbdLDvGuo-Rm_X62DBmSJVL5SBYkDBZlcmdIHM4RRQgpqA7ljvu5q5LIxoxQc_-O8oyY3I0q1L2slyL4xuc8aTPzmqO56VubqrePQw/painting_a_fence_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 2\nCase #2: 3\nCase #3: IMPOSSIBLE\nCase #4: IMPOSSIBLE\nCase #5: 2\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<p>\n  In the first test case, accepting both offers will exactly paint the whole\n  fence, 5000 sections each, with no overlap.\n</p><p>\n  In the second case, the painters will overlap, which is acceptable.\n</p><p>\n  In the third case, accepting all four offers would cover the whole fence,\n  but it would use 4 different colours, so this is not acceptable.\n</p><p>\n  In the fourth case, section 4001 cannot be painted.\n</p><p>\n  In the fifth case, we can accept just the first and second offer and\n  successfully paint the fence.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Painting a Fence","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  The problem can be solved by using dynamic programming and matrix\n  multiplication for solving linear recursive sequences.\n</p><p>\n  Consider a configuration of buses that are within a window of width P and\n  advance the leftmost bus in such a way that all of the buses are still within\n  a (shifted) window of width P.\n</p><p>\n  Now we can define a state as the position of the buses within P units. For\n  instance if we have P = 10 and K = 5 buses, then we have 252 possible states\n  (10 choose 5). Let NS be the number of states.<br>\n  To be sure we don't count the same state in different windows we can required\n  that there always be a bus at the leftmost position in the window.\n</p><p>\n  To advance the window of size P we move the leftmost bus. There is always a\n  bus there. Now remember that the new state has to have a bus at the leftmost\n  position, so the window might move to the right by more than one spot.\n</p><p>\n  We compute all the possible state transitions. Let C be the matrix of state\n  transitions having C<sub>a,b</sub> be the number of ways we can go from state\n  a to state b.<br>\n  For each state j, with the window in the position i we will have something\n  like:\n</p>\n<pre>\nA[S<sub>j</sub>][i+1] = C<sub>1,j</sub>A[S<sub>1</sub>][i] + C<sub>2,j</sub>A[S<sub>2</sub>][i] + ... + C<sub>NS,j</sub>A[S<sub>NS</sub>][i]\n</pre>\n<p>\n  A[s][p] is the number of ways we can get into state s while having the window\n  in position p.\n</p><p>\n  This would be enough to solve the small input. For the large input we need to\n  speed things up, so we are going to compute that linear recurrence of order NS\n  by using matrix multiplication. Let's look instead at a much simpler example\n  of a linear recurrence -- Fibonacci numbers.\n</p>\n<pre>\nF<sub>N</sub> = F<sub>N-1</sub> + F<sub>N-2</sub>\n</pre>\n<p>\n  This can be rewritten as:\n</p>\n<pre>\n(1 0) * (F<sub>N-2</sub>) = (F<sub>N-1</sub>)\n(1 1)   (F<sub>N-1</sub>)   (F<sub>N</sub>  )\n</pre>\n<p>\n  In a shorter form we have:\n</p>\n<pre>\nM * V<sub>N-1</sub> = V<sub>N</sub><br>\n</pre>\n<p>\n  This says that to compute V<sub>N</sub> = (F<sub>N</sub>, F<sub>N-1</sub>)\n  from V<sub>N-1</sub> = (F<sub>N-2</sub>, F<sub>N-1</sub>) we need to multiply\n  with M. Now we can apply this recursively:\n</p>\n<pre>\nM<sup>X</sup> * V<sub>0</sub> = V<sub>X</sub>\n</pre>\n<p>\n  M<sup>X</sup> can be computed using an algorithm called\n  <i>successive squaring</i> in time that is logarithmic in X.\n</p>\n","id":"0000000000436e2e","statement":"<h3>Problem</h3>\n<p>\n  In the First City of Mars there are <b>N</b> bus stops, all aligned in a\n  straight line of length <b>N</b>-1 km. The mayor likes to keeps things simple,\n  so he gave the bus stops numbers from 1 to <b>N</b>, and separated adjacent\n  stops by exactly 1 km.\n</p><p>\n  There are also <b>K</b> buses in the city. The mayor has to plan the bus\n  schedule and he would like to know in how many ways that can be done. This\n  number can be very large. Luckily there are a few constraints:\n</p>\n<ul>\n  <li>\n    In the beginning of the day all the buses are in the first <b>K</b> bus\n    stops (one bus per stop)\n  </li>\n  <li>\n    Buses only move from the left to the right (1 is the leftmost bus stop)\n  </li>\n  <li>\n    At the end of the day all the buses must be in the last <b>K</b> bus stops\n    (one bus per stop)\n  </li>\n  <li>In each bus station exactly one bus has to stop</li>\n  <li>\n    For the same bus the distance between any two consecutive stops is at most\n    <b>P</b> km\n  </li>\n</ul>\n<p>\n  Help the mayor evaluate the number of schedules. However try not to give him\n  very bad news (a lot of schedules) so just output the real number modulo\n  30031.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line in the input file is the number of cases <b>T</b>.<br>\n  Each of the next <b>T</b> lines contains 3 integers separated by one space:\n  <b>N</b>, <b>K</b> and <b>P</b>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each case output the number of ways to plan the bus schedules (modulo\n  30031) in the format \"Case #<b>t</b>: [number of ways modulo 30031]\" where\n  <b>t</b> is the number of the test case, starting from 1.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &lt; <b>T</b> &le; 30<br>\n  1 &lt; <b>P</b> &le; 10<br>\n  <b>K</b> &lt; <b>N</b><br>\n  1 &lt; <b>K</b> &le; <b>P</b>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>1 &lt; <b>N</b> &lt; 1000</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>1 &lt; <b>N</b> &lt; 10<sup>9</sup></p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n10 3 3\n5 2 3\n40 4 8\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 3\nCase #3: 7380\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Let's name the buses: A, B, C...<br>\n  For the first case there is only one possible way of planning the schedule:\n  A &rarr; 1, 4, 7, 10. B &rarr; 2, 5, 8. C &rarr; 3, 6, 9. <br>\n  For the second case the possible ways of planning are:<br>\n  (A &rarr; 1,3,5. B &rarr; 2,4),<br>\n  (A &rarr; 1,3,4. B &rarr; 2,5),<br>\n  (A &rarr; 1,4. B &rarr; 2,3,5).<br>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":26}],"title":"Bus Stops","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  In this problem we are given a triangle and another triangle obtained by\n  applying an affine transformation on the first one -- translation, rotation\n  and scaling. We are asked to find a fixed point for this transformation.\n</p><p>\n  This is actually a particular case of \"Bannach's fixed point theorem\" which\n  guarantees the existence and uniqueness of fixed points of certain self maps\n  of metric spaces, though knowing the theorem was not a requirement.\n</p><p>\n  To solve this problem, we need to find the parameters of the transformation.\n</p><p>\n  Such transformations are familiar to anyone who has ever played with computer\n  graphics. To view the transformation as a linear operator, it is convenient to\n  use homogeneous coordinates, where our plane is embedded as the plane z=1 in\n  3D space. i.e., consider each point (x, y) as (x, y, 1). (<i>Note</i>: As\n  usual, all the vectors corresponding to points are considered column vectors,\n  in spite of the horizontal way we write them here.) In this setting, rotating\n  a point by an angle alpha around the point (0, 0) corresponds to multiplying\n  the vector v = (x, y, 1) by the matrix R = [[cos alpha sin alpha 0] [-sin\n  alpha cos alpha 0] [0 0 1]]. Translating a point x, y by (dx, dy) corresponds\n  to multiplying v by T = [[1 0 dx] [0 1 dy] [0 0 1]], and a scaling transform\n  centered at 0 corresponds to multiplying a point v = (x, y, 1) by the matrix S\n  = [[S 0 0] [0 S 0] [0 0 1]]. The total transform looks like this\n</p>\n<pre>\nv' = T R S v = M v.\n</pre>\n<p>\n  Note that above we focused on the effect of the transformation on the plane\n  z=1. The interested reader can verify that it maps every horizontal plane\n  z=z<sub>0</sub> to itself.\n</p><p>\n  To get the matrix <b>M</b>, we may solve separately for the matrices T, R, and\n  S. There is an easier way. From the input constraints, we know that point A is\n  mapped to A', B to B' and C to C'. View each point as a vector in the plane\n  z=1, so that A, B, C are linearly independent. So the 3 by 3 matrix [A B C] is\n  invertible. Therefore,\n</p>\n<pre>\nM [A B C] = [A' B' C']\n</pre>\n<p>has a unique solution for <b>M</b>.</p><p>\n  From here, there are still two solutions to our problem. One observation is\n  that if we apply the transformation and we have a point that doesn't change,\n  we can apply it again on the resulting triangle and the point will remain the\n  same. So we apply this transformation until the triangle becomes very small.\n  The fixed point will still be inside the triangle so we can stop when the side\n  lengths of the current triangle get smaller than the needed precision.\n</p><p>\n  The more algebraic solution looks at the equation again. We know there is a\n  unique point v = (x, y, 1) such that <b>M</b> v = v. From here we know that\n  (i) 1 must be an eigen-value for the matrix M; (ii) the space of the\n  eigen-vectors corresponding to 1 must be one-dimensional.<br>\n  So we can just solve the equation [M - I] v = 0, and find the intersection of\n  the solution space (a line) and the plane z=1.\n</p>\n\n<h3>More information</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=banach+fixed+point+theorem\" target=\"_blank\">Banach fixed point theorem</a> -\n  <a href=\"http://www.google.com/search?q=homogeneous+coordinate\" target=\"_blank\">Homogeneous coordinate</a> -\n  <a href=\"http://www.google.com/search?q=eigen+value\" target=\"_blank\">Eigen value, eigenvectors, and more</a>\n</p>\n","id":"0000000000436ecf","statement":"<h3>Problem</h3>\n<p>\n  You are given two triangle-shaped pictures. The second picture is a possibly\n  translated, rotated and scaled version of the first. The two triangles are\n  placed on the table, with the second one placed completely inside (possibly\n  touching the boundary of) the first one. The second triangle is always scaled\n  by a factor that is strictly between 0 and 1.\n</p><p>\n  You need to process the picture, and for that you need a point in the picture\n  which overlaps with the same point of the scaled picture. If there is more\n  than one solution, you can return any of them. If there are no solutions,\n  print \"No Solution\" (without the quotes) for that test case.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>N</b>. Then for each\n  test case, there will be two lines, each containing six space-separated\n  integers -- the coordinates of one of the triangles -- in the format\n  \"x<sub>1</sub> y<sub>1</sub> x<sub>2</sub> y<sub>2</sub> x<sub>3</sub>\n  y<sub>3</sub>\". The point (x<sub>1</sub>, y<sub>1</sub>) in the first\n  triangle corresponds to the same corner of the picture as (x<sub>1</sub>,\n  y<sub>1</sub>) in the second triangle, and similarly for (x<sub>2</sub>,\n  y<sub>2</sub>) and (x<sub>3</sub>, y<sub>3</sub>).\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>x</b>: \" followed two\n  real numbers representing the coordinates of the overlapping point separated\n  by one space character, or the string \"No Solution\". Answers with a relative\n  or absolute error of at most 10<sup>-5</sup> will be considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>N</b> &le; 10.<br>\n  The coordinates of the points will be integer numbers between -10 000 and 10\n  000. The three points in each triangle will not be collinear.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  All tests will contain isosceles right-angle triangles. (i.e., the triangle's\n  angles will be 45 degrees, 45 degrees, and 90 degrees.)\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  The triangles can have any shape.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n0 0 0 2 2 0\n0 0 0 1 1 0\n10 0 0 10 0 0\n3 3 1 1 3 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.000000 0.000000\nCase #2: 2.692308 1.538462\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Scaled Triangle","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000436d8a","type":1,"type__str":"SPECTATOR"},"title":"EMEA Semifinal 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
