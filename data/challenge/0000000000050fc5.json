{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1550343600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000050fc5","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Our 2019 Code Jam to I/O for Women round was the first round using a\n  redesigned UI &mdash; we know there were issues with loading the contest at\n  the start of the round, but we hope you enjoyed solving the problems and had\n  a smooth experience once the round began. Please don't hesitate to let us\n  know if you encountered any issues by emailing codejamio@google.com.\n</p><p>\n  <i>Grid Escape</i> and <i>Parcel Posts</i> were the two easier problems of\n  the four, but both took some thought and had non-obvious edge cases. The\n  formidable infinite field of <i>Sheepwalking</i> could be tamed with some\n  algebra and memoization. <i>War of the Words</i> was our first interactive\n  problem in Code Jam to I/O for Women, and it was quite fiendish even on top\n  of the challenge of getting used to this problem type &dash; even the first\n  test set was tough to pass!\n</p><p>\n  We had over a thousand participants attempt at least one problem. In the\n  first hour of the contest, we saw many solutions to our first two problems,\n  but Sheepwalking and especially War of the Words proved to be tougher to\n  crack. Only a handful of contestants earned any points on War of the Words,\n  and nobody solved the second test set, but we saw some submissions get close!\n  Over 60 contestants solved the first three problems, and 10 of those also\n  solved test set 1 of War of the Words. Most contestants who got into top 150\n  either fully solved the first three problems or fully solved the first two\n  with a small enough time penalty.\n</p><p>\n  Thanks to everyone who participated &mdash; and congratulations to the top\n  150! We'll be in touch in the upcoming days, pending finalization of the\n  results. We hope to see all of you again next year!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  <i>Grid Escape</i>: Written by Ian Tullis. Prepared by Jonathan Irvin\n  Gunawan.\n</p><p>\n  <i>Parcel Posts</i>: Written by Ian Tullis. Prepared by Pablo Heiber.\n</p><p>\n  <i>Sheepwalking</i>: Written by Ian Tullis. Prepared by Jonathan Irvin\n  Gunawan.\n</p><p>\n  <i>War of the Words</i>: Written by Ian Tullis. Prepared by Pi-Hsun Shih.\n</p><p>\n  Solutions and other problem preparation and review by Shane Carr, Luis Hector\n  Chavez, Md Mahbubul Hasan, Trung Thanh Nguyen, Lizzie Sapiro, Pi-Hsun Shih,\n  Micah Stairs, Mary Streetzel, Dave Walker, Jeroen van Wolffelaar, and Adilet\n  Zhaxybay.\n</p>\n<p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Grid Escape: Ian Tullis</li>\n  <li>Parcel Posts: Pablo Heiber</li>\n  <li>Sheepwalking: Pablo Heiber and Ian Tullis</li>\n  <li>War of the Words: Ian Tullis</li>\n</ul>\n","registration_gives_participant":true,"result_status":30,"result_status__str":"FINALIZED","start_ms":1550334600000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  Test set 1 has a small upper bound of only 10 for <b>K</b>, which leaves at\n  most 9 places where a post can be placed. That means we can just try every\n  one of the 2<sup>9</sup> = 512 combinations. For each one, check whether all\n  of the produced parcels are valid, and if they all are, update a result if\n  the number of posts in this option is larger than it. To check whether a\n  parcel is valid, notice the condition is equivalent to checking if the list\n  of elevations is not sorted non-decreasingly nor non-increasingly. We can do\n  that by either sorting it in both ways and compare whether either is equal to\n  the original, or check there exist two consecutive marks with one strictly\n  lower than the other, and also two consecutive marks with one stricly higher\n  than the other.\n</p>\n<h3>Test set 2</h3>\n<p>\n  We can improve upon the exponential time required for the solution in the\n  previous paragraph with the following insight: if a parcel between marks i\n  and j is valid, so is any extension of it to a parcel between marks i-d and\n  j+e for non-negative d and e. So, let i be the westernmost mark such that the\n  parcel between marks 0 and i is valid and the parcel between i and <b>K</b>\n  is valid. If there is not such an i, then the result is just 0 (no posts\n  can be added). We can then prove that there is a way to place a maximum\n  number of posts that places a post at mark i and not at any mark west of i.\n  If that's true, a greedy algorithm follows: find such i, place a post there,\n  and recursively try to place more posts within the [i, <b>K</b>] parcel. This\n  algorithm takes O(<b>K</b><sup>2</sup>) time if implemented as described,\n  which is fast enough to solve this test set, but a linear time alternative is\n  presented in the next paragraph.\n</p><p>\n  To solve the problem in linear time, we scan the list of elevations from west\n  to east, recording when we see consecutive marks in strictly increasing and\n  strictly decreasing order. As soon as we have seen both, we found a potential\n  i (we don't check if [i, <b>K</b>] is valid just yet, to save time). We add 1\n  to the result, reset whether we have seen markings in each order to false,\n  and resume scanning (this is equivalent to the recursive step in the previous\n  presentation). After the scan is complete, it's possible that the eastmost\n  parcel is not valid (since we didn't check it), but we can check it by\n  inspecting the value of the same two boolean variables showing whether we saw\n  markings in each order since our last reset. If the westmost parcel is not\n  valid, the last place we found for a post was not valid, so we subtract 1\n  from our running result. Notice that each time we find a place where we can\n  place a new post, it means that all previously placed posts were valid. This\n  takes a single linear pass and a constant number of updates and checks of 3\n  variables at each step (two boolean variables about having seen markings in\n  each order, and the result), so the algorithm runs in linear time.\n</p><p>\n  To prove the main proposition, notice first that the parcel between marks 0\n  and j for j &lt; i is never valid by definition of i, so any valid placement\n  of posts does not place a post at mark j &lt; i. For the second part, since\n  just i is a valid placement, there exists a non-empty valid placement. Let\n  L = i<sub>1</sub>, i<sub>2</sub>, ..., i<sub>m</sub> be the list of mark\n  positions where posts should be added in a valid placement of a maximum\n  number m of posts, in increasing order. Then, i &leq; i<sub>1</sub> because\n  of the first part, so we can define L' = i, i<sub>2</sub>, ...,\n  i<sub>m</sub>. Now we can show L' is also such a list, and one that has i as\n  its westernmost post. L' has m posts by definition. The validity of L'\n  follows because the parcel between marks 0 and i is valid by definition of i,\n  and the parcel between i and i<sub>2</sub> is an extension of the one\n  between i<sub>1</sub> and i<sub>2</sub> (because i &leq; i<sub>1</sub> from\n  the previous part). All other parcels in L' are also parcels in L, and are\n  therefore also valid, so L' is valid.\n</p>\n","id":"0000000000054e9a","statement":"<h3>Problem</h3>\n<p>\n  You just bought a parcel of land that is <b>K</b> kilometers long; it is so\n  narrow that, for the purposes of this problem, we will consider it to be\n  a polyline that runs from west to east, varying in elevation. You know\n  the elevations of the land (in meters) at <b>K</b> + 1 regularly spaced\n  <i>measurement marks</i> <b>M<sub>0</sub></b>, <b>M<sub>1</sub></b>, ...,\n  <b>M<sub>K</sub></b>. These marks are 0, 1, ..., <b>K</b> km, respectively,\n  from the western end.\n</p><p>\n  In this region, a wooden post denotes the boundary between two adjacent\n  parcels of land. Wooden posts can only be placed at measurement marks, and\n  there can be at most one post at each mark. Right now, there are two posts:\n  one at the 0 km mark, and one at the <b>K</b> km mark. A measurement mark\n  with a post is considered to be part of both of the parcels it demarcates, so\n  your parcel of land includes all measurement marks between 0 and <b>K</b> km,\n  inclusive.\n</p><p>\n  A parcel is considered <i>desirable</i> if it contains three measurement\n  marks such that the west-most and east-most of those three marks are both\n  strictly higher than the remaining one of the three marks, or both strictly\n  lower than the remaining one of the three marks. People like some variation\n  in their landscapes! Notice that these three marks are not necessarily\n  consecutive, and the west-most and east-most of the three marks are not\n  necessarily the west-most and east-most marks of the parcel.\n</p><p>\n  Consider an example with <b>K</b> = 5 and <b>M<sub>0</sub></b>,\n  <b>M<sub>1</sub></b>, ..., <b>M<sub>K</sub></b> = 5, 6, 6, 1, 2, 4. The\n  measurement marks with elevations 5, 2, and 4 satisfy the condition, as do\n  the measurement marks with elevations 6, 1, and 2. However, the measurement\n  marks with elevations 6, 6, and 1 do not satisfy the condition, nor do the\n  measurement marks with elevations 1, 2, and 4. Any three measurement marks\n  that satisfy the condition make the whole parcel desirable; for example, a\n  parcel containing the measurement marks 4 7 6 7 is desirable because of the\n  first three values.\n</p><p>\n  Your parcel is desirable, but you think it may be possible to extract even\n  more value from it! You want to add additional posts to this parcel to divide\n  it up into multiple parcels, all of which must be desirable, since you do not\n  want to waste any land. What is the largest number of posts you can add?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with one line containing an\n  integer <b>K</b>: the length, in kilometers, of your parcel of land. Then,\n  there is one more line with <b>K</b> + 1 integers <b>M<sub>0</sub></b>,\n  <b>M<sub>1</sub></b>, ..., <b>M<sub>k</sub></b>; where <b>M<sub>i</sub></b>\n  is the elevation (in meters) at the measurement mark that is i km from the\n  western end of your land.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the largest possible number of posts you can add, as described above.\n</p>\n\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set. (10 seconds per test run.)<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  0 &le; <b>M<sub>i</sub></b> &le; 1000, for all i.<br/>\n  (<b>M<sub>i</sub></b> - <b>M<sub>j</sub></b>) &times;\n  (<b>M<sub>k</sub></b> - <b>M<sub>j</sub></b>) &gt; 0,\n  for some i &lt; j &lt; k. (Your starting parcel is desirable.)<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  4 &le; <b>K</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  4 &le; <b>K</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n4\n4 8 7 3 5\n4\n4 8 7 7 5\n7\n1 2 2 1 2 1 2 1\n6\n2 1 3 10 9 12 20\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 0\nCase #3: 2\nCase #4: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, you can add one post at 2 km to get a total of two\n  desirable parcels. The parcel from 0 to 2 km is desirable because\n  4 &lt; 8 and 8 &gt; 7. The parcel from 2 to 4 km is desirable because\n  7 &gt; 3 and 3 &lt; 5.\n</p><p>\n  In Sample Case #2, there is no way to add another post. If you added one\n  at 1 km or 3 km, one of the parcels would include only two measurement marks\n  and could not be desirable. If you added one at 2 km, the parcel between\n  0 and 2 km would be desirable, but the parcel between 2 and 4 km would not.\n</p><p>\n  In Sample Case #3, posts can be added at 3 km and 5 km.\n</p><p>\n  In Sample Case #4, a post can be added at 2 km. Notice that the parcel from\n  2 km to 6 km is desirable because 10 &gt; 9 and 9 &lt; 12. However, there is\n  no way to add a second post.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Parcel Posts","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  In the first test set, there can be at most 8 rooms in the grid. Each room\n  can have its working exit in any one of the four directions, so we can use\n  brute force to check all 4<sup>8</sup> possible ways to choose the 8\n  working exits, and see how many players escape from each possible layout.\n  Either we will find a solution, or we will show that the case is\n  <code>IMPOSSIBLE</code>.\n</p>\n<h3>Test set 2</h3>\n<p>\n  In the second test set, we can no longer get away with an exhaustive\n  approach! However, since we have some freedom in designing the grid, it's\n  worth looking for a constructive solution.\n</p><p>\n  If <b>R</b> = <b>C</b> = 1, then <b>K</b> = 0 is impossible, and any\n  solution works for <b>K</b> = 1. Otherwise, imagine drawing a \"snaking\"\n  path through all of the rooms of the grid, choosing our working doors to\n  allow us to follow this path. We start in the northwesternmost cell of the\n  grid, and move eastward through rooms until we reach the northeasternmost\n  cell. (If <b>C</b> = 1, we will already be there and so we will not need to\n  move.) Then we make one move south, and if we have not exited the grid, we\n  move westward through rooms until we reach a cell on the western border.\n  Then we make one more move south (if possible), and then move eastward, and\n  so on, until one of our moves to the south exits the grid.\n</p><p>\n  (By the way, a more obscure term for this type of winding path is\n  <a href=\"https://en.wikipedia.org/wiki/Boustrophedon\"><i>boustrophedon</i></a>,\n  which derives from a way to direct oxen when plowing a field. Algorithms\n  have been useful for a very long time!)\n</p><p>\n  Notice that all of the players can escape along our path, no matter where\n  they start. Now consider choosing some room along the path and \"reversing\"\n  its working door &mdash; that is, choosing the door that opens onto the\n  previous room on the path. Then every player who starts in that room or a\n  room earlier than it along the path cannot escape &mdash; they will be\n  trapped in an infinite loop! Every other player will still be able to escape\n  just as before.\n</p><p>\n  Since we can choose any room along the path, we can allow any desired number\n  of players to escape... well, <i>almost</i> any number. If we try to use the\n  above strategy to allow all but one of the players to escape, it breaks down\n  because the very first room (where that player is) has no \"previous room on\n  the path\".\n</p><p>\n  In fact, we can never allow all but one of the players to escape. Consider\n  the room with the one player who we want to prevent from escaping. One of\n  their doors has to work, and it cannot open onto the outside world, so it\n  must open onto another room. But that means that our player will share the\n  fate of the player in that other room &mdash; either they will both be able\n  to escape, or neither will.\n</p><p>\n  So, if <b>K</b> = <b>R</b> &times; <b>C</b> - 1, the case is\n  <code>IMPOSSIBLE</code>, and for any other case, the above construction gets\n  us our answer. If <b>K</b> = <b>R</b> &times; <b>C</b>, we do not modify any\n  of the path’s doors; otherwise, to allow exactly <b>K</b> of the players to\n  escape, we \"reverse\" the door in the (<b>K</b>+1)-th-from-last room of the\n  path.\n</p><p>\n  Many other approaches are possible. For example, we can design around the\n  target number of players who cannot escape. As long as that number is at\n  least two, we can create a \"nucleus\" of the trap in the upper left corner of\n  the grid: either an <code>E</code> room to the west of a <code>W</code> room,\n  or an <code>S</code> room to the north of an <code>N</code> room, depending\n  on our given dimensions. Then we can turn cells sharing rows with the\n  nucleus into <code>W</code>s, cells sharing columns with the nucleus into\n  <code>N</code>s, and other cells (scanning top-to-bottom, then left-to-right)\n  into <code>W</code>s until our set of trapped rooms is large enough. The\n  remaining rooms can safely be filled with <code>S</code>. Alternatively,\n  we can use <a href=\"https://en.wikipedia.org/wiki/Flood_fill\">flood fill</a>\n  to extend the sink.\n</p>\n","id":"0000000000054e9c","statement":"<h3>Problem</h3>\n<p>\n  You are designing a new \"escape\" adventure that uses a rectangular grid of\n  rooms (unit cells) with <b>R</b> rows and <b>C</b> columns. Each room has\n  four doors oriented in the four orthogonal directions of the grid: north,\n  south, east, and west. The doors on the border of the grid lead outside, and\n  all of the other doors lead to other rooms.\n</p><p>\n  The adventure will be played by exactly <b>R</b> &times; <b>C</b> players,\n  with each player starting in a different one of the <b>R</b> &times; <b>C</b>\n  rooms. Once everyone is in position and the game starts, all of the doors\n  close, and there is a mechanical trick: one of the four doors in each room\n  can be opened from inside the room, and the other three doors cannot be\n  opened. This remains consistent throughout the adventure; in a given room,\n  it is always the same door that can be opened. Notice that it is possible\n  that a door that connects two rooms might be able to be opened from one side\n  but not the other.\n</p><p>\n  Each player moves independently of all other players. Players can only go\n  through doors that they opened themselves, and they must close doors behind\n  them. Each player will keep going through doors until they go through a door\n  that leads outside (and therefore they escape), or they have made\n  <b>R</b> &times; <b>C</b> moves without escaping (at which point they are\n  considered to have failed, and they do not escape).\n</p><p>\n  You want to choose which door in each room can be opened, such that exactly\n  <b>K</b> of the players will be able to escape. Can you find a way to do\n  this, or determine that it is <code>IMPOSSIBLE</code>?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of one line containing three\n  integers <b>R</b>, <b>C</b>, and <b>K</b>, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is <code>IMPOSSIBLE</code> if there is no solution, or <code>POSSIBLE</code>\n  if there is. If there is a solution, output <b>R</b> more lines of <b>C</b>\n  characters each, representing the grid of rooms. The j-th character on the\n  i-th of these lines represents the room in the i-th row and j-th column of\n  the grid; each character must be either uppercase <code>N</code>,\n  <code>S</code>, <code>E</code>, or <code>W</code>, according to whether the\n  door that opens from that room is the one that leads north, south, east, or\n  west.\n</p><p>\n  If multiple answers are possible, you may output any one of them.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set. (10 seconds per test run.)<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>R</b>.<br/>\n  1 &le; <b>C</b>.<br/>\n  0 &le; <b>K</b> &le; <b>R</b> &times; <b>C</b>.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; (<b>R</b> &times; <b>C</b>) &le; 8.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; (<b>R</b> &times; <b>C</b>) &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2 3 2\n1 1 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: POSSIBLE\nSES\nSNW\nCase #2: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In our solution for Sample Case #1, the two players who start in the\n  westernmost two rooms will go south until they escape, whereas the four\n  players who start in the other four rooms will travel between those rooms in\n  an endless clockwise circle and cannot escape.\n</p><p>\n  In Sample Case #2, there is only one room, so the player can definitely\n  escape regardless of which particular door can be opened.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Grid Escape","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  It might seem impossible to promise that we will achieve any particular\n  score in a game in which we do not know which options are better than others,\n  and we don't even know when we are scoring points! But we have our ways...\n</p>\n<h3>Test set 1</h3>\n<p>\n  At first, we might be tempted to send a totally random word every turn.\n  Unfortunately, that's not enough to pass the first test set! When we pick a\n  random word W, the robot will respond with a word R chosen uniformly at random\n  from all words ranked higher than W. Since our W will have a 50th percentile\n  rank on average, the robot's R will have a 75th percentile rank on average,\n  so we might expect to score around 25 points in each case (less if we tie).\n  But we have to get at least 25 points in each of 50 test cases. Good luck\n  winning 50 coin flips in a row!\n</p><p>\n  One approach against an unknown strong opponent, familiar to practitioners of\n  aikido, is to use the opponent's own strength against them:\n</p>\n<ul>\n  <li>Play some fixed but arbitrary word W &mdash; say, <code>HIGCJ</code>. The\n    robot responds with some word R<sub>1</sub>.</li>\n  <li>Play W again. The robot responds with some word R<sub>2</sub>.</li>\n  <li>Now \"borrow\" and play R<sub>1</sub>; the robot responds with some word\n    R<sub>3</sub>.</li>\n  <li>Play W again. The robot responds with some word R<sub>4</sub>.</li>\n  <li>Now \"borrow\" and play R<sub>3</sub>; the robot responds with some word\n    R<sub>5</sub>...</li>\n</ul>\n<p>\n  Suppose that our initial choice of W ranks somewhere around the middle of the\n  pack. We certainly lose by playing W against R<sub>1</sub>, since we know\n  that R<sub>1</sub> beats W. But then when we borrow R<sub>1</sub> to play\n  against R<sub>2</sub>, we know that both R<sub>1</sub> and R<sub>2</sub> were\n  chosen uniformly and independently at random from among words that beat W, so\n  we should a slightly less than 50% chance of winning (because R<sub>1</sub>\n  and R<sub>2</sub> might be the same, and we do not score points for ties).\n  Then we lose again by playing against R<sub>3</sub>, but when we borrow\n  R<sub>3</sub> to play against R<sub>4</sub>, we are playing a word that beat\n  a word that beat W against a word that beat W, so we should have around a 75%\n  chance of winning. As this strategy unfolds, we should lose every other\n  round, but win the remaining rounds with probability 50%, 75%, 87.5%, and so\n  on. This seems like it should easily be enough to get us to 25 points.\n</p><p>\n  However, there is a flaw in this argument: as our \"borrowed\" words get\n  stronger and stronger, at some point, one of them may be the highest-ranking\n  word, in which case the next \"borrowed\" robot word will be the lowest-ranking\n  word. Then our \"borrowed\" words, which are supposed to get us our wins, are\n  actually weak and will cause us to lose those rounds. But now we start to\n  win on the rounds on which we play W, since the robot is playing weakish words\n  in response to our weak \"borrowed\" words, and W probably beats them. So we\n  still get our wins, but now from the W rounds, until the cycle passes by W\n  again. Notice that this implies that the rank of our initial choice of W was\n  not important.\n</p><p>\n  It turns out that this strategy scores close to 50 points on average, but\n  with enough variance that it will not pass test set 2. (We do not need to\n  worry about it failing test set 1, though. In general, running simulations\n  can help us get estimates of the variance of random solutions like this.)\n</p>\n<h3>Test set 2</h3>\n<p>\n  The most notable characteristic of the game is the fact that the otherwise\n  lowest-ranking word L beats the highest-ranking word H. Can we exploit this\n  irregularity? Suppose that we had a way of knowing the identities of L and H.\n  Then we could score a point on <i>every</i> turn by repeating the following\n  cycle:\n</p>\n<ul>\n  <li>We play H, forcing the robot to play L in response.</li>\n  <li>We play some arbitrary word that is not H or L, beating L and earning a\n    point. The robot plays some other word W in response.</li>\n  <li>We beat W with H, forcing the robot to play L in response, and so on.\n    (If W just happened to be H, which is unlikely, then we play L in response\n    instead, and the robot plays another word W' in response, and so on.)</li>\n</ul>\n<p>\n  So, if we can confidently find L and H in fewer than 50 turns, we can\n  certainly pass.\n</p><p>\n  One strategy is as follows. Start with an arbitrary word, and then spend a\n  number of turns copying the robot's most recent response. Since the robot\n  always has to play something higher-ranking in response, and our play will\n  always be of the same rank as the robot's last word, this algorithm will\n  gradually visit higher-ranked words. Eventually, there must be an exchange\n  in which we play H and the robot is forced to play L. Then we climb the\n  ranks again from there. So, this strategy will repeatedly \"cycle\" us through\n  the rankings. Although we will not necessarily visit the same particular\n  subset of ranks each time, each cycle will contain H followed by L.\n</p><p>\n  How many of our turns (not counting the robot's turns) will it take us, on\n  average, to reach the H to L transition? It will take 0 turns if we are lucky\n  enough to start there, 1 turn if we start 1 rank away, an expected\n  1 + ((0 + 1) / 2) = 1.5 turns if we start 2 ranks away, an expected\n  1 + ((0 + 1 + 1.5) / 3) = 1.8333... turns if we\n  start 3 ranks away, and so on. These are the\n  <a href=\"https://en.wikipedia.org/wiki/Harmonic_number\">harmonic numbers</a>.\n  If we start with a random one of our 10<sup>5</sup> words, the mean number of\n  turns to reach the highest-ranking word is about 11.09. So if we spend 50\n  turns, we can go through at least three cycles, with high probability.\n</p><p>\n  Then, our program can look through the results to identify these H to L\n  transitions; we should see multiple instances of those two words back to\n  back. There may be a few other instances of consecutive ranks that appear in\n  multiple cycles &mdash; for example, maybe the robot always happens to choose\n  the second-highest-ranking word on its way to the highest-ranking word. But\n  the H to L must be present in every cycle, and even if we are unlucky and\n  other consecutive patterns also appear in all of our cycles, we can still\n  reason that the one that occurs closely after all the others is the real\n  transition, since other consecutive patterns are only likely to occur\n  closely before the transition.\n</p><p>\n  Another approach is based on the fact that there are only two words that\n  leave the robot with a single choice: if we play the second-highest-ranking\n  word, the robot must play the highest-ranking word, and if we play the\n  highest-ranking word, the robot must play the lowest-ranking word. So, when\n  the robot sends us a word W, we can send two instances of W and note the\n  robot's two responses. If they are different, we pick the first one and send\n  two instances of that, and so on. If they are the same, we can send W a\n  few more times to see whether we always get the same response R. Then we can\n  send R a few times to see whether we always get the same response S (in which\n  case R is the second-highest-ranking word and S is the highest-ranking word)\n  or varying responses (in which case R is the highest-ranking word and S is\n  the lowest-ranking word).\n</p><p>\n  You can experiment locally and run your own simulations until you are\n  confident that you have a solution that will pass the test sets with high\n  probability. Since both test sets are Visible, and the judge is\n  deterministic, it is possible to tweak your solution and try again if you get\n  unlucky with a reasonable approach. Any overall success probability over,\n  say, 50% should suffice, but the approaches described above should do much\n  better than that.\n</p>\n","id":"0000000000054ea5","statement":"<h3>Problem</h3>\n<p>\n  Finally, you are face to face with the leader of the alien robots! You have\n  managed to distract it with its favorite word game, while your fellow\n  Resistance members try to shut down the robots' power supply.\n</p><p>\n  The game uses the robot language, which is made up of 10<sup>5</sup> words:\n  the set of all five-letter strings made up of uppercase English letters\n  between <code>A</code> and <code>J</code>, inclusive. For example,\n  <code>AAAAA</code>, <code>FGHIJ</code>, and <code>BEIGE</code> are among\n  the valid words.\n</p><p>\n  You know that these words have a rank order, with no ties, such that a\n  higher-ranked word beats any lower-ranked word, with the one exception that\n  the lowest-ranked word beats the highest-ranked word. Unfortunately, you do\n  not know the rank order of the words in the robot language!\n</p><p>\n  The game has the following rules:\n</p>\n<ul>\n  <li>Turn 0: You start by naming a word W<sub>0</sub>.</li>\n  <li>Turn 1: The robot names a word W<sub>1</sub>. If W<sub>1</sub> beats\n    W<sub>0</sub>, the robot scores a point.</li>\n  <li>This continues; on turn i, the active player is you if i is even,\n    or the robot if i is odd. The active player names a word W<sub>i</sub>\n    and scores a point if W<sub>i</sub> beats W<sub>i-1</sub>. (If the two\n    words are the same, no point is scored.) The score is not announced &mdash;\n    in particular, you will not know whether each of your words has scored a\n    point!\n  <li>This continues for a total of 201 turns.</li>\n  <li>Notice that you get the last turn (naming W<sub>200</sub>), and that at\n    the end of that turn, each player's score is between 0 and 100,\n    inclusive.</li>\n</ul>\n<p>\n  Thanks to some great work by the Resistance's spies, you know the strategy\n  that the robot will use for every turn of the game. It only cares about\n  scoring 100 points, so on every turn, it will choose a word uniformly at\n  random from all possible words that will score a point on that turn, and\n  independently of all of its previous word choices. The robot knows the rank\n  order of the language, so it has no trouble choosing words!\n</p><p>\n  If you do not score at least <b>N</b> points, the robot will become bored and\n  stop playing with you, so your plan (and the universe) will be\n  doomed!\n</p>\n<h3>Input and output</h3>\n<p>\n  This problem is\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\">interactive</a>,\n  which means that the concepts of input and output are different than in\n  standard Code Jam problems. You will interact with a separate process that\n  both provides you with information and evaluates your responses. All\n  information comes into your program via standard input; anything that you\n  need to communicate should be sent via standard output. Remember that many\n  programming languages buffer the output by default, so make sure your output\n  actually goes out (for instance, by flushing the buffer) before blocking to\n  wait for a response. See the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\">FAQ</a>\n  for an explanation of what it means to flush the buffer. Anything your\n  program sends through standard error is ignored, but it might consume some\n  memory and be counted against your memory limit, so do not overflow it.\n</p><p>\n  In addition, sample solutions to a\n  previous Code Jam interactive problem (in various languages) are provided\n  in the Analysis section of\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000000130/0000000000000523\">this past problem</a>.\n</p><p>\n  Initially, your program should read a single line containing two integers\n  <b>T</b> and <b>N</b>: the number of test cases, and the number of points you\n  must score in each case. (Notice that the <b>N</b> parameter is the same for\n  every test case in a test set.) Then, you need to process <b>T</b> test cases.\n</p><p>\n  At the start of a test case, the judge chooses a rank order for the words\n  in the robot language, uniformly at random from all such orders, and\n  independently of any previous choices of rank order. (However, the judge\n  uses a deterministic seed, so if your program is deterministic, its\n  interaction with the judge will be the same even across submissions for\n  this problem.)\n</p><p>\n  At the start of a test case, you must output one line with a five-letter\n  string of uppercase English letters in the inclusive range <code>A</code>\n  through <code>J</code>: a valid word W<sub>0</sub> in the robot language.\n  Then you will have 100 exchanges with the judge; the j-th of these\n  (counting starting from 1) proceeds as follows:\n</p>\n<ol>\n  <li>The judge will output one line with a valid word\n    <b>W<sub>2j-1</sub></b>: the robot's word.</li>\n  <li>You output one line with another valid word W<sub>2j</sub>.</li>\n</ol>\n<p>\n  After you send your last word for a test case, your program should terminate\n  if it was the last test case; otherwise, it should output a word to begin the\n  next test case.\n</p><p>\n  If your program outputs something wrong (e.g., gives an invalid word), the\n  judge will send <code>-1</code> to your input stream and it will not send any\n  other output after that. If your program continues to wait for the judge after\n  receiving <code>-1</code>, your program will time out, resulting in a Time\n  Limit Exceeded error. Notice that it is your responsibility to have your\n  program exit in time to receive a Wrong Answer judgment instead of a\n  Time Limit Exceeded error. As usual, if the total time or memory is\n  exceeded, or your program gets a runtime error, you will receive the\n  appropriate judgment.\n</p><p>\n  You should not send additional information to the judge after processing all\n  test cases. In other words, if your program keeps printing to standard output\n  after the last test case, you will get a Wrong Answer judgment.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 50.<br/>\n  Time limit: 40 seconds per test set. (10 seconds per test run.)<br/>\n  Memory limit: 1GB.<br/>\n  <b>W<sub>i</sub></b> is five characters long and consists only of characters\n  in the set of uppercase letters <code>ABCDEFGHIJ</code>, for all odd i. (The\n  robot plays valid words.)<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>N</b> = 25.<br/>\n</p>\n\n<h4>Test set 2 (Visible)</h4>\n<p>\n  <b>N</b> = 50.<br/>\n</p>\n\n<h3>Sample Interaction</h3>\n<p>\n  Notice that interactive problems do not have sample input and output like\n  other Code Jam problems. Your code will not be run against samples, and the\n  following interaction is just an example.\n</p>\n<pre>\n  t, n = readline_int_list()   // reads 50, 25 into t, n\n  // Before the case starts, the judge silently chooses a rank order for the\n  // 100000 words. Suppose that the word FADED is the lowest-ranked word,\n  // AHEAD is the highest-ranked word, and CAGED and HIGCJ are ranked\n  // such that FADED &lt; CAGED &lt; HIGCJ &lt; AHEAD. As the contestant,\n  // though, we do not know this!\n  printline AHEAD to stdout    // you name AHEAD as word 0. What luck!\n  flush stdout\n  robot_word = readline_str()  // reads FADED into robot_word\n  printline CAGED to stdout    // you name CAGED as word 2\n  flush stdout\n  robot_word = readline_str()  // reads HIGCJ into robot_word\n  printline GAFFED to stdout   // you name an invalid word as word 4\n  flush stdout\n  robot_word = readline_str()  // reads -1 (judge has decided our solution is\n                               //   incorrect)\n  exit                         // exits to avoid an ambiguous TLE error\n</pre>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0jExSJHy9poeCqVHzQSkLbbm6Xm-TaQ0tMIfKzywjMuvEJAKYwtCQXPz4YarO1I1kzeVud8ca5zYtACg6E/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":1,"type__str":"VISIBLE","value":24}],"title":"War of the Words","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<h3>Herding strategy</h3>\n<p>\n  What is the most efficient way to herd Bleatrix from cell\n  (<b>X</b>, <b>Y</b>) back to the \"origin\" cell (0, 0)? We will simplify our\n  discussion by assuming that <b>X</b> and <b>Y</b> are both nonnegative;\n  because Bleatrix's two-dimensional field is symmetric across both axes, our\n  solutions can safely work with the absolute values of <b>X</b> and <b>Y</b>.\n</p><p>\n  If Bleatrix is ever at a cell (x, y) such that x &ne; 0, and y &ne; 0\n  &mdash; that is, she is not along one of the two \"axes\" of cells &mdash; then\n  two of her possible moves will take her toward the origin cell (reducing\n  either her horizontal or vertical distance from it), and the other two will\n  take her away from the origin. In this case, we should use the two sheepdogs\n  to block the two \"away\" moves. Any move away from the goal in some direction\n  would need to be reversed later on, costing us two moves. Moreover, we do not\n  want to spend both sheepdogs to block opposite directions of movement (e.g.,\n  placing them to Bleatrix's left and right to force her to move either up or\n  down), because then she would make a purely random horizontal or vertical\n  walk, with no tendency toward the goal.\n</p><p>\n  The only remaining case &mdash; apart from being at the origin and thus being\n  done &mdash; is that Bleatrix is at a cell of the form (x, 0) or (0, y).\n  That is, she is along one of the two main \"axes\" of unit cells; without loss\n  of generality, we will suppose she is at a cell of the form (0, y).\n</p><p>\n  We know from the argument above that we do not want to use both sheepdogs to\n  force her to randomly walk along the y-axis, so we should use one sheepdog to\n  block her movement along the y-axis away from the origin. But should we\n  deploy the other sheepdog to block one of her moves perpendicular to the\n  axis? If we do not, she will move toward the goal with probability &frac13;\n  and perpendicular to it with probability &frac23;; if we do, she will move\n  toward or perpendicular to the goal with equal probability. Since moving\n  toward the goal is better (again, any lateral move needs to be undone\n  eventually), we should use the additional sheepdog. For convenience, we will\n  always deploy it in a way that keeps both of her coordinates nonnegative\n  &mdash; that is, below her if she is along the x-axis, and to the left of her\n  if she is on the y-axis.\n</p><p>\n  A more rigorous proof of the optimality of our strategy follows at the end of\n  this analysis.\n</p>\n<h3>Simulation can only get us so far!</h3>\n<p>\n  Now that we have a strategy, a natural approach is to simulate it and take\n  the average of, say, a million runs. Test set 1 only includes nine distinct\n  cases; the others are symmetric, differing only in signs and/or in which\n  values are X and Y. How hard can it be to get those nine answers?\n</p><p>\n  As it turns out: pretty hard! The problem is that the length of our random\n  walk has very high variance, so it is hard to get a confident estimate of the\n  true expected length. A straightforward simulation solution will either take\n  too long or not meet the strict tolerance requirements of the problem.\n  However, we can run simulations offline and inspect the results, and we might\n  notice that the answers are always close to a value of the form A / 9, where\n  A is some integer. This pattern will not hold up for X and Y values outside\n  of the [-3, 3] range, but it can serve us well here &mdash; an offline\n  simulation can get us close enough to the true answers that we can\n  confidently guess the value of A for each case, and then submit a solution\n  that packages up those answers.\n</p><p>\n  It is also possible to solve Test set 1 by hand, using the same method that\n  also leads to a solution for Test set 2...\n</p>\n<h3>Expected herding time</h3>\n<p>\n  Notice that the problem is \"memoryless\"; if Bleatrix moves to cell (x, y),\n  the expected number of additional moves to reach the origin from there is the\n  same as if she had begun at (x, y). So, to calculate the expected number of\n  moves needed from a given starting point, we can use a series of\n  <i>recurrences</i>. Let T(x, y) be the expected number of moves when starting\n  from cell (x, y); trivially, T(0, 0) = 0. Let us consider our cases from\n  above:\n</p>\n<ul>\n  <li>Some cell (x, y) not on an axis: Bleatrix will move either left or down\n    with equal probability; either way, this uses one move. So we have T(x, y)\n    = &frac12; T(x-1, y) + &frac12; T(x, y-1) + 1.</li>\n  <li>Some cell (0, y) on the y-axis: Bleatrix will move either down or right\n    with equal probability; either way, this uses one move. So we have T(0, y)\n    = &frac12; T(0, y-1) + &frac12; T(1, y) + 1. (The expression for a cell on\n    the x-axis is similar.)</li>\n</ul>\n<p>\n  We can simplify the second recurrence by replacing T(1, y) with its\n  representation from the first recurrence: &frac12; T(0, y) +\n  &frac12; T(1, y-1) + 1.\n  Then, after some algebra, the second recurrence simplifies to T(0, y) =\n  &frac23; T(0, y-1) + &frac13; T(1, y-1) + 2. Now we are expressing T(0, y)\n  only in terms of recurrences for smaller values of y. So, all told, for any\n  starting cell, we have T(x, y)=\n</p><p>\n<ul>\n  <li>0 if x = y = 0.</li>\n  <li>&frac23; T(0, y-1) + &frac13; T(1, y-1) + 2, if x = 0 but y &ne; 0.</li>\n  <li>&frac23; T(x-1, 0) + &frac13; T(x-1, 1) + 2, if y = 0 but x &ne; 0.</li>\n  <li>&frac12; T(x-1, y) + &frac12; T(x, y-1) + 1, if x &ne; 0 and\n    y &ne; 0.</li>\n</ul>\n<p>\n  At this point, we can use recursion plus\n  <a href=\"https://en.wikipedia.org/wiki/Memoization\">memoization</a>\n  &mdash; or some other form of\n  <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">dynamic programming</a>\n  &mdash; to quickly compute any answer we want. We will never need to evaluate\n  T() for any particular cell more than once, so we have tamed the infiniteness\n  and randomness inherent in the problem.\n</p><p>\n  If we use, e.g., C++ <code>double</code>s, might our solution fail due to\n  accumulated floating-point errors? This phenomenon is often worth worrying\n  about, but in this problem, it is not even close to posing a threat. The total\n  number of calculations needed is not very large &mdash; only a few per\n  recurrence. Even if our solution for e.g. the case <code>500 500</code>\n  involves calculating the answer for every possible distinct test case\n  along the way, we will have at most a few million chances to introduce a\n  tiny amount of error. A standard double precision floating point number has\n  15 decimal digits of precision, but we only need the first 6 to be correct,\n  so even if our errors pathologically did not cancel each other out at all,\n  we would be fine.\n</p>\n<h3>A (perhaps) surprising property of the solution</h3>\n<p>\n  Check out the answers for the cases <code>100 0</code>, <code>100 1</code>,\n  ..., all the way up to <code>100 30</code>. They are all (to nine decimal\n  places) the same: 201.500000000. The answer for <code>100 100</code> is\n  212.727275769. Why are these values so close? That is, if we compare starting\n  200 moves away from the goal at (100, 100) versus starting only 100 moves\n  away from the goal at (100, 0), why does the latter not help us very much?\n</p><p>\n  Observe that, in our strategy, once Bleatrix has made enough left moves to\n  reach the y-axis, her horizontal moves will alternate between right and left;\n  once she has made enough down moves to reach the x-axis, her vertical moves\n  will alternate between up and down. But regardless of where we are in the\n  strategy, she has an equal probability of moving horizontally or vertically.\n  Given that Bleatrix starts at (<b>X</b>, <b>Y</b>), we can be sure that she\n  will reach the goal only after she has made at least <b>X</b> horizontal\n  moves <i>and</i> at least <b>Y</b> vertical moves.\n</p><p>\n  How many moves will it take until the first time at which both of those\n  conditions are satisfied? Without loss of generality, let us assume that\n  <b>X</b> &ge; <b>Y</b>. If <b>X</b> is much larger than <b>Y</b>, then by the\n  time we get our <b>X</b>-th horizontal move, we will almost certainly have\n  gotten <b>Y</b> vertical moves, so we can ignore <b>Y</b>. Then the expected\n  number of moves needed to get <b>X</b> horizontal moves is 2<b>X</b>, since\n  the probability of a horizontal move is &frac12;. However, if <b>X</b> is not\n  much larger than <b>Y</b>, or equal to <b>Y</b>, we cannot ignore <b>Y</b>,\n  and it may take more than 2<b>X</b> moves in expectation for <i>both</i>\n  conditions to be satisfied.\n</p><p>\n  The above explains why the (100, 100) answer is larger than the (100, 0)\n  answer. It also explains why it is not <i>too</i> much larger, since a large\n  discrepancy would imply that it is very likely to get 100 moves in one\n  direction <i>long</i> before getting 100 moves in the other direction.\n</p><p>\n  However, why is the (100, 0) answer 201.5 rather than 2<b>X</b> = 200?\n  Consider the first time at which we have at least <b>X</b> horizontal moves\n  and at least <b>Y</b> vertical moves; call the number of moves M. We have\n  just hit one of the axes for the first time, and we will be on the other\n  axis (and thus done) if M matches the parity of <b>X</b> + <b>Y</b>, or one\n  cell away otherwise. We know that T(0, 1) = T(1, 0) = 3; for large\n  <b>X</b> + <b>Y</b>, we would expect parity effects to even out, so this\n  final herding process should add &frac12;(3) = 1.5 more moves to the\n  expected total.\n</p><p>\n  Also note that even though our chosen precision level obscures it, the\n  (100, 0) answer is in fact slightly smaller than the (100, 1) answer, and\n  so on.\n</p>\n<h3>Appendix: optimality proof</h3>\n<p>\n  T(0, 0) = 0, and for any other (x<sub>0</sub>, y<sub>0</sub>),\n  T(x<sub>0</sub>, y<sub>0</sub>) is the minimum of 1/k &times; the sum of the\n  T values of any k neighbors of (x<sub>0</sub>, y<sub>0</sub>), where\n  k &ge; 2. Observe that k can always be 2 &mdash; it is never suboptimal to\n  place 2 dogs adjacent to the current cell, since they block the neighbors\n  with the larger values of T, and decrease our average T over all remaining\n  neighbors. Therefore, to compute T(x<sub>0</sub>, y<sub>0</sub>), we will\n  pick any smallest two among T(x<sub>0</sub> - 1, y<sub>0</sub>),\n  T(x<sub>0</sub> + 1, y<sub>0</sub>), T(x<sub>0</sub>, y<sub>0</sub> - 1), and\n  T(x<sub>0</sub>, y<sub>0</sub> + 1), and take their average.\n</p><p>\n  <i>Lemma 1</i>: T(x<sub>0</sub> - 1, y<sub>0</sub>) &le;\n  T(x<sub>0</sub> + 1, y<sub>0</sub>) for all x<sub>0</sub> &gt; 0,\n  y<sub>0</sub> &ge; 0.\n</p><p>\n  <i>Lemma 2</i>: T(x<sub>0</sub> - 1, y<sub>0</sub>) &le;\n  T(x<sub>0</sub>, y<sub>0</sub> + 1) for all x<sub>0</sub> &gt; 0,\n  y<sub>0</sub> &ge; 0.\n</p><p>\n  By Lemmas 1 and 2, T(x<sub>0</sub> - 1, y<sub>0</sub>) (and, by symmetry,\n  T(x<sub>0</sub>, y<sub>0</sub> - 1)) are better than the other two neighbors,\n  so we place the sheepdogs to block the other two neighbors.\n</p><p>\n  <i>Proof of Lemma 1</i>: Let <i>S</i> be an optimal strategy starting\n  from (x<sub>0</sub> + 1, y<sub>0</sub>). From\n  (x<sub>0</sub> - 1, y<sub>0</sub>), we could use a strategy <i>S</i>' that,\n  as long as we don't get to the column of cells x = x<sub>0</sub>, always\n  places the dogs in a way that \"mirrors\" their placements in <i>S</i> with\n  respect to the column x = x<sub>0</sub>. Call this stage 1. When we first\n  touch that column, we switch to using strategy <i>S</i>; call this stage 2.\n</p><p>\n  During stage 1, if strategy <i>S</i> is in cell (x<sub>0</sub> + a, b) after\n  k moves, then <i>S</i>' is in cell (x<sub>0</sub> - a, b). During stage 2,\n  after k moves, they are always in the same cell. Since the path from\n  (x<sub>0</sub> + 1, y<sub>0</sub>) to (0, 0) must cross column\n  x = x<sub>0</sub>, using this strategy means that for any random choices,\n  either our modified strategy reaches (0, 0) before crossing column\n  x = x<sub>0</sub>, and therefore before strategy <i>S</i>... or the two\n  strategies reach (0, 0) during stage 2, that is, both at the same time.\n</p><p>\n  <i>Sketch of proof of Lemma 2</i>: This is similar to our proof of Lemma 1,\n  but we mirror across the diagonal y = x<sub>0</sub> + y<sub>0</sub> - x.\n  From (x<sub>0</sub>, y<sub>0</sub> + 1), the path must cross that diagonal,\n  so we can define <i>S</i>' with similar stages, and a similar argument\n  demonstrates the inequality.\n</p>\n","id":"0000000000054edd","statement":"<h3>Problem</h3>\n<p>\n  Bleatrix Trotter is a sheep who lives in a two-dimensional field that is an\n  infinite grid of unit cells. Her home is in a unit cell that we denote as\n  (0, 0) &mdash; that is, all coordinates are given relative to Bleatrix's home\n  cell. However, because she has been sleepwalking, she is currently in the\n  unit cell at the coordinates (<b>X</b>, <b>Y</b>) &mdash; that is, in a cell\n  <b>X</b> columns east of, and <b>Y</b> rows north of, her home cell. The two\n  sheepdogs who have been assigned to protect Bleatrix have just noticed that\n  she is missing, and now they want to herd her back to her home cell.\n</p><p>\n  Before each of Bleatrix's moves, the two sheepdogs can move to any grid cells\n  that they want, except that they cannot both move to the same cell, and\n  neither one can move to Bleatrix's current cell. Once the sheepdogs are in\n  place, Bleatrix, who is sleepwalking, will make a random unit move in a\n  direction that would not take her into a cell with a sheepdog. That is, she\n  takes the set of four possible unit moves (north, south, west, east),\n  discards any that would move her into a cell with a sheepdog, and then\n  chooses uniformly at random from the remaining moves. Then the sheepdogs can\n  position themselves again, and so on (notice that, unlike Bleatrix, the\n  sheepdogs do not have to make unit moves).\n</p><p>\n  Once Bleatrix arrives at her home at (0, 0), she stops sleepwalking, wakes\n  up, and grazes peacefully, and does not make any more moves thereafter.\n</p><p>\n  If the sheepdogs coordinate their movements to minimize the expected number\n  of Bleatrix's moves to reach her home, what is that expected number?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case consists of one line with two integers\n  <b>X</b> and <b>Y</b>, representing the coordinates of Bleatrix's starting\n  cell, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the expected number of Bleatrix's moves, as described above.\n  <code>y</code> will be considered correct if it is within an absolute or\n  relative error of 10<sup>-6</sup> of the correct answer. See the Competing\n  section of the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\">FAQ</a>\n  for an explanation of what that means, and what formats of real numbers we\n  accept.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set. (10 seconds per test run.)<br/>\n  Memory limit: 1GB.<br/>\n  (<b>X</b>, <b>Y</b>) &ne; (0, 0).<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>T</b> &le; 48.<br/>\n  -3 &le; <b>X</b> &le; 3.<br/>\n  -3 &le; <b>Y</b> &le; 3.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n   1 &le; <b>T</b> &le; 100.<br/>\n  -500 &le; <b>X</b> &le; 500.<br/>\n  -500 &le; <b>Y</b> &le; 500.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n-1 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4.000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  Notice that the values of <b>X</b> and/or <b>Y</b> may be negative. An\n  <b>X</b> value of -1, for example, means that the cell is one unit west of\n  Bleatrix's home cell. (Similarly, a negative value of <b>Y</b> means the\n  cell is south of Bleatrix's home cell.)\n</p><p>\n  In the sample case, Bleatrix starts off one cell to the north of, and one\n  cell to the west of, her home. Before she makes her first move, the two\n  sheepdogs could position themselves in cells (-2, 1) and (-1, 2). Then,\n  whichever direction she might choose, she would end up only one step away\n  from her home&hellip; but the sheepdogs could not guarantee that she would go\n  there on her next move! The remaining details are left for you to discover.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Sheepwalking","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000050fc5","type":1,"type__str":"SPECTATOR"},"title":"Code Jam to I/O for Women 2019"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
