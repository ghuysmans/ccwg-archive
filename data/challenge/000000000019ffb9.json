{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1589646600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000019ffb9","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Round 2 began with our second pancake problem of 2020:\n  <i>Incremental House of Pancakes</i>. Unlike in Round 1C, you didn't need to\n  do any slicing, but this was tough for a first problem in Round 2, and\n  careful coding was needed. Next came <i>Security Update</i>, which required\n  you to think through the details of an ordering algorithm on a graph.\n  The last two problems were even tougher! <i>Wormhole in One</i> asked you to\n  play some space golf in which the ball could travel between connected holes.\n  <i>Emacs++</i> was another problem in our series of\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000201bf3\" target=\"_blank\">riffs</a>\n  on programming languages and editors. We just might create a Vim++ or C++++\n  problem eventually...\n</p><p>\n  Our first fully correct solution to a problem didn't come in until just\n  after the 10 minute mark, and it took around an hour to see our first full\n  solve of every problem except Emacs++. Shortly before the two-hour mark,\n  we got our first scores of 77, missing only Test Set 2 of Emacs++. The only\n  perfect score came in within the last five minutes in the contest, from\n  <b>Benq</b>, who won the round! The next four, all with 77 points, were\n  <b>imeimi</b>, <b>sevenkplus</b>, <b>bmerry</b>, and <b>scottwu</b>. 22\n  contestants solved at least one test set of the fearsome Emacs++, and\n  <b>Benq</b> and <b>CCCiq</b> were the only contestants to fully solve it.\n</p><p>\n  Over 4000 of our 4500 qualified contestants participated in the round!\n  As usual, please bear with us as we review the results, but the top 1000\n  scorers in this round win this year's Code Jam T-shirt and advance to\n  Round 3! Advancers have three weeks\n  to <a href=\"https://codingcompetitions.withgoogle.com/codejam/archive\" target=\"_blank\">practice</a>...\n  but even if you didn't advance, please remember that competing in Round 2 is\n  itself a noteworthy accomplishment.\n  We'll also note that there's a\n  <a href=\"http://codingcompetitions.withgoogle.com/kickstart\" target=\"_blank\">Kick Start</a>\n  round coming up\n  <a href=\"http://codingcompetitions.withgoogle.com/kickstart/schedule\" target=\"_blank\"><i>very</i> soon</a>!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Incremental House of Pancakes: Written and prepared by Pablo Heiber.\n</p><p>\n  Security Update: Written by Pablo Heiber. Prepared by John Dethridge and\n    Kevin Gu.\n</p><p>\n  Wormhole in One: Written by Pablo Heiber. Prepared by Artem Iglikov.\n</p><p>\n  Emacs++: Written by Max Ward. Prepared by Darcy Best and Max Ward.\n</p><p>\n  Solutions and other problem preparation and review by Mohamed Yosri Ahmed,\n  Liang Bai, Darcy Best, Timothy Buzzelli, John Dethridge, Evan Dorundo, Kevin\n  Gu, Jonathan Irvin Gunawan, Md Mahbubul Hasan, Andy Huang, Artem Iglikov,\n  Nafis Sadique, Pi-Hsun Shih, Sudarsan Srinivasan, Ian Tullis, and Max Ward.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Incremental House of Pancakes: Pablo Heiber.</li>\n  <li>Security Update: Pablo Heiber.</li>\n  <li>Wormhole in One: Artem Iglikov.</li>\n  <li>Emacs++: Darcy Best and Max Ward.</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1589637600000,"tasks":[{"analysis":"<h3>Test Set 1</h3>\n<p>\n  Test Set 1 is small enough that we can simulate the process. Since each step\n  removes at least one pancake from a stack, this takes at most\n  <b>L</b> + <b>R</b> operations. One thing we can notice is that because the\n  i-th step removes i pancakes, the first i steps together remove\n  i &times; (i + 1) / 2 pancakes. This means that the number of steps is\n  actually bounded by 2 &times; sqrt(<b>L</b> + <b>R</b>), which means the\n  simulation algorithm is also O(sqrt(<b>L</b> + <b>R</b>)). It would work for\n  limits that are much larger than the ones in this test set!\n</p>\n<h3>Test Set 2</h3>\n<p>\n  Unfortunately, O(sqrt(<b>L</b> + <b>R</b>)) is still too slow for the\n  10<sup>18</sup> limits in Test Set 2, especially with 1000 cases to go\n  through!\n</p><p>\n  We can simulate multiple steps at a time by noticing that there are two\n  distinct phases of the process. The first phase uses a single stack: the one\n  that starts out with more pancakes. The second phase begins when that stack\n  has a number of pancakes remaining that is less than or equal to the number\n  in the other stack. Notice that if the left stack is the one we serve from in\n  phase 1, it is possible that it is also the first one to be used in phase 2.\n  It is also possible that no customer is served in either phase.\n</p><p>\n  We may serve a lot of customers in phase 1 depending on the difference in\n  size between the stacks at the beginning. If we serve i pancakes from one\n  stack, we remove i &times; (i + 1) / 2 pancakes from it, so we can\n  efficiently calculate how many customers we can serve in phase 1 by finding\n  the largest i<sub>1</sub> such that\n  i<sub>1</sub> &times; (i<sub>1</sub> + 1) / 2 is less than or equal to the\n  difference in number of pancakes between the two stacks at opening time. We\n  can calculate that either by solving a quadratic equation and rounding\n  carefully, or by using\n  <a href=\"https://en.wikipedia.org/wiki/Bisection_method\">binary search</a>.\n</p><p>\n  The second phase is where the magic happens. Let us say that when serving\n  customer i, stack X is used and Y is not, but then we serve customer i + 1\n  from stack Y. Therefore, stack X lost i pancakes and stack Y lost i + 1\n  pancakes. Since X was used instead of Y for customer i, X must have had no\n  fewer pancakes than Y had at that time. Since X lost fewer pancakes than Y, X\n  must have had more pancakes than Y after we served customers i and i + 1.\n  This means if we ever use two different stacks in the order (X, Y), we must\n  use X next. And, using the same reasoning with the roles reversed, we have\n  now have used (Y, X) most recently, so we will use Y next, and so on. So,\n  once we have used both piles, we always go on alternating between them.\n</p><p>\n  We can use this observation to efficiently determine what happens in phase 2.\n  After updating the original totals by subtracting the pancakes served in\n  phase 1, we know which stack is used first in phase 2. The first stack will\n  be used to serve customers i<sub>1</sub> + 1, i<sub>1</sub> + 3,\n  i<sub>1</sub> + 5, ... which means that if it is used for c<sub>1</sub>\n  customers, a total of (i<sub>1</sub> &times; c<sub>1</sub>) +\n  (c<sub>1</sub>)<sup>2</sup> pancakes are served from it. At\n  this point, we know the value of i<sub>1</sub>, so once again, we can\n  calculate c<sub>1</sub> by solving a quadratic equation or binary search. The\n  other stack is similar, since it will be used to serve customers\n  i<sub>1</sub> + 2, i<sub>1</sub> + 4, i<sub>1</sub> + 6, ... so if it is used\n  for c<sub>2</sub> customers, a total of ((i<sub>1</sub> + 1) &times;\n  c<sub>2</sub>) + (c<sub>2</sub>)<sup>2</sup> pancakes will be\n  served from it. So the final number of customers served is\n  i<sub>1</sub> + c<sub>1</sub> + c<sub>2</sub>. The total numbers of pancakes\n  served from each stack come from the quantities in phase 2, with the quantity\n  from phase 1 added to whichever stack was first.\n</p><p>\n  If we use binary searches, each phase requires O(log(<b>L</b> + <b>R</b>)) time.\n  If we directly solve the quadratic equations, each phase is actually constant\n  time. Either is fast enough for the limits of this problem.\n</p><p>\n  Notice that solving quadratic equations may be harder than usual, since typically\n  that involves computing some square roots. While most languages provide a way to do\n  that, they do it with\n  <a href=\"https://en.wikipedia.org/wiki/Double-precision_floating-point_format\">\n  double precision floating point</a>, which does not have enough\n  precision for this problem and can lead to off-by-one errors. We should either\n  compute square roots directly on integers (by binary searching for the answer, for example) or\n  use the built-in function, and then check the returned value and other values in its\n  vicinity to find the correct rounded result.\n</p>\n","id":"00000000003384ea","statement":"<h3>Problem</h3>\n<p>\n  Every morning at The Incremental House of Pancakes, the kitchen staff prepares all of its\n  pancakes for the day and arranges them into two stacks. Initially, the stack on the left has\n  <b>L</b> pancakes, and the stack on the right has <b>R</b> pancakes.\n</p><p>\n  This restaurant's customers behave very consistently: the i-th customer to arrive (counting\n  starting from 1) always orders i pancakes. When the i-th customer places their order of i\n  pancakes, you take i pancakes from the stack that has the most pancakes remaining (or from the\n  left stack if both have the same amount). If neither stack has at least i pancakes, the restaurant\n  closes and the i-th customer does not get served any pancakes. You never complete an order using\n  pancakes from both stacks.\n<p></p>\n  Given the initial numbers of pancakes in each stack, you want to know how many customers will be\n  served, and how many pancakes will remain in each stack when the restaurant closes.\n<p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\n  Each test case consists of a single line containing two integers <b>L</b> and <b>R</b>: the\n  initial numbers of pancakes in the left and right stacks, respectively, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: n l r</code>, where <code>x</code>\n  is the test case number (starting from 1), <code>n</code> is the number of customers who will be\n  served, and <code>l</code> and <code>r</code> are the numbers of pancakes that will remain in the\n  left and right stacks, respectively, when the restaurant closes.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 1000.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>L</b> &le; 1000.<br/>\n  1 &le; <b>R</b> &le; 1000.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>L</b> &le; 10<sup>18</sup>.<br/>\n  1 &le; <b>R</b> &le; 10<sup>18</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1 2\n2 2\n8 11\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1 1 1\nCase #2: 2 1 0\nCase #3: 5 0 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the first customer gets 1 pancake from the right stack, leaving 1 pancake in\n  each stack. The second customer wants 2 pancakes, but neither stack has enough for them, even\n  though there are 2 pancakes in total.\n</p><p>\n  In Sample Case #2, the first customer gets 1 pancake from the left stack, because both\n  stacks have the same amount. This leaves 1 pancake in the left stack and 2 in the right stack.\n  The second customer wants 2 pancakes, which you serve to them from the right stack, emptying it.\n  When the third customer arrives, neither stack has 3 pancakes, so no more orders are fulfilled.\n</p><p>\n  In Sample Case #3, the first customer is served from the right stack, leaving 8 pancakes in the\n  left stack and 10 in the right stack. The second customer is also served from the right stack,\n  leaving 8 pancakes in each stack. The third customer is served from the left stack, leaving 5\n  pancakes there and 8 in the right stack. The fourth customer is then served from the right stack,\n  leaving 4 pancakes there. Serving the fifth customer empties the left stack, and then there are\n  not enough pancakes remaining in either stack to serve a sixth customer.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Incremental House of Pancakes","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>\n  Test Set 1\n</h3>\n<p>\n  As the limits for Test Set 1 are very small, we should be able to apply a brute-force algorithm\n  and check all possible directions, starting points, and links between holes. However, there are\n  infinitely many directions and starting points. Let's find a way to work with a finite number of\n  possibilities.\n</p>\n<p>\n  First, let us observe that in order for the ball to touch more than two holes, some pairs of holes\n  must be on lines parallel to the chosen direction. Otherwise, the best we can do is to link\n  together two holes; the ball will go through them and will not touch any other holes.\n</p>\n<p>\n  So, when choosing an initial hit direction, we only need to consider those that are parallel to\n  lines that connect pairs of holes.\n</p>\n<p>\n  Also, the exact starting point is not important. We can decide which hole we want to enter first,\n  and then, regardless of which hit direction we choose, we can position the ball such that it will\n  enter that hole (before any others). For example, because the holes are always at unique integer\n  coordinates, we can choose a starting distance of 0.1 from the hole, in the direction that is the\n  opposite of our hit direction.\n</p>\n<p>\n  Now, we can try all possible starting holes and linking schemes &mdash; with a recursive\n  backtracking algorithm, for example &mdash; and choose the combination that touches the largest\n  number of holes. This should be enough to pass Test Set 1.\n</p>\n<h3>\n  Test Set 2\n</h3>\n<p>\n  Suppose for now that we have chosen the direction of the hit. Let's calculate the maximum possible\n  answer given that decision.\n</p>\n<p>\n  Imagine lines parallel to the chosen direction and going through all of the holes. Notice that\n  each hole is on at most one such line. We will call a line an <i>odd line</i> if it contains an\n  odd number of holes (but more than one), and an <i>even line</i> if it contains an even number of\n  holes (at least two). If there are lines which only contain one hole, we call these holes\n  <i>standalone holes</i>.\n</p>\n<p>\n  Let's also consider the holes along each line to be ordered in the chosen direction.\n</p>\n<p>\n  Note that:\n</p>\n<ul>\n  <li>\n    We cannot touch more than two standalone holes: one at the beginning, and one at the very end of\n    the ball's journey.\n  </li>\n  <li>\n    In the best case, we would touch all non-standalone holes.\n  </li>\n</ul>\n<p>\n  Let's say we have C<sub>odd</sub> total holes on the odd lines, C<sub>even</sub> total holes on\n  the even lines, and C<sub>1</sub> standalone holes. Then the answer is not greater than\n  C<sub>odd</sub> + C<sub>even</sub> + min(2, C<sub>1</sub>).\n</p>\n<p>\n  To touch two standalone holes, we should touch an even number of holes between them. To understand\n  why, note that first of the standalone holes must be an entry to a wormhole, and the second one\n  must be an exit from another wormhole. All of the holes that the ball touches in between those\n  starting and ending holes must be linked in pairs by wormholes, which means there should be an\n  even number of holes. This also means that if the number of non-standalone holes is odd, then we\n  will not be able to touch two standalone holes; in such a case, the answer will not be greater\n  than C<sub>odd</sub> + C<sub>even</sub> + min(1, C<sub>1</sub>).\n</p>\n<p>\n  As we will see, these upper limits can actually be achieved, so the answer is:\n</p>\n<ul>\n  <li>\n    C<sub>odd</sub> + C<sub>even</sub> + min(1, C<sub>1</sub>), if C<sub>odd</sub> +\n    C<sub>even</sub> is odd\n  </li>\n  <li>\n    C<sub>odd</sub> + C<sub>even</sub> + min(2, C<sub>1</sub>), if C<sub>odd</sub> +\n    C<sub>even</sub> is even\n  </li>\n</ul>\n<p>\n  Note that the parity of C<sub>odd</sub> + C<sub>even</sub> is the same as the parity of\n  C<sub>odd</sub>, as C<sub>even</sub> is always even.\n</p>\n<p>\n  Let's construct the linking scheme for the case when C<sub>odd</sub> is even and C<sub>1</sub> is\n  greater than 1:\n</p>\n<ol>\n  <li>\n    Connect one standalone hole to the first hole of any even line.\n  </li>\n  <li>\n    Connect the other holes on that line pairwise consecutively (the last hole will remain\n    unconnected).\n  </li>\n  <li>\n    Connect the last hole on that line to the first hole of another even line, and repeat steps 2\n    and 3 until only odd lines are left untouched.\n  </li>\n  <li>\n    Connect the last hole of the last even line to the first hole of any odd line.\n  </li>\n  <li>\n    Connect the second hole of that odd line (A) to the second hole of another odd line (B).\n  </li>\n  <li>\n    Connect the last hole of line B to the first hole of line B.\n  </li>\n  <li>\n    Connect the last hole of line A to the first hole of another odd line.\n  </li>\n  <li>\n    Connect the remaining holes of line A in consecutive pairs.\n  </li>\n  <li>\n    Connect the remaining holes of line B in consecutive pairs.\n  </li>\n  <li>\n    Repeat steps 5-9 until all the odd lines are used.  When there are no more odd lines, connect\n    the last hole of the last odd line to an unused standalone hole.\n  </li>\n</ol>\n<p>\n  This scheme can be easily modified for the other cases, when C<sub>odd</sub> is odd, and/or\n  C<sub>1</sub> is less than 2.\n</p>\n<p>\n  Summarizing this, we can make full use of all of the odd and even lines and up to two standalone\n  holes.\n</p>\n<p>\n  To calculate the number of holes on each line for a given direction, we can iterate through all\n  ordered pairs of the holes and find the equation of the line that connects them in the form y =\n  mx + y<sub>0</sub>. Now, for each m, we store how many times we see each y<sub>0</sub>. This\n  number will be equal to the number of pairs of holes on this line, which we can use to calculate\n  the number of holes. Note that we only need to do this once, as we will get the counts for all\n  directions we are interested in.\n</p>\n<p>\n  Now, we can iterate through all the directions and calculate the answer for each one as described\n  earlier by iterating through all the lines parallel to the current direction. Our final answer\n  will be the maximum over the answers for all directions.\n</p>\n<p>\n  Note that even though there are O(<b>N</b><sup>2</sup>) directions, and O(<b>N</b>) lines parallel\n  to a direction, the total number of lines for all directions is O(<b>N</b><sup>2</sup>), as every\n  line can be parallel to two (opposite) directions. So the total time complexity of this solution\n  implemented optimally is O(<b>N</b><sup>2</sup>), but slower implementations might also pass.\n</p>\n","id":"00000000003386d0","statement":"<h3>Problem</h3>\n<p>\n  You are participating in an inter-galactic hyperspace golf competition, and\n  you have advanced to the final round! You are really determined to triumph,\n  and so you want to prepare a winning strategy.\n</p><p>\n  In hyperspace golf, just as in conventional golf, you hit a ball with a\n  club, which sends the ball in a direction chosen by you. The playing field in\n  hyperspace golf is a 2-dimensional plane with points representing the\n  different holes. The ball is also represented by a point, and you get to\n  choose where the ball starts, as long as it is not in the same place as a\n  hole.\n</p><p>\n  Since this is hyperspace golf, the players are allowed to turn some pairs of\n  holes into wormholes by linking them together. Each hole can be either left\n  as a normal hole, or linked to at most one other hole (never to itself).\n  Wormholes are undirected links, and can be traversed in either direction.\n</p><p>\n  Because the environment is frictionless, when you hit the ball, it moves in\n  a straight direction that it maintains forever unless it reaches a hole;\n  call that hole h. Upon touching hole h, the ball stops if h is not connected\n  to another hole. If h is connected to another hole h', then the ball\n  immediately comes out of h' and continues moving in the same direction as\n  before.\n</p><p>\n  You know the location of each hole. You want to maximize the number of\n  distinct holes you can touch with a single hit. With that goal in mind, you\n  want to pick the ball's starting location, the direction in which to send\n  the ball, and which pairs of holes, if any, to link together as wormholes.\n  The ball cannot start in the same place as a wormhole.\n  When the ball goes through a wormhole, both the hole it goes into and the\n  hole it comes out of are counted towards your total. Each hole is only\n  counted once, even if the ball goes into it or comes out of it (or both)\n  multiple times. If the ball stops in a hole, that hole also counts toward\n  your total.\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with one line containing a\n  single integer <b>N</b>: the total number of holes. The following <b>N</b>\n  lines contain two integers each: <b>X<sub>i</sub></b> and\n  <b>Y<sub>i</sub></b>, representing the X and Y coordinates, respectively, of\n  the i-th hole.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing Case #x: y, where x is\n  the test case number (starting from 1) and y is the maximum number of distinct holes\n  you can touch if you make optimal decisions as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  -10<sup>9</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>9</sup>, for all\n  i.<br/>\n  -10<sup>9</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>9</sup>, for all\n  i.<br/>\n  (<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>) &ne; (<b>X<sub>j</sub></b>, <b>Y<sub>j</sub></b>),\n    for all i &ne; j. (No two holes are at the same coordinates.)<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>N</b> &le; 7.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2\n0 0\n5 5\n3\n0 0\n5 5\n5 0\n5\n0 0\n5 5\n5 0\n3 2\n2 4\n7\n0 0\n1 1\n2 1\n3 1\n8 2\n11 2\n14 2\n1\n-1000000000 1000000000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 3\nCase #3: 4\nCase #4: 7\nCase #5: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  In Sample Case #1, we can connect the two holes with a wormhole so that we\n  could touch both of them by sending the ball into either one. Notice that\n  without the wormhole, the ball would just stay in the first hole it touches,\n  so it would be impossible to touch more than one hole.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2SvwGI53NLljLwOGnC0yA0a0EPDVZupXLw_Kf1ZkcLXpC32VfX1IDURgrqVH080QsucMMHIn9jwxWUzpfV3zKz0Q/sample_case_1.svg\"/>\n</p>\n<p>\n  In Sample Case #2, we can connect the holes at (0, 0) and at (5, 5). We can\n  then hit the ball from position (4.9, 5), for example, in the positive horizontal direction\n  so that it first touches the hole at (5, 5). It goes into that hole and comes out of the\n  hole at (0, 0), retaining its positive horizontal direction of movement. Finally, it\n  touches the hole at (5, 0), and stops (since there is no wormhole linked to that hole).\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3e2LzZskNCBlJ_YsmBZKuyzUkof5EyVonGLQ9ry22h36ol2PQWNyacB1J9dllq4M0J_RWY1qV2im8bMbhxdymLoA/sample_case_2.svg\"/>\n</p>\n<p>\n  In Sample Case #3, we can connect the pair of holes at positions (0, 0) and\n  (5, 0), and also the pair of holes at positions (3, 2) and (5, 5). Hitting\n  the ball from (4, -1) towards the hole at (5, 0) makes it touch the holes at\n  positions (5, 0), (0, 0), (5, 5) and (3, 2), in that order.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1i7x9tL207jJRK9ETWMHlDYOfNNScwu-iKdkAeh5IuKdG9U9a72oSxAu6ZxrHI6j1zedE45NMOhHMhsn7pAByAUw/sample_case_3.svg\"/>\n</p>\n<p>\n  In Sample Case #4, we can connect the pairs of holes at positions (0, 0) and\n  (1, 1), the pair of holes at positions (2, 1) and (11, 2), and also the pair of holes\n  at positions (8, 2) and (14, 2). Hitting\n  the ball from (-1, 0) towards the hole at (0, 0) makes it touch the holes at the following\n  positions, in this order: (0, 0), (1, 1), (2, 1), (11, 2), (14, 2), (8, 2), (11, 2), (2, 1),\n  and (3, 1). Note that although the holes at positions\n  (11, 2) and (2, 1) are touched twice, they are only counted once each for the answer,\n  since the problem asks for a count of distinct holes.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3KweRBDzTvE0VLjezXgNWqqxv11wbZ9_soBfYNOEiADWV6ZNjWXkdFwTH_RFXKQf19dT-mfB17wSi_7fuW7MZ51w/sample_case_4.svg\"/>\n</p>\n<p>\n  In Sample Case #5, there is only one hole, and we can hit the ball into it\n  without needing to consider wormholes at all. (For what it's worth, we can\n  choose any starting location we want, even outside of the allowable range of\n  coordinates for holes.)\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0wyXiJIRs3p6SGYg-dPx8CaejPkVVMdLpqzH6dVcuNM51IdSi8n-ftUPTrI0LNJZnpPBCX49NP2CLQaTS9aW6hXw/sample_case_5.svg\"/>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":16}],"title":"Wormhole in One","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nLet R<sub>i</sub> be the number of computers that receive the update before computer i, and\nT<sub>i</sub> be the time between computer 1 and computer i receiving the update. For each i,\nthe input gives us exactly one of these numbers. We can set\nR<sub>1</sub> = T<sub>1</sub> = 0 for convenience.\n</p>\n<h3>A simplified problem</h3>\n<p>\nLet us assume for now that we have all the T<sub>i</sub>s. If computers i and j share a direct\nconnection and T<sub>i</sub>=T<sub>j</sub>, then any path that gets to computer i in time\nT<sub>i</sub> does not go through computer j, and vice versa, because all latencies are positive.\nTherefore, we can assign any positive latency to all those connections.\nIf computer i has a given T<sub>i</sub>, it means that any connection\ncoming from computer j with T<sub>j</sub> &lt; T<sub>i</sub> needs to have a latency of\nat least T<sub>i</sub>-T<sub>j</sub>, or otherwise the update could get to computer i in\nless than T<sub>i</sub> time by getting to computer j in T<sub>j</sub> time and then using that\nconnection. In addition, for at least one j, the latency of the connection between i and j has to be\nexactly T<sub>i</sub>-T<sub>j</sub>, or otherwise the time for the update to reach computer i would\nbe larger than T<sub>i</sub>. One simple way to solve this problem is to make all connections\nbetween computers with different T values have a latency of exactly\n|T<sub>i</sub>-T<sub>j</sub>|; this takes O(<b>D</b>) time.\n</p><p>\nNotice that the algorithm above finds a valid assignment for any set of\nT<sub>i</sub>s. To solve the actual test sets, we are left with the problem: given some\nT<sub>i</sub>s and some other R<sub>i</sub>s, assign all of the non-given values in a way such that\nsorting the computers by T<sub>i</sub> leaves them sorted by R<sub>i</sub>, and vice versa.\nIn particular, computers with equal T values should have equal R values, and vice versa.\n</p>\n<h3>Test Set 1</h3>\n<p>\nIn this test set, we can solve the subproblem from the previous section by setting\nT<sub>i</sub> := R<sub>i</sub>.\n</p>\n<h3>Test Set 2</h3>\n<p>\nFor Test Set 2, we again focus on solving the subproblem.\nWe do that by first ordering the computers by what is going to be their final\nT<sub>i</sub> value (or equivalently, by their final R<sub>i</sub> value).\nWe can partition the set of computers other than the source computer into two:\nthose for which we know R<sub>i</sub> (part R)\nand those for which we know T<sub>i</sub> (part T). We can sort each of those\nin non-decreasing order of the known value.\nWe now have 2 sets that are in the right relative order, and need to merge them as in the last\nstep of <a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Merge Sort</a>.\nWe assign the source computer first. Then we iterate through the remaining <b>C</b>-1 slots in\norder. Suppose we have already merged N computers, and let computer k be the last one of those.\nLet i and j be the first computers remaining in parts R and T,\nrespectively. If R<sub>i</sub> &le; N, we take computer i next and assign\nT<sub>i</sub> := T<sub>k</sub> if R<sub>i</sub> = R<sub>k</sub>, and\nT<sub>i</sub> := T<sub>k</sub>+1 otherwise. If R<sub>i</sub> &gt; N, we take computer j\nnext and assign R<sub>j</sub> := R<sub>k</sub> if T<sub>j</sub> = T<sub>k</sub>\nand R<sub>j</sub> := N otherwise.\n</p><p>\nWe can prove that if the original set of values is consistent with at least one latency\nassignment (which the statement guarantees), this generates a valid order and assignment\nof missing values, and moreover, it generates one in which the T value of the last\ncomputer in the order is minimal.\nWe do that by induction on the number of computers. For a single computer, this is trivially true.\nSuppose we have <b>C</b> &gt; 1 computers. By our inductive\nhypothesis, the first <b>C</b>-1 computers in the order were ordered and assigned values\nin a consistent way, with a minimal T value for the last computer among all options.\nLet us say the last computer in the full order is computer i, and the next-to-last computer is\ncomputer j. By definition of how we assign missing values, R<sub>i</sub> = R<sub>j</sub> if and\nonly if T<sub>i</sub> = T<sub>j</sub>. If indeed R<sub>i</sub> = R<sub>j</sub> and\nT<sub>i</sub> = T<sub>j</sub>, then the condition for the final assignment is equivalent to the\ninductive hypothesis. If computers i and j come from the same part, then the ordering choice\nbetween them was fixed, and the assignment of T values if needed is clearly minimal. So consider\nfurther the case in which computer i comes from a different part than computer j, and their\nR and T values are different. We have two cases: either computer i was in part R, or in part T.\n</p><p>\nIf computer i was in part R, then its assigned T value is by definition the largest among all\ncomputers, and it's the smallest possible for it to go after computer j, whose value is minimal\nby the inductive hypothesis. As for the order,\nR<sub>i</sub> &le; <b>C</b>-1 per the limits. Since computer j comes from part T\nand was chosen for position <b>C</b>-1 (when N was <b>C</b> - 2), that means\nR<sub>i</sub> &gt; <b>C</b> - 2. Therefore, R<sub>i</sub>=<b>C</b>-1, and the chosen\nposition is correct.\n</p><p>\nIf, on the other hand, computer i was in part T, then its T value is minimal because\nT<sub>i</sub> is fixed. As for the\norder, notice that all computers have either a T value strictly less than T<sub>i</sub> or an R\nvalue strictly less than <b>C</b>-1, so none of them could have been last. By the inductive\nhypothesis, T<sub>j</sub> is minimal among all possible orders, which means, by the existence of a\nfull assignment, it has to be T<sub>j</sub> &lt; T<sub>i</sub>, which implies the consistency of the\nfinal order and value assignment.\n</p>\n","id":"000000000033871f","statement":"<h3>Problem</h3>\n<p>\n  The Apricot Rules company just installed a critical security update on its network. The network\n  has one <i>source computer</i>, and all other computers in the network are connected to the\n  source computer via a sequence of one or more direct bidirectional connections.\n</p><p>\n  This kind of update propagates itself: once a computer receives the update for the first time,\n  that computer immediately begins to transmit the update to all of\n  the computers that are directly connected to it. Each of the direct connections has a\n  <i>latency</i> value: the number of seconds needed for that connection to transmit the update\n  (which is the same in either direction). Therefore, the update does not spread to all computers\n  instantly.\n</p><p>\n  The Apricot Rules engineers do not know any of these latency values, but they know\n  that they are all positive integers. They would like your help in figuring out what these latency\n  values could be, based on how they saw the update spread in a recent experiment.\n</p><p>\n  The Apricot Rules engineers installed the update only on the source computer and then waited\n  for it to propagate throughout the system until every computer was updated. They recorded some\n  information about how the update spread. Specifically, for every computer K other than the\n  source computer, you know exactly one of two things.\n</p>\n<ul>\n  <li>\n    The exact time in seconds between the time when the source computer received the update\n    and the time when K first received the update.\n  </li>\n  <li>\n    The number of other computers (including the source computer) that first got the update\n    strictly before K.\n  </li>\n</ul>\n<p>\n  Notice that multiple computers may have received the update at the exact same time.\n</p><p>\n  You are required to compute a latency in seconds for each of the direct connections between two\n  computers. Each latency value must be a positive integer no greater than 10<sup>6</sup>. The set\n  of latencies that you provide must be consistent with all of the known information. It is\n  guaranteed that there is at least one consistent way to assign latencies.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\n  Each case begins with one line containing two integers <b>C</b> and <b>D</b>: the number of\n  computers and the number of direct connections, respectively. The computers are numbered from 1 to\n  <b>C</b>, with computer 1 being the source computer.\n</p><p>\n  The next line contains <b>C</b>-1 integers <b>X<sub>2</sub></b>, <b>X<sub>3</sub></b>, ...,\n  <b>X<sub>C</sub></b>. A positive <b>X<sub>i</sub></b> value indicates that computer i received\n  the update <b>X<sub>i</sub></b> seconds after computer 1. A negative <b>X<sub>i</sub></b> value\n  indicates that -<b>X<sub>i</sub></b> other computers received the update strictly before computer\n  i; this value includes the source computer.\n</p><p>\n  After that, there are <b>D</b> more lines that represent the <b>D</b> direct connections in the\n  network. The i-th of these lines contains two integers <b>U<sub>i</sub></b> and\n  <b>V<sub>i</sub></b>, indicating that computers <b>U<sub>i</sub></b> and <b>V<sub>i</sub></b>\n  are directly connected to each other.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y<sub>1</sub> y<sub>2</sub> ...\n  y<sub><b>D</b></sub></code>, where <code>x</code> is the test case number (starting from 1) and\n  <code>y<sub>i</sub></code> is a positive integer not more than 10<sup>6</sup> representing the\n  latency, in seconds, assigned to the i-th direct connection.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>C</b> &le; 100.<br/>\n  <b>C</b> - 1 &le; <b>D</b> &le; 1000.<br/>\n  1 &le; <b>U<sub>i</sub></b> &lt; <b>V<sub>i</sub></b> &le; <b>C</b>, for all i.<br/>\n  (<b>U<sub>i</sub></b>, <b>V<sub>i</sub></b>) &ne; (<b>U<sub>j</sub></b>, <b>V<sub>j</sub></b>),\n  for all i &ne; j.<br/>\n  All computers (except the source computer) are connected to the source computer through a sequence\n  of one or more direct connections.<br/>\n  There exists at least one way of assigning latency values that is consistent with the input.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  -<b>C</b> &lt; <b>X<sub>i</sub></b> &lt; 0, for all i.\n    (You get the second type of information for all computers.)<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  -<b>C</b> &lt; <b>X<sub>i</sub></b> &le; 1000, for all i.<br/>\n  <b>X<sub>i</sub></b> &ne; 0, for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 4\n-1 -3 -2\n1 2\n1 3\n2 4\n3 4\n4 4\n-1 -1 -1\n1 4\n1 2\n1 3\n2 3\n3 2\n-2 -1\n2 3\n1 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5 10 1 5\nCase #2: 2020 2020 2020 2020\nCase #3: 1000000 1000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  In Sample Case #1, the following picture represents the computer network that is illustrated by\n  the sample output. The i-th computer is represented by the circle with the label i. A line\n  linking two circles represents a direct connection. The number on each line represents the\n  latency of the direct connection.\n</p>\n<p style=\"text-align:left\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1AoliSmNU6R5CwGmY6vawGOuETyYXXqYVJPYVBM3bzhEoyPJV8bELsWkqLfWFikAuimqDHHdk7gixxJ-c/sample_1.png\"/>\n</p><p>\n  In Sample Case #2, the first three connections need to have the same latency, while the fourth\n  can have any valid latency. Note that -2, 0, 1000001, and 3.14 are examples of invalid latencies.\n</p><p>\n  In Sample Case #3, remember that the connections are bidirectional, and so the update can travel\n  from computer 3 to computer 2. Any two valid latency values work here.\n</p><p>\n  The following case could not appear in Test Set 1, but could appear in Test Set 2:\n</p>\n<pre>\n1\n6 9\n10 -2 -5 15 20\n1 2\n1 3\n2 3\n2 4\n2 5\n3 5\n3 6\n4 5\n5 6\n</pre>\n<p>\n  One of the correct outputs is <code>10 12 4 15 8 3 9 7 5</code>, as illustrated by the picture\n  below.\n</p>\n<p style=\"text-align:left\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U12_5Yoahw7EWbrplArv7yxGD9S3ou-qJCiDTRGAbj-bVijVJdqxHiFA_JabPhp0BaW83YTlct-_4Jnek956w/sample_ts2.png\"/>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":11}],"title":"Security Update","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  TL;DR: Think of the brackets like a tree where a position's parent is the closest pair of\n  brackets that contain that position. Go to the Lowest Common Ancestor, then back down the tree.\n</p><p>\n  With this problem, our first thought may be to write a\n  <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">breadth first search</a>\n  for each query and add up the values. Unfortunately, this is much too slow for the bounds\n  provided. Thankfully, we can make use of the structure of the Lisp++ program and the\n  fact that all movement costs are 1 (going left, going right, or going to the\n  matching bracket&mdash;we will call going left or right \"walking\" and going to the\n  matching bracket \"jumping\" to make the explanation easier).\n</p><p>\n  Two somewhat simple observations are needed before we can talk about the intended solution.\n  The first observation needed is that we almost always want to jump instead of walking\n  inside of a pair of brackets. If we are at\n  a bracket endpoint, and jumping to the other endpoint doesn't make us \"overshoot\" the query's\n  destination, then we should take that jump instead of walking there.\n  The second observation needed is that if a pair of brackets contains both our current position\n  and our destination, we should never move outside of that pair of brackets.\n</p><p>\n  Using just these two observations, let's discuss what an optimal path looks like for a specific\n  query. Consider the closest pair of brackets that contains both the start and end of the query:\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0QlbtbYltgXAPXGEc6EtKn_vQKqH1Tx3Q7jXBBe_sbVEPxkPmiPys5Qr_aDSeYnjWRfYmG7qI/ts1_a.png\" style=\"width: 500px; height: auto;\" />\n</p><p>\n  The optimal path for this query must move \"up\" to this level:\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1ISr3RFRLGkwAnNtzYVp4m4nWG-ApTmMP_sgi47w7rpKZPAcDGFHJ1gHfJBC2P7naBIdsRIaw/ts1_b.png\" style=\"width: 500px; height: auto;\" />\n</p><p>\n  One we are at this level, we jump along the top level of the siblings until we are\n  at the brackets for the end query, then move \"down\" to the query answer.\n  Note that we can jump either left or right (one of which will wrap around\n  when we hit the bracket's endpoint) so we should check both and take the minimum.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2gqYjAB5Y7qJ-Rw5pM0pFO3SqQHNCFBxL0_TO2_wIKcLw76vI4KHvIttan7ix9wgmwgEINkGs/ts1_c.png\" style=\"width: 500px; height: auto;\" />\n</p><p>\n  At this point, we treat the Lisp++ program as a tree with the parents in the tree\n  being the closest pair of brackets that enclose us. Note that one of the parents is\n  strictly closer than the other, so we will always go to that parent first on our path \"up\"\n  or \"down\" the tree. The layer at the top is simply the\n  <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\">lowest common ancestor</a>\n  in the tree, which can be computed in O(log <b>K</b>) time.\n</p>\n\n<h3>Test Set 2</h3>\n<p>\n  TL;DR: (1) Find two pairs of brackets that partition the Lisp++ program into\n  4 disjoint sections. (2) Compute the shortest path from the break points to answer\n  queries that go from one region to another. (3) Recurse on the 4 subregions.\n</p><p>\n  For Test Set 2, some of the properties we used are no longer available to us.\n  In particular, it may now be optimal to venture outside of the LCA described above.\n  There are two main classes of solutions that are used to solve this test set. One is a\n  modification of the LCA algorithm above. We will show the other here because it demonstrates\n  an algorithm that is less traditional. Rather than answering the queries one at a\n  time, we will employ a method where we can solve them in batches.\n</p><p>\n  The key property we will be using is the ability to partition the Lisp++ program into multiple\n  (almost) independent sections. First, let's start with a crucial observation. Consider a\n  pair of matching brackets. The only way to get from inside the brackets to outside\n  the brackets is to cross through the brackets themselves. These brackets that are used to split\n  the input into the different sections will be called the <i>special brackets</i>\n  throughout the explanation.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0ANFswM89nDSCIgHL0kbHPDQZ2oQsTY-kKcz828w16tzY5fzr0zRh2ltELDyrOAAmrhzxHWg0/ts2_a.png\" style=\"width: 500px; height: auto;\" />\n</p><p>\n  We can use this fact to answer queries differently. Rather than computing the\n  distance from the starting point to the ending point of the query, we can compute the\n  distance from each of the special brackets to the query's starting point and from the special\n  brackets to the query's ending point. Since we know that any shortest path must go\n  through one of the special brackets, we know that the sum of these two distances is the answer\n  to the query.\n</p><p>\n  At first, it doesn't seem like this helps us. However, note that we can compute the\n  answer to all queries that go from inside the brackets to outside the brackets at\n  once! Just compute the distance from the special brackets to all locations (using\n  <a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Dijkstra's algorithm</a>,\n  for example) and use the method above.\n</p><p>\n  Now what about all of the queries that start and end inside the special brackets (or outside the\n  special brackets)? Well, the shortest path from the start to the end <i>might</i> go through\n  the special brackets we chose,\n  so we should make note of the potential answer if it does. Now, we're only\n  interested in paths that do not use the special brackets.\n</p><p>\n  Thus, we can split our problem up into two sub-problems: the \"inside\" part and the\n  \"outside\" part. Split the queries up into their appropriate parts (inside and outside)\n  and recursively solve\n  each of these. Note that the special brackets can be removed completely since we know\n  the answers to any query involving them.\n  There is one issue, though: this isn't necessarily fast enough. &#9785; If we\n  choose our special brackets poorly so that the \"inside\" is always a short string,\n  then this algorithm will need\n  O(<b>K</b><sup>2</sup>) time. In order to make this fast, we need to ensure that\n  both subproblems are about half the size of the original problem. If we add in some\n  more heuristics and choose our bracket pair randomly, we can make our code faster on\n  average, but it is not guaranteed to pass the data. There is a slight tweak we can make\n  described below which will save us!\n</p><p>\n  Instead of spliting the string into 2 sections, we will instead split the string into 4\n  sections. Consider a specific pair of brackets. Those brackets' <i>parents</i> are the\n  closest pair of brackets that enclose them. If we split using a pair\n  of brackets and their parents' brackets, we split our input into 4 sections. Note\n  that it is impossible to get from those inner side pieces to the other side without\n  crossing one of our two pairs of special brackets (since the parents are the closest brackets\n  to our original brackets that would allow us to do that).\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0geDP15_mchRpLTW0iCYwdo4FNKXE1hLCjYlcxW1MklVp7iOtoQN5svS9M7_p7HLwQaGyWJHI/ts2_b.png\" style=\"width: 500px; height: auto;\" />\n</p><p>\n  This small change looks like we just made things more complicated, but it solves our issue\n  from above! First, let's add a pair of brackets to the outside of our string\n  and set its <b>L<sub>i</sub></b>, <b>R<sub>i</sub></b>, and <b>P<sub>i</sub></b> to infinity.\n  This way, all pairs of brackets have a parent, except for this new infinite pair we added.\n</p><p>\n  Let's consider all the bracket pairs whose span (from starting bracket to closing\n  bracket, inclusive) includes the middle bracket (there are two \"middle\" brackets; we\n  can choose either). Call these brackets the \"middle line brackets\".\n  The middle line brackets will form a chain in which each bracket pair nests\n  under another middle line bracket, or is the outermost bracket that we added.\n  Our middle line brackets have some nice properties that we can use.\n</p><p>\n  If we consider the middle line brackets from outermost to innermost, we can observe\n  that the spans of the brackets go from containing more than half the characters (the outermost\n  bracket that we added spans the whole string)\n  in our Lisp++ program, to containing at most half of the characters.\n  This is because they are always getting smaller, and the innermost one spans\n  at most half of all characters. Let's consider this \"pivot point\". It comprises a pair\n  of consecutive middle line brackets in which one spans more than half,\n  and it has a direct child that is also a middle line bracket that spans at most half.\n  If we take these two brackets and cut them out of the string, we will have broken the\n  string into 4 disjoint (possibly empty) parts, none of which contain more than half\n  of the characters in the string.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3oI6HUJQVEBPWIN_oq36IJAjD9P8S8WW_x3Rm1YH96VYWPZuBmJqLgUPD8B5uCU_KsgzZqmjw/ts2_c.png\" style=\"width: 500px; height: auto;\" /><br/>\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0Ock8fhsYv3n2yqdTptyb8bckyz441hIi6FNezwe25a_azyRVIGSuQzSaXs-msPgZjqsl6YCU/ts2_d.png\" style=\"width: 500px; height: auto;\" />\n</p><p>\n  Why? Let's say our brackets look like this  <code>A ( B ( C ) D ) A</code>. We know\n  that since the outer bracket pair spans more than half, the region <code>A</code>\n  contains less then half of the characters. We know that the inner bracket either\n  crosses or touches the middle line, so the regions <code>B</code> and <code>D</code>\n  contain less than half of the characters. Finally, <code>C</code> has at most half\n  (remember that we chose <code>C</code> specifically because it was the first middle\n  line bracket that contained at most half of the characters). Note that we cannot get\n  from one region to another without crossing a special bracket. In particular, we cannot\n  get between <code>B</code> and <code>D</code> because the outer special brackets are\n  the parent of the inner special brackets.\n</p><p>\n  Thus, we can solve the problem by finding the two pairs of special brackets we are\n  going to split on, using Dijkstra's algorithm to answer the queries that go between\n  different regions (as well as compute potential answers for those queries that do not),\n  and then recursing into the 4 sub-problems.\n  Since each recursion cuts the length of the input string\n  in half, we recurse at most O(log <b>K</b>) times. The sum of the strings at any particular\n  depth of the recursion is at most the length of the original string. So the total\n  work we needed to do at each layer is at most O(<b>K</b> log <b>K</b>) to run Dijkstra\n  from our 4 special brackets. Also, each query is looked at at most once on each layer\n  of the recursion, so the total complexity is\n  O(<b>K</b> log<sup>2</sup> <b>K</b> + <b>Q</b> log <b>K</b>).\n</p>\n<h3>Some Common Issues</h3>\n<p>\n  Here is a list of common issues that might explain a Wrong Answer or\n  Time Limit Exceeded verdict:\n\n</p>\n  <ul style=\"list-style: initial; padding: initial;\">\n    <li>\n      The edges are directed! This means that the distance from A to B is not\n      necessarily the same as the distance from B to A. For the intended solution,\n      this means we need to run Dijkstra's algorithm twice, not just once.\n    </li><li>\n      If we place values in our code about \"infinity\", those values must be large enough,\n      but not so large as to cause overflows.\n    </li><li>\n      Picking a random edge and just breaking it into doing inside and outside is in general\n      too slow. Even if we break the left and the right apart if they're not connected,\n      we can run into issues. Consider the following. Let X=<code>((((( ... )))))</code>, be of\n      length sqrt(N). If the input is XXXXX ... XXXX sqrt(N) times, then picking randomly\n      is not very efficient. In order to split the input, we need to get lucky and\n      hit one of the outer points of X in order to really cut down on the size of the\n      input.\n    </li>\n</ul>\n","id":"000000000033893b","statement":"<h3>Problem</h3>\n<p>\n  In 2016's Distributed Code Jam, we introduced the Lisp++ language for Lisp\n  fans who prefer a higher density of parentheses. Here is a reminder of how\n  the language's syntax works:\n</p>\n<p>\n  A Lisp++ program is a string of balanced parentheses. More formally, a Lisp++\n  program consists of one of the following. (In this specification, <i>C</i>\n  stands for some program code &mdash; not necessarily the same code each time.)\n</p>\n<ul>\n  <li><code style=\"font-weight: 900;\">()</code> Literally, just an opening parenthesis and a closing\n    parenthesis. We say that this <code style=\"font-weight: 900;\">(</code> matches this <code style=\"font-weight: 900;\">)</code>,\n    and vice versa.</li>\n  <li><code style=\"font-weight: 900;\">(</code><i>C</i><code style=\"font-weight: 900;\">)</code> A program within a pair of enclosing\n    parentheses. We say that this <code style=\"font-weight: 900;\">(</code> matches this <code style=\"font-weight: 900;\">)</code>,\n    and vice versa.</li>\n<li><i>CC</i> Two programs (not necessarily the same), back to back.</li>\n</ul>\n<p>\n  This year, we are pleased to announce Emacs++, a text viewer for Lisp++.\n  Emacs++ displays a Lisp++ program of length <b>K</b> as a single long line\n  with a cursor that you can move around. The cursor is a \"block cursor\" that\n  is always located <i>on</i> one of the <b>K</b> characters in the program,\n  rather than between characters.\n</p><p>\n  At any point, you can perform one of the following three actions to move the\n  cursor. (i represents the current position of the cursor, counting starting\n  from 1 for the leftmost position.)\n</p>\n<ul>\n  <li>Move the cursor one character to the left (or, if the cursor is already\n    on the leftmost character, does nothing). This takes <b>L<sub>i</sub></b>\n    seconds.</li>\n  <li>Move the cursor one character to the right (or, if the cursor is already\n    on the rightmost character, does nothing). This takes <b>R<sub>i</sub></b>\n    seconds.</li>\n  <li>Teleport the cursor to the parenthesis matching (as described above) the\n    parenthesis that is the i-th character. This takes <b>P<sub>i</sub></b>\n    seconds.</li>\n</ul>\n<p>\n  We think Emacs++ will be simple for power users, but we still need to\n  understand how efficient it is. We have a single Lisp++ program and list of\n  <b>Q</b> queries about that program; each query consists of a start position\n  <b>S<sub>j</sub></b> and an end position <b>E<sub>j</sub></b>. To answer the j-th query,\n  you must determine the smallest possible amount of time N<sub>j</sub> (in\n  seconds) that it will take to take the cursor from position <b>S<sub>j</sub></b>\n  to position <b>E<sub>j</sub></b>, if you make optimal decisions.\n</p><p>\n  Please output the sum of all of those N<sub>j</sub> values.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. The first line of a test case contains two integers <b>K</b>,\n  which is the length of the Lisp++ program, and <b>Q</b>, which is the number of queries.\n</p>\n<p>\n  The second line of a test case contains a string <b>P</b> of <b>K</b> characters, each of which\n  is either <code style=\"font-weight: 900;\">(</code> or <code style=\"font-weight: 900;\">)</code>,\n  representing a Lisp++ program (string of balanced parentheses), as described above.\n</p>\n<p>\n  The third, fourth, and fifth lines of a test case each contain <b>K</b> integers. The i-th\n  integers in these lines are the values <b>L<sub>i</sub></b>, <b>R<sub>i</sub></b>, and\n  <b>P<sub>i</sub></b>, respectively, that are described above.\n</p>\n<p>\n  The sixth and seventh lines of a test case each contain <b>Q</b> integers. The j-th integers\n  in these lines are <b>S<sub>j</sub></b> and <b>E<sub>j</sub></b>, respectively, that are\n  described above.\n</p>\n\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the sum of the N<sub>j</sub> values that are described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 60 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  <b>K</b> = 10<sup>5</sup> and <b>Q</b> = 10<sup>5</sup>, for at most 9 test cases.<br/>\n  2 &le; <b>K</b> &le; 1000 and  1 &le; <b>Q</b> &le; 1000, in all other cases.<br/>\n  length of <b>P</b> = <b>K</b>\n  <b>P</b> is a string of balanced parentheses, as described above.<br/>\n  1 &le; <b>S<sub>j</sub></b> &le; <b>K</b>, for all j.<br/>\n  1 &le; <b>E<sub>j</sub></b> &le; <b>K</b>, for all j.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  <b>L<sub>i</sub></b> = 1, for all i.<br/>\n  <b>R<sub>i</sub></b> = 1, for all i.<br/>\n  <b>P<sub>i</sub></b> = 1, for all i.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>L<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  1 &le; <b>R<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  1 &le; <b>P<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n12 5\n(()(((()))))\n1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 1 1 1 1 1 1 1\n7 4 4 12 5\n12 11 10 1 6\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 10\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n\n<p>\n  In the sample case, which obeys the limits for Test Set 1, all of the time\n  costs are the same (1 second per move). <br/>\n  The shortest times for the queries are as follows:\n  <ol>\n    <li>Move right from 7 five times to 12 taking 5 seconds.</li>\n    <li>Teleport from 4 to 11 taking 1 second.</li>\n    <li>Teleport from 4 to 11, then move left to 10 taking 2 seconds.</li>\n    <li>Teleport from 12 to 1, taking 1 second.</li>\n    <li>Move right from 5 to 6 taking 1 second.</li>\n  </ol>\n  Thus, the sum of query times is 5+1+2+1+1 = 10 seconds.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Emacs++","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000019ffb9","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2020"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
