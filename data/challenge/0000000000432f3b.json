{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1307205000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432f3b","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 2 started off with a flurry of submissions to problem A. After that, half of the contestants chose to work on B; others started on C. austrin was the lone dissenter, solving the tricky D at the 28-minute mark. He was the only person on the scoreboard with a correct D-large for a long time.\n</p>\n\n<p>\nBy the end of the first hour of competition, two-time champion acrush took the lead for the first time in Code Jam 2011, with correct solutions to problems A, B and C. Ahyangyi and mystic followed him soon after, with their own error-free solutions to those problems. At that point, it was a race to see whether austrin could finish the rest of the problems before anybody else figured out a solution to D -- a tricky graph theory problem.\n</p>\n\n<p>\nAt the 1h7m mark, acrush submitted a correct solution to D-large, decisively taking first place. Ten minutes later, mystic and meret followed with correct solutions of their own, taking second and third place, respectively. austrin ended up solving the four problems in the order (D, B, C, A) and earning fourth place.\n</p>\n\n<p>\nCongratulations to all contestants who have won t-shirts, and good luck to the top 500 in Round 3!\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Airport Walkways</i> Written by Bartholomew Furrow and Onufry Wojtaszczyk. Prepared by Tomek Czajka.</p>\n<p>Problem B. <i>Spinning Blade</i> Written by Igor Naverniouk and Onufry Wojtaszczyk. Prepared by Onufry Wojtaszczyk.</p>\n<p>Problem C. <i>Expensive Dinner</i> Written by Bartholomew Furrow. Prepared by Onufry Wojtaszczyk.</p>\n<p>Problem D. <i>A.I. War</i> Written by Bartholomew Furrow. Prepared by Onufry Wojtaszczyk.</p>\n<p>Contest analysis by Stephen Fulwider, Jonathan Calhoun, David Arthur and Tomek Czajka. </p>\n<p>Solutions and other problem preparation by Jorge Bernadas Saragoza, Bartholomew Furrow, Tomek Czajka, Igor Naverniouk, Stephen Fulwider, Md. Arifuzzaman Arif, David Arthur, Stephen Thomas and Konstantin Azarov.\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1307196000000,"tasks":[{"analysis":"<p>Let us begin by thinking how can we determine the center of mass of a given blade. The simplest formula for the center of mass (obtained by transforming the formula from the problem statement) is: <b>sum(Mass<sub>i</sub> * P<sub>i</sub>) / sum(Mass<sub>i</sub>)</b>, where <b>P<sub>i</sub></b> is the position of cell <b>i</b> relative to a static location, such as the upper-left corner of the sheet of metal, <b>Mass<sub>i</sub></b> is the mass of cell <b>i</b>, and <b>i</b> is iterated over all cells in the blade.\n \n<p>The first thing to note about this problem is that the X and Y coordinates of the center of mass can be calculated independently, which will simplify the calculations significantly. The X and Y coordinates of the center of the blade are also easy to calculate (the X coordinate is the average of the smallest and largest X coordinate of any cell in the blade).</p>\n\n<p> The thing we are interested in is whether the center of the blade and the center of mass of the blade coincide. To avoid floating point calculations (which would induce the need to think about possible precision problems) we can multiply the equality <b>sum(Mass<sub>i</sub> * X<sub>i</sub>) / sum(Mass<sub>i</sub>) = (minX + maxX) / 2</b> by the denominators of both sides. Thus, for each blade we need to check the equality <b>2 * sum(Mass<sub>i</sub> * X<sub>i</sub>) = (minX + maxX) * sum(Mass<sub>i</sub>)</b>.</p>\n\n<p>So, we simply need to test this equality for all possible blades. This can be done by iterating over all possible X and Y coordinates of the upper-left corner of the blade, and then over all possible sizes of the blade. Calculating either side of the equality above can be performed by iterating over all cells in the blade (remember to omit the corners!). As there are O(RC) possible upper-left corners, O(min(R,C)) possible sizes and O(min(R,C)^2) cells in a blade, the whole algorithm has a time complexity of  O(N<sup>5</sup>) (where <b>N</b> denotes the common upper bound for <b>R</b> and <b>C</b>), which works for the small input, but we cannot expect to make it work for the large.</p>\n\n<p>\nBefore we attack the large case, let us spend a moment to look at potential overflow problems &mdash; we already saw that this can be a serious issue in this competition! The left-hand size of the inequality can be estimated by <b> 2 * N<sup>2</sup> * N * maxW </b> &mdash; two times the number of cells times the largest possible value of <b>X<sub>i</sub></b> times the largest possible weight of a cell. In the small test cases, this value will easily fit into a 32-bit integer, while in the large case we should use 64-bit integers to be safe. We also considered giving a 10<sup>18</sup> bound on <b>D</b>, several approaches of dealing with overflow (that can also handle this obscenely large limit) are given at the end of this editorial, you might also want to think about this problem yourself. \n</p>\n\n<p> Back to the large case. Notice that in the previous approach we have seen there are O(N<sup>3</sup>) blades to consider, so one approach to reducing the run time is to attempt to make the center of mass calculation for every blade constant. This requires a bit of precalculation.</p>\n\n<p>To precalculate the center of mass (or rather, the <b>sum(Mass<sub>i</sub> * X<sub>i</sub>)</b> and <b>sum(Mass<sub>i</sub>)</b> quantities) for any given blade, we will first calculate the center of mass and total mass for all rectangles with the two corners at (0,0) and (x,y). We will start with the rectangle with corners at (0,0) and (1,1). This is just the first cell of the grid, so we already know its center of mass and total mass. We will store this answer and move on to the next rectangle we want to calculate, which will have corners at (0,0) and (1,2). Since we already know the center of mass and total mass for the rectangle with corners (0,0) and (1,1) we can use this rectangle, and the rectangle with corners at (0,1) and (1,2) to calculate the center of mass and total mass for the rectangle with corners (0,0) and (1,2). As long as we iterate over the Y axis 1 by 1 we can calculate the total mass and center of mass of all possible rectangles in constant time. </p>\n\n<p>Now we have to handle the case where we have to iterate the X axis of the corner, so we need to know the center of mass and total mass of the rectangle with corners at (0,0) and (2,1). This is the same as the first case for the Y axis, so we just calculate the center of mass and total mass using the rectangle with corners at (0,0) and (1,1) as well as the rectangle with corners at (1,0) and (2,1). In the next step we run into a problem. We have a grid that looks something like the image below.</p>\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2gw94pEm1AR90D8epaeIIL_ZKrOnRpXkXhJ-v6bGgjiZpJEst9pV4sGrAiLiGtpm41qBLjYVokZFmAfWVO50o/SpinningBladeABCD.png\"></p>\n<p>If it is not clear in the image, the rectangles marked B and C overlap with the rectangle D.</p>\n<p>We know the appropriate sums for the rectangles marked A, B, C, and D, but we need to know the sums for the entire rectangle, which we will call R. This can be done in constant time using:<br></p>\n<p>R = A + B + C - D</p><p>We subtract D because it is added twice when we add both B and C.</p>\n<p>This can be used to calculate center of mass and total mass both for all rectangles with corners (0,0) and (2,2) on to (X,Y). The total run time for this is O(N<sup>2</sup>) since we only have to look at each cell once. Now, how can this be used to calculate the sums for a square with corners at (x<sub>1</sub>,y<sub>1</sub>) and (x<sub>2</sub>,y<sub>2</sub>) (or any other square we might be interested in)? This is very similar to the way we calculated the center of mass and total mass during the precalculations. Assume we label a few of the rectangles we have already precalculated as:<br></p>\n<p>A = Square we are looking for, with corners at (x<sub>1</sub>,y<sub>1</sub>) and (x<sub>2</sub>,y<sub>2</sub>)</p>\n<p>B = Rectangle with corners at (0,0) and (x<sub>1</sub>,y<sub>2</sub>)</p>\n<p>C = Rectangle with corners at (0,0) and (x<sub>2</sub>,y<sub>1</sub>)</p>\n<p>R = Rectangle with corners at (0,0) and (x<sub>2</sub>,y<sub>2</sub>)</p>\n<p>D = Rectangle with corners at (0,0) and (x<sub>1</sub>,y<sub>1</sub>)</p>\n<p>The same picture, reasoning and equation as before gives us <b>R = A + B + C - D</b>, which transforms to <b>A = R + D - B - C</b>. Thus, having all the precalculations done, we can compute all the needed quantities for any square (and thus, by subtracting the values in the corners, for any blade) in constant time!</p>\n<p>With a constant center of mass calculation, this brings the total run time to O(N<sup>2</sup>&nbsp;+ N<sup>3</sup>). This will easily work with N &lt;= 500. </p>\n\n<h3>Side Note</h3>\n<p>Another approach to this problem is to try all possible upper-left corners for the blade, and then slowly expand the size of the blade by 1 unit to the bottom-right at a time until it cannot be expanded any further, calculating the required sums using O(N) calculations at each step to increment the previous values. That brings the total run time to O(N<sup>4</sup>). While this may seem incredibly large when N can be up to 500, in practice this is really a lot less calculations than 500<sup>4</sup> (as for most corners we cannot expand up to size N), while the input file size limit guarantees there are at most two max-cases in the input. Thus, this approach will run in time on most computers and in most languages.</p>\n\n<h3>Dealing with overflow</h3>\nLet us go back to the question what would we do if the limit on <b>D</b> was larger.\n<ol>\n<li> We can try to use BigIntegers of some sort. This solution costs us in terms of efficiency, although if we go for the O(N<sup>3</sup>) solution we should still be able to make it.</li>\n<li> We can realize that the value of <b>D</b> is irrelevant. On an intuitive level - adding a constant mass <b>D</b> to each cell is the same as putting a new sheet with each cell of mass <b>D</b> on top of our sheet. The center of mass is going to be somewhere in between the centers of mass for the two sheets &mdash; and so it is going to be in the middle if and only if our original sheet had the center of mass in the middle. On a formal level, if we add <b>D</b> to each <b>Mass<sub>i</sub></b>, both sides of the equation increase by <b>2 * AvgX * NumberOfCells</b>, where <b>AvgX</b> is the average X coordinate of a cell in the blade. Thus, we can set <b>D</b> to, say, 1 and use 32-bit integers</li>\n<li> We can also set <b>D</b> to zero. This is somewhat scary, as it would result in a division by zero in the original equation for the center of mass, we encourage you to consider why this works.</li>\n<li> Finally, we may ignore the overflow problem totally, if only our compiler guarantees that overflow results in modulo arithmetics. As <b>D</b> cancels out on both sides of the equation anyway, it also cancels out modulo MAXINT, so if only the rest of the equation will not overflow, we will be fine. This requires some knowledge of your tools, though &mdash; for instance modular arithmetic for integers in C++ is guaranteed for unsigned integers, but not for signed integers, and the compiler can make optimizations that assume overflow does not happen for signed integers (and thus break code depending on the modular arithmetic). </li>\n</ol>\n","id":"00000000004329fc","statement":"<h3>Problem</h3>\n<p>\nBeing bored with the traps in your secret hideout design, you decided to go for something classical, but always enjoyable - the <i>spinning blade</i>. You ordered a really heavy metal sheet out of which you will cut the blade; a uniform square <b>C</b>-by-<b>R</b> grid will be painted on the sheet. You have determined the best shape for the blade -- you will first cut a large square consisting of <b>K</b>-by-<b>K</b> grid cells, where <b>K</b> &ge; 3. Then, you will cut out the four 1-by-1 corner cells out of the square to end up with a <i>blade</i>. After determining all this, you started waiting for the sheet to arrive.\n</p>\n\n<p>\nWhen the sheet arrived, you were shocked to find out that the sheet had imperfections in it! You expected each cell to have mass <b>D</b>, but it turned out that the mass can vary a bit because of differences in thickness. This is bad because you want to insert a shaft exactly in the center of the blade and spin it very fast, so the center of mass of the blade must be exactly in its center as well. The definition of the center of mass of a flat body can be found below.\n</p>\n\n<p>\nGiven the grid and the mass of each cell, what is the largest possible size of the blade you can make so that the center of mass is exactly in its center?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one starts with a line containing 3 integers: <b>R</b>, <b>C</b> and <b>D</b> &mdash; the dimensions of the grid and the mass you expected each cell to have. The next <b>R</b> lines each contain <b>C</b> digits <b>w<sub>ij</sub></b> each, giving the differences between the actual and the expected mass of the grid cells. Each cell has a uniform density, but could have an integer mass between <nobr><b>D + 0</b></nobr> and <nobr><b>D + 9</b></nobr>, inclusive.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: <b>K</b>\", where x is the case number (starting from 1) and <b>K</b> is the largest possible size of the blade you can cut out. If no acceptable blade of size at least 3 can be found, print \"IMPOSSIBLE\" instead.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 20.<br/>\n0 &le; <b>w<sub>ij</sub></b> &le; 9.<br/>\nThe size of the input file will not exceed 625KB.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n3 &le; <b>R</b> &le; 10.<br/>\n3 &le; <b>C</b> &le; 10.<br/>\n1 &le; <b>D</b> &le; 100.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n3 &le; <b>R</b> &le; 500.<br/>\n3 &le; <b>C</b> &le; 500.<br/>\n1 &le; <b>D</b> &le; 10<sup>6</sup>.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n6 7 2\n1111111\n1122271\n1211521\n1329131\n1242121\n1122211\n3 3 7\n123\n234\n345\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5\nCase #2: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<h3>Note</h3>\n<p>\nThe <i>center of mass</i> of a 2D object is formally defined as a point <b>c</b>. If you compute the sum of <nobr>(<b>p</b> - <b>c</b>) * mass(<b>p</b>)</nobr> for all points <b>p</b> in the object, you must get <b>0</b>. Here, <b>p</b>, <b>c</b> and <b>0</b> are two-dimensional vectors. This definition also works if you treat each grid cell as a \"point\", with all of its mass at its center.\n</p>\n<p>\nIn real life, you could place your finger under a flat object's center of mass, and balance that object on your finger.  It would not fall.\n</p>\n<p>\nTo illustrate with an example, the only blade that is possible to cut out in the second sample test case, the 3x3 blade created by cutting away the corners, has its center of mass at the point (1.54, 1.46), where we assume the bottom-left corner of the sheet has coordinates (0, 0), and the coordinates grow right and up, respectively. This is verified by checking the following equality: <nobr>(-1.04, 0.04) * 9 + (-0.04, 1.04) * 9 + (-0.04, 0.04) * 10 + (-0.04, -0.96) * 11 + (0.96, 0.04) * 11 = (0, 0)</nobr>.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Spinning Blade","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem might look pretty intimidating at first:\n</p>\n<ul>\n<li>There are <b>N</b>! possible orders in which your friends could arrive.</li>\n<li>Not only is O(<b>N</b>!) too slow for this problem, even O(<b>N</b>) is too slow!</li>\n<li>The actual price your friends are paying will quickly exceed the bounds of a 64-bit integer.</li>\n</ul>\n<p>\nWhen O(<b>N</b>) is too slow, it means you need to forget about coding for a while and think. You will need some insight to even get started.\n</p>\n\n<p>\nLet's begin by fixing an ordering (x<sub>1</sub>, x<sub>2</sub>, ..., x<sub><b>N</b></sub>) of your friends. Also let y<sub>i</sub> be the total price that your group is paying after the first i friends enter, the waiter has been called if necessary, and everyone has become happy.\n</p>\n\n<br/>\n<p>\n<b>Observation 1:</b> y<sub>i</sub> = LCM(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>i</sub>). This does not depend on the order your friends buy things after the waiter has been called.\n</p>\n\n<p>\n<b>Explanation:</b> LCM(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>i</sub>) is, by definition, the smallest multiple of x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>i</sub>. Since y<sub>i</sub> must be a multiple of all these numbers for your friends to be happy, it is certainly true that y<sub>i</sub> &ge; LCM(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>i</sub>). Conversely, a friend x<sub>j</sub> would never buy something that skips over a multiple of x<sub>j</sub>. In particular, none of the friends here would buy something that would skip over LCM(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>i</sub>). Since y<sub>i-1</sub> &le; LCM(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>i</sub>), you will eventually reach this price and then stop.\n</p>\n<br/>\n\n<p>\nLet <b>M</b> be the number of times the waiter is called over. Then, <b>M</b> is equal to the number of values i in {1, 2, ..., <b>N</b>} such that y<sub>i</sub> != y<sub>i-1</sub>. (We define y<sub>0</sub> = 0, because the waiter is always called over by the first friend who enters.) So the question becomes: how do we make <b>M</b> as big as possible according to this definition, and how do we make it as small as possible?\n</p>\n\n<p>\nLeast common multiples are closely related to prime numbers and factorizations, so let's define p<sub>1</sub>, p<sub>2</sub>, ..., p<sub><b>P</b></sub> to be the primes less than or equal to <b>N</b>. Also let e<sub>i</sub> be the largest integer such that p<sub>i</sub><sup>ei</sup> is less than or equal to <b>N</b>.\n</p>\n\n<p>\n<br/>\n<b>Observation 2:</b> Let <b>P'</b> be 1 + sum e<sub>i</sub> (i.e., the number of prime powers less than or equal to <b>N</b>, including 1). Then the maximum value of <b>M</b> is exactly equal to <b>P'</b>.\n</p>\n\n<p>\n<b>Explanation:</b> Suppose your friends arrive in the order 1, 2, ..., <b>N</b>. Then each friend with a prime power index will cause the price to increase, and so the maximum value of <b>M</b> is at least <b>P'</b>.\n</p>\n\n<p>\nOn the other hand, the price is always a least-common multiple by the first observation, and it always increases to a multiple of itself. In particular, the sum of the exponents in its prime factorization must always go up every time the waiter is called. After the first friend arrives, this sum is at least 0. At the very end, it is equal to <b>P'</b> - 1. Therefore, the waiter can be called at most <b>P'</b> - 1 times after the first person arrives. Combining that with the initial increase proves that <b>M</b> &le; <b>P'</b>.\n</p>\n\n<p>\n<br/>\n<b>Observation 3:</b> If <b>N</b> &gt; 1, then the minimum value of <b>M</b> is equal to <b>P</b>.\n</p>\n\n<p>\n<b>Explanation:</b> Suppose the first friends to arrive are numbered p<sub>1</sub><sup>e1</sup>, p<sub>2</sub><sup>e2</sup>, ..., p<sub><b>P</b></sub><sup>e<b>P</b></sup>. Then the price is already equal to\nLCM(p<sub>1</sub><sup>e1</sup>, p<sub>2</sub><sup>e2</sup>, ..., p<sub><b>P</b></sub><sup>e<b>P</b></sup>) = LCM(1, 2, ..., <b>N</b>) after these friends have arrived. This means no subsequent friend will change the total price, and hence <b>M</b> = <b>P</b> in this case. \n</p>\n\n<p>\nOn the other hand, notice there is no number less than <b>N</b> that is divisible by both <b>p</b><sub>i</sub><sup>ei</sup> and <b>p</b><sub>j</sub><sup>ej</sup>. This is because <b>p</b><sub>i</sub><sup>ei</sup> and <b>p</b><sub>i</sub><sup>ej</sup> are relatively prime and larger than sqrt(<b>N</b>). (If one of them was at most sqrt(<b>N</b>), then its exponent could be increased, which is a contradiction.) Therefore, no single friend can make the total price divisible by two different entries out of {p<sub>1</sub><sup>e1</sup>, p<sub>2</sub><sup>e2</sup>, ..., p<sub><b>P</b></sub><sup>e<b>P</b></sup>}. And so the waiter must be called at least <b>P</b> times, as claimed.\n</p>\n<br/>\n\n<p>\nTo solve the small input, you can just calculate <b>P</b> and <b>P'</b> directly and go from there. The large input requires one last clever trick. The number of primes less than 10<sup>12</sup> is quite large, and you probably cannot afford to just count them all. However, calculating <b>P</b> - <b>P'</b> is actually easier than this!\n</p>\n\n<p>\nIf you go back to the original definitions, you can see <b>P</b> - <b>P'</b> is precisely the number of integers less than or equal to <b>N</b> that can be written in the form p<sup>e</sup> for e != 1. When e = 0, you just get 1. When e &gt; 1, then p &le; 10<sup>6</sup>, and you can easily enumerate all primes of this size! One good way is to use the <a href=\"http://www.google.com/search?q=sieve+of+eratosthenes\" target=\"_blank\">Sieve of Eratosthenes</a>. As always, you can look at solutions from other contestants to see a full implementation.\n</p>\n\n<br/>\n<p>\n<b>Bonus Comment:</b> The Sieve of Eratosthenes runs in O(<b>M</b> * log log <b>M</b>) time, so the simplest implementation of the method described here runs in O(sqrt(<b>N</b>) * <b>T</b> * log log <b>N</b>) time altogether. However, it's worth pointing out that you can do even better. If you pre-compute and sort all prime powers less than 10<sup>12</sup> with exponent other than one, you can then use a binary search to very efficiently count how many are less than <b>N</b> for each test case. This is not necessary to solve the problem, but it lets you speed things up even more to a blazing O(sqrt(<b>N</b>) * log log <b>N</b> + <b>T</b> * log <b>N</b>). Proving this running time is a little tricky though!\n</p>\n","id":"0000000000432b31","statement":"<h3>Problem</h3>\n<p>\nYour friends are all going to a restaurant for dinner tonight.  They're all very good at math, but they're all very strange: your <b>a</b><sup>th</sup> friend (starting from 1) will be <i>unhappy</i> unless the total cost of the meal is a positive integer, and is divisible by <b>a</b>.\n</p>\n<p>\nYour friends enter the restaurant one at a time.  As soon as someone enters the restaurant, if that person is unhappy then the group will <i>call</i> a waiter immediately.\n</p>\n<p>\nAs long as there is at least one unhappy person in the restaurant, one of those unhappy people will buy the lowest-cost item that will make him or her happy. This will continue until nobody in the restaurant is unhappy, and then the waiter will leave.  Fortunately, the restaurant sells food at every integer price.  See the explanation of the first test case for an example.\n</p>\n<p>\nYour friends could choose to enter the restaurant in any order.  After the waiter has been called, if there is more than one unhappy person in the restaurant, any one of those unhappy people could choose to buy something first.  The way in which all of those choices are made could have an effect on how many times the group calls a waiter.\n</p>\n<p>\nAs the owner of the restaurant, you employ some very tired waiters.  You want to calculate the <b>spread</b> of your friends: the difference between the maximum number of times they might call a waiter and the minimum number of times they might call a waiter.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow, each on its own line.  Each test case will contain one integer <b>N</b>, the number of friends you have.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the spread for that test case.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 1000.<br/>\n1 &le; <b>N</b> &le; 10<sup>12</sup>.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1\n3\n6\n16\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 1\nCase #3: 2\nCase #4: 5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<h4>Explanation</h4>\n\n<p>\nIn Case #2, suppose your friends arrive in the order [1, 2, 3].  Then #1 arrives; is unhappy; calls a waiter; and buys something costing 1.  Now nobody is unhappy.  #2 arrives next; is unhappy; calls a waiter; and buys something costing 1 (for a total of 2).  Now nobody is unhappy.  #3 arrives next; is unhappy; calls a waiter; and buys something costing 1 (for a total of 3).  Now #2 is unhappy, and buys something costing 1 (for a total of 4).  Now #3 is unhappy, and buys something costing 2 (for a total of 6).  Finally nobody is unhappy, and a waiter was called three times.\n</p>\n<p>\nSuppose instead that your friends arrived in the order [3, 1, 2].  Then #3 arrives; is unhappy; calls a waiter; and buys something costing 3.  Now nobody is unhappy. #1 arrives next; nobody is unhappy.  #2 arrives next; is unhappy; calls a waiter; and buys something costing 1 (for a total of 4).  Now #3 is unhappy, and buys something costing 2 (for a total of 6).  Now nobody is unhappy, and a waiter was called two times.  The spread is 1.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Expensive Dinner","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe computer game A.I. War hides at least a few good algorithmic problems.  The\nauthor is anything but an expert, but musing about the game brought both this\nproblem and Space Emergency (which originally took place on a graph\nlike this one) to life.  The game presents a trickier version of this problem:\nthere are two A.I. homeworlds, multiple other planets that you might want to\nvisit, and you don't know where to find any of them at the start of the game.\nFortunately, here we're dealing with a simplified version of the problem and\nyou didn't have to know anything about the game.\n</p>\n<p>\nLet's first state the problem in graph theory terms. We are given an\nundirected graph with <b>P</b> vertices and <b>W</b> edges. We are looking\nfor a sequence of vertices, starting with vertex 0 (our home planet) and ending\nwith a neighbor of 1 (A.I.'s home planet), such that:\n</p>\n<ul>\n  <li>every vertex in the sequence is adjacent to one of the previous vertices\n  <li>the sequence is as short as possible\n  <li>given the above, the number of distinct neighbors of the vertices in the\n  sequence, but outside the sequence, must be as large as possible\n</ul>\n<p>\nLet <b>D</b> be the distance from vertex 0 to vertex 1. It's clear that every such sequence\nmust have at least <b>D</b> elements. We also note that we will achieve\nexactly <b>D</b> elements if and only if the sequence forms a shortest path\nfrom vertex 0 to vertex 1. Hence we're looking for a shortest path. Unfortunately, there may\nbe many shortest paths and we have to pick the one that optimizes the last\nrequirement.\n</p>\n<p>\nIt simplifies things to include among the \"threatened\" planets those planets\nthat we do conquer. Given that we already know that we have to conquer exactly\n<b>D</b> planets, we just have to subtract <b>D</b> at the end.\n</p>\n\n<h3>Crucial observation</h3>\n\n<p>The crucial observation for solving the problem is the following: if a\nvertex is at distance <b>d</b> from 0, it can only be threatened by a vertex at\ndistance <b>d</b> - 1, <b>d</b> or <b>d</b> + 1. This is true because the distances of two adjacent vertices differ by at most 1.\nTherefore every vertex in the graph is only threatened (or conquered) within at\nmost three consecutive vertices in the path. As we will see, this observation allows us to use dynamic programming to compute best paths of larger and larger lengths.\n</p>\n<h3>The algorithm</h3>\n\n<p>The first step in our algorithm is to run\n<a href=\"http://en.wikipedia.org/wiki/Breadth-first_search\" target=\"_blank\">breadth-first search</a>\nto compute for every vertex <b>v</b> its distance from 0: dist[<b>v</b>].\ndist[0] = 0 and dist[1] = <b>D</b>. Every shortest path will start with vertex 0, then continue with vertices at\ndistance 1, distance 2, ..., distance <b>D</b>-1.\n</p>\n\n<p>For any two adjacent\nvertices <b>a</b>, <b>b</b> such that dist[<b>b</b>] = dist[<b>a</b>] + 1,\ndefine <b>F</b>(<b>a</b>, <b>b</b>) = the maximum number of planets threatened\nor conquered by a shortest path 0&rarr;...&rarr;<b>a</b>&rarr;<b>b</b>. We will compute this\nusing dynamic programming for increasing distances from 0.\nThe answer to\nthe problem is the maximum value of <b>F</b>(<b>a</b>, <b>b</b>) - <b>D</b>,\nwhere <b>a</b>, <b>b</b> are adjacent, dist[<b>a</b>] = <b>D</b>-2,\ndist[<b>b</b>] = <b>D</b>-1, and <b>b</b> is adjacent to 1.\n</p>\n<p>\n<b>F</b>(0, <b>a</b>) can be computed directly (there is only one path possible).\nIt remains to compute the values of <b>F</b> for a given distance, given\nthe values of <b>F</b> at a previous distance. To compute <b>F</b>(<b>b</b>,\n<b>c</b>), dist[<b>b</b>]=<b>d</b>, dist[<b>c</b>]=<b>d</b> + 1, try all\nvertices <b>a</b> adjacent to <b>b</b> such that dist[<b>a</b>] = <b>d</b> - 1.\nIn other words, we are looking for paths ending with <b>a</b>&rarr;<b>b</b>&rarr;<b>c</b>.\nWe have already computed the value of <b>F</b>(<b>a</b>, <b>b</b>) in the\nprevious iteration, the question is: how many new unique threatened vertices\ndoes extending the path to <b>c</b> add?\n</p>\n\n<p>This is where our \"crucial observation\" becomes useful. If a neighbor of\n<b>c</b> was already threatened (or conquered) before, it must have been a\nneighbor of either <b>a</b> or <b>b</b>. Therefore we must add the number of\nneighbors of <b>c</b> that are not neighbors of either <b>a</b> or <b>b</b>.\nLet's call this value <b>G</b>(<b>a</b>, <b>b</b>, <b>c</b>). So we have the\nrecursive formula that we can use for dynamic programming:<br>\n<b>F</b>(<b>b</b>, <b>c</b>) = max<sub><b>a</b></sub> <b>F</b>(<b>a</b>, <b>b</b>) +\n<b>G</b>(<b>a</b>, <b>b</b>, <b>c</b>).\n</p>\n\n<h3>Computing G: four algorithms</h3>\n\n<p>We are almost done, but how do we compute the values of\n<b>G</b>, and what is the total run-time of the algorithm? There are O(<b>W</b>) values of <b>F</b> to compute (at most one for each\nedge), and for each one we look at O(<b>P</b>) other values of <b>F</b> (one for\neach <b>a</b>). So if we already knew all the values of <b>G</b>, it would take\nO(<b>PW</b>) time to compute all the values of <b>F</b> and solve the problem.\nComputing the values of <b>G</b> turns out to be the most\ntime-consuming part though.\n</p>\n\n<p>We may have to compute <b>G</b>(<b>a</b>, <b>b</b>, <b>c</b>) for every sub-path\n<b>a</b>&rarr;<b>b</b>&rarr;<b>c</b> of increasing dist. How do we compute these values?\nWe have thought of at least 4 ways. In the actual contest it didn't really\nmatter which you chose, all would easily run in time, but we will mention them\njust for fun.</p>\n\n<p>\n<ul>\n<li><b>Approach 1.</b> We need to compute the number of vertices <b>v</b> such\nthat <b>v</b> is a neighbor of <b>c</b>, but not of <b>a</b> or <b>b</b>. The\nsimplest approach here is to just check this condition for every <b>v</b>. This\ncomputation takes O(<b>P</b>) time. How many values do we need to compute? At\nmost O(<b>P</b><sup>3</sup>), which gives a total run-time of\nO(<b>P</b><sup>4</sup>) for the whole algorithm. We can give a better estimate.\nSince <b>a</b> and <b>b</b> are neighbors, there are at most <b>W</b> such\npairs. This gives the total run-time of O(<b>P</b><sup>2</sup>&nbsp;<b>W</b>).\n<li><b>Approach 2.</b> Modify approach 1 slightly. Instead of checking every\nvertex <b>v</b>, we only need to check every neighbor of <b>c</b>. This way\nthere are O(<b>W</b>) pairs <b>a</b>, <b>b</b> and O(<b>W</b>) pairs <b>c</b>,\n<b>v</b>, which gives the total run-time of O(<b>W</b><sup>2</sup>).\n<li><b>Approach 3.</b> Modify approach 1 in another way. Precompute the\nset of neighbors of each vertex as a bitmask neighbors[<b>v</b>]. Now\nwe are simply interested in the number of bits set in (neighbors[<b>c</b>] <b>and\n  not</b> (neighbors[<b>a</b>] <b>or</b> neighbors[<b>b</b>]). This is a speedy\ncomputation due to\n<a href=\"http://en.wikipedia.org/wiki/Bit-level_parallelism\" target=\"_blank\">bit-level\n  parallelism</a>. If our computer has machine words of size <b>w</b> (this is\ntypically 32 or 64),\nwe cut our work by a factor of <b>w</b>. This assumes that we can count the\nnumber of bits set in a word in a single step, which modern processors support\nin a single machine instruction. The final runtime:\nO(<b>P</b><sup>2</sup>&nbsp;<b>W</b>&nbsp;/&nbsp;<b>w</b>).\n<li><b>Approach 4.</b> Finally, we come to a theoretically interesting, but rather\ncomplex to implement aproach. Define two matrices, <b>A</b> of size <b>W</b> x\n    <b>P</b>, and <b>B</b> of size <b>P</b> x <b>P</b>, as follows.\n    <b>A</b><sub><b>ij</b></sub> = 1 if vertex number <b>j</b> does\n    not neighbor any of the two endpoints of the edge number <b>i</b>, 0\n    otherwise. <b>B</b><sub><b>ij</b></sub> = 1 if vertices number <b>i</b>,\n    <b>j</b> are adjacent (or equal), 0 otherwise. Now compute the matrix\n    product <b>C</b> = <b>A</b> * <b>B</b>. If we apply the definition of\n    matrix product and do the math, we will see that <b>C</b> is a <b>W</b> x\n    <b>P</b> matrix and that the entries are exactly the values of <b>G</b>.\n    Specifically, <b>C</b><sub><b>ij</b></sub> = <b>G</b>(<b>a</b>, <b>b</b>,\n    <b>j</b>) if the <b>i</b>-th edge is <b>a</b>&harr;<b>b</b>.\n\n    <br>\n    If we evaluate the matrix product in the natural way, we get the same\n    complexity as in approach 1: O(<b>P</b><sup>2</sup>&nbsp;<b>W</b>). We have basically expressed approach 1 in matrix\n    notation.<br>\n    The trick is that there are faster matrix multiplication algorithms. The\n    fastest currently known is the <a href=\"http://en.wikipedia.org/wiki/Coppersmith%E2%80%93Winograd_algorithm\" target=\"_blank\">Coppersmith-Winograd algorithm</a>. To make a long story short, it gives us a theoretical asymptotic run-time of O(<b>P</b><sup>1.376</sup>&nbsp;<b>W</b>).\n</ul>\n<p>We do not recommend the last approach in the contest. Not only is this\nunnecessarily complicated, it also wouldn't actually run any faster for the graph sizes we are\nconsidering. The asymptotic advantage would only materialize for impractically\nenormous, dense graphs.</p>\n","id":"0000000000432cd0","statement":"<h3>Introduction</h3>\n<p>\nA.I. War is a real-time strategy game developed by Arcen Games.  This problem was inspired by the game, but does not assume you have played it.\n</p>\n\n<h3>Problem</h3>\n<p>\nYou're facing an artificial intelligence in a deadly war for the future of the galaxy.  In order to defeat the A.I., you will need to threaten its <i>home planet</i>.  Some planets are connected to each other by wormholes; any planet may be connected to any number of other planets using the wormholes.\n</p>\n<p>\nYou begin by owning only your home planet.  Each turn, you may conquer any planet you <i>threaten</i>.  You threaten a planet if you don't own it, and it is connected by a wormhole to any of the planets you own.  Once you have conquered a planet, you own it.   As soon as you threaten the A.I.'s home planet, you may not conquer any more planets.\n</p>\n<p>\nWhile attending the most important day in tactical school, you discovered two things about the A.I.:\n</p>\n<ul>\n<li>For each planet you conquer, the A.I. will become more powerful, because it will see you as a threat and produce more ships to defend itself.</li>\n<li>The A.I. will defend every planet you're currently threatening.</li>\n</ul>\nYou have combined those two facts to create a strategy:\n<ol>\n<li>You will conquer planets until you threaten the A.I.'s home base.</li>\n<li>If there are multiple ways of completing step 1, do it while conquering the <b>smallest</b> possible number of planets.</li>\n<li>If there are multiple ways of completing step 2, do it so that at the end you will threaten the <b>largest</b> possible number of planets.</li>\n</ol>\n<p>\nGiven the planets and the wormholes, how many planets will you conquer and threaten on your way to the A.I.'s home base if you follow the strategy described above?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case starts with a single line containing two space-separated integers: <b>P</b>, the number of planets, and <b>W</b>, the number of wormholes.  Your home planet is planet 0, and the A.I.'s home planet is planet 1.\n</p>\n<p>\nThe second line of each test case will contain <b>W</b> space-separated pairs of comma-separated integers <b>x</b><sub>i</sub>,<b>y</b><sub>i</sub>.  Each of these indicates that there is a two-way wormhole connecting planets <b>x</b><sub>i</sub> and <b>y</b><sub>i</sub>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: c t\", where x is the case number (starting from 1), c is the number of planets you conquer if you follow the above strategy, and t is the number of planets you threaten at the end (including the A.I.'s home planet).\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 50.<br/>\n0 &le; <b>x</b><sub>i</sub> &lt; <b>y</b><sub>i</sub> &lt; <b>P</b>.<br/>\nEach wormhole is unique: If i &ne; j, then (<b>x</b><sub>i</sub>, <b>y</b><sub>i</sub>) &ne; (<b>x</b><sub>j</sub>, <b>y</b><sub>j</sub>).<br/>\nThere will be at least one way to reach the A.I.'s home planet from your home planet using a series of wormholes.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n2 &le; <b>P</b> &le; 36.<br/>\n1 &le; <b>W</b> &le; 630.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n2 &le; <b>P</b> &le; 400.<br/>\n1 &le; <b>W</b> &le; 2000.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2 1\n0,1\n3 3\n0,1 1,2 0,2\n5 5\n0,4 0,2 2,4 1,2 1,4\n7 9\n0,6 0,2 0,4 2,4 3,4 2,3 3,5 4,5 1,5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 1\nCase #2: 0 2\nCase #3: 1 2\nCase #4: 2 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<h3>Explanation</h3>\n<p>\nIn the first case, you don't have to conquer anything, and you're already threatening the A.I.'s home planet.\n</p>\n<p>\nIn the third case, you can threaten the A.I.'s home planet after conquering only one planet.  You end up threatening two planets, and there's an extra planet that isn't connected to anything.\n</p>\n<p>\nIn the fourth case, you can threaten the A.I.'s home planet by conquering planets 4 and 5.  You end up threatening planets 6, 2, 3 and 1 (the A.I.'s home planet).\n</p>\n\n<h3>Note</h3>\n<p>\nArcen Games is the creator of A.I. War.  Arcen Games does not endorse and has no involvement with Google Code Jam.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":22}],"title":"A.I. War","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nSome people will tell you that programming contest problems, while interesting to think about, have no practical use in the real world. After solving this problem, you can laugh at these people as you catch your flight and they are left waiting in line at the airport with all the other chumps.\n</p>\n\n<p>\nAn important thing to notice about this problem is that the location of the walkways does not matter, since you can instantly transition between different speeds. This means that two walkways with speed <b>v</b> of length <b>L<sub>1</sub></b> and <b>L<sub>2</sub></b> can be combined into a single walkway of length <b>L<sub>1</sub> + L<sub>2</sub></b> with speed <b>v</b>. By combining this with the observation that any section of corridor with no walkway is equivalent to a walkway with <b>v = 0</b>, you reduce the problem to having 101 different speed walkways of variable length (possibly 0) and deciding for each whether to run or walk (or do some of each).\n</p>\n\n<p>\nThe small dataset can be solved by brute force. Let <b>W</b> be the set of all positive length walkways (each with a unique speed). Since there are only <b>|W| &le; 21</b> different speed walkways to consider, you can simply try choosing each subset <b>S &sube; W</b> of them to run (and just walk the rest, <b>W - S</b>). This solution is slightly complicated by the fact that once you choose <b>S</b>, you still have to decide which one to only run partially, in case you don’t have time to run them all fully. However, you can again just brute force this decision by iterating over each walkway <b>x &isin; S</b> and only running on walkway <b>x</b> with whatever time is left after completely running all walkways in <b>S - {x}</b>. You simply take the minimum over all choices, discarding any choice which requires more than <b>t</b> seconds of running time. This can easily be implemented in <b>O(N<sup>2</sup> * 2<sup>N</sup>)</b> and will run in time for <b>N</b> at most 20.<br/>\n<b>Bonus:</b> Implement this algorithm in <b>O(N * 2<sup>N</sup>)</b> time.\n</p>\n\n<p>\nHowever, this approach will time out for the large data set, where <b>N</b> is at most 1000 and you can have walkways of all 101 different speeds. For this, we need a better way to decide when to run and when to walk. We just need to decide if it’s better to run on slower or faster walkways. It turns out we can solve this with a simple greedy algorithm, and we can prove it is optimal by using a simple <a href=\"http://www.google.com/#q=greedy%20algorithm%20exchange%20argument\" target=\"_blank\">exchange argument</a>.\n</p>\n\n<p>\nLet’s say we have two arbitrary walkways of speed <b>w<sub>1</sub></b> and <b>w<sub>2</sub></b>, with <b>w<sub>1</sub> &lt; w<sub>2</sub></b>. Now let’s say that in some algorithm we’ve decided to run for <b>r<sub>1</sub></b> and <b>r<sub>2</sub></b> seconds on each of the walkways, respectively. If <b>s<sub>1</sub></b> and <b>s<sub>2</sub></b> are the amount of time we spent walking on each of the two walkways, then our total time spent would be <b>T = r<sub>1</sub> + s<sub>1</sub> + r<sub>2</sub> + s<sub>2</sub></b> seconds. What if instead we decided to run for <b>r<sub>1</sub> + &epsilon;</b> seconds on the first walkway and <b>r<sub>2</sub> - &epsilon;</b> seconds on the second walkway, with <b>&epsilon; &gt; 0</b>? Then our total time would be <b>T’ = (r<sub>1</sub> + &epsilon;) + s<sub>1</sub>’ + (r<sub>2</sub> - &epsilon;) + s<sub>2</sub>’</b> seconds. Solving for <b>T - T’</b>, you will get <b>&epsilon; * (w<sub>2</sub> - w<sub>1</sub>) * (R - S) / ((w<sub>1</sub> + S) * (w<sub>2</sub> + S)) &gt; 0</b>, which says that <b>T &gt; T’</b>, and so the change will always be beneficial. Simply put, it’s always better to run on slower walkways as much as possible. <i>Note that some of the details of these equations have been excluded from this analysis and are left as an exercise to the reader.</i>\n<p>\n\n<p>\nHere is some simple Java code which solves the problem:<br/>\n<code>\n<pre>\ndouble res=0;\nfor (int i=0; i&lt;=100; ++i) {\n  double runTime=Math.min(t,W[i]/(i+R));\n  double walkDist=W[i]-runTime*(i+R);\n  double walkTime=walkDist/(i+S);\n  res+=runTime+walkTime;\n  t-=runTime;\n}\nSystem.out.printf(\"Case #%d: %.12f%n\",TC,res);\n</pre>\n</code>\n</p>\n\n<p>\n<b>Bonus:</b> Solve the problem if the limits changed to 1 &leq; <b>w<sub>i</sub></b> &leq; 10<sup>9</sub>.\n</p>","id":"000000000043324d","statement":"<h3>Problem</h3>\n<p>\nYou're in an airport, standing at point 0. A corridor of length <b>X</b> leads to the gate, where your plane is about to leave. There are moving walkways in the corridor, each moving with some speed <b>w<sub>i</sub></b>. When you walk or run on one of those, you move with speed (your speed + <b>w<sub>i</sub></b>). The walkways do not change their position; they just make you move faster. The walkways do not overlap: at any given point of the corridor there is at most one walkway, but one walkway can begin at the point where another ends.\n</p>\n\n<p>\nYour normal walking speed is <b>S</b>. You are worried that you might not catch your plane, though, so you can run a bit - you can run with speed <b>R</b> for at most <b>t</b> seconds in total. You do not have to run for <b>t</b> consecutive seconds: you can split these <b>t</b> seconds into any number of intervals, or even not use some part of them.\n</p>\n\n<p>\nHow long does it take you to get to the gate, assuming you choose when to walk and when to run in order to reach it as soon as possible?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case begins with a line containing five integers: <b>X</b> (the length of the corridor, in meters), <b>S</b> (your walking speed, in meters per second), <b>R</b> (your running speed, in meters per second), <b>t</b> (the maximum time you can run, in seconds) and <b>N</b> (the number of walkways).\n</p>\n<p>\nEach of the next <b>N</b> lines contains three integers: <b>B<sub>i</sub></b>, <b>E<sub>i</sub></b> and <b>w<sub>i</sub></b> - the beginning and end of the walkway (in meters from your starting point) and the speed of the walkway (in meters per second).\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the time (in seconds) you need to reach point <b>X</b> if you walk and run optimally. Answers with relative or absolute error of at most 10<sup>-6</sup> will be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 40.<br/>\n1 &le; <b>S</b> &lt; <b>R</b> &le; 100.<br/>\n1 &le; <b>w<sub>i</sub></b> &le; 100.<br/>\n0 &le; <b>B<sub>i</sub></b> &lt; <b>E<sub>i</sub></b> &le; <b>X</b>.<br/>\n<b>E<sub>i</sub></b> &le; <b>B<sub>i+1</sub></b>.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>t</b> &le; 100.<br/>\n1 &le; <b>X</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 20.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>t</b> &le; 10<sup>6</sup>.<br/>\n1 &le; <b>X</b> &le; 10<sup>6</sup>.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n10 1 4 1 2\n4 6 1\n6 9 2\n12 1 2 4 1\n6 12 1\n20 1 3 20 5\n0 4 5\n4 8 4\n8 12 3\n12 16 2\n16 20 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4.000000\nCase #2: 5.500000\nCase #3: 3.538095238\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<p>\nThe best solution in the first case is to start running immediately and run for one second.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Airport Walkways","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432f3b","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2011"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
