{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1619868600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000004362d7","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\r\nThe final of the Round 1s of 2021, Round 1C, was quite\r\n<a href=\"https://en.wikipedia.org/wiki/International_Workers%27_Day\" target=\"_blank\">laborious</a>.\r\nThe first problem, <i>Closest Picks</i>, was all about carefully picking your bets to\r\nmaximize your odds. It could be solved with a combination of simple probabilities and\r\na greedy strategy. <i>Roaring Years</i> took us on a history refresher course, but besides\r\nthe playful reference, it was all about properly splitting the space into disjoint cases,\r\nand a solution followed straightforwardly from that. Finally, <i>Double or NOTing</i>\r\nlooked like a classical application of graph algorithms. However,\r\nto get the full points you had to go a different route and think\r\ncarefully about binary representations.\r\n</p><p>\r\nThe first perfect score took just over an hour, which was longer than both of the other Round 1s.\r\nThis gave <b>nqiiii</b> first place in the round. <b>daltao</b> and <b>square1001</b> came in\r\nsecond and third place, respectively. Ultimately, 71 coders managed a perfect score.\r\nAround 8000 coders submitted solutions in today's contest. The unofficial cutoff to advance to\r\nRound 2 is 54 points.\r\n</p><p>\r\nThis wraps up our Round 1s for the year. We'll finalize the results in the coming\r\ndays. In the meantime, you can keep improving your skills by practicing on this round's or\r\nany past round's problems in the\r\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/archive\" target=\"_blank\">archive</a>.\r\n</p><p>\r\nIf you placed in the top 1500, we will see you again in about 2 weeks as you join\r\n3000 participants coming from the other Round 1s to compete in Round 2. Don't forget\r\nto check your local time in the\r\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/schedule\" target=\"_blank\">schedule</a>\r\npage. If you didn't earn enough points to advance, we hope you had a wonderful time\r\nwith our first 14 problems of the year. You are invited to follow along for the rest of the season,\r\nand we hope to see you again next year!\r\n</p>\r\n<hr>\r\n<p>\r\n  <b>Cast</b>\r\n</p>\r\n<p>\r\n  Closest Pick: Written by Pablo Heiber. Prepared by Timothy Buzzelli.\r\n</p><p>\r\n  Roaring Years: Written by Ian Tullis. Prepared by Artem Iglikov.\r\n</p><p>\r\n  Double or NOTing: Written by Ian Tullis. Prepared by Artem Iglikov.\r\n</p><p>\r\nSolutions and other problem preparation and review by Abhishek Singh, Andy Huang, Artem Iglikov,\r\nDarcy Best, Ian Tullis, Liang Bai, Max Ward, Md Mahbubul Hasan, Nafis Sadique, Pablo Heiber,\r\nSadia Atique, Swapnil Gupta, Timothy Buzzelli, and Yui Hosaka.\r\n</p><p>\r\nAnalysis authors:\r\n</p><ul>\r\n  <li>Closest Pick: Pablo Heiber.</li>\r\n  <li>Roaring Years: Pablo Heiber.</li>\r\n  <li>Double or NOTing: Artem Iglikov.</li>\r\n</ul>\r\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1619859600000,"tasks":[{"analysis":"<h3>Test Set 1</h3>\n<p>\nIn Test Set 1, the limits are small enough that we can try every one of the\n$$$\\mathbf{K}^2$$$ possible pairs of integers to pick. For each of those, we can calculate the\nprobability of winning with each possible draw. There are $$$\\mathbf{K}$$$ possible values for $$$c$$$.\nIf for each one, we check the distance to each $$$\\mathbf{P_i}$$$ and to our own two picks, we end up\nwith an overall running time of $$$O(\\mathbf{K}^3 \\cdot \\mathbf{N})$$$. This is fast enough to pass.\n</p><p>\nThere are several possible optimizations.\nA simple one is to search for the \"closest picked integer\" using a sorted\nstructure, reducing that phase to $$$O(\\log \\mathbf{N})$$$ and the overall running\ntime to $$$O(\\mathbf{K}^2 \\cdot \\mathbf{N} \\log \\mathbf{N})$$$. It is also possible to search for the\ndistance from each $$$c$$$ to each $$$\\mathbf{P_i}$$$ only once, independently of our choices,\nwhich reduces the overall running time further to $$$O(\\mathbf{K}^2)$$$.\n</p>\n<h3>Test Set 2</h3>\n<p>\nFor Test Set 2, we can optimize all phases from the previous solution.\nIf every integer is already picked at least once, then the answer is\nalways $$$0$$$ as the samples demonstrate. Otherwise,\nwe can divide the non-purchased integers from $$${1, 2, ..., \\mathbf{K}}$$$\ninto intervals between $$$\\mathbf{P_i}$$$s. For example, if the $$$\\mathbf{P_i}$$$ values are\n$$$3, 4, 8, 3$$$ and $$$\\mathbf{K}=8$$$, the intervals would be\n$$$[1, 2], [5, 7]$$$.\n</p><p>\nIf we make only one of our picks within\none of those intervals, we can get closest to all of it if the interval contains\n$$$1$$$ or $$$\\mathbf{K}$$$, by picking ours next to the only delimiting $$$\\mathbf{P_i}$$$\n(picking $$$2$$$ from $$$[1, 2]$$$ in the example above). If the interval\nis surrounded by two $$$\\mathbf{P_i}$$$s, we can get closest to at most half of\nthe integers in the interval (rounding up), which is achievable by picking either end\n(picking either $$$5$$$ or $$$7$$$ from $$$[5, 7]$$$).\nIf we make both of our picks\nwithin one of those intervals, we can get closest to all integers in the interval\nby picking both ends ($$$5$$$ and $$$7$$$ from $$$[5, 7]$$$).\n</p><p>\nThis shows that only integers that are next to an already purchased\ninteger are worth picking for ourselves. At this point, we can go back to our last\nTest Set 1 solution and do the same but restricting our picks to integers next to\na $$$\\mathbf{P_i}$$$, which makes the $$$\\mathbf{K}$$$s in the running time be $$$O(\\mathbf{N})$$$, making it\nfast enough with the right implementation.\n</p><p>\nA few extra reasoning steps lead to a much more efficient solution. There are only\n$$$O(\\mathbf{N})$$$ ways to make both picks within the same interval, and we can check each\nof them. If we choose two different intervals, it is always optimal to choose the\ntwo most valuable ones, so we do not need to check each combination separately. This leads\nto a single additional case that requires $$$O(\\mathbf{N})$$$ time to compute to find the\ntop two intervals. All in all, this solution takes only linear time (after sorting the array to find\nthe intervals). This solution\nrequires some care about corner cases, specifically the cases when no or just one\ninteger from $$$[1, \\mathbf{K}]$$$ is not a $$$\\mathbf{P_i}$$$, and the case of the intervals list containing\na single interval.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U06hW0D0S89hnGtwLm2KDQiYOYDfWhcrEt4w3sH8OrBSkjdPYJhqoYDP1BKZ_C57XHtEXdU_H6f/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"00000000007c0f00","statement":"<h3>Problem</h3>\n<p>\nYou are entering a raffle for a lifetime supply of pancakes.\n$$$\\mathbf{N}$$$ tickets have already been sold. Each ticket contains a single integer between\n$$$1$$$ and $$$\\mathbf{K}$$$, inclusive. Different tickets are allowed to contain the same integer.\nYou know exactly which numbers are on all of the tickets already sold and would like to maximize\nyour odds of winning by purchasing two tickets (possibly with the same integer on them).\nYou are allowed to choose which integers between $$$1$$$ and $$$\\mathbf{K}$$$, inclusive, are\non the two tickets.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2Ed1w-41W6O_Byu_wOZ9PG91eUw1CPqftbE-BwIPg2caSAvuBC1R30mlI-cipSG3PVZe45eT5q0DfTcfs4pg/closest_pick.png\" style=\"max-width:550px;\" alt=\"Two piles of tickets. The left has numbers 1, 3, and 7. The right has numbers 4 and 8.\">\n</p><p>\nYou know you are the last customer, so after you purchase your tickets, no more tickets will\nbe purchased. Then, an integer $$$c$$$ between $$$1$$$ and $$$\\mathbf{K}$$$, inclusive, is\nchosen uniformly at random. If one of your tickets is strictly closer to $$$c$$$ than\nall other tickets or if\nboth of your tickets are the same distance to $$$c$$$ and strictly closer than all other tickets,\nthen you win the raffle.\nOtherwise, you do not win the raffle.\n</p><p>\nGiven the integers on the $$$\\mathbf{N}$$$ tickets purchased so far, what is the maximum probability of\nwinning the raffle you can achieve by choosing the integers on your two tickets optimally?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case consists of two lines. The first line of a test case contains two integers $$$\\mathbf{N}$$$\nand $$$\\mathbf{K}$$$: the number of tickets already sold and the limit of the range of integers to pick from,\nrespectively. The second line contains $$$\\mathbf{N}$$$ integers\n$$$\\mathbf{P_1}, \\mathbf{P_2}, \\dots, \\mathbf{P_N}$$$, representing the integers on the tickets that have already\nbeen purchased.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere <code>$$$x$$$</code> is the test case number (starting from 1) and\n<code>$$$y$$$</code> is the maximum win probability you can achieve if you choose your tickets\noptimally.\n</p>\n<p><code>$$$y$$$</code> will be considered correct if it is within an\nabsolute or relative error of $$$10^{-6}$$$ of the correct answer. See the\n<a href=\"/codejam/faq#competing\">FAQ</a>\nfor an explanation of what that means, and what formats of real numbers\nwe accept.</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 10 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n$$$1 \\le \\mathbf{N} \\le 30$$$.<br/>\n$$$1 \\le \\mathbf{P_i} \\le \\mathbf{K}$$$, for all $$$i$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\n$$$1 \\le \\mathbf{K} \\le 30$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Visible Verdict)</h4>\n<p>\n\n$$$1 \\le \\mathbf{K} \\le 10^9$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0WrZ8Yqg-_CxS0-YKG2MXbmeKtZe1p7ck9Lb3YX1KhOeHJd6cakGfLtXCUdSjHsavaMJ33NPv_M0pk0VxEVp20PAllCXtW1NqZ1ik/closest_pick_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n3 10\n1 3 7\n4 10\n4 1 7 3\n4 3\n1 2 3 2\n4 4\n1 2 4 2\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0PdO4e1whsXLWdlAePq1zGdi_p6r9S6N8zoRiNqMvJCWg4OwUxUP284XXcdxU1mWBumWhOXyNpOrPnsqULBdnlLQ9uk3n-G8fKuCYu/closest_pick_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 0.5\nCase #2: 0.4\nCase #3: 0.0\nCase #4: 0.25\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, you can purchase tickets with the integers $$$4$$$ and $$$8$$$ on them and\n  then win if $$$4, 5, 8, 9$$$, or $$$10$$$ are chosen giving you $$$5/10 = 0.5$$$\n  probability of winning. Purchasing tickets with the integers $$$6$$$ and $$$8$$$ on them\n  also yields a $$$0.5$$$ probability of winning, but no combination yields more.\n</p><p>\n  In Sample Case #2, $$$6$$$ and $$$8$$$ is a possible optimal pair of tickets, which wins when\n  $$$c$$$ is one of $$$6, 8, 9$$$, or $$$10$$$. Note that the integers on the tickets are not\n  necessarily given in sorted order.\n</p><p>\n  In Sample Case #3, every possible $$$c$$$ is at distance $$$0$$$ from an already purchased ticket,\n  so you cannot win regardless of your choices.\n</p><p>\n  In Sample Case #4, if you pick $$$3$$$ for at least one of your tickets, you win on $$$c = 3$$$, for\n  $$$1/4 = 0.25$$$ win probability. There is no way to win when $$$c$$$ is any other integer,\n  so that is the best you can do.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":1,"type__str":"VISIBLE","value":16}],"title":"Closest Pick","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<h4>A straightforward approach</h4>\n<p>\nNotice that $$$1234567$$$ is a roaring year that happens after every possible input. That means\nthat if we simply check every year after $$$\\mathbf{Y}$$$ to see if it is roaring or not, we need to check\nno more than $$$1234567$$$ years per case. It is a lot less in practice, but that is also\nharder to prove.\n</p><p>\nTo check whether a year $$$y$$$ is roaring, we can check for each prefix $$$p$$$ of $$$y$$$ whether\n\"completing it\" by appending $$$p+1$$$, $$$p+2$$$, etc., would work. Since only prefixes that\nare at most half the length of $$$y$$$ can work, this is a small number of things to check.\nIf we are unconvinced about the running time, we can simply run a check of roaringness\nfor every integer up to $$$1234567$$$ once initially and remember it, after which each test\ncase is simply looking for the next \"true\" in a rather small table, making the running time\nmostly independent of the actual input, so a test run can help convince us that it will run in\ntime without risking penalty with a real submission.\n</p>\n<h4>An approach with a more clear time complexity</h4>\n<p>\nAnother way to go is to first use the observation at the end of the solution above: the length\nof the first number in the concatenation is small\t&mdash; at most 3 digits. We can try each of the\n$$$999$$$ possibilities and concatenate numbers to it until it goes above the $$$1234567$$$\nthreshold. Notice that this is at most $$$6$$$. This builds a set of all possible roaring years\nthat matter in very little time. After that, we can use linear search in this very small\nlist (less than $$$6000$$$ elements) to find the smallest roaring year that is larger than $$$\\mathbf{Y}$$$\nfor each test case. Of course, we could use\n<a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\" target=\"_blank\">binary search</a>\nto make each test case run even faster, but that is not required.\n</p>\n<h3>Test Set 2</h3>\n<p>\nNone of the approaches above work for Test Set 2. The gap between two consecutive roaring years\ncan easily be large (for example, you can prove as an exercise that\nthere are no other roaring years between $$$100000000100000001$$$ and $$$100000001100000002$$$)\nand checking an individual one, while quick, takes a bit more time than before. For the second\napproach, there are now $$$10^9-1$$$ candidates for the first number in the concatenation,\nand the amount of concatenated numbers can also be much larger for some of those, making\nthe full set of roaring years too big to even fit in memory, not to mention the computation\ntime.\n</p>\n<h4>A case-based approach</h4>\n<p>\nThe last sentence of the previous paragraph hints at an idea. While the full set of roaring years\nin range\nis too big, the full set of roaring years that are the concatenation of $$$3$$$ or more numbers\nis not: for that case, the maximum possible starting number has $$$6$$$ digits. We can use the\nsecond Test Set 2 solution with this change to solve for those. We still need to check roaring\nyears that are the concatenation of exactly two consecutive numbers. Notice that $$$f(x) = $$$\nthe concatenation of $$$x$$$ and $$$x+1$$$ is an increasing function. Therefore, we can use\nthe <a href=\"https://en.wikipedia.org/wiki/Bisection_method\">bisection method</a> to\nefficiently find the minimum of that subset of roaring years that is above $$$\\mathbf{Y}$$$.\nAfter we found the best candidate from each subset, we simply return the smallest of them.\n</p>\n<h4>A general approach</h4>\n<p>\nWe can also generalize the second case of our first approach for Test Set 2. The family of\nfunctions $$$f_n(x) = $$$ concatenation of $$$x, x+1, \\dots, x+n-1$$$ are all increasing.\nWe can therefore use bisection to find the best candidate for each possible amount of\nconsecutive numbers $$$n$$$, and then answer the best of those. Since $$$n$$$ is at most\n$$$\\log \\mathbf{Y}$$$ this yields a method that runs in $$$O(\\log^2 \\mathbf{Y})$$$ time, which means it\ncan work for really large bounds.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0ScpJ85aBAvLaRUoKf2qzGfLAPCRcj6fHWUwNl92ZQdsf8s-deeqQ67WzgV0jb2GumkLa6ImyZ/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"00000000007c0f01","statement":"<h3>Problem</h3>\n<p>\nSomething is happening in $$$2021$$$ that has not happened in over a century.\n$$$2021$$$, like $$$1920$$$ before it, is a roaring year.\nA year represented by a positive integer $$$y$$$ is roaring if\nthe decimal writing (without leading zeroes) of $$$y$$$ is the concatenation\nof the decimal writing (without leading zeroes) of two or more distinct consecutive\npositive integers, in increasing order. In this case, $$$2021$$$ is a roaring year\nbecause it is the concatenation of $$$20$$$ and $$$21$$$.\n</p>\n<div align=center>\n  <div style=\"display: inline-block; flex-direction: column;\">\n    <div>\n      <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0p3T2XVDuNmhOefdLLYtjAE5fbZHrv_zHdfidahIUCy4yAwCCYa4HpqVi401hqA_wWMNQqiq1LYMiieZAlyaQ/roaring_years.png\" style=\"max-width: 550px;\" alt=\"Three calendars from roaring years 789, 2021, and 910. Each is marked to show how roaring it is.\">\n    </div>\n    <div>\n      <p>\n        <i>Three calendars from roaring years, marked to show how roaring their years are.</i>\n      </p>\n    </div>\n  </div>\n</div>\n<p>\nOther examples of roaring years are\n$$$12$$$, $$$789$$$, $$$910$$$, $$$1234$$$, and $$$9899100$$$.\n$$$2020$$$ was not roaring because the only list of two or more positive integers\nthat concatenate into $$$2020$$$ is $$$[20, 20]$$$, and it is not made of consecutive\nintegers. Similarly, there are only three lists for $$$2019$$$:\n$$$[20, 1, 9]$$$, $$$[201, 9]$$$, and $$$[20, 19]$$$. The first two are not made of consecutive\nintegers, while the third does\nnot have the integers in increasing order. Thus, $$$2019$$$ was also not roaring. As a final\nexample, $$$778$$$ was not a roaring year because $$$[7, 78]$$$ and $$$[77, 8]$$$ are not\nmade up of consecutive integers and $$$[7, 7, 8]$$$ is not made up of distinct integers.\n</p><p>\nGiven the current year (which may or may not be roaring),\nfind what the next roaring year is going to be.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ lines follow.\nEach line represents a test case and contains a single integer $$$\\mathbf{Y}$$$, the current year.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$z$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$z$$$ is the first\nyear strictly after $$$\\mathbf{Y}$$$ that is roaring.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\n$$$1 \\le \\mathbf{Y} \\le 10^6$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n\n$$$1 \\le \\mathbf{Y} \\le 10^{18}$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3VA9jo1rqX6OBg0OLBC_jgn2s_qWKiIyLu3uicEpv8ryVwf5WCFOYbFq34z5P4MA9g3ThjuBte0V0GcvU5iB0GVqhK1mSmNtt1rhUK/roaring_years_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n2020\n2021\n68000\n101\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U18BlHRpI_rFi8iSBS-02hRlHWcZHoEW7A3suV1WWuwGz_HZ-8hW9_UzEeGMH43VP4tNLwJiNrKocZGNdD_8_vpxC5ZE3N41IeG_pEotA/roaring_years_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 2021\nCase #2: 2122\nCase #3: 78910\nCase #4: 123\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\nNotice in the last Sample Case that $$$102$$$ is not a roaring year because $$$[10, 2]$$$ is not\na list of consecutive integers and you cannot write $$$2$$$ with a leading zero to use\n$$$[1, 02]$$$.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Roaring Years","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>\n  Test Set 1\n</h3>\n<p>\n  Let's construct a graph where the nodes are numbers and the edges are the operations described\n  in the statement. The problem asks us to find the shortest path from node $$$\\mathbf{S}$$$ to node\n  $$$\\mathbf{E}$$$ in this graph. The graph is infinite, but we can inspect only a limited set of\n  nodes to find the answer.\n</p>\n<p>\n  When thinking about binary representations, the double operation\n  can be described as \"add a trailing zero\". Note that it is never optimal to add more\n  zeroes than we have bits in $$$\\mathbf{E}$$$: because the NOT operation can only drop leading digits,\n  any additional zeroes will ultimately have to be dropped anyway.\n</p>\n<p>\n  We can use this fact to limit the maximal length to the sum of the lengths of $$$\\mathbf{S}$$$ and $$$\\mathbf{E}$$$,\n  and then use a\n  <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-first search</a> algorithm\n  to find the shortest path.\n</p>\n<h3>\n  Test Set 2\n</h3>\n<p>\n  Let's define a <i>bit group</i> as a maximally long group of consecutive zeroes or consecutive\n  ones (that is, a group of all bits $$$b$$$ that does not have a $$$b$$$ adjacent to it).\n  Let's assume that there are $$$K$$$ bit groups in $$$\\mathbf{S}$$$ and $$$L$$$ bit groups in $$$\\mathbf{E}$$$.\n</p>\n<p>\n  The double operation appends a bit to the right end of the binary string, and the NOT\n  operation complements and possibly drops bits from the left end.\n  Therefore, the result of applying operations to $$$\\mathbf{S}$$$ comes from some (possibly empty) suffix of\n  $$$\\mathbf{S}$$$ (possibly complemented) and then some extra bits that were created using double. Let us\n  call the bits that come from a bit in $$$\\mathbf{S}$$$ <i>reused</i>.\n</p>\n<p>\n  First, let's consider the case when we do not reuse any bits from $$$\\mathbf{S}$$$. In such a case we need\n  to construct $$$\\mathbf{E}$$$ naively using only the bits added by double operations and removing\n  all the bits that came from $$$\\mathbf{S}$$$ originally. We can do this by adding zeroes with double\n  operations and applying a NOT operation whenever we need to start a new bit group.\n  We also need to apply additional NOT operations to eliminate\n  all bits that came from $$$\\mathbf{S}$$$ originally. If we end up with $$$\\mathbf{E}$$$, then let's count\n  this as a possible answer. For example, to get from 101<sub>2</sub> to 11100<sub>2</sub> we would\n  need to do perform the following sequence of operations (we use a space to separate bits\n  originated from $$$\\mathbf{S}$$$ from the extra bits added with double operations):\n</p>\n<table>\n  <tr><th>Operation</th><th>Result</th></tr>\n  <tr><td>double (to add an extra bit)</td><td>101&nbsp;0</td></tr>\n  <tr><td>double (to add an extra bit)</td><td>101&nbsp;00</td></tr>\n  <tr><td>double (to add an extra bit)</td><td>101&nbsp;000</td></tr>\n  <tr><td>NOT (because the length of first bit group in $$$\\mathbf{E}$$$ is 3, and we have added 3 zeros already, now we need to start a new bit group)</td><td>10&nbsp;111</td></tr>\n  <tr><td>double (to add an extra bit)</td><td>10&nbsp;1110</td></tr>\n  <tr><td>double (to add an extra bit)</td><td>10&nbsp;11100</td></tr>\n  <tr><td>NOT (because we already have the desired $$$\\mathbf{E}$$$ as suffix, now we just need to remove extra bits from $$$\\mathbf{S}$$$)</td><td>1&nbsp;00011</td></tr>\n  <tr><td>NOT (to remove the leftover bit of $$$\\mathbf{S}$$$)</td><td>11100</td></tr>\n</table>\n<p>\n  If $$$\\mathbf{S}$$$ ends in $$$0$$$, we need to perform an extra NOT operation at the beginning so that\n  our first double operation creates a brand new bit group. After we finish removing all bits\n  from $$$\\mathbf{S}$$$, we might need another NOT operation, if the removal process\n  left us with the complement of $$$\\mathbf{E}$$$.\n</p>\n<p>\n  Now, let's try to reuse some bits from $$$\\mathbf{S}$$$.\n</p>\n<p>\n  The NOT operation removes one bit group\n  from the left end of the binary representation and complements the rest. It is never optimal to\n  apply a NOT operation more than $$$K + 1$$$ times, as in such a case we will either be looping\n  between $$$0$$$ and $$$1$$$, or will be removing bits which were added with the double operation\n  (which we could have just not added in the first place if they were not useful).\n</p>\n<p>\n  Let's assume that the answer will have NOT operations applied exactly $$$X$$$ times.\n  Let's apply $$$X$$$ NOT operations to\n  $$$\\mathbf{S}$$$ to obtain $$$S'$$$. If $$$S'$$$ is not a prefix of $$$\\mathbf{E}$$$,\n  then it is not possible to get to $$$\\mathbf{E}$$$ from $$$\\mathbf{S}$$$ using $$$X$$$ NOT operations, as\n  the double operation will not change the prefix of the string.\n</p>\n<p>\n  If $$$S'$$$ is a prefix of $$$\\mathbf{E}$$$, let's see whether we can construct the suffix. We will\n  need exactly $$$Y = \\text{len}(\\mathbf{E}) - \\text{len}(S')$$$ double operations.\n  Let's say there are $$$M$$$ bit groups in the suffix we need to create,\n  then we will also need to apply $$$M$$$ or $$$M + 1$$$ NOT operations, depending on the\n  parity of $$$M$$$ and the first bit of the prefix. Let's denote the number as $$$Z$$$.\n  If $$$Z$$$ is greater than $$$X$$$, then this case does not work, as we would apply\n  more than $$$X$$$ NOT operations, violating the assumption. Otherwise, the answer is\n  $$$X + Y$$$, as even if $$$X$$$ is greater than $$$Z$$$, extra NOT operations won't\n  affect the suffix (we can perform them before adding any extra bits with a double operation).\n</p>\n<p>\n  We can now iterate through all possible values of $$$X$$$ from $$$0$$$ to $$$K + 1$$$, inclusive,\n  and choose the minimum answer between all of those and the non-reuse case we considered first.\n  If none of the cases work, we output <code>IMPOSSIBLE</code>.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1kJ4sMFR86ZNT5T91GpbMf6VhwCh1iQemJO3gP8M4iBcU7MYPc-MdOVJnly8NKfcXu8fo7aur0/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"00000000007c1139","statement":"<h3>Problem</h3>\n<p>\n  You are given a starting non-negative integer $$$\\mathbf{S}$$$ and an ending non-negative integer $$$\\mathbf{E}$$$.\n  Both $$$\\mathbf{S}$$$ and $$$\\mathbf{E}$$$ are given by their binary representation (that is, they are given written\n  in base $$$2$$$).\n  Your goal is to transform $$$\\mathbf{S}$$$ into $$$\\mathbf{E}$$$. The following two operations are available to you:\n</p>\n<ul>\n  <li>\n    Double your current value.\n  </li>\n  <li>\n    Take the bitwise NOT of your current value. The binary representation of your current value\n    is taken without unnecessary leading zeroes, and any unnecessary leading zeroes produced by\n    the operation are dropped. (The only necessary leading zero is the one in the\n    representation of $$$0$$$).\n  </li>\n</ul>\n<p>\n  For example, by using the double operation, $$$6$$$ becomes $$$12$$$, $$$0$$$ becomes $$$0$$$,\n  and $$$10$$$ becomes $$$20$$$. By using the NOT operation,\n  $$$0$$$ becomes $$$1$$$, $$$1$$$ becomes $$$0$$$, $$$3 = 11_2$$$ becomes $$$0$$$,\n  $$$14=1110_2$$$ becomes $$$1$$$, $$$10=1010_2$$$ becomes $$$5=101_2$$$, and\n  $$$5=101_2$$$ becomes $$$2=10_2$$$. ($$$X_2$$$ means the integer whose binary representation\n  is $$$X$$$).\n</p><p>\n  You can use these operations as many times as you want in any order. For example, you can\n  transform $$$\\mathbf{S} = 10001_2$$$ to $$$\\mathbf{E} = 111_2$$$ using the NOT operation first,\n  then using the double operation twice, and then another NOT operation:\n  $$$$10001_2 \\overset{\\text{NOT}}{\\Longrightarrow} 1110_2 \\overset{\\times 2}{\\Longrightarrow} 11100_2 \\overset{\\times 2}{\\Longrightarrow} 111000_2 \\overset{\\text{NOT}}{\\Longrightarrow} 111_2.$$$$\n</p><p>\n  Determine the smallest number of operations needed to complete the transformation, or say it is\n  impossible to do so.\n</p>\n<h3>\n  Input\n</h3>\n<p>\n  The first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\n  Each consists of a single line containing two strings $$$\\mathbf{S}$$$ and $$$\\mathbf{E}$$$, the binary representations\n  of the starting and ending integers, respectively.\n</p>\n<h3>\n  Output\n</h3>\n<p>\n  For each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>, where $$$x$$$\n  is the test case number (starting from 1) and $$$y$$$ is <code>IMPOSSIBLE</code>\n  if there is no way to transform $$$\\mathbf{S}$$$ into $$$\\mathbf{E}$$$ using the two operations. Otherwise, $$$y$$$\n  is the smallest number of operations needed to transform $$$\\mathbf{S}$$$ into $$$\\mathbf{E}$$$.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 10 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\nEach character of $$$\\mathbf{S}$$$ is either <code>0</code> or <code>1</code>.<br/>\nThe first digit of $$$\\mathbf{S}$$$ can be <code>0</code> only if the length of $$$\\mathbf{S}$$$ is $$$1$$$.<br/>\nEach character of $$$\\mathbf{E}$$$ is either <code>0</code> or <code>1</code>.<br/>\nThe first digit of $$$\\mathbf{E}$$$ can be <code>0</code> only if the length of $$$\\mathbf{E}$$$ is $$$1$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\n$$$1 \\le$$$ the length of $$$\\mathbf{S} \\le 8$$$.<br/>\n$$$1 \\le$$$ the length of $$$\\mathbf{E} \\le 8$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n\n$$$1 \\le$$$ the length of $$$\\mathbf{S} \\le 100$$$.<br/>\n$$$1 \\le$$$ the length of $$$\\mathbf{E} \\le 100$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U05kGgv86esz64eZj8fzDHClIH6RKF9XVyg4ssNQP0Fyetfa0ceYdvcQD5jRSCI-agnJyYTzDn_auc8LoeIkNffanUR0KibiZkhRIb_ZYyJ/double_or_noting_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">6\n10001 111\n1011 111\n1010 1011\n0 1\n0 101\n1101011 1101011\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0PYeVuRgPMOjfDAzUGTaXZGcvRwuGjlZkhoU08BrCHAaY5AolQnDJBhsl8VmjdAsqlILY_vxHLej9-xbKK3_67g0D-cII0-0-OigD11MS58Q/double_or_noting_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 4\nCase #2: 3\nCase #3: 2\nCase #4: 1\nCase #5: IMPOSSIBLE\nCase #6: 0\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Sample Case #1 is the example shown in the main part of the statement.\n</p>\n<p>\n  These are possible optimal ways of solving Sample Cases #2, #3, and #4, respectively:\n    $$$$1011_2 \\overset{\\text{NOT}}{\\Longrightarrow} 100_2 \\overset{\\times 2}{\\Longrightarrow} 1000_2 \\overset{\\text{NOT}}{\\Longrightarrow} 111_2,$$$$\n    $$$$1010_2 \\overset{\\times 2}{\\Longrightarrow} 10100_2 \\overset{\\text{NOT}}{\\Longrightarrow} 1011_2, \\text{ and}$$$$\n    $$$$0_2 \\overset{\\text{NOT}}{\\Longrightarrow} 1_2.$$$$\n<p>\n  In Sample Case #5, it is not possible to get from $$$0_2$$$ to $$$101_2$$$ with any sequence\n  of operations.\n</p>\n<p>\n  In Sample Case #6, we do not need to perform any operations because $$$\\mathbf{S} = \\mathbf{E}$$$.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":26}],"title":"Double or NOTing","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000004362d7","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2021"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
