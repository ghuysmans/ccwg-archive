{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1305948600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433198","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1 was off to a rather brutal start. The scoreboard quickly started filling up with incorrect submissions on all three problems. It took almost 40 minutes for somebody to solve Problem B and over two hours for a correct solution to problem C to appear.\n</p>\n\n<p>\nAt the end, a significant number of large submissions turned out to be incorrect as well, which caused a lot of reshuffling at the top of the score board.\n</p>\n\n<p>\nSome of the confusion in problem B was caused by a sentence that was not as clear as we would have liked. We are sorry that it took us almost two hours to understand the confusion, and we had to broadcast a clarification message.\n</p>\n\n<p>\nkrijgertje ended up being the first to solve all problems correctly with 27 minutes to go. Progbeat followed soon after and took second place, only to be overtaken 15 minutes later by Myth. No one else managed to solve all of the problems.\n</p>\n\n<p>\nCongratulations to the top 1000 contestants. They have advanced to Round 2. Everyone else has two more chances in rounds 1B and 1C.\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>FreeCell Statistics</i> Written by Igor Naverniouk and prepared by Onufry Wojtaszczyk.</p>\n<p>Problem B. <i>The Killer Word</i> Written by David Arthur and prepared by Tomek Czajka.</p>\n<p>Problem C. <i>Pseudominion</i> Written by David Arthur and prepared by Luka Kalinovcic.</p>\n<p>Contest analysis presented by Stephen Fulwider, David Arthur and Luka Kalinovcic.</p>\n<p>Solutions and other problem preparation by Jorge Bernadas Saragoza, Sean Henderson, Petr Mitrichev, Greg Tener, Cosmin Negruseri and John Dethridge.\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1305939600000,"tasks":[{"analysis":"<p>\nLet's denote the bonus numbers of a card c by c.card_draw, c.score and c.turns. Let c.index be the (zero based) index of the card in the ordering from the input file.\n</p>\n\n<p>\nAfter looking at the problem constraints, we can classify a card c as:\n</p>\n<ul>\n  <li>\n    a T card, if c.turns &gt; 0.\n  </li>\n  <li>\n    a C<sub>0</sub> card, if c.turns = 0 and c.card_draw = 0\n  </li>\n  <li>\n    a C<sub>1</sub> card, if c.turns = 0 and c.card_draw = 1\n  </li>\n  <li>\n    a C<sub>2</sub> card, if c.turns = 0 and c.card_draw = 2\n  </li>\n</ul>\n<p>\nLet T[i] denote the i-th T card in the sequence of all T cards sorted by the index. We define C<sub>0</sub>[i],  C<sub>1</sub>[i] and C<sub>2</sub>[i] analogously.\n</p>\n\n<p>\nThe first key observation is that it never hurts to play a T card whenever we have one in our hand. We never lose turns or score and we may draw new cards by doing so.\n</p>\n\n<p>\nLet's think about some arbitrary sequence of played cards. There are two observations we need to make before we can proceed.\n</p>\n<ol>\n<li>\nBecause C<sub>0</sub> cards do not add turns or cards to our hand, we can postpone playing them until we have no other cards we want to play. So we can transform any valid sequence of played cards into another sequence that has all C<sub>0</sub> cards at the very end. The total score, being the sum of individual scores of all played cards, will obviously remain the same.\n</li>\n<li>\nLet's say there are two C<sub>1</sub> cards a and b such that we played a before b, but b.index &lt; a.index. Because b.index &lt; a.index, we already had both cards in our hand when we played card a. So we can instead play card b first and card a second. The resulting sequence with a and b swapped will remain valid because a and b both have the same card bonus (1 card) and the same turn bonus (0 turns). Furthermore, the score will remain the same. We can do the same for two C<sub>2</sub> cards.\n</li>\n</ol>\n\n<p>\nThe first observation shows us that we don't care about C<sub>0</sub> cards until the very end when we can use our remaining turns on whatever C<sub>0</sub> cards we have already drawn. Obviously, we should sort the C<sub>0</sub> cards in our hand by decreasing score bonus and then play as many as we can.\n</p>\n\n<p>\nThe second observation shows us that we can transform any optimal sequence of played cards into another one that has cards of the same type ordered by index. This means that we can play C<sub>1</sub> (and C<sub>2</sub>) cards in increasing order by index.\n</p>\n\n<p>\nSo, whenever we have more than one C<sub>1</sub> (or C<sub>2</sub>) cards in our hand we can always look at the one with the smallest index and choose whether we will play it right now or never at all.\n</p>\n\n<p>\nThese observations lead us to construct a directed acyclic weighted graph. A node represents a state of the game and is defined by these properties:\n</p>\n<ul>\n  <li>\n    hand - the number of drawn cards.\n  </li>\n  <li>\n    turns - the number of turns left.\n  </li>\n  <li>\n    t - T[t] is the first T card that we haven't played yet.\n  </li>\n  <li>\n    c1 - C<sub>1</sub>[c1] is the first C<sub>1</sub> card which we are not yet sure if we are going to play.\n  </li>\n  <li>\n    c2 - C<sub>2</sub>[c2] is the first C<sub>2</sub> card which we are not yet sure if we are going to play.\n  </li>\n</ul>\n<p>\nAn edge represents a valid transition from one game state to another and is usually associated with playing a card or deciding not to play a certain card at all. The weight of an edge indicates how much your score goes up when you switch between the two game states. For each node (hand, turns, t, c1, c2), we add edges according to these rules:\n</p>\n<ol>\n  <li>\n    If we have a T card in our hand, we can play it.\n    <ul>\n      <li>\n        Condition: T[t].index &lt; hand\n      </li>\n      <li>\n        Weight: T[t].score\n      </li>\n      <li>\n        Target node: (min(N, hand + T[t].card_draw), min(N, turns + T[t].turns - 1), t + 1, c1, c2)\n      </li> \n    </ul>\n  </li>\n  <li>\n    If we have a C<sub>1</sub> card in our hand, we can play the first one.\n    <ul>\n      <li>\n        Condition: C<sub>1</sub>[c1].index &lt; hand\n      </li>\n      <li>\n        Weight: C<sub>1</sub>[c1].score\n      </li>\n      <li>\n        Target node: (min(N, hand + 1), turns - 1, t, c1 + 1, c2)\n      </li> \n    </ul>\n  </li>\n  <li>\n    If we have a C<sub>1</sub> card in our hand, we can throw away the first one.\n    <ul>\n      <li>\n        Condition: C<sub>1</sub>[c1].index &lt; hand\n      </li>\n      <li>\n        Weight: 0\n      </li>\n      <li>\n        Target node: (hand, turns, t, c1 + 1, c2)\n      </li> \n    </ul>\n  </li>\n  <li>\n    If we have a C<sub>2</sub> card in our hand, we can play the first one.\n    <ul>\n      <li>\n        Condition: C<sub>2</sub>[c2].index &lt; hand\n      </li>\n      <li>\n        Weight: C<sub>2</sub>[c2].score\n      </li>\n      <li>\n        Target node: (min(N, hand + 2), turns - 1, t, c1, c2 + 1)\n      </li> \n    </ul>\n  </li>\n  <li>\n    If we have a C<sub>2</sub> card in our hand, we can throw away the first one.\n    <ul>\n      <li>\n        Condition: C<sub>2</sub>[c2].index &lt; hand\n      </li>\n      <li>\n        Weight: 0\n      </li>\n      <li>\n        Target node: (hand, turns, t, c1, c2 + 1)\n      </li> \n    </ul>\n  </li>\n  <li>\n    We can always decide to finish the game by spending the remaining turns on C<sub>0</sub> cards. This edge leads to the special final node and the weight of the edge is defined by the greedy algorithm that spends all remaining turns picking the best C<sub>0</sub> cards.\n  </li>\n</ol>\n\n<p>\nThe answer to our problem is the length of the longest path in the graph described above. The graph is acyclic, so we can use dynamic programming or recursion with memoization to find the length of the longest path.\n</p>\n\n<p>\nThe number of nodes in the graph is O(n<sup>5</sup>), so the asymptotic time complexity of the algorithm is O(n<sup>5</sup>) too. In practice, the runtime of the program is really small because the vast majority of these states are unreachable. You can speed things up even more if you use the preceding observations to their full power. For example, if there is an edge corresponding to a T card, you should always follow it first.\n</p>\n<br/>\n<br/>\n<i>Remark</i>: This problem is inspired by the game Dominion, published by Rio Grande Games.\n","id":"0000000000432b81","statement":"<h3>Problem</h3>\n\n<p>\nYou are playing a game with a fancy deck of cards. Each card has three bonus numbers: a <i>card bonus</i> <b>c</b>, a <i>score bonus</i> <b>s</b>, and a <i>turn bonus</i> <b>t</b>. Some of the cards start in your hand, while the rest are in a deck on the table.  You start with one turn.\n</p>\n\n<p>\nOn each turn, you can choose any card from your hand and play it. If it has bonus numbers <b>c</b>, <b>s</b>, <b>t</b>, then the following happens:\n</p>\n<ul>\n<li> The card is discarded from your hand, and it can never be used again.</li>\n<li> You draw the first <b>c</b> cards from the deck into your hand. If the deck has fewer than <b>c</b> cards in it, you draw all of them.</li>\n<li> Your total score increases by <b>s</b>.</li>\n<li> Your number of remaining turns increases by <b>t</b>.</li>\n</ul>\n<p>\nIf you do not have any cards in your hand at the start of a turn, then nothing happens on that turn. Your goal is to get as high a score as possible before running out of turns.\n</p>\n\n<p>\nFor example, suppose your hand and deck contain the following cards:\n</p>\n<pre>\n         +---+---+---+            +---+---+---+\n   HAND: | <b>c</b> | <b>s</b> | <b>t</b> |      DECK: | <b>c</b> | <b>s</b> | <b>t</b> |\n         +---+---+---+            +---+---+---+\nCard #1: | 0 | 0 | 2 |   Card #4: | 1 | 1 | 0 |\nCard #2: | 0 | 5 | 0 |   Card #5: | 0 | 1 | 1 |\nCard #3: | 2 | 1 | 1 |   Card #6: | 2 | 2 | 0 |\n         +---+---+---+            +---+---+---+\n</pre>\nThe following table shows how you can get a score of 8 from these cards. The first three columns show your hand, the number of turns left, and your score before playing each card, and the final column shows which card to play.\n<pre>\n+---------+------------+-------+------+\n| Hand    | Turns left | Score | Play |\n+---------+------------+-------+------+\n| 1, 2, 3 |      1     |   0   |   1  |\n| 2, 3    |      2     |   0   |   3  |\n| 2, 4, 5 |      2     |   1   |   2  |\n| 4, 5    |      1     |   6   |   5  |\n| 4       |      1     |   7   |   4  |\n| 6       |      0     |   8   |   -  |\n+---------+------------+-------+------+\n</pre>\n<p>\nAs you can see, the card bonuses and turn bonuses allow you to chain together a long sequence of cards before you have to stop.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\n</p>\n\n<p>\nEach test case begins with a single line containing <b>N</b>, the number of cards in your hand. The next <b>N</b> lines each contain three integers, <b>c</b>, <b>s</b>, and <b>t</b>, representing the bonus numbers for a single card in your hand.\n</p>\n\n<p>\nThis is followed by a single line containing <b>M</b>, the number of cards in the deck. The next <b>M</b> lines each contain three integers, <b>c</b>, <b>s</b>, and <b>t</b>, representing the bonus numbers for a single card in the deck. These cards are listed in the same order in which you draw them.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: S\", where S is the largest score you can obtain before running out of turns.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b>.<br/>\n0 &le; <b>M</b>.<br/>\n<b>N + M</b> &le; 80.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n0 &le; <b>c</b> &le; 1.<br/>\n0 &le; <b>s</b> &le; 20.<br/>\n0 &le; <b>t</b> &le; 20.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n0 &le; <b>c</b> &le; 2.<br/>\n0 &le; <b>s</b> &le; 50.<br/>\n0 &le; <b>t</b> &le; 50.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n4\n1 0 0\n1 1 1\n0 5 0\n1 2 0\n0\n2\n1 1 1\n0 6 0\n1\n0 1 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 6\nCase #2: 8\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":35}],"title":"Pseudominion","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe first thing to notice in this problem is that both <b>P<sub>D</sub></b> and <b>P<sub>G</sub></b> can range from 0 to 100, so letâ€™s start by taking care of some easy cases. If our unnamed player has won 100% of his total games (<b>P<sub>G</sub></b> = 100) but not won 100% of his games today (<b>P<sub>D</sub></b> &lt; 100), then something has clearly gone wrong with the calculator. Similarly, if <b>P<sub>G</sub></b> = 0 but <b>P<sub>D</sub></b> &gt; 0, something is wonky.\n</p>\n\n<p>\nThe cases where <b>P<sub>D</sub></b> = <b>P<sub>G</sub></b> = 0 or <b>P<sub>D</sub></b> = <b>P<sub>G</sub></b> = 100 are also easy, and the answer for both of them is \"Possible\" &mdash; they mean that all the games ever ended with the same result (loss or win, respectively).\n</p>\n\n<p>\nThe trick now is that once we ruled out the case of <b>P<sub>G</sub></b> being zero or a hundred, we do not need to worry about it any more! Indeed, assume we have a solution that gives the correct daily percentage of wins, and it consists of <b>W</b> games won and <b>L</b> games lost today. To get a global win percentage of <b>P<sub>G</sub></b>, we can, for instance, assume we won a total of <b>(W + L) * P<sub>G</sub></b> and lost a total of <b>(W + L) * (100 - P<sub>G</sub></b>). As 1 &le; <b>P<sub>G</sub></b> &le; 99, the numbers are greater than <b>W</b> and <b>L</b>, respectively, so they are possible to achieve.\n</p>\n\n<p>\nThe small data set can now be solved by brute force by simply trying all possible values of <b>D</b> from 1 to <b>N</b> and all possible number of games won from 0 to <b>D</b>, and seeing if any of them results in exactly <b>P<sub>D</sub></b> percentage of games being won.\n</p>\n\n<p>\nSolving the large date set can require some maths. One way to solve the problem is to directly solve for the minimum number of games we would need to play in order to get a win percentage of <b>P<sub>D</sub></b> and simply verify that this number is &le; <b>N</b>. If we let <b>W</b> be the number of games we have won today, then we want to solve <b>W / D</b> = <b>P<sub>D</sub> / 100</b> for the minimum value of <b>D</b> such that <b>W</b> is integral.\n</p>\n\n<p>\nFrom here, it is easy to see <b>D</b> = <b>100 * W / P<sub>D</sub></b>. Thus, if we want to minimize <b>D</b>, then we need to find the smallest value <b>W</b> such that the right hand side is integral. In order to do this, we divide 100 and <b>P<sub>D</sub></b> by their <a href=\"http://en.wikipedia.org/wiki/Greatest_common_divisor\" target=\"_blank\">greatest common divisor</a> (let's call this value <b>G</b>) so that they are relatively prime and <b>W</b> is minimal when it is <b>P<sub>D</sub></b> / <b>G</b>. Plugging this in and cancelling terms tells us that <b>D</b> = <b>100 / G</b> is the fewest number of games we must be play.\n</p>\n\n<p>\nA simpler way to solve this problem is by brute force. We can just try all possible values of <b>D</b> from 1 to <b>N</b> and check if any of them could result in exactly <b>P<sub>D</sub></b> percentage of games being won by checking that <b>D</b> * <b>P<sub>D</sub></b> = 0 (mod 100), stopping the loop the first time we find a candidate value of <b>D</b> or we exceed <b>N</b> games. While at first this solution appears to be O(<b>N</b>) and would time out for the large data set, this loop will in fact run <i>at most</i> 100 times, regardless of the value of <b>N</b>, so this solution will be plenty fast enough. Coders who noticed this simpler solution early were rewarded with very fast submission times.\n</p>","id":"0000000000432df9","statement":"<h3>Problem</h3>\n<p>\nI played <b>D</b> (<b>D</b> &gt; 0) games of FreeCell today. Each game of FreeCell ends in one of two ways -- I either win, or I lose. I've been playing for many years, and have so far played <b>G</b> games in total (obviously, <nobr><b>G</b> &ge; <b>D</b></nobr>).\n</p>\n\n<p>\nAt the end of the day, I look at the game statistics to see how well I have played. It turns out that I have won exactly <b>P<sub>D</sub></b> percent of the <b>D</b> games today, and exactly <b>P<sub>G</sub></b> percent of <b>G</b> total games I had ever played. Miraculously, there is no rounding necessary -- both percentages are exact! Unfortunately, I don't remember the exact number of games that I have played today (<b>D</b>), or the exact number of games that I have played in total (<b>G</b>). I do know that I could not have played more than <b>N</b> games today (<nobr><b>D</b> &le; <b>N</b></nobr>).\n</p>\n\n<p>\nAre the percentages displayed possible, or is the game statistics calculator broken?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each line contains 3 integers -- <b>N</b>, <b>P<sub>D</sub></b> and <b>P<sub>G</sub></b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is either \"Possible\" or \"Broken\".\n</p>\n\n<h3>Limits</h3>\n<p>\n0 &le; <b>P<sub>D</sub></b> &le; 100;<br>\n0 &le; <b>P<sub>G</sub></b> &le; 100.<br>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 100;<br>\n1 &le; <b>N</b> &le; 10.<br>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 2000;<br>\n1 &le; <b>N</b> &le; 10<sup>15</sup>.<br>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1 100 50\n10 10 100\n9 80 56\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: Possible\nCase #2: Broken\nCase #3: Possible\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<p>In Case #3, I could have played 5 games today <nobr>(<b>D</b> = 5)</nobr> and 25 games in total <nobr>(<b>G</b> = 25)</nobr>, and won 4 games today  <nobr>(80% of 5)</nobr> and 14 games in total <nobr>(56% of 25)</nobr>.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":14}],"title":"FreeCell Statistics","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>Every year, contestants come to us saying they implemented a program correctly but it ran too slowly. Unfortunately, being too slow is the same thing as being wrong. The Google Code Jam is an <i>algorithms</i> contest, and once you get past the early questions, coming up with a fast algorithm is often the whole point of the problem.</p>\n\n<p>Why do we bring this up? Because this problem is a trap. On first glance, it looks just like the first two problems from the Qualification Round. We tell you an algorithm, and you implement it exactly as described:</p>\n<ul>\n<li>Loop through every one of Sean's lists.</li>\n<li>Loop through every word in the dictionary.</li>\n<li>See how many mistakes Sean makes while guessing this word.</li>\n</ul>\n<p>Since the last step requires iterating over every word again, the running time here is O(<b>N</b><sup>2</sup><b>M</b>).</p>\n\n<p>We will always give you the hardest inputs we can fit within the stated limits, which means you <i>will</i> see <b>N</b> = 10000 and <b>M</b> = 100. Neither a fast computer nor a fast language will save you here - the whole approach is simply too slow. For example, our C++ implementation takes over 20 minutes for a single test case. To succeed on an algorithms contest, you need to see these issues in advance, either by looking at the Big O complexity or by trying a worst-case input of your own.</p>\n\n<p>Once you do see the issue, it isn't too hard to dramatically speed things up. The main idea is to combine the last two steps:</p>\n<ul>\n<li> Loop through every one of Sean's lists.</li>\n<li> Divide the words into different classes by length. If you focus on a single class, Sean will make the same first guess for any word in that class. This is because he has exactly the same information in each case.</li>\n<li> For each class, figure out what letter Sean will guess, and further divide the class based on each of the different responses you could give to Sean's guess.</li>\n<li> Repeat for each of the sub-classes until you are down to a single word, at which point Sean will finish with no mistakes.</li>\n</ul>\n<p>The running time here is O(<b>NM</b>), and it will go hundreds of times faster than the more straightforward algorithm.</p>\n\n<p>This technique is similar to Dynamic Programming - the game begins in the same way for many different words, so we should not have to redo all that work every time.\n</p>\n\n<p>Fun facts: this problem was originally called Bloodthirsty Executioner Man, but was renamed because the hangman is made out of paper, and has no blood.  Sean himself answered several of the clarifications for this problem.\n</p>\n","id":"0000000000432fe2","statement":"<h3>Problem</h3>\n\n<p>\nYou are playing Hangman with your friend Sean. And while you have\nheard that Sean is very good at taking candy from a baby, he is not as\ngood at this game. Can you take advantage of Sean's imperfect\nstrategy, and make him lose as badly as possible?\n</p>\n\n<pre>\n +--+\n |  O\n | /|\\       Mystery word: _ a _ a _ a _\n | / \\\n |\n+-+---+\n</pre>\n\n<p>\nHangman is played as follows:\n<ul>\n<li> There is a dictionary <b>D</b> of all valid words, which both you\nand Sean know. A word consists only of the characters <code>a</code> -\n<code>z</code>. In particular, there are no spaces.</li>\n<li> You begin by choosing any word from <b>D</b>, and writing it down\non a blackboard with each letter replaced by a blank:\n<code>_</code>.</li>\n<li> On his turn, Sean can choose any letter and ask you if it is in\nthe word. If it is, you reveal <i>all</i> locations of that letter.\nOtherwise, Sean loses a point.</li>\n<li> Once all letters in the word have been revealed, the round ends.</li>\n<li> The round never ends early, no matter how many points Sean loses.</li>\n</ul>\n</p>\n\n<p>\nSean uses a very simple strategy. He makes a list <b>L</b> of the 26\nletters in some order, and goes through the list one letter at a time.\nIf there is at least one word in <b>D</b> that (a) has the letter he\nis thinking of, and (b) is consistent with what you have written down\nso far <i>and the result of all of Sean's previous guesses</i>, then Sean guesses that letter. Otherwise, he skips it. No\nmatter what, Sean then moves on to the next letter in his list.\n</p>\n\n<p>\nGiven Sean's list, what word should you choose to make Sean lose as\nmany as points as possible? If several choices are equally good, you\nshould choose the one that appears first in <b>D</b>.\n</p>\n\n<h3>Example</h3>\n\n<p>\nSuppose Sean decides to guess the letters in alphabetical order (i.e.,\n<b>L</b> = \"abcdefghijklmnopqrstuvwxyz\"), and <b>D</b> contains the\nwords <code>banana</code>, <code>caravan</code>, and\n<code>pajamas</code>. If you choose <code>pajamas</code>, the game\nwould play out as follows:\n</p>\n<ul>\n<li> You begin by writing 7 blanks <code>_ _ _ _ _ _ _</code> on the\nblackboard. Based on the number of blanks, Sean knows immediately that\nthe word is either <code>caravan</code> or <code>pajamas</code>.</li>\n<li> Sean begins by guessing <code>a</code> since it is first in\n<b>L</b>, and you reveal all locations of the letter <code>a</code> on\nthe blackboard: <code>_ a _ a _ a _</code>.</li>\n<li> Sean skips <code>b</code> even though it is used in\n<code>banana</code>. Sean already knows that is not your word. </li>\n<li> He then guesses <code>c</code> because it appears in\n<code>caravan</code>. It does not appear in the word you actually\nchose though, so Sean loses a point and nothing more is revealed.\n</li>\n<li> By process of elimination, Sean now knows your word has to be\n<code>pajamas</code>, so he proceeds to guess <code>j</code>,\n<code>m</code>, <code>p</code>, and <code>s</code> in order, without\nlosing any more points.\n</ul>\n<p>\nSo Sean loses one point if you choose <code>pajamas</code>. He would\nhave gotten either of the other words without losing any points.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.\n<b>T</b> test cases follow. Each test case begins with a line\ncontaining integers <b>N</b> and <b>M</b>, representing the number of\nwords in the dictionary and the number of lists to consider.\n</p>\n\n<p>\nThe next <b>N</b> lines contain the words in the dictionary, one per\nline: <b>D</b><sub>1</sub>, <b>D</b><sub>2</sub>, ...,\n<b>D<sub>N</sub></b>. Each word is an arbitrary sequence of characters\n<code>a</code> - <code>z</code>.</p>\n\n<p>\nThe final <b>M</b> lines contain all of the lists Sean will use, one per line: <b>L</b><sub>1</sub>, <b>L</b><sub>2</sub>, ..., <b>L<sub>M</sub></b>. Each list is exactly 26 letters long, containing each letter exactly once. Sean will use these lists to guess letters as described above.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x:\n<b>w</b><sub>1</sub> <b>w</b><sub>2</sub> ...\n<b>w</b><sub><b>M</b></sub>\", where x is the case number (starting\nfrom 1) and <b>w</b><sub>i</sub> is the word you should choose if Sean\nguesses the letters in order <b>L</b><sub>i</sub>. If multiple words\ncause Sean to lose the same number of points, you should choose the\noption that appears first in the dictionary.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 10.<br/>\nEach word in <b>D</b> will have between 1 and 10 characters inclusive.<br/>\nNo two words in <b>D</b> will be the same within a single test case.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 100.<br/>\n1 &le; <b>M</b> &le; 10.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 10000.<br/>\n1 &le; <b>M</b> &le; 100.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 2\nbanana\ncaravan\npajamas\nabcdefghijklmnopqrstuvwxyz\netaoisnhrdlcumwfgypbvkjxqz\n4 1\npotato\ntomato\ngarlic\npepper\nzyxwvutsrqponmlkjihgfedcba\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: pajamas caravan\nCase #2: garlic\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"The Killer Word","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433198","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2011"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
