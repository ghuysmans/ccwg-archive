{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1402763400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043371f","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThis round was challenging. It consisted of 4 problems: Problem A required binary search, Problem B required Dynamic Programming, Problem C had a greedy solution while Problem D was a challenging problem requiring Dynamic Programming. Nobody was able to solve the large input for problem D and only 3 people tried to submit solutions for it.\n</p>\n<p>\n<i>EgorKulikov</i> placed first in Round 3 with 86 points and a penalty of 1:47:30. <i>vepifanov</i> was the fastest to solve Problem A’s large input in just 7:31.\n</p>\n<p>\n<i>mystic</i> the winner of Google Code Jam World Finals 2013 gets an automatic invite to this year’s World Finals. Since he placed in the top 25, we will be inviting the top 26 contestants to the onsite finals. The top 26 had a score of 64 or higher, and in fact 55 contestants had scores of 64 or higher, therefore determining the top 26 came down to penalty points. Contestants who solved the small and large input for the first three problems were ranked 12 or higher.\n</p>\n<p>\nVarious countries are represented by the top 26: 7 from Russia, 4 from China, 3 from Belarus, 3 from Ukraine, 2 from Japan and 1 each from Brazil, Bulgaria, Croatia, Czech Republic, Poland, Romania and South Korea.\n</p>\n<p>\nCongratulations to the 26 finalists, and see you all in Los Angeles this August!\n</p>\n<hr>\n<p>\nCast\n</p>\n<p>\nProblem A. Magical, Marvelous Tour written and prepared by Bartholomew Furrow.\n</p>\n<p>\nProblem B. Last Hit written by Khaled Hafez. Prepared by Khaled Hafez and John Dethridge.\n</p>\n<p>\nProblem C. Crime House written by Bartholomew Furrow. Prepared by Bartholomew Furrow and Steve Thomas.\n</p>\n<p>\nProblem D. Willow written by Khaled Hafez. Prepared by Khaled Hafez and Steve Thomas.\n</p>\n<p>\nContest analysis presented by Bartholomew Furrow, Felix Halim, Jonathan Paulson, Khaled Hafez, Steve Thomas, Steven Zhang, Sumudu Fernando, Topraj Gurung, and Zong-Sian Li.\n</p>\n<p>\nSolutions and other problem preparation by Ahmed Aly, Bartholomew Furrow, Igor Naverniouk, John Dethridge, Jonathan Paulson, Jonathan Shen, Khaled Hafez, Nikolay Kurtov, Onufry Wojtaszczyk, Patrick Nguyen, Petr Mitrichev, Steve Thomas, Steven Zhang, and Sumudu Fernando.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1402754400000,"tasks":[{"analysis":"<p>\nYou are given a log of criminals entering and leaving a house from the front door. The log is for one day, and at the start of the day there might be criminals in the house. This house may have other entrances and exits besides the front door, and the criminals might wear masks when entering/leaving the house. The task is to figure out if, given the log, it is possible that there is only one door (i.e. the front door only), and if so to figure out the minimum number of people that could be in the house at the end of the day.\n</p>\n<h3><b>Building intuition:</b></h3>\n<p>\nBefore proceeding with the solution, let us develop some intuition for the problem. Let us say we are actually given a log where <b><i>none</i></b> of the criminals wore a mask, i.e. none of the entries are ‘E 0’ or ‘L 0’. In that case, the solution would be to simulate the log from <b>start to end</b>, i.e. simulate criminals entering and leaving the house via <b><i>one</i></b> door only, and to see if the simulation is valid. When is a simulation valid? Let us instead discuss when a simulation would be invalid. During the simulation, if we encounter a ‘E X’ command (note X &gt; 0), and ‘X’ was already in the house then it is invalid (impossible to enter twice without leaving). Similarly if we encounter a ‘L X’ command, and ‘X’ isn’t already in the house then it is invalid. Note that if it was the first time encountering the ‘L X’ command then we can say that ‘X’ was already in the house at the start of the day so it would be valid.\n</p>\n<p>\nThe reason why the problem we are given is complicated is because of the presence of masked criminals. We are going to tackle this problem using a greedy strategy. We will first assume that there are <b>‘S’</b> number of criminals at the start of the day. Then we will do a simulation like we described before (i.e. simulation from start to end), except whenever we encounter a masked criminal, we will try to greedily assign a criminal number to the masked criminal. We will describe this greedy assignment later, but first let us describe a few terms we use in the editorial.\n</p>\n<h3><b>Terms:</b></h3>\n<p>\nLet us first describe some of the terms we use in this editorial. We call the log an <b>event</b> queue, which is a sequence of ‘E 0’, ‘L 0’, ‘E X’, or ‘L X’ (where X &gt; 0) events. During our simulation, we will go through the queue from start to end. During the simulation let us say we are at index i in the event queue, then we define the <b>current</b> event queue to be the subsequence of the event queue starting from index i to the end of the queue. During the simulation, we will also maintain a set of criminal numbers that are inside the house: we call the set <b>INSIDE</b>. Finally, the last term to define is the <b>next known event</b> for a particular criminal (non-zero) number. To help understand this term, we will use an example. Let us say our current event queue (along with the location indices) is:\n</p>\n<pre>\n0: ‘E 0’\n1: ‘E 0’\n2: ‘E 5’\n3: ‘L 1’\n4: ‘E 1’\n5: ‘L 1’\n6: ‘E 1’\n7: ‘L 5’\n8: ‘E 2’\n</pre>\n<p>\nThere are three unmasked criminal numbers: 1, 2 and 5. Note we do not consider the masked criminals. Criminal ‘1’ appears 4 times in the current queue at indices 3, 4, 5, and 6. The next known event for criminal ‘1’ is defined to be ‘L 1’ at index 3 (which is the earliest among the 4 events). Similarly criminal ‘2’ appears 1 time at index 8, therefore the next known event for criminal ‘2’ is ‘E 2’ at index 8. Similarly criminal ‘5’ appears 2 times, at indices 2 and 7. The next known event for criminal ‘5’ is defined to be ‘E 5’ at index 2.\n</p>\n<h3><b>Greedy strategy:</b></h3>\n<p>\nNow, let us proceed with the explanation for the greedy solution. First, let us assume we start with ‘S’ criminals already in the house. We will simulate the presence of these ‘S’ criminals in the house by adding ‘S’ ‘E 0’ events at the start of the event queue. To make things simpler during the simulation, we will pretend that all the criminals leave at the end of the day. To do so, we can add <b>‘T’</b> ‘L 0’ events to the end of the event queue such that the number of ‘E’ events and ‘L’ events are equal. We will then proceed to simulate this resulting event queue to check for validity and also in the process, if possible, assign numbers to the masked criminals. If the simulation is a valid simulation then for this event queue, our answer is ‘T’ i.e. the number of criminals remaining in the house at the end of the day. We will discuss how we find ‘S’ (and correspondingly ‘T’) later.\n</p>\n<p>\nWe now describe the simulation. As mentioned earlier, we simulate from the start to the end. If we are able to successfully go through all the events then this event queue is a valid event queue. At any instant we have a current event queue (which is defined above). Note that at the start of the simulation, the set INSIDE is an empty set. We will now discuss how to address the four cases for the first event in the current queue, i.e. the cases ‘E X’, ‘L X’, ‘E 0’ and ‘L 0’ (note that X &gt; 0).\n</p>\n<h3><b><i>Case ‘E X’:</i></b></h3>\n<p>\nIn this case, person ‘X’ is entering the house. It will only be valid if ‘X’ is <i>not</i> already inside the house, which we can check by seeing if the INSIDE set does not already contain ‘X’. If true, then this is a valid event, else it is an invalid event hence an invalid simulation therefore we end the simulation. Also, if ‘E X’ is valid, we need to update the INSIDE set by adding ‘X’ to it.\n</p>\n<h3><b><i>Case ‘L X’:</i></b></h3>\n<p>\nIn this case, person ‘X’ is leaving the house. It will only be valid if ‘X’ is already inside the house, which we can check by seeing if the INSIDE set contains ‘X’. If true, then this is a valid event, else it is an invalid event hence an invalid simulation therefore we end the simulation. Also, if ‘L X’ is valid, we need to update the INSIDE set by removing ‘X’ from it.\n</p>\n<h3><b><i>Case ‘E 0’:</i></b></h3>\n<p>\nIn this case, a masked criminal is entering. Our objective is to assign a number to this masked criminal. If we are able to assign a number to the masked criminal, the criminal will then enter the house which we do so by adding the assigned criminal number to the INSIDE set. Now the question is how do we assign numbers to this masked criminal. There are two cases to consider:\n</p>\n<h3><b><i>Case ‘E 0’ (a):</i></b></h3>\n<p>\nFirst, we consider the set of known criminals (i.e. ones that aren’t masked) in the current queue who are also not inside the house (i.e. not in the INSIDE set). Out of these criminals, we consider the criminals for which the next known event is a leave event (i.e. ‘L X’ for criminal ‘X’). These are the people who need to leave the house at some point, but it isn’t known when they leave the house. All of these people must enter the house in ‘E 0’ events that happen before they leave. If such a person exists, we make a greedy choice and choose the person who is leaving soonest, to leave ourselves with maximum time to get the remaining people out. Why do we make this greedy choice? Consider two such people, 1 and 2. The sequence, then, looks like this:\n</p>\n<pre>\n‘E 0’ ... ‘L 1’ ... ‘L 2’\n</pre>\n<p>\nNote that the ‘...’ denotes other events in the event queue which we do not list out to avoid complexity. In order for this event queue to be valid, there must be another ‘E 0’ to match the ‘L 1’ and ‘L 2’ events (note that 1 and 2 are not in the INSIDE set). There are two possibilities then:\n</p>\n<pre>\n‘E 0’ ... ‘E 0’ ... ‘L 1’ ... ‘L 2’\n</pre>\nand\n<pre>\n‘E 0’ ... ‘L 1’ ... ‘E 0’ ... ‘L 2’\n</pre>\n<p>\nIn both situations, choosing the entering masked criminal to have been criminal number ‘1’ works. But if we had instead chosen the entering masked criminal to have been criminal number ‘2’, then the second possibility listed above would be invalid (the second ‘L 1’ cannot be matched with the ‘E 0’ that comes after it). Therefore we are better off if we choose ‘1’. This logic generalizes to the case where there are more than two people.\n</p>\n<h3><b><i>Case ‘E 0’ (b):</i></b></h3>\n<p>\nIf no such person in Case ‘E 0’ (a) exists, we simply create a new person who doesn't show up anywhere unmasked (i.e. assign a number that is big e.g. a million; make sure to assign unique numbers to each new person). Why create a new person? It is because the alternative is to use someone who is outside the building, but whose next known event is an enter event. For example, let's suppose the person doing that is person 5. Then we have a sequence like this:\n</p>\n<pre>\n‘E 0’ ... ‘E 5’\n</pre>\n<p>\nFor person 5 to be entering at the start, we need the sequence to look like this:\n</p>\n<pre>\n‘E 0’ ... ‘L 0’ ... ‘E 5’\n</pre>\n<p>\nIn that situation, having person 1,000,000 enter is just as good as having person 5 enter. But in the situation where there is no ‘L 0’ between the ‘E 0’ and the ‘E 5’, person 1,000,000 could leave the house later (if there is a ‘L 0’ afterwards), but person 5 is stuck entering the house, then entering it again causing the simulation to be invalid. Therefore we better off to create a new person with a new unique number in such cases.\n</p>\n<h3><b><i>Case ‘L 0’:</i></b></h3>\n<p>\nIn this case, a masked criminal is leaving the house. As in the case for case ‘E 0’, the goal is to assign a number to the masked criminal. After assigning the number ‘X’ to the criminal (if that is possible), we must update the INSIDE set by removing ‘X’ from the set. Note that if the INSIDE set is empty when we encounter the ‘L 0’ event then it is an invalid simulation. For cases when there are criminals in the INSIDE set, there are three cases to consider:\n</p>\n<h3><b><i>Case ‘L 0’ (a):</i></b></h3>\n<p>\nConsider all the criminals who are inside, and whose next known event is that they are entering the house. By the same logic as in Case ‘E 0’ (a), we choose the one who is entering the soonest. If we are able to do such an assignment, we need not consider any of the other ‘L 0’ cases.\n</p>\n<h3><b><i>Case ‘L 0’ (b):</i></b></h3>\n<p>\nIf no such person in the previous case exists, then we consider all criminals who are inside the house. If there is one criminal who has no next known event (either ‘E X’ or ‘L X’) with the house, have that person leave; they have to leave at some point in no particular order, and it's better to have them leave than someone whose next known event is that they are leaving. If we were able to choose such a criminal, then we need not consider the last case.\n</p>\n<h3><b><i>Case ‘L 0’ (c):</i></b></h3>\n<p>\nIf no such person in the previous two cases exists, we're now stuck with criminals who are inside and whose next known event is that they're leaving. In such a case, we make a greedy choice and take the one who leaves as late as possible, so we have the maximum number of chances for our selected person to enter the house again (with an ‘E 0’ event). Why do we make this greedy choice? Consider two such people we need to choose from, 1 and 2. The sequence, then, looks like this:\n</p>\n<pre>\n‘L 0’ ... ‘L 1’ ... ‘L 2’\n</pre>\n<p>\nIn order for this to be valid, there must be another ‘E 0’. There are two possibilities:\n</p>\n<pre>\n‘L 0’ ... ‘E 0’ ... ‘L 1’ ... ‘L 2’\n</pre>\n<p>\nand\n</p>\n<pre>\n‘L 0’ ... ‘L 1’ ... ‘E 0’ ... ‘L 2’\n</pre>\n<p>\nIn both situations, assigning the leaving masked person (‘L 0’) to be person 2 works, but choosing 1 does not work for the second possibility. So we are better off to choose person 2 for ‘L 0’. This logic generalizes to the case where there are more than two people.\n</p>\n<br>\n<p>\nAnd so that concludes the four cases to consider for the first event in the current queue. As discussed earlier, if the first event is deemed invalid when considering the four cases, then we have an invalid simulation. But if we are able to successfully assign a criminal number, then we advance to the next event in the event queue and get a new current queue, and continue on with our simulation. If we reach the end, then it is a valid event queue.\n</p>\n<h3><b>Picking ‘S’ criminals initially in the house:</b></h3>\n<p>\nEarlier on, we had assumed there were ‘S’ criminals initially in the house. But the question is what value do we consider for ‘S’? We can try all values from 0 to <b>N</b> (the size of the queue). Doing so one by one might still be slow for the large input. However,  we can use binary search to make the search faster. Note that having more people (larger ‘S’) in the house gives us more flexibility to make the simulation work i.e. bigger values of ‘S’ gives us more ‘E 0’ at the start and more ‘L 0’ at the end to work with. Also if the simulation was valid for ‘S’ = i, it would be valid for ‘S’ = i + 1 too because we are adding a ‘E 0’ at the start and correspondingly a ‘L 0’ at the end (which can match each other in our already valid simulation for ‘S’ = i). This means that for the smaller values of ‘S’, we might get invalid simulations (i.e. false values), but after a certain ‘S’ value we will start getting valid simulations (i.e. true values). This indicates that the boolean function (i.e. that function that indicates whether the simulation is valid or not) is a <a href=\"http://en.wikipedia.org/wiki/Monotonic_function#Boolean_functions\" target=\"_blank\">monotonic boolean function</a> (for input ‘S’ = 0 to N). When a function is monotonic, we can use <a href=\"https://www.google.com/search?q=binary+search+topcoder\" target=\"_blank\">binary search</a> to make the search faster.\n</p>\n<p>\nFinally, as specified in the problem, if we are unable to find any valid simulation for any of the values of ‘S’ then we report “CRIME TIME” as the answer.\n</p>","id":"00000000004331cb","statement":"<h3>Problem</h3>\n\n<p>\nWhile working for the police, you've identified a house where people go to commit crimes, called Crime House. One day, you set up a camera over the door of the house and record a video.\n</p>\n<p>\nYou don't know how many people were in Crime House at the start of the day, but you can see people enter and leave through the front door. Unfortunately, because the people entering and leaving Crime House are criminals, sometimes they wear masks; and you aren't quite sure if the front door is the only way in or out.\n</p>\n<p>\nSometimes you can guess who was wearing a mask. If criminal #5 entered the house, then someone wearing a mask left, then criminal #5 entered the house again, then either the person wearing the mask was criminal #5, or there is another way out of Crime House.\n</p>\n<p>\nAt the end of the day, when Crime House has closed its doors for the night, you watch your video. Because you're an optimist, you want to figure out if it's <i>possible</i> that there are no other entrances or exits from crime house; and if so, you want to figure out the <i>minimum</i> number of people who could be in Crime House at the end of the day.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case starts with a line containing a single integer <b>N</b>, the number of times people pass through the front door of Crime House in the day. Next follows <b>N</b> lines, each of which contains information about one person entering or leaving Crime House through the front door.\n</p>\n<p>\nThat information consists of a single character, <code>E</code> or <code>L</code>, followed by a space and then an integer <b>id</b>. If the first character is <code>E</code>, that indicates someone entered Crime House through the front door; if it's <code>L</code>, someone left through the front door. If <b>id</b> is greater than zero, the person with that identifier entered or left Crime House. If <b>id</b> is zero, then the person who entered or left Crime House was wearing a mask, and we don't know who he or she was.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1).  If it's possible that there are no other entrances or exits from Crime House, then y should be the minimum number of people who could be in Crime House at the end of the day. If that's impossible, y should be \"CRIME TIME\".\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &le; <b>id</b> &le; 2000.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 15.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 1000<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n3\nE 5\nL 0\nE 5\n2\nL 1\nL 1\n4\nL 1\nE 0\nE 0\nL 1\n7\nL 2\nE 0\nE 1\nE 2\nE 0\nE 3\nL 4\n13\nL 4\nL 1\nL 2\nE 0\nL 1\nE 0\nL 2\nE 0\nL 2\nE 0\nE 0\nL 1\nL 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: CRIME TIME\nCase #3: 1\nCase #4: 4\nCase #5: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  ","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Crime House","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe problem can be paraphrased as follows: we are given a tree with N vertices where each vertex i has Ci coins. There are two players taking turns in the game. First, each player picks a starting vertex (could be the same vertex), then player 1 makes the first move. In a move, the player picks a new neighboring vertex adjacent to the last picked vertex, forming a simple path. The path of one player is allowed to intersect with at most one vertex (i.e., no edges overlap) with the path of the other player. The game ends when neither player can make a move. The score for the player is the sum of all coins in the vertices picked by the player subtracted by the sum of all coins in the vertices picked by the other player. Our task is to find the maximum score player 1 can get.\n</p>\n<p>\nThere are N possible starting vertices for player 1. After player 1 picks a starting vertex, player 2 also has N possible starting vertices. Both players will pick a starting vertex that maximizes their score. The high level solution for finding the maximum score for player 1 is shown in the pseudocode below:\n<p>\n<pre>\n  p1_max_score = -INFINITE\n  for p1_start_vertex in 1 .. N:\n    min_score = INFINITE\n    for p2_start_vertex in 1 .. N:\n      p1_score = <b>minimax</b>(p1_start_vertex, p2_start_vertex)\n      min_score = min(min_score, p1_score)\n    p1_max_score = max(p1_max_score, min_score)\n\n  print p1_max_score\n</pre>\n<p>\nPlayer 1 tries to pick the starting vertex that maximizes the p1_max_score while player 2 tries to pick the starting vertex that minimizes player 1’s score. The function <a href=\"https://www.google.com/search?q=minimax\" target=\"_blank\">minimax</a> is the main algorithm to maximize the score for the first player, given the starting vertex of each player.\n</p>\n<p>\nIn the next two sections, we will present two minimax algorithms. The first minimax algorithm is based on a depth-first search simulation which runs in O(N^2), thus giving the overall complexity of O(N^4). The other minimax algorithm is based on <a href=\"https://www.google.com/?#q=dynamic+programming+topcoder\" target=\"_blank\">dynamic programming</a> which can be precomputed in O(N^2) and gives answers in O(1), thus giving the overall complexity of O(N^2 + N^2) = O(N^2).\n</p>\n\n<h3><b>Minimax using simulation O(N^2)</b></h3>\n<p>\nGiven the starting vertex for each player, we can do a depth-first search (DFS) simulation for the minimax algorithm. The DFS state is the last vertices picked by each player and the player currently making the turn. The current player that makes the turn first grabs the coins at the current vertex and then tries to pick a neighboring vertex to visit that maximizes the total coins. Before visiting the neighboring vertex, the (bi-directional) edge connected to the new vertex is removed and later restored when the DFS backtracks. Finally, if the current player cannot make a move, then the player gives the turn to the other player to continue to make a move. The pseudocode below shows the sketch of the algorithm.\n</p>\n<pre>\nfunction rec(i, j, turn)  # See note 1\n  if visited[i][j][turn] return 0  # See note 2\n  visited[i][j][turn] = true\n\n  ci = C[i]  # See note 3\n  C[i] = 0  # Remove the coins at vertex i\n\n  ret = -INF\n  for each neighbor ni of i\n    remove edge[i][ni]  # See note 4\n    ret = max(ret, -rec(j, ni, 1 - turn))\n    restore edge[i][ni]\n\n  if ret == -INF\n    ret = -rec(j, i, 1 - turn)  # See note 5\n\n  C[i] = ci  # Restore the coins at vertex i\n\n  return ret + ci\n</pre>\n\n<p>\nNotes:\n<ol>\n<li>\nThe first parameter i of the rec function is the last vertex picked by the current player that is currently making the turn. The second parameter j is the last vertex picked by the other player. The third parameter <b><i>turn</i></b> is the player ID that is making the turn (0 is the first player and 1 is the second player)\n</li>\n<li>\nThe state (i, j, turn) is visited exactly once. The next visit to this vertex returns 0 which signifies a terminal condition.\n</li>\n<li>\nWe temporarily store the coins at the vertex of the current player. Then we remove coins from the vertex i (so that further moves in the DFS cannot reuse the coins again), and later restore the coins before returning.\n</li>\n<li>\nRemoving the connecting edge before visiting (recursing) the next vertex ensures that the edge will not be used any further by any of the players later in the DFS. Notice that the edge is restored later when the recursion backtracks. The same is true for the coins.\n</li>\n<li>\nIf the current player cannot move, it must give the turn to the other player.\n</li>\n</ol>\n</p>\n<p>\nGiven the starting vertex of both players, the DFS simulation above runs in O(N^2) to compute the maximum score for the first player. This comes from the number of distinct states in the parameters (N^2) and the fact that we never process the same state twice. The inner loop which loops through the neighbors of i can be amortized to O(1) since on average each vertex has 1 outgoing edge.\n</p>\n<p>\nUnfortunately, for different starting vertices, we cannot reuse the computation (i.e., we need to clear the visited states and start from scratch). Therefore the overall runtime complexity is O(N^4) which is only good for the small input N = 80.\n</p>\n<h3><b>Minimax with Dynamic Programming O(1)</b></h3>\n<p>\nThe idea behind the O(1) runtime complexity is to be able to reuse the computation when computing for different starting vertices for each player. The DFS state described in the previous section is not independent from another DFS state because it has to keep track of the coins that have already been taken and also the edges that cannot be used anymore. Different DFS states have different sets of coins and edges that are available. If we can design a state where it does not need to care about which coins or edges are available, then we can make each state independent and we can memoize (cache) the state results and reuse it to compute other states. This way, each state can be computed in O(1).\n</p>\n<p>\nTo design a state that is independent of each other, we need to make an important observation: <i>after a player makes a move, the edge connecting the last vertex to the new vertex is removed. If the new vertex is now unreachable from the other player’s last vertex then the two vertices are disconnected and each vertex is in its own tree, then the solution becomes trivial: each player simply takes <b>the best path</b> that remains open (the best path is the path that gives the maximum total coins) in its own tree. We therefore only need to perform minimax across states where the last vertices for both players are still in the same tree.</i>\n</p>\n<p>\nIn our new minimax algorithm, the state space can be entirely described by <b>the last edge</b> traversed by each player (which is only O(N^2) pair of edges). There are two choices for the current player to move (i.e., to pick the new neighboring vertex):\n<ol>\n<li>\n<b>Pick the vertex towards the other player’s last vertex.</b> Note that the input graph is a tree, therefore, there is exactly one unique path connecting the last vertices of both player. The player picks the next vertex in this path that brings them closer together. This move will transition (recurse) to a new state where the other player is now the one taking the turn. The new state is independent from the previous state since we do not need to care about which coins or edges have been removed (i.e., the current player cannot go back to the previous vertex and the other player cannot reach the vertices behind the current player anyway). The vertex that leads to the other player’s last vertex can be found in O(1) by precomputing it beforehand. The precomputation uses dynamic programming where the states are the last edge used by the current player, and the last vertex of the other player. The transition for the current player is to move closer to the last vertex of the other player which can be done in O(1) since each vertex has 1 edge on average (please refer to the sample implementation below for the details of how the <b><i>next_node_to</i></b> is pre-calculated). Now, let’s see an example for the first choice we have just described:\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1jmaDjdKPKUxWRDA4FCaUE_eSABffHxxivdr8bAfVO16DVl3VGBrL63eqmdoEfzBSWxOF5Bw/choice1.png\"><br>\n\nPlayer 1 is the current player that is making the move and is at vertex i1 and the last edge used is the connecting edge to vertex p1. Player 2 is at vertex i2 and the last edge used is the connecting edge to vertex p2. The current player 1 makes a move by picking the vertex n1 that leads to i2 (there is exactly one path that leads to i2). After player 1 makes a move, we can recurse to a new independent state where the current player is player 2 at i2 with the same last edge and the other player is player 1 at n1 with the last edge being the connecting edge to i1.\n<br><br>\n</li>\n<li>\n<b>Pick the next best vertex that does not lead to the other player’s last vertex.</b> We can pick the vertex in O(1) if we precompute the list of next best vertex beforehand. This move will disconnect the current player’s newly picked vertex from the other player’s last vertex and their maximum total coins can now be processed independently in O(1) as explained in the example below. The other player can then independently pick the best path that avoids the edges used by the current player in O(1). We demonstrate it with the following example:\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1GutgX9MN6a05acFH_i9HySDAqF6lGtCue8GIOpaqdmYm-9ZJUJrPH7ROjlu6FOgxkkv2jJg/choice2.png\"><br>\nJust like before, player 1 is the current player that is making the move and is at vertex i1 with the last edge connecting to vertex p1. The other player is player 2 at vertex i2 with the last edge connecting to vertex p2. The current player 1 picks the new vertex n1 which is the vertex leading to the best path that is disconnected with the other player’s last vertex i2. At this point, both players become independent. Player 2 is free to pick the best path that avoids the two edges used by player 1 (marked as red edges). Player 2 can try moving in the direction to i1 and then “branch-off” at any time to another direction to find its best path. The special case is when it has reached i1, it cannot branch-off in the direction of p1 nor n1 since those edges are already used. Player 2 can only branch-off to vertex f2 from vertex i1. This means that it is sufficient to keep the best 3 outgoing edges for each vertex because when we branch-off, we only consider the next best path to branch-off and the 3rd best path is used only in the special case. We can pre-compute the maximum total coins gained via branching-off in between i2 to i1 (both inclusive) using dynamic programming in O(N^2) (please refer to the <b><i>branch_off_between</i></b> method and its comments in the sample implementation below). Thus, to answer the maximum coins that player 2 can get in this case can be answered in O(1).\n</li>\n</ol>\n</p>\n<p>\nThe two cases above can be answered in O(1), therefore each state can be computed in O(1) and the result can be cached and reused to compute other states (i.e., it does not need to be re-set for different starting vertices). Since there are O(N^2) possible last edges for each player, there are only O(N^2) distinct states. Therefore, given any two starting vertices for each player, the new minimax algorithm can answer the maximum score for player 1 in O(1).\n</p>\n<p>\nBelow is the sample implementation in C++11.\n</p>\n\n<pre>\n<b>#include</b> &lt;algorithm&gt;\n<b>#include</b> &lt;cstdio&gt;\n<b>#include</b> &lt;cstring&gt;\n<b>#include</b> &lt;vector&gt;\n\n<b>using</b> <b>namespace</b> std;\n\n<b>#define</b> MAXN 4001\n<b>#define</b> MAXE (MAXN * 3)\n\n<b>vector</b><i>&lt;</i><b>int</b><i>&gt;</i> con[MAXN];\n<b>int</b> T<i>,</i> N<i>,</i> C[MAXN]<i>,</i> id;\n<b>int</b> edge_id[MAXN][MAXN];\n<b>int</b> next_node_to[MAXN][MAXN];\n<b>int</b> best_coins[MAXE];\n<b>int</b> best_nodes[MAXE][3];\n<b>int</b> memo_rec[MAXE][MAXE];\n<b>int</b> memo_branch_off[MAXE][MAXE];\n\n<i>// Pre-calculate the next_node_to, best_coins, best_nodes.</i>\n<b>void</b> precalc(<b>int</b> i<i>,</i> <b>int</b> pi<i>,</i> <b>int</b> from<i>,</i> <b>int</b> first_node) {\n  next_node_to[from][i] <i>=</i> first_node;\n  <b>int</b> <i>&amp;</i>best <i>=</i> best_coins[edge_id[i][pi]];\n  best <i>=</i> 0;\n  <b>vector</b><i>&lt;</i><b>pair</b><i>&lt;</i><b>int</b><i>,</i> <b>int</b><i>&gt;</i> <i>&gt;</i> arr;\n  <b>for</b> (<b>int</b> ni <i>:</i> con[i]) <b>if</b> (ni <i>!</i><i>=</i> pi) {\n    precalc(ni<i>,</i> i<i>,</i> from<i>,</i> first_node);\n    <b>int</b> coins <i>=</i> best_coins[edge_id[ni][i]];\n    arr<i>.</i>push_back(make_pair(coins<i>,</i> ni));\n    best <i>=</i> <b>max</b>(best<i>,</i> coins);\n  }\n  <b>sort</b>(arr<i>.</i>rbegin()<i>,</i> arr<i>.</i>rend());\n  <b>for</b> (<b>int</b> j <i>=</i> 0; j <i>&lt;</i> arr<i>.</i>size() <i>&amp;</i><i>&amp;</i> j <i>&lt;</i> 3; j<i>+</i><i>+</i>)\n    best_nodes[edge_id[i][pi]][j] <i>=</i> arr[j]<i>.</i>second;\n  best <i>+</i><i>=</i> C[i];\n}\n\n<i>// Returns the best next vertex when coming from</i>\n<i>// edge (pi -&gt; i), excluding vertex v1 and v2.</i>\n<b>int</b> next_best_except(<b>int</b> i<i>,</i> <b>int</b> pi<i>,</i> <b>int</b> v1<i>,</i> <b>int</b> v2 <i>=</i> <i>-</i>1) {\n  <b>int</b> ei <i>=</i> edge_id[i][pi];\n  <b>int</b> j <i>=</i> 0<i>,</i> <i>*</i>arr <i>=</i> best_nodes[ei];\n  <b>if</b> (arr[j] <i>=</i><i>=</i> v1 <i>|</i><i>|</i> arr[j] <i>=</i><i>=</i> v2) j<i>+</i><i>+</i>;\n  <b>if</b> (arr[j] <i>=</i><i>=</i> v1 <i>|</i><i>|</i> arr[j] <i>=</i><i>=</i> v2) j<i>+</i><i>+</i>;\n  <b>return</b> arr[j];\n}\n\n<i>// Maximum coins for sub-tree i with parent pi.</i>\n<b>int</b> max_coins(<b>int</b> i<i>,</i> <b>int</b> pi) {\n  <b>return</b> (i <i>&lt;</i> 0) <i>?</i> 0 <i>:</i> best_coins[edge_id[i][pi]];\n}\n\n<i>// Maximum coins for branching off at any vertex in [i, j].</i>\n<b>int</b> branch_off_between(<b>int</b> i<i>,</i> <b>int</b> pi<i>,</i> <b>int</b> j<i>,</i> <b>int</b> pj) {\n  <b>int</b> ei <i>=</i> edge_id[i][pi];\n  <b>int</b> ej <i>=</i> edge_id[j][pj];\n  <b>int</b> <i>&amp;</i>ret <i>=</i> memo_branch_off[ei][ej];\n  <b>if</b> (ret <i>!</i><i>=</i> <i>-</i>1) <b>return</b> ret;\n\n  <b>if</b> (i <i>=</i><i>=</i> j) {\n    <b>int</b> ni <i>=</i> next_best_except(i<i>,</i> pi<i>,</i> pj);\n    <b>int</b> nj <i>=</i> next_best_except(i<i>,</i> pi<i>,</i> pj<i>,</i> ni);\n    <i>// The other player takes the third best vertex nj since</i>\n    <i>// the best two are already taken by the current player.</i>\n    <b>return</b> ret <i>=</i> max_coins(nj<i>,</i> j);\n  }\n\n  <b>int</b> nj <i>=</i> next_node_to[j][i];\n  <b>int</b> njb <i>=</i> next_best_except(j<i>,</i> pj<i>,</i> nj);\n  <b>int</b> branch_off_now <i>=</i> max_coins(njb<i>,</i> j);\n  <b>int</b> branch_off_later <i>=</i> ((nj <i>=</i><i>=</i> i) <i>?</i> 0 <i>:</i> C[nj])\n    <i>+</i> branch_off_between(i<i>,</i> pi<i>,</i> nj<i>,</i> j);\n\n  <b>return</b> ret <i>=</i> <b>max</b>(branch_off_now<i>,</i> branch_off_later);\n}\n\n<i>// Minimax for the current player with last edge (pi -&gt; i)</i>\n<i>// and the other player with last edge (pj -&gt; j).</i>\n<b>int</b> rec(<b>int</b> i<i>,</i> <b>int</b> pi<i>,</i> <b>int</b> j<i>,</i> <b>int</b> pj) {\n  <b>int</b> ei <i>=</i> edge_id[i][pi];\n  <b>int</b> ej <i>=</i> edge_id[j][pj];\n  <b>int</b> <i>&amp;</i>ret <i>=</i> memo_rec[ei][ej];\n  <b>if</b> (ret <i>!</i><i>=</i> <i>-</i>1) <b>return</b> ret;\n\n  <b>if</b> (i <i>=</i><i>=</i> j) {\n    <i>// The current player pick the next best path.</i>\n    <b>int</b> ni <i>=</i> next_best_except(i<i>,</i> pi<i>,</i> pj);\n    <i>// The other player pick the next next best path.</i>\n    <b>int</b> nj <i>=</i> next_best_except(i<i>,</i> pi<i>,</i> pj<i>,</i> ni);\n    <b>return</b> ret <i>=</i> max_coins(ni<i>,</i> i) <i>-</i> max_coins(nj<i>,</i> j);\n  }\n\n  <i>// The first option for the current player:</i>\n  <i>// The current player pick the vertex ni</i>\n  <i>// that leads to other player last vertex.</i>\n  <b>int</b> ni <i>=</i> next_node_to[i][j];\n  <b>int</b> option1 <i>=</i> ((ni <i>=</i><i>=</i> j) <i>?</i> 0 <i>:</i> C[ni]) <i>-</i> rec(j<i>,</i> pj<i>,</i> ni<i>,</i> i);\n\n  <i>// The second option for the current player:</i>\n  <i>// The current player go to the best path other than ni.</i>\n  ni <i>=</i> next_best_except(i<i>,</i> pi<i>,</i> ni);\n  <b>int</b> p1coins <i>=</i> max_coins(ni<i>,</i> i);\n  <i>// The other player branch off at any point</i>\n  <i>// between vertex i and j (inclusive).</i>\n  <b>int</b> p2coins <i>=</i> branch_off_between(i<i>,</i> pi<i>,</i> j<i>,</i> pj);\n  <b>int</b> option2 <i>=</i> p1coins <i>-</i> p2coins;\n\n  <i>// Pick the best outcome for the current player.</i>\n  <b>return</b> ret <i>=</i> <b>max</b>(option1<i>,</i> option2);\n}\n\n<b>int</b> <b>main</b>() {\n  <b>scanf</b>(<b>\"</b><i>%d</i><b>\"</b><i>,</i> <i>&amp;</i>T);\n  <b>for</b> (<b>int</b> TC <i>=</i> 1; TC <i>&lt;</i><i>=</i> T; TC<i>+</i><i>+</i>) {\n    <b>scanf</b>(<b>\"</b><i>%d</i><b>\"</b><i>,</i> <i>&amp;</i>N);\n    <b>for</b> (<b>int</b> i <i>=</i> 0; i <i>&lt;</i> N; i<i>+</i><i>+</i>) {\n      <b>scanf</b>(<b>\"</b><i>%d</i><b>\"</b><i>,</i> <i>&amp;</i>C[i]);\n      con[i]<i>.</i>clear();\n    }\n    id <i>=</i> 0;\n    <b>memset</b>(edge_id<i>,</i> <i>-</i>1<i>,</i> <b>sizeof</b>(edge_id));\n    <b>for</b> (<b>int</b> i <i>=</i> 0<i>,</i> j; i <i>&lt;</i> N <i>-</i> 1; i<i>+</i><i>+</i>) {\n      <b>scanf</b>(<b>\"</b><i>%d</i><b>\"</b><i>,</i> <i>&amp;</i>j); j<i>-</i><i>-</i>;\n      con[i]<i>.</i>push_back(j);\n      con[j]<i>.</i>push_back(i);\n      edge_id[i][j] <i>=</i> id<i>+</i><i>+</i>;\n      edge_id[j][i] <i>=</i> id<i>+</i><i>+</i>;\n    }\n    <b>for</b> (<b>int</b> i <i>=</i> 0; i <i>&lt;</i> N; i<i>+</i><i>+</i>) {\n      edge_id[i][N] <i>=</i> id<i>+</i><i>+</i>;\n    }\n\n    <i>// These memoizations are reset per test case.</i>\n    <b>memset</b>(best_coins<i>,</i> <i>-</i>1<i>,</i> <b>sizeof</b>(best_coins));\n    <b>memset</b>(best_nodes<i>,</i> <i>-</i>1<i>,</i> <b>sizeof</b>(best_nodes));\n    <b>memset</b>(next_node_to<i>,</i> <i>-</i>1<i>,</i> <b>sizeof</b>(next_node_to));\n    <b>memset</b>(memo_rec<i>,</i> <i>-</i>1<i>,</i> <b>sizeof</b>(memo_rec));\n    <b>memset</b>(memo_branch_off<i>,</i> <i>-</i>1<i>,</i> <b>sizeof</b>(memo_branch_off));\n\n    <i>// Pre-calculation.</i>\n    <b>for</b> (<b>int</b> i <i>=</i> 0; i <i>&lt;</i> N; i<i>+</i><i>+</i>) {\n      precalc(i<i>,</i> N<i>,</i> i<i>,</i> N);\n      <b>for</b> (<b>int</b> j <i>:</i> con[i]) precalc(j<i>,</i> i<i>,</i> i<i>,</i> j);\n    }\n\n    <b>int</b> max_diff <i>=</i> <i>-</i>1000000000;\n    <b>for</b> (<b>int</b> i <i>=</i> 0; i <i>&lt;</i> N; i<i>+</i><i>+</i>) {\n      <b>int</b> min_diff <i>=</i> 1000000000;\n      <b>for</b> (<b>int</b> j <i>=</i> 0; j <i>&lt;</i> N; j<i>+</i><i>+</i>) {\n        <b>int</b> cost <i>=</i> C[i] <i>-</i> (i <i>=</i><i>=</i> j <i>?</i> 0 <i>:</i> C[j]);\n        min_diff <i>=</i> <b>min</b>(min_diff<i>,</i> cost <i>+</i> rec(i<i>,</i> N<i>,</i> j<i>,</i> N));\n      }\n      max_diff <i>=</i> <b>max</b>(max_diff<i>,</i> min_diff);\n    }\n    <b>printf</b>(<b>\"</b><b>Case #</b><i>%d</i><b>: </b><i>%d</i><i>\\n</i><b>\"</b><i>,</i> TC<i>,</i> max_diff);\n  }\n}\n</pre>","id":"00000000004336d0","statement":"<h3>Problem</h3>\n\n<p>\nHanaa and Sherine are playing Willow, a game that is played on a board containing <b>N</b> cities. The <code>i</code><sup>th</sup> city contains <b>C<sub>i</sub></b> coins, and there are <b>N</b> - 1 bidirectional roads running between the cities. All cities are reachable from one another. The game is played as follows:\n</p>\n<p>\nFirst Hanaa chooses one of the cities as her starting location, then Sherine chooses one of the cities (possibly the same one Hanaa chose) as her starting location. Afterwards, they take turns playing the game, with Hanaa going first.\n</p>\n<p>\nOn a player's turn, that player <i>must</i> take all the coins on the city where she currently is, if there are any; there might be none if the city starts with no coins, or if one of the players has already started a turn in that city. Then, if possible, the player must travel to an adjacent city on a road. It might not be possible, because each road can be used at most once. This means that after one player has used a road, neither player is allowed to use the same road later. The game ends when neither Hanaa nor Sherine can make a move.\n</p>\n<p>\nAfter the game ends, each player's score is equal to the difference between the number of coins she has and the number of coins her opponent has. If her opponent has more coins, this means that her score will be negative. Both players are trying to maximize their scores. Assuming that they are both using the best possible strategy to maximize their scores, what is the highest score that Hanaa can obtain?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case starts with a line containing one integer <b>N</b>, the number of cities on the board. <b>N</b> lines then follow, with the <code>i</code><sup>th</sup> line containing an integer <b>C<sub>i</sub></b>, the number of coins in city i.\n</p>\n<p>Finally there will be another <b>N</b> - 1 lines, with the <code>i</code><sup>th</sup> line (<code>i</code> starts from 1) containing a single integer <code>j</code> (<code>i</code>&nbsp;&lt;&nbsp;<code>j</code>&nbsp;&le;&nbsp;<b>N</b>) indicating that there is a road between city <code>i</code> and city <code>j</code>. All cities are guaranteed to be reachable from one another at the start of the game.\n</p>\n\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the highest score that Hanaa can obtain.\n</p>\n\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 50.<br>\n0 &le; <b>C<sub>i</sub></b> &le; 10000.<br>\n</p>\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>N</b> &le; 80.\n</p>\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n2 &le; <b>N</b> &le; 500.<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n1000\n200\n1000\n2\n3\n8\n8\n0\n8\n0\n0\n0\n0\n10\n2\n5\n4\n5\n6\n7\n8\n10\n150\n200\n0\n5000\n0\n100\n0\n0\n0\n10000\n10\n3\n8\n5\n8\n7\n8\n9\n10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 200\nCase #2: -2\nCase #3: 5100\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Willow","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>There is an array of devices, each containing a known number of transistors, and among these there is 1 golden transistor both players want. Player 1 (Arnar) specifies a section of the array (this will divide the array into 3 sections [0,i), [i,j], (j,N-1]), then player 2 (Solveig) will pick one of the sections to take, leaving the other two for player 1. The problem asks us to find Arnar's chances of getting the special transistor given that both players act optimally and that every transistor has the same probability of being the golden one.\n\n<p>First, we recognize that we can compute the summation of any section of the array in O(1) time after precomputing a sum array. A sum array can be constructed using the following recurrence from 0 to N:\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2DKtPWib9QbDXFzo5u1LknczYNGwKZ7twXGYGZlnGcB_dHOXAWGmZ85GMdBruNTX86yw/gcj0.png\">\n\n<p>Then, for any partition of the device array, we can efficiently find the number of transistors inside each section using:\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0S7_czCFCrLBOMqQynUL1GoBS-wfBiwOOmcWfBHJ-tUkKb8sE4rhLObzxlY3j28U_xiQ/gcj1.png\">\n\n<p>In order to determine the best boundaries that Arnar can put on the array, we can iterate through all the possible boundaries and store the best one. In code, this translates to using 2 for loops that cover all combinations of i and j with i &lt;= j. For each, we can obtain the number of transistors in each resulting section (using the sum array as discussed above). Then, since Solveig will always take the section with the most transistors, Arnar’s score for a particular choice of boundaries is the minimum of any combination of 2 sections (right + left, middle + left, middle + right).\n\n<p>This solution runs in O(N^2) because we consider all combinations of i and j. This is good enough to pass the small input; however, it will timeout when running the large input. To pass the large input, we should come up with an O(N log N) algorithm. We need a couple more key observations for the O(N log N) algorithm:\n\n<p>First, notice that we can reformulate this problem as finding which 3-way partitioning minimizes the largest value of any partition, since Solveig will definitely choose the section with the most transistors after Arnar has decided on the 3-way partition.\n\n<p>Second, as a follow-up to the observation above, it only makes sense for Arnar to choose boundaries in which the values of the 3 sections are as close as possible with each other (otherwise Solveig will gain the upper hand by choosing the section that has significantly more transistors than the other 2, leaving less for Arnar).\n\n<p>The last insight that will allow us to come up with an O(N log N) algorithm is that the cumulative sum array is by nature sorted therefore it is monotonically increasing, which hints at the idea that we can utilize <a href=\"https://www.google.com/search?q=binary+search+topcoder\" target=\"_blank\">binary search</a>. The algorithm idea is to iterate through the possible values for i (left boundary), and then to binary search for the optimal j (right boundary) given that left boundary. Specifically, we want the value of j that minimizes the difference between the transistor counts in the [i,j] section and the (j,N-1] section. We now describe the binary search process. We will start with 2 pointers (the possible range that our right boundary could be). The pivot will be in the middle of the 2 pointers (this is our guess at where the right boundary will be). If the right side of the pivot is greater than the left side of the pivot then we know our right boundary will be somewhere on the right and vice versa, so we can cut our possible range by half (and do so repeatedly until there is only one possibility).\n\n<p>Let’s go through an example for clarification. This example is taken from sample input 2 :\n\n<pre><code>INPUT: 10 17 1 7 1  generates  [2 5 1 4 7 3 6 2 5 1]</code></pre>\n\n<p>Now let’s say our left pointer is between index 0 and 1 and we are trying to find the best right boundary using binary search. Our first guess should be for the right boundary to be between the left boundary and the end of the array (which puts it between values 3 and 6). The table below will illustrate the progression of our binary search. The first column contains a visualization of our array and the boundaries we are checking. The next 3 columns contain the values of each partition that is made by the boundaries. The last 2 columns tells us how many transistors each player will receive with the given partition. Each row is an iteration of our binary search.\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U20F1_I7VhmhFItGHCw4ji7QEdqjkC4VwIf7Fon5PetiCXBhp5CwgQ5noIg5IQow9UF4w/gcj2.png\">\n\n<p>Notice that the right partition is always moving in such a way to maximize the value of the partition (middle and right)  that is lacking (i.e. in the second row in the figure above we moved to the left because the middle partition value is greater than the right partition value in the first row).\n\n<p>Since we have a way to find the optimal partitioning with a given left boundary, our answer is then the best answer out of those after we iterate through all possible left boundaries. Binary search takes O(log N) and we do that for N left boundaries which gives us a total of O(N log N) runtime.\n\n<p>This solution is good enough to pass all of our tests; however, it is possible to do even better. For example, we can try to find a tight lower bound on Solveig's score by answering questions of the form: \"Can Arnar produce a 3-way partitioning that limits Solveig to a score of at most Z?\". Clearly there is some value K such that the answer to this question is \"no\" for Z &lt; K and \"yes\" for Z &gt;= K, which means that K can be found by binary search.\n\n<p>In order to answer such a question, we note that given Z, Arnar can't do better than to choose the left and middle sections greedily: he selects i as large as possible while putting no more than Z transistors in the left section, and then j as large as possible while putting no more than Z transistors in the middle section. Then, if the resulting right section also contains no more than Z transistors, the answer to the question is \"yes\", otherwise \"no\". Finally, we see that these values for i and j can be found efficiently by using binary search in the sum array, so we can answer our question for a specific Z in O(log N) time.\n\n<p>This strategy takes O((log N)^2) for the outer binary search (we ask O(log N) questions that each take O(log N) time to answer), but of course it also requires use of the sum array which takes O(N) time to compute. Therefore, the overall complexity is O(N). Perhaps surprisingly, it is even possible to solve this problem in O((log r)(log N)^2)! See if you can figure out how to use some <a href=\"https://www.google.com/search?q=A+Simple+Algorithm+for+Lattice+Point+Counting+in+Rational+Polygons\" target=\"_blank\">complicated math</a> to avoid computing all O(N) elements of the sum array (hint: you need to exploit the particular formula given for the number of transistors in each device).\n","id":"000000000043380e","statement":"<h3>Problem</h3>\n\n<p>\nThe mysterious owner of an electronics factory has decided to do something very intriguing. She has hidden <i>golden transistors</i> inside seven electronic devices, and the people who buy those devices will be invited to a magical, marvelous tour of the factory.\n</p>\n<p>\nArnar and Solveig have received a tip that there is a golden transistor hidden inside one device in their local electronics store. First they pooled their money together and bought all the devices, then placed them in a straight line, numbering the devices 0 to <b>N</b>-1. Each device has some number of transistors in it. Then they agreed on a strategy to decide who gets the golden transistor:\n</p>\n<p>\nFirst, Arnar will select a range <code>[a, b]</code> (inclusive) of the devices, where <code>0&nbsp;&le;&nbsp;a&nbsp;&le;&nbsp;b&nbsp;&lt;&nbsp;N</code>. Next, Solveig will choose which one set of devices she wants to take:\n<ul>\n<li>If a &gt; 0, she may take all the devices in the range <code>[0, a-1]</code>.\n<li>If b &lt; <b>N</b>-1, she may take all the devices in the range <code>[b+1, N-1]</code>.\n<li>She may always choose to take all the devices in the range <code>[a, b]</code>.\n</ul>\nOnce Solveig has chosen one of the sets of devices, Arnar takes all the devices she did not take.\n</p>\n<p>\nFor example, if there are 3 devices and Arnar selects the range <code>[1, 1]</code>, Solveig may choose to take the range <code>[0, 0]</code>, the range <code>[1, 1]</code> or the range <code>[2, 2]</code>. On the other hand, if Arnar selects the range <code>[1, 2]</code>, then Solveig may choose to take the range <code>[0, 0]</code> or the range <code>[1, 2]</code>.</p>\n<p>\nGiven how many transistors are in each device, and that Arnar and Solveig will each try to maximize their probability of getting the golden transistor (which is maximized by taking electronics with the maximum number of transistors), what is Arnar's probability of getting the golden transistor and thus winning the magical, marvelous tour?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> lines follow. Each line contains five numbers: <b>N</b>, <b>p</b>, <b>q</b>, <b>r</b> and <b>s</b>. This indicates that there are <b>N</b> devices, and the <code>i</code><sup>th</sup> device contains ((<code>i</code> * <b>p</b> + <b>q</b>) MOD <b>r</b> + <b>s</b>) transistors. Remember that the devices are numbered from 0 to <b>N</b>-1.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is Arnar's probability of winning the magical, marvelous tour.\n</p>\n<p>\ny will be considered correct if it is within an absolute or relative error of 10<sup>-9</sup> of the correct answer.  See the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an explanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>p</b> &le; 10<sup>6</sup>.<br/>\n1 &le; <b>q</b> &le; 10<sup>6</sup>.<br/>\n1 &le; <b>r</b> &le; 10<sup>6</sup>.<br/>\n1 &le; <b>s</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">8\n1 1 1 1 1\n10 17 1 7 1\n2 100 100 200 1\n20 17 3 23 100\n10 999999 999999 1000000 1000000\n2 1 1 1 1\n3 1 99 100 1\n999999 1000000 999999 1000000 1000000\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.0000000000\nCase #2: 0.6111111111\nCase #3: 0.0098039216\nCase #4: 0.6471920290\nCase #5: 0.6000006000\nCase #6: 0.5000000000\nCase #7: 0.0291262136\nCase #8: 0.6666666667\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n<p>\nNote that the last sample case does not meet the limits for the Small dataset. You could have a correct solution for the Small dataset that returns the wrong answer, or runs for a very long time, on the last sample case.\n</p>\n\n<h4>Explanation of Sample Cases</h4>\n<p>\nIn the first sample case, there is one electronic device with one transistor. Arnar must select the range [0, 0], and Solveig must choose to take all the devices in the range [0, 0]. Arnar can't possibly win the magical, marvelous tour.\n</p>\n<p>\nIn the second sample case, there are ten electronic devices, with the following numbers of transistors: <code>[2, 5, 1, 4, 7, 3, 6, 2, 5, 1]</code>. Arnar will choose the range [4, 5], which contains the devices with 7 and 3 transistors. Solveig will choose the range [6, 9], which contains the devices with 6, 2, 5 and 1 transistors, leaving Arnar with the first six devices, and a probability of 22/36 of winning the tour.\n</p>\n<p>\nIn the third sample case, the devices have 101 and 1 transistors.\n</p>\n<p>\nIn the fourth sample case, the devices have the following numbers of transistors: <code>[103, 120, 114, 108, 102, 119, 113, 107, 101, 118, 112, 106, 100, 117, 111, 105, 122, 116, 110, 104]</code>.\n</p>\n<p>\nIn the fifth sample case, the devices have the following numbers of transistors: <code>[1999999, 1999998, 1999997, 1999996, 1999995, 1999994, 1999993, 1999992, 1999991, 1999990]</code>.\n</p>\n<p>\nIn the sixth sample case, the devices both have 1 transistor.\n</p>\n<p>\nIn the seventh sample case, the devices have the following numbers of transistors: <code>[100, 1, 2]</code>.\n</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":8}],"title":"Magical, Marvelous Tour","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>Diana and the tower take turns in shooting N monsters and Diana goes first. Diana can shoot any monster or skip the turn, while the tower always shoots the monster that is the closest to the tower. Each monster i starts with a certain hit points <b>H<sub>i</sub></b> and it decreases by P when shot by Diana and decreases by Q when shot by the tower. If the hit points goes below 1, the monster dies and cannot be shot further. Diana is awarded <b>G<sub>i</sub></b> gold if her shot kills the i-th monster, but none if the tower’s shot kills it. What is the maximum amount of gold Diana can obtain?\n\n<p>The key observation here is that, for Diana, shooting a monster other than the one currently targeted by the tower is exactly equivalent to not shooting any monster in this turn and instead getting an “extra” shot that can be used at a later turn. Later, Diana may use some or all of her accumulated extra shots consecutively. So instead of making the decision “which monster do I shoot?” before each tower shot, Diana only needs to decide whether to use one of her extra shots (on the closest living monster) or let the tower take a shot.\n\n<p>This reduces the problem to a <a href=\"https://www.google.com/search?q=dynamic+programming+topcoder\" target=\"_blank\">dynamic programming (DP)</a> solution with the state being: the current monster i to target, the remaining hits points for the current monster and the number extra shots that Diana has. Note that since there is a lower limit on P and Q, the maximum number of extra shots for Diana is <b>1000</b>. In the DP solution, there are three transitions:\n<ol>\n<li>The current monster is dead and we move on to the next monster,\n<li>Diana skips a shot and gains one extra shot (letting the tower shoot once),\n<li>Diana shoots the monster once using her extra shots, possibly killing the current monster and getting its gold.\n</ol>\n\n<p>Below is the pseudocode for the top-down dynamic programming with some clarifying comments:\n\n<pre><code># We are at monster <b><i>i</i></b> which has <b><i>rem_hp</i></b> HP left and Diana has\n# <b><i>extra_shots</i></b> shots saved up, how much gold can she get?\nfunction rec(i, rem_hp, extra_shots)\n  # Base case: all monsters have been killed.\n  if (rem_hp &lt;= 0 &amp;&amp; i + 1 == N) return 0\n\n  # Monster i is dead, move on to the next one.\n  if (rem_hp &lt;= 0) return rec(i + 1, H[i + 1], extra_shots)\n\n  # Memoization.\n  if is_set(memo[i][rem_hp][extra_shots])\n    return memo[i][rem_hp][extra_shots]\n\n  # The tower shoots next. Diana saves up another shot.\n  ret = rec(i, rem_hp - Q, extra_shots + 1)\n\n  # Diana shoots next, using one of the saved up shots.\n  # If the shot kills the current monster, she gets its gold.\n  if (extra_shots &gt; 0)\n    gold = (rem_hp &lt;= P) ? G[i] : 0\n    ret = max(ret, gold + rec(i, rem_hp - P, extra_shots - 1))\n\n  return memo[i][rem_hp][extra_shots] = ret\n\n\n# Since Diana plays first, she has one extra shot initially.\nprint rec(0, H[0], 1)\n</code></pre>\n","id":"0000000000433a3e","statement":"<h3>Problem</h3>\n\n<p>\nDiana needs your help maximizing her gold while playing her favorite game. She is often faced with a scenario where she is standing close to her tower and is facing <b>N</b> monsters. When that happens, Diana and the tower take turns shooting the monsters, and she goes first. During her turn, Diana <i>may</i> choose a monster to shoot at (this means Diana may choose to skip a turn). During its turn, the tower shoots the monster closest to it. Diana and the tower can not shoot dead monsters.\n\n<p>\nIf Diana shoots at a monster, its hit points are reduced by <b>P</b>. If the tower shoots at a monster, its hit points are reduced by <b>Q</b>. If a monster's hit points are reduced below 1, it is killed. The <code>i</code><sup>th</sup> monster starts with <b>H<sub>i</sub></b> hit points. Diana is awarded <b>G<sub>i</sub></b> gold if her shot kills the <code>i</code><sup>th</sup> monster, but none if the tower's shot kills it. What is the maximum amount of gold Diana can obtain?<br><br>\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each case begins with one line containing three space-separated integers representing <b>P</b>, <b>Q</b> and <b>N</b>. <b>N</b> lines then follow, with the <code>i</code><sup>th</sup> line containing two space-separated integers representing <b>H<sub>i</sub></b> and <b>G<sub>i</sub></b>.<br><br>\n\nThe monsters are given in the order of their distance from the tower. In other words, the tower will shoot at the <code>i</code><sup>th</sup> monster only if all monsters &lt; i are dead.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the maximum amount of gold that Diana can obtain.\n</p>\n<p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100<br>\n20 &le; <b>P</b> &le; 200<br>\n20 &le; <b>Q</b> &le; 200<br>\n1 &le; <b>H<sub>i</sub></b> &le; 200<br>\n0 &le; <b>G<sub>i</sub></b> &le; 10<sup>6</sup><br>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 4\n</p>\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 100\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n20 40 3\n100 100\n20 100\n60 100\n20 60 3\n80 100\n80 200\n120 300\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 300\nCase #2: 500\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \nIn the second example, Diana should give up the first monster. During her first two turns she should soften up the third monster bringing it down to 80 hp, allowing her to easily get the last shot on the second and the third monsters.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Last Hit","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043371f","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2014"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
