{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1367692200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432be7","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"  <p>Round 1B attracted nearly 5000 participants fighting for the 1000 spots that gave qualification to Round 2. The first problem our contestants faced was game-based Osmos with a greedy solution; over 3500 contestants managed to figure it out. This was followed by Falling Diamonds, where you had to calculate the probability of getting a diamond; a significant number of contestants had a hard time with getting the small input right. See the analysis of the problem for our ideas on how to solve it!</p>\n\n<p>The final problem of this round was Garbled Email, which was much more accessible than Round 1A's Good Luck, with over 200 successful submissions for the large. This required some insightful string manipulation to handle a huge dictionary we provided.</p>\n\n<p>119 contestants managed to get a full score from this round, led by Indonesia's dolphinigle, who finished all the problems in a bit over an hour. To advance to Round 2 you needed either the large of one of the two more difficult problems, large of Osmos and the small of Falling Diamonds, or large of Osmos, small of Garbled Email, and a really impressive speed!</p>\n\n<p>Congratulations to the top 1000, and we hope you enjoyed the problems in this round!</p>\n\n<hr/>\n<p>Cast</p>\n<p>Problem A. <i>Osmos</i> written by Bartholomew Furrow. Prepared by Zhen Wang and Bartholomew Furrow.</p>\n\n<p>Problem B. <i>Falling Diamonds</i> written by Onufry Wojtaszczyk. Prepared by Alex Fetisov and Tomek Czajka.</p>\n\n<p>Problem C. <i>Garbled Email</i> written by Bartholomew Furrow. Prepared by Jonathan Wills and Bartholomew Furrow.</p>\n\n<p>Contest analysis presented by Onufry Wojtaszczyk and Bartholomew Furrow. Solutions and other problem preparation by Igor Naverniouk, Ahmed Aly, Tomek Kulczynski, Hackson Leung, Karim Nosseir, Hao Pan, Md. Arifuzzaman Arif, Sean Henderson and John Dethridge.</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1367683200000,"tasks":[{"analysis":"We can simplify the problem by making the following observation:\n\n<blockquote>\nThere is an optimal solution where Armin chooses to absorb motes in order from smallest to largest (skipping removed motes).\n</blockquote>\n<p>\nIf Armin's solution absorbs mote X before mote Y, and mote X is larger than mote Y, then he could change his solution to absorb Y right before X, without needing to perform any extra \"add\" or \"remove\" operations.  So if Armin has an optimal solution, we can always change it into an optimal solution that absorbs motes in order of size.\n</p>\n<p>\nNow we can limit our search to solutions that absorb motes in order of size.  We could use a dynamic programming algorithm where the state is the number of motes considered, and Armin's mote's current size or the number of operations performed, but there is a simpler algorithm based on the following observation:\n\n<blockquote>\nIn an optimal solution, if Armin removes a mote, he also removes all motes of equal or greater size.\n</blockquote>\n\nTo see this, consider a solution where there exist motes X and Y where X is smaller than or equal in size to Y, X is removed, and Y is absorbed.  X could instead be absorbed immediately before Y is absorbed, which would save an operation by not removing X.  So the solution cannot be optimal.\n</p>\n<p>\nSo to find an optimal solution, we only need to consider <b>N</b>+1 cases -- those where we try to absorb 0, 1, ... <b>N</b> of the original motes and remove the remainder.\n</p>\n<p>\nTo find how many operations are needed for each of these cases, we simulate Armin trying to absorb each mote in turn.  If Armin's mote is not yet large enough to absorb the next mote, we add motes of size one less than Armin's mote's current size and absorb them, until Armin's mote is large enough.\n</p>\n<p>This solution takes O(<b>N</b><sup>2</sup>) time to run as written, which is fast enough given the input size limits. There is a small adjustment to it that will make it linear, though. Can you see it?\n</p>\n<p>\nOne final case to handle is when Armin's mote is of size 1, and so is unable to absorb any motes at all.  We were generous and added this as a case in the sample input!\n</p>\n<br>\n<p>\nThis mechanics for this problem were inspired by <a href=\"http://www.youtube.com/watch?v=jrzhlTn1_ds\" target=\"_blank\">Osmos</a> by <a href=\"http://www.hemispheregames.com/osmos/\" target=\"_blank\">Hemisphere Games.</a>\n</p>","id":"0000000000432a8b","statement":"<h3>Problem</h3>\n<p>\nArmin is playing Osmos, a physics-based puzzle game developed by Hemisphere Games.  In this game, he plays a \"mote\", moving around and absorbing smaller motes.\n</p>\n<p>\nA \"mote\" in English is a small particle.  In this game, it's a thing that absorbs (or is absorbed by) other things!  The game in this problem has a similar idea to Osmos, but does not assume you have played the game.\n</p>\n<p>\nWhen Armin's mote absorbs a smaller mote, his mote becomes bigger by the smaller mote's size.  Now that it's bigger, it might be able to absorb even more motes.\nFor example: suppose Armin's mote has size 10, and there are other motes of sizes 9, 13 and 19.  At the start, Armin's mote can only absorb the mote of size 9.  When it absorbs that, it will have size 19.  Then it can only absorb the mote of size 13.  When it absorbs that, it'll have size 32.  Now Armin's mote can absorb the last mote.\n</p>\n<p>\nNote that Armin's mote can absorb another mote if and only if the other mote is <i>smaller</i>.  If the other mote is the same size as his, his mote can't absorb it.\n</p>\n<p>\nYou are responsible for the program that creates motes for Armin to absorb.  The program has already created some motes, of various sizes, and has created Armin's mote.  Unfortunately, given his mote's size and the list of other motes, it's possible that there's no way for Armin's mote to absorb them all.\n</p>\n<p>\nYou want to fix that.  There are two kinds of operations you can perform, in any order, any number of times: you can add a mote of any positive integer size to the game, or you can remove any one of the existing motes.  What is the minimum number of times you can perform those operations in order to make it possible for Armin's mote to absorb every other mote?\n</p>\n<p>\nFor example, suppose Armin's mote is of size 10 and the other motes are of sizes [9, 20, 25, 100].  This game isn't currently solvable, but by adding a mote of size 3 and removing the mote of size 100, you can make it solvable in only 2 operations.  The answer here is 2.\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  The first line of each test case gives the size of Armin's mote, <b>A</b>, and the number of other motes, <b>N</b>. The second line contains the <b>N</b> sizes of the other motes.  All the mote sizes given will be integers.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the minimum number of operations needed to make the game solvable.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>A</b> &le; 100.<br/>\n1 &le; all mote sizes &le; 100.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>A</b> &le; 10<sup>6</sup>.<br/>\n1 &le; all mote sizes &le; 10<sup>6</sup>.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2 2\n2 1\n2 4\n2 1 1 6\n10 4\n25 20 9 100\n1 4\n1 1 1 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 1\nCase #3: 2\nCase #4: 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Notes</h3>\n<p>\nAlthough the size of motes is limited in the input files, Armin's mote may grow larger than the provided limits by absorbing other motes.\n</p>\n<p>\nOsmos was created by Hemisphere Games.  Hemisphere Games does not endorse and has no involvement with Google Code Jam.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Osmos","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>This was a tricky problem, and solving the small often made the difference between advancing and not - in particular, solving all of this problem was enough to advance; as was solving the small of this problem and the large of Osmos.</p>\n\n<h2>The small case</h2>\n<p>For the small case, we had only twenty diamonds to deal with in each test case. Note that every diamond will do something non-deterministic at most once, when it falls point down on the point of another diamond (when it can slide in one of two directions). This means that we will have at most 2<sup>20</sup> different things that can happen when the diamonds fall, so we can simply try to enumerate all of them (note that there is actually less possible paths - for instance the first, fifth and sixth will never have a choice).\n</p>\n\n<p>\nThis is actually a bit tricky to do, since in each branch we have to keep track of what is the probability of reaching this branch &mdash; it is not only dependent on how many diamonds we processed so far, but rather on how many diamonds had a choice so far. After this is done, we need to figure out in how many of all the options the place we're interested in did get a diamond and add them all up. All this is not easy to get right, but it is doable, as over 900 of our contestants proved!\n</p>\n\n<h2>The large case</h2>\n<p>\nFor the large test case, we will need to be smarter &mdash; simulating all the options is obviously not a choice for 10<sup>6</sup> diamonds. We will begin with the following observation:\n<blockquote>\nThe diamonds fall in layers. First a diamond falls at (0, 0), then diamonds fall into positions with |X| + |Y| = 2, only after all five of these are filled the positions with |X| + |Y| = 4 start filling, only after them the |X| + |Y| = 6 start filling, and so on.\n</blockquote>\nIndeed, note that the diamond sliding to one side does not change the layer it is in, since it always starts sliding in some (0, 2k) position, and the (0, 2k) position is always the last in a layer to be filled.\n</p>\n\n<p>\nThus, when <b>N</b> diamonds fall, the only uncertainty as to how they shape up is in the last layer, and this is what we have to calculate. If the place we are considering is not in this layer, we can respond immediately. Thus, we have only to figure out probabilities in the last layer.\n</p>\n\n<h2>The dynamic programming approach</h2>\n<p>\nFirst let's estimate how large the last layer can be. If we have at most a million diamonds, one can calculate there will be no more than 710 layers. When diamonds fall, the state of the layer can be described by two numbers &mdash; how many diamonds are on the left of the center (with negative X), and how many are to the right (we assume here there aren't enough diamonds to fill this layer, so the top spot with X = 0 will stay empty). This means that when the diamonds drop, there are roughly 500,000 different states to consider. \n<p>\nOne can approach to this problem is dynamic programming. For each of the states possible for the last layer, we calculate the probability of reaching this state when the appropriate number of diamonds has dropped (each state determines the number of diamonds uniquely).\n</p>\n<h2>A formulaic approach</h2>\n<p>\nOne can also notice that what matters is how many diamonds of the ones that hit the top decide to go left, and how many to go right. Which diamonds exactly are those does not matter for the final state. Thus, we can precalculate binomial coefficients (or rather binomial coefficients divided by 2<sup>D</sup>, where D is the number of diamonds falling into the layer), and &mdash; once we know which layer we're looking &mdash; sum up the options that lead to a diamond falling into the right place.\n</p>","id":"0000000000432ada","statement":"<h3>Problem</h3>\n<p>\nDiamonds are falling from the sky. People are now buying up locations where the diamonds can land, just to own a diamond if one does land there. You have been offered one such place, and want to know whether it is a good deal.\n</p>\n\n<p>\nDiamonds are shaped like, you guessed it, diamonds: they are squares with vertices (X-1,&nbsp;Y), (X,&nbsp;Y+1), (X+1,&nbsp;Y) and (X,&nbsp;Y-1) for some X,&nbsp;Y which we call the center of the diamond. All the diamonds are always in the X-Y plane. X is the horizontal direction, Y is the vertical direction. The ground is at Y=0, and positive Y coordinates are above the ground.\n</p>\n\n<p>The diamonds fall one at a time along the Y axis. This means that they start at (0,&nbsp;Y) with Y very large, and fall vertically down, until they hit either the ground or another diamond.\n</p>\n\n<p>\nWhen a diamond hits the ground, it falls until it is buried into the ground up to its center, and then stops moving. This effectively means that all diamonds stop falling or sliding if their center reaches Y=0.\n</p>\n\n<p> When a diamond hits another diamond, vertex to vertex, it can start sliding down, without turning, in one of the two possible directions: down and left, or down and right. If there is no diamond immediately blocking either of the sides, it slides left or right with equal probability. If there is a diamond blocking one of the sides, the falling diamond will slide to the other side until it is blocked by another diamond, or becomes buried in the ground. If there are diamonds blocking the paths to the left and to the right, the diamond just stops.\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1H_rMeotkVMm6sHEIwrw3cwKYaRrKFLGRNV9e6Y3ZGbLV8KrINuxEl_rW9dr2t6DP-TX0cpm0/diamonds.png\">\n\n<p>\nConsider the example in the picture. The first diamond hits the ground and stops when halfway buried, with its center at (0,&nbsp;0). The second diamond may slide either to the left or to the right with equal probability. Here, it happened to go left. It stops buried in the ground next to the first diamond, at (-2,&nbsp;0). The third diamond will also hit the first one.  Then it will either randomly slide to the right and stop in the ground, or slide to the left, and stop between and above the two already-placed diamonds. It again happened to go left, so it stopped at (-1,&nbsp;1). The fourth diamond has no choice: it will slide right, and stop in the ground at (2,&nbsp;0).\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> lines follow.  Each line contains three integers: the number of falling diamonds <b>N</b>, and the position <b>X,&nbsp;Y</b> of the place you are interested in. Note the place that you are interested in buying does not have to be at or near the ground.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case output one line containing \"Case #x:&nbsp;p\", where x is the case number (starting from 1) and p is the probability that one of the <b>N</b> diamonds will fall so that its center ends up exactly at (<b>X</b>,&nbsp;<b>Y</b>). The answer will be considered correct if it is within an absolute error of 10<sup>-6</sup> away from the correct answer.  See the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an explanation of what that means, and what formats of floating-point numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n-10,000 &le; <b>X</b> &le; 10,000.<br/>\n0 &le; <b>Y</b> &le; 10,000.<br/>\n<b>X + Y</b> is even.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 20.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">7\n1 0 0\n1 0 2\n3 0 0\n3 2 0\n3 1 1\n4 1 1\n4 0 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.0\nCase #2: 0.0\nCase #3: 1.0\nCase #4: 0.75\nCase #5: 0.25\nCase #6: 0.5\nCase #7: 0.0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":28}],"title":"Falling Diamonds","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThere are multiple approaches possible to this problem. For the small test case, one can use a <a href=\"http://en.wikipedia.org/wiki/Dynamic_programming\" target=\"_blank\">dynamic programming</a> approach to calculate for each prefix of the given word what's the smallest number of substitutions needed to form this word so that the last substitution was <i>k</i> characters ago, for <i>k</i> = 1, 2, 3, ...\n</p>\n\n<p>\nFor example, for the word \"codejam\", we will find that \"c\" cannot be formed without a substitution, but can be formed (for instance from \"a\") by a substitution 1 character away. We find this by going over all dictionary words. Then, we go over all dictionary words to try and form \"co\" (we can do this, for instance, from \"do\" with one substitution 2 characters ago). We can also consider one letter words to extend the \"c\" we already know how to form, but this won't work, since \"o\" isn't a word, and we're too near to the last substitution. Next goes \"cod\", which actually is a word, so can be formed with zero subsitutions. Next goes \"code\" &mdash; for this we have a number of choice, like combining the \"c\" we know how to form and \"ode\", or the \"cod\" and a one substitution to form \"e\" from \"a\", or &mdash; the best one, since requiring no subsitutions &mdash; just using the word \"code\".\n</p>\n\n<p>\nIn this fashion for each prefix and each distance of the last substitution we can find out what's the least number of substitutions needed to form this prefix by looking at all smaller prefixes (including the empty one), all smaller dictionary words, and figuring out whether we can combine them.\n</p>\n\n<p>\nFor the large test case, we can't afford to go over the whole dictionary that often. So, we start by building a hash table.  For each dictionary word, we insert that word into the hash table, and also insert the word with each possible set of changed letters in the word replaced by '*' characters.\n</p>\n<p>\nFor example, for the word \"coders\", we store in the hash table:\n\n<ul>\n<li><code>coders</code></li>\n<li><code>*oders</code></li>\n<li><code>c*ders</code></li>\n<li><code>co*ers</code></li>\n<li><code>cod*rs</code></li>\n<li><code>code*s</code></li>\n<li><code>coder*</code></li>\n<li><code>*oder*</code></li>\n</ul>\n\nNext we use dynamic programming to build a table that contains, for each prefix of the email and location within that prefix of the last changed letter, the minimum number of changes required to transform a sequence of dictionary words into the prefix, if it is possible.  (To save time, we can merge together all the states for a prefix where the last changed letter was 5 or more positions from the end of the prefix, because if the last changed letter is more than 4 positions back, it doesn't matter how much more.)\n</p>\n<p>\nEach of the states where this is possible corresponds to a partial solution.  We consider each possible way of adding one more word to create a longer partial solution.  To do this, we try each combination of:\n\n<ul>\n<li>The length of the next word, <b>L</b> (1 &le; <b>L</b> &le; 10).\n<li>Each possible set of positions of changed letters in the next word, <b>S</b>.\n</ul>\n\nFor each of these combinations, we construct a string by taking the next <b>L</b> letters of the original email, and changing the positions in <b>S</b> to '*' characters.  Then we search for this string in the hash table.  If we find it, we can update the table to reflect a partial solution formed by appending that word.\n</p>\n<p>\nThe answer is the minimum number of changes found to produce the prefix that is the entire email.\n</p>","id":"000000000043308b","statement":"<h3>Problem</h3>\n\n<p>\nGagan just got an email from her friend Jorge.  The email contains important information, but unfortunately it was corrupted when it was sent: all of the spaces are missing, and after the removal of the spaces, some of the letters have been changed to other letters!  All Gagan has now is a string <b>S</b> of lower-case characters.\n</p>\n\n<p>\nYou know that the email was originally made out of words from the dictionary described below.  You also know the letters were changed after the spaces were removed, and that the difference between the indices of any two letter changes is not less than 5.  So for example, the string \"code jam\" could have become \"codejam\", \"dodejbm\", \"zodejan\" or \"cidejab\", but not \"kodezam\" (because the distance between the indices of the \"k\" change and the \"z\" change is only 4).\n</p>\n\n<p>\nWhat is the minimum number of letters that could have been changed?\n</p>\n\n<h3>Dictionary</h3>\n<p>\nThe dictionary contains <b>W</b> words of at least 1 and at most 10 lower-case characters and is given at the start of the input file.\nIt is not a dictionary from any natural language, though it does contain some English words.\nThe dictionary is the same for all test cases in a single input file.\nThe dictionary is given in lexicographically increasing order and does not contain duplicate words.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of words in the dictionary, <b>W</b>.  Each of the\nnext <b>W</b> lines contains a string of lower-case characters a-z representing a word in the\ndictionary.\nThe next line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of a single line containing a string <b>S</b>, consisting of lower-case characters a-z.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the minimum number of letters that could have been changed in order to make <b>S</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n<b>W</b> = 521196.<br/>\nEach word in the dictionary contains at least 1 and at most 10 lower-case characters.<br/>\nThe dictionary is sorted in lexicographically increasing order.<br/>\nThe dictionary does not contain duplicate words.<br/>\nThe total number of characters in the dictionary is 3323296.<br/>\n<b>S</b> is valid: it is possible to make it using the method described above.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n1 &le; length of <b>S</b> &le; 50.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>T</b> &le; 4.<br/>\n1 &le; length of <b>S</b> &le; 4000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">9\naabea\nbobs\ncode\nin\njam\noo\noperation\nproduction\nsystem\n4\ncodejam\ncxdejax\ncooperationaabea\njobsinproduction\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 2\nCase #3: 1\nCase #4: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Explanation</h3>\n<p>\n\"code\" and \"jam\" both appear in the dictionary.  Although \"cooperation\" is an English word, it doesn't appear in the dictionary; \"aabea\" does.\n</p>\n<p>\nNote that to make the sample case visible in the problem statement, the size of the dictionary in\nthe sample case does not satisfy the limits.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Garbled Email","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432be7","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2013"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
