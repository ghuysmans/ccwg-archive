{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1255199400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000004329f8","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThis round featured some of the toughest problems we could come up with.  Of the four we posed, only one was a somewhat \"standard\" problem in any sense; the others all required ingenuity or insight of some sort.  All the problems were solved, though only barely; KOTEHOK, the only contestant to solve D-large, didn't have time to solve enough other problems to make it into the top 25.\n</p>\n<p>\nFor the judges, this was by far the most fun round to watch.  bmerry, a familiar figure at the top of the scoreboard, took the lead with half an hour to go, and held onto it.  ACRush, who won last year's competition and finished Round 2 with more than half the time to spare, got off to a slow start: he was briefly out of the top 25 before roaring into 5th place 2 hours in and holding on to claim his spot in the final.  And, of course, we love to see all of the different colours on the scoreboard: if they can all make it, this year's finalists will represent 15 different countries.\n</p>\n<p>\nCongratulations to everyone who made it this far, and special congratulations to the top 25, who win a trip to Mountain View, California and a chance to compete in the Google Code Jam 2009 World Finals!\n</p>\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>EZ-Sokoban</i> Written by Mohamed Eldawy. Prepared by Tomek Czajka and Marius Andrei.</p>\n<p>Problem B. <i>Alphabetomials</i> Written and prepared by Xiaomin Chen.</p>\n<p>Problem C. <i>Football Team</i> Written by John Dethridge. Prepared by Ante Derek, Xiaomin Chen and John Dethridge.</p>\n<p>Problem D. <i>Interesting Ranges</i> Written by Petr Mitrichev. Prepared by Pablo Dal Lago and Bartholomew Furrow.</p>\n<p>Contest analysis presented by Xiaomin Chen, Tomek Czajka, Bartholomew Furrow, and Petr Mitrichev.</p>\n<p>Solutions and other problem preparation provided by Petr Mitrichev and Igor Naverniouk.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1255190400000,"tasks":[{"analysis":"<p>This is a state space search problem: given a set of states (positions on the board), an initial state and a final state, and rules for state transformations, find a sequence of moves that transforms the initial state to the final state. In our case, the problem asks for the length of the shortest such sequence of moves.\n<p>\nConceptually, we can represent such a state space as a graph. The nodes of the graph are the possible positions, and the edges are the allowed moves. The problem then becomes: find the shortest path in the graph. The standard algorithm to solve this graph problem is <a href=\"http://www.google.com/search?q=breadth-first+search\" target=\"_blank\">breadth-first search</a>.\n<p>\nLet's estimate the number of nodes in the graph. Assuming the maximum number of boxes (5), first estimate the number of positions where all the boxes are connected. 5 connected boxes form a <a href=\"http://www.google.com/search?q=pentomino\" target=\"_blank\">pentomino</a>. There are 63 different pentominoes, counting all rotations and reflections. Each of these can be positioned at no more than 12*12 different positions. Hence we get an upper bound of 63*12*12 = 9072 connected positions. It is a little more difficult to estimate the \"dangerous\" positions accurately, but we can see that from each connected position there are not too many moves, so we can guess that the total is not going to be too large for our computer to handle.\n<p>\nOne approach would be to first generate the graph with all the edges explicitly, and then run the breadth-first-search on it. Another is to not store the graph at all, but compute the possible moves (edges) from a given position as we go, and only store the set of visited positions in a data structure.\n<p>\nSome details to work out are:\n<ul>\n<li>How to represent positions. A simple list of box coordinates can work. One can also use a whole-board bit-mask.\n<li>How to look up positions. We need this to see if a position has already been visited, or to avoid constructing the same node in the graph multiple times. We can use some kind of a dictionary data structure - a hash table or a binary search tree.\n<li>How to generate moves. Just try moving all the boxes in every direction, if the space in front and in the back of the box is empty. We also have to make sure that we don't move from a dangerous position to another dangerous position.\n<li>How to check whether a position is dangerous. To do this, we need to check if our 1 to 5 boxes are all connected. This can be represented as another, small graph problem (<a href=\"//www.google.com/search?q=graph+connectivity\" target=\"_blank\">graph connectivity</a>). We run another breadth-first-search on the little graph, where the nodes are the boxes and the edges indicate whether two boxes touch. Another approach would be to pre-generate all <a href=\"http://www.google.com/search?q=polyomino\" target=\"_blank\">polyominoes</a> of sizes up to 5, store them in a hash table, and then look up the shape appearing in a given position.\n</ul>","id":"0000000000432b28","statement":"<h3>Problem</h3>\nSokoban is a famous Japanese puzzle game. Sokoban is Japanese for \"warehouse keeper\". In this game, your goal is to push boxes to their designated locations in the warehouse. To push a box, the area behind the box and in front of the box must be empty. This is because you stand behind the box when pushing and you can push only one box at a time. You cannot push a box out of the board and you cannot stand outside the board when pushing a box.<p>\n\nFor example, in this picture:\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1stMVP3AxFXuR7zTI1iqwfFObQ9rzw9iF817BM96ZjAAPwYfdMDjRI8EnF0mD4bx-UjUrkTg/sokoban.png\">\n</p>\nBox 1 can be pushed in any of the four directions because the four spaces adjacent to it are empty. Box 2 can only be pushed east or west; it cannot be pushed north or south because the space to its south is not empty. Box 3 cannot be pushed in any direction. Box 4 can only be pushed east or west because there is a wall south of it.<p>\n\nSokoban was proved to be a P-Space complete problem, but we deal with an easier variation here. In our variation of Sokoban, boxes have strong magnets inside and they have to stick together <i>almost</i> all the time. Under \"stable\" conditions, all boxes should be connected, edge to edge. This means that from any box we can get to any other box by going through boxes that share an edge.\nIf you push a box and boxes are no longer connected, you are in \"dangerous mode\". In dangerous mode, the next push must make the boxes connected again.<p>\nFor example, in this picture:\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3LjpKdyNhjiRCSOsjopPb13mCt03ECs2QPKgk_NpLPDqNohRFSaFSAaqPy6mvw4vVkBFZ8stc6/sokoban01.png\">\n</p>\nThe situation is stable, since all 4 boxes are connected, edge to edge. Let's assume that you decided to push the northmost box west:\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2E2POe_fYRAXlz24tggREfBurgztrxpFNn4Hds0gzzcWrQzNJIE2jn2WeAzCZvUeyHDopuDzsS/sokoban02.png\">\n</p>\nNow, we are in dangerous mode since the northmost box is not connected to any other boxes. The next push must return us to a stable position. For example, we can push that northmost box south:\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U13PIPM5KpIM5D75WCSwwO3jcOXhI8ORjJF4sHzTOzE6rxKxejiD7K8daRbQdiApXUsl0ffdM9E/sokoban03.png\">\n</p>\nMaking the boxes stable again.\n<p>\nA Sokoban puzzle consists of a board, initial configuration of the boxes and the final configuration (where we want the boxes to be at the end).\nGiven an EZ-Sokoban puzzle, find a solution that makes the minimum number of box moves, or decide that it can't be solved. The final and initial configurations will not be in \"dangerous\" mode.<p>\nTo simplify things, we will assume that you, the warehouse keeper, can jump at any time to any empty spot on the board.</p>\n\n<h3>Input</h3>\nThe first line in the input file contains the number of cases, <b>T</b>. <p>\nEach case consists of several lines. The first line contains <b>R</b> and <b>C</b>, the number of rows and columns of the board, separated by one space. This is followed by <b>R</b> lines. Each line contains <b>C</b> characters describing the board:\n<ul>\n  <li>'.' is an empty spot</li>\n  <li>'#' is a wall</li>\n  <li>'x' is a goal (where a box should be at the end)</li>\n  <li>'o' is a box</li>\n  <li>'w' is a both a box and a goal</li>\n</ul>\nThe number of boxes will be equal to the number of goals.\n\n<h3>Output</h3>\n<p>For each test case, output\n<pre>Case #X: K</pre>\nwhere <b>X</b> is the test case number, starting from 1, and <b>K</b> is the \nminimum number of box moves that are needed to solve the puzzle or <b>-1</b> if it cannot be solved.\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n</p>\n1 &le; <b>T</b> &le; 50<br/>\n1 &le; <b>R</b>,<b>C</b> &le; 12<br/>\n\n<h3>Small dataset</h3>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; the number of boxes &le; 2<br/>\n</p>\n<h3>Large dataset</h3>\n<p>\nTime limit: 45 seconds.<br/>\n1 &le; the number of boxes &le; 5<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n5 4\n....\n#..#\n#xx#\n#oo#\n#..#\n7 7\n.######\n.x....#\n.x....#\n..#oo.#\n..#...#\n.######\n.######\n4 10\n##########\n#.x...o..#\n#.x...o..#\n##########\n3 4\n.#x.\n.ow.\n....\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 8\nCase #3: 8\nCase #4: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<!--\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"problem-item-gray\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"problem-item-gray\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<code>\n6<br/>\n5 4<br/>\n....<br/>\n#..#<br/>\n#xx#<br/>\n#oo#<br/>\n#..#<br/>\n7 7<br/>\n.######<br/>\n.x....#<br/>\n.x....#<br/>\n..#oo.#<br/>\n..#...#<br/>\n.######<br/>\n.######<br/>\n7 7<br/>\n#######<br/>\n#x....#<br/>\n#xx.o.#<br/>\n#..oo.#<br/>\n#.#...#<br/>\n#######<br/>\n#######<br/>\n4 10<br/>\n##########<br/>\n#.x...o..#<br/>\n#.x...o..#<br/>\n##########<br/>\n7 7<br/>\n#######<br/>\n#x....#<br/>\n#x..o.#<br/>\n#x#oo.#<br/>\n#.#...#<br/>\n#######<br/>\n#######<br/>\n3 4<br/>\n.#x.<br/>\n.oww<br/>\n....<br/>\n</code>\n</td>\n<td>\n<code>\nCase #1: 2<br/>\nCase #2: 8<br/>\nCase #3: 12<br/>\nCase #4: 8<br/>\nCase #5: -1<br/>\nCase #6: 2<br/>\n<br/>\n</code>\n</td></tr></table>\n</div>\n!-->\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":10}],"title":"EZ-Sokoban","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>1. How big can the answer be?</h3>\n<p>First, let's get a crude upper bound on the answer. More specifically, if L=1 and R=N, there are N*(N+1)/2 subsegments of [L,R]. Not all of them will contain an even number of palindromes, but a significant part (roughly half) will.</p>\n<p>So even for the small input we might get more than 10^25 segments in the answer; it's obvious we can't enumerate them one by one. We have to figure out a way to process them in bulks.</p>\n<h3>2. First optimization</h3>\n<p>The first idea required to solve the small dataset helps us reduce the number of segments to consider from O(N^2) to O(N). To achieve that, we rely on the following observation: [L,R] can be represented as [0,R] minus [0,L-1]; thus it contains an even number of palindromes if and only if [0,L-1] and [0,R] both contain even or both contain odd number of palindromes.</p>\n<p>But how exactly does that help us? Suppose we know which of [0,X] segments contain even number of palindromes (we'll call them just \"even 0-segments\" further on) and which contain odd number of palindromes (\"odd 0-segments\"). We know that each interesting segment corresponds to exactly one pair of even 0-segments or to exactly one pair of odd 0-segments. But this is true the other way around as well: each pair of distinct even 0-segments corresponds to exactly one interesting segment, and so does each pair of distinct odd 0-segments! (when X is between L-1 and R, inclusive).</p>\n<p>That means that if there are A even 0-segments and B odd 0-segments, the answer is A*(A-1)/2+B*(B-1)/2.</p>\n<h3>2. Second optimization</h3>\n<p>But we can't even afford O(N) running time since N is 10^13 even in the small dataset! So we have to do another optimization.</p>\n<p>Let's write out an infinite string of zeroes and ones, with X-th symbol (0-based) being equal to 0 if [0,X] contains an even number of palindromes, and equal to 1 if [0,X] contains an odd number of palindromes. What we need to find in this problem is how many zeroes (number A above) and ones (number B above) are there in the substring starting with (L-1)-th character and ending with R-th character of this string.</p>\n<p>This string looks like this: 1010101010011111111111000000000001111111111100...</p>\n<p>Now we can spot the second optimization: zeroes and ones tend to go in big blocks in this string. More specifically, one changes to zero or vice versa only when we pass a palindrome. And there are only O(sqrt(N)) palindromes up to N - so the number of groups of consecutive zeros or ones in the first N characters is O(sqrt(N)).</p>\n<p>All groups except maybe two boundary ones fit into [L-1,R] segment entirely. So we just need to sum them all and handle the boundary ones carefully, and we get an O(sqrt(N)) algorithm that is sufficient to solve the small dataset.</p>\n<p>We can also reduce the number of boundary groups to consider from two to one relying on the fact that the number of zeroes/ones in [L-1,R] is the number of zeroes/ones in [0,R] minus the number of zeroes/ones in [0,L-2].</p>\n<h3>3. Third optimization</h3>\n<p>So what about the large one? Sqrt(10^100)=10^50, so we're definitely not there yet.</p>\n<p>The final optimization idea still relies on the above infinite string of zeroes and ones. You might have noticed already that many blocks of ones and zeroes have the same length. For example, block of ones from 11 to 21 has length 11, and so is the block of zeroes from 22 to 32, ones from 33 to 43, zeroes from 44 to 54, and so on.</p>\n<p>This is because of the fact that a palindrome number is uniquely determined by its first half. For example, consider 6-digit palindrome number 127721. What is the next 6-digit palindrome number? 128821. It's followed by 129921, 130031, and so on. As you can see, in most cases the difference between two consecutive 6-digit palindrome numbers is 1100 (change of +1 in two middle digits). And the difference between two consecutive palindrome numbers is exactly the length of the block of ones/zeroes!</p>\n<p>But there are also some blocks which have length different from usual. For example, the block of zeroes from 88 to 98 still has 11 numbers, but the block of ones from 99 to 100 has just two numbers; then follow several blocks of 10 (zeroes from 101 to 110; ones from 111 to 120; ...; zeroes from 181 to 190), then we have a block of 11 ones from 191 to 201.</p>\n<p>The above explanation about consecutive palindromes allows us to understand why there are such unusual-length blocks. It happens in two cases: when the amount of digits in the palindrome changes, and when the middle digit of the starting palindrome of the block is 9. The first several unusual-length blocks are: zeroes from 9 to 10, ones from 99 to 100, ones from 191 to 201, ones from 292 to 302, ..., ones from 898 to 908, ones from 999 to 1000, ones from 1991 to 2001, ones from 2992 to 3002, and so on.</p>\n<p>And here comes the final step. All such unusual-length blocks except the one from 9 to 10 consist of ones! Or, in other words, all blocks of zeroes have the same length within palindromes of the same amount of digits, except the block from 9 to 10.</p>\n<p>Why? Because there's ten blocks between two consecutive palindromes with a 9 in the middle (with the only exception being 9 and 99), and ten is an even number. That's why every time we have a 9 in the middle, we start a block of ones.</p>\n<p>And that allows us to calculate in one step the total amount of zeroes in the part of our infinite string that corresponds to one amount of digits in the palindrome. That means we can calculate the overall amount of zeroes in any segment in O(number of digits in the maximal palindrome) steps. Of course, we have to be careful near L and R.</p>\n<p>And what about the amount of ones? It's equal to the total length minus the amount of zeroes :)</p>\n<h3>4. Modulo calculations</h3>\n<p>With the numbers in the input being quite big, the above calculations have to be performed carefully.</p>\n<p>Some programming languages allow easy calculations with arbitrarily long numbers. But what if we use a language without this feature? Luckily, we're asked to find the answer modulo a (relatively) small number M.</p>\n<p>That allows us to perform most calculations modulo M, and thus use only small numbers in those calculations. The calculations we need to find the answer are: addition, multiplication, subtraction and division by 2. The first three are performed in a standard way (first calculate the answer in integers, then take it modulo M). The fourth one is made possible by the fact that the modulo used in the problem is odd. When we divide a number X by 2 modulo M, we get just X/2 if X is even, and (X+M)/2 when x is odd. One can easily check that multiplying by 2 gets X back in both those cases.</p>","id":"0000000000432bdd","statement":"<h3>Problem</h3>\n\n<p>A positive integer is a <i>palindrome</i> if its decimal representation (without leading zeros) is a palindromic string (a string that reads the same forwards and backwards). For example, the numbers 5, 77, 363, 4884, 11111, 12121 and 349943 are palindromes.</p>\n<p>A range of integers is <i>interesting</i> if it contains an even number of palindromes. The range [L, R], with L &le; R, is defined as the sequence of integers from L to R (inclusive): (L, L+1, L+2, ..., R-1, R).  L and R are the range's first and last numbers.</p>\n<p>The range [L<sub>1</sub>,R<sub>1</sub>] is a <i>subrange</i> of [L,R] if L &le; L<sub>1</sub> &le; R<sub>1</sub> &le; R.  Your job is to determine how many interesting subranges of [L,R] there are.</p>\n\n<h3>Input</h3>\n\n<p>The first line of input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow. Each test case is a single line containing two positive integers, <b>L</b> and <b>R</b> (in that order), separated by a space.</p>\n\n<h3>Output</h3>\n\n<p>For each test case, output one line. That line should contain \"Case #x: y\", where x is the case number starting with 1, and y is the number of interesting subranges of [L,R], modulo 1000000007.</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 45 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n</p>\n\n1 &le; <b>T</b> &le; 120\n\n<h3>Small dataset</h3>\n\n1 &le; <b>L</b> &le; <b>R</b> &le; 10<sup>13</sup><br/>\n\n<h3>Large dataset</h3>\n\n1 &le; <b>L</b> &le; <b>R</b> &le; 10<sup>100</sup><br/>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1 2\n1 7\n12 110\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 12\nCase #3: 2466\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Interesting Ranges","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>1. Product of two sets</h3>\n<p>\nThe problem was created during a short walk in Manhattan in a summer evening. At first there came the picture of an N by M matrix. Let <i>A</i> be a set of N words  {A<sub>i</sub> | 1 &le; i &le; N}, and <i>B</i> be a set of M words {B<sub>j</sub> | 1 &le; j &le; M}. For any word X, let us denote X(<i>c</i>) the number of occurrences of character <i>c</i> in X. In the (i,j)-entry of the matrix, we write, say, the product A<sub>i</sub>('a')B<sub>j</sub>('a')B<sub>j</sub>('b'). What is the sum of all the entries in the matrix?<br/>\nOne can compute the NM terms one by one. But it is easy to see, as you can sum them row by row, as well as column by column, it is nothing but the full expansion of the following expression\n<blockquote> (1) &nbsp;&nbsp;&nbsp; &sum;<sub>X &isin; A, Y &isin; B</sub>X('a')Y('a')Y('b') = &sum;<sub>X &isin; A</sub>X('a') &sum;<sub>Y &isin; B</sub>Y('a')Y('b').\n</blockquote>\ni.e., you can compute the sum on A and B separately, then compute their product.\n</p>\n<p>\nWhat if, as in our problem, instead of writing A<sub>i</sub>('a')B<sub>j</sub>('a')B<sub>j</sub>('b') for the (i,j)-entry, we write Z('a')<sup>2</sup>Z('b'), where Z is the concatenation of A<sub>i</sub> and B<sub>j</sub>? i.e., we do not care which 'a's are from the first set, and which are from the second. In this case we do not have something as simple as (1). But, we can reduce it if we <i>do care</i> which of the 'a's are from the first set. We use a somehow simplified notation (which is closer to our problem statement) -- the symbol <i>a</i> now also represent the number of 'a's in a string. For a fixed string Z that is a concatenation of words from <i>A</i> and <i>B</i>, let a<sub>1</sub> denote the number of 'a's contributed by the first set, and a<sub>2</sub> the number of 'a's contributed by the second set. For each entry in the matrix, we write a<sup>2</sup>b, this is equal to (a<sub>1</sub>+a<sub>2</sub>)<sup>2</sup>(b<sub>1</sub>+b<sub>2</sub>). Expand it, we have\n<blockquote> (2) &nbsp;&nbsp;&nbsp; &sum;<sub>X &isin; A, Y &isin; B</sub> a<sup>2</sup>b = \n&sum;<sub>X &isin; A, Y &isin; B</sub> (a<sub>1</sub>+a<sub>2</sub>)<sup>2</sup>(b<sub>1</sub>+b<sub>2</sub>) <br/>\n=\n&sum;<sub>X &isin; A, Y &isin; B</sub> (a<sub>1</sub><sup>2</sup>b<sub>1</sub> + a<sub>1</sub><sup>2</sup>b<sub>2</sub> + 2a<sub>1</sub>a<sub>2</sub>b<sub>1</sub> + 2a<sub>1</sub>a<sub>2</sub>b<sub>2</sub> + a<sub>2</sub><sup>2</sup>b<sub>1</sub> + a<sub>2</sub><sup>2</sup>b<sub>2</sub>) <br/>\n= \n&sum;<sub>A,B</sub> (a<sub>1</sub><sup>2</sup>b<sub>1</sub>) + &sum;<sub>A,B</sub> (a<sub>1</sub><sup>2</sup>b<sub>2</sub>) + 2&sum;<sub>A,B</sub> (a<sub>1</sub>a<sub>2</sub>b<sub>1</sub>) + <br/>&nbsp;&nbsp;&nbsp; 2&sum;<sub>A,B</sub> (a<sub>1</sub>a<sub>2</sub>b<sub>2</sub>) + &sum;<sub>A,B</sub> (a<sub>2</sub><sup>2</sup>b<sub>1</sub>) + &sum;<sub>A,B</sub> (a<sub>2</sub><sup>2</sup>b<sub>2</sub>) <br/>\n=\n&sum;<sub>A</sub> a<sup>2</sup>b &sum;<sub>B</sub> 1 + \n&sum;<sub>A</sub> a<sup>2</sup> &sum;<sub>B</sub> b + \n2&sum;<sub>A</sub> ab &sum;<sub>B</sub> a + <br/>&nbsp;&nbsp;&nbsp;\n2&sum;<sub>A</sub> a &sum;<sub>B</sub> ab + \n&sum;<sub>A</sub> b &sum;<sub>B</sub> a<sup>2</sup> + \n&sum;<sub>A</sub> 1 &sum;<sub>B</sub> a<sup>2</sup>b\n</blockquote>\nIn the last step, for each summand, since the characters from the first set and those from the second set are nicely separated, we can apply the same reason for (1).\n</p>\n<br/>\n<h3>2. Product of ten sets</h3>\nOur problem asks to compute the sum of expressions such like a<sup>2</sup>b over the product of a dictionary set by itself up to 10 times. (Or more generally, we can think of the product of 10 sets.) The size of the product set is the huge number n<sup>10</sup>. But if we use the same trick as in the previous section, write a<sup>2</sup>b as\n<blockquote>\n(a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>10</sub>)<sup>2</sup>\n(b<sub>1</sub> + b<sub>2</sub> + ... + b<sub>10</sub>)\n</blockquote>\nand expand it. Then we reduce the problem to at most K<sup>D</sup> easier problems, where D is the maximal degree (K &le; 10 and D &le; 4 in our problem). Each of the easier problems can be solved similar as in (1).\n</p>\n<p>\nThis gives one solution to our problem. Focus on one monomial a time. We are basically choosing the origin (one of the ten sets) for each letter in the monomial, so each set gets a sub-monomial, which can be expressed as a subset of the indices of the letters in the original monomial.<br/>\nWe pre-compute &sum;<sub>X &isin; A</sub>q(X) for each sub-monomial <i>q</i>, there are at most 16 of these. Then for each of the K<sup>D</sup> \"easier problems\", the computation involves only multiplying K of the pre-computed numbers.\n</p>\n<br/>\n<h3>3. Speedups</h3>\n<p>\nThe solution above can be easily sped up to solve for much bigger K and slightly bigger D, if one compute the summations incrementally, do the product of two sets in each step (you call it dynamic programming or not).<br/>\nFirst, we compute the sum for A &times; A, not only for the monomial, but for all its sub-monomials. Then we compute the sums over A<sup>3</sup>. Now we can view A<sup>3</sup> as A<sup>2</sup> &times; A. Each sub-monomial can be expanded to at most 2<sup>D</sup> terms, and every one of them submit to the simple trick in (1). Because we already have the summation of A<sup>2</sup> on any sub-monomial, each of the 2<sup>D</sup> problems can be solved in constant time. The running time of this solution is mostly dominated by O(3<sup>D</sup>K) for each monomial form the input.\n</p>\n<p>\nObserve the last line in (2), notice that we only have one dictionary set in our problems, so we can ignore the subscripts -- A, B, etc are the same set. There are other speedups available along this line by exploring the symmetry in indices. We omit the details.\n</p>\n<br/>\n<h3>4. The theory behind it</h3>\n<p>\nIn case you are familiar with discrete probability, you may well know that probability theory provides some powerful abstract machinery for counting. What we went through so far are just some easy exercises in probability. And solving this problem with the abstract theory in mind certainly speeds up your thinking and boosts your confidence in the solution.<br/>\nEspecially, we went through the important fact that the expectation of the product of K random variables equals to the product of the expectation of each of the variables, given that the K random variables are mutually independent. The interested readers may carry the formal correspondences out.\n</p>\n\n","id":"0000000000432cc9","statement":"<h3>Problem</h3>\n<p>\nAs we all know, there is a big difference between polynomials of degree 4 and those of degree 5. The question of the non-existence of a closed formula for the roots of general degree 5 polynomials produced the famous Galois theory, which, as far as the author sees, bears no relation to our problem here.\n</p>\n<p>\nWe consider only the multi-variable polynomials of degree up to 4, over 26 variables, represented by the set of 26 lowercase English letters.  Here is one such polynomial:\n<pre>\naber+aab+c\n</pre>\n</p>\n\n<p>\nGiven a string <i>s</i>, we evaluate the polynomial on it. The evaluation gives <i>p</i>(<i>S</i>) as follows: Each variable is substituted with the number of appearances of that letter in <i>S</i>.<br/>\nFor example, take the polynomial above, and let <i>S</i> = \"abracadabra edgar\". There are six a's, two b's, one c, one e, and three r's. So \n<pre>\np(S) = 6 * 2 * 1 * 3 + 6 * 6 * 2 + 1 = 109.\n</pre>\n</p>\n\n<p>\nGiven a dictionary of distinct words that consist of only lower case letters, we call a string <i>S</i> a <i>d-phrase</i> if \n<pre>\nS = \"S<sub>1</sub> S<sub>2</sub> S<sub>3</sub> ... S<sub>d</sub>\",\n</pre> \nwhere S<sub>i</sub> is any word in the dictionary, for 1 &le; i &le; d. i.e., <i>S</i> is in the form of <i>d</i> dictionary words separated with spaces. Given a number <b>K</b> &le; 10, your task is, for each 1&le; <i>d</i> &le; <b>K</b>, to compute the sum of <i>p</i>(<i>S</i>) over all the <i>d</i>-phrases. Since the answers might be big, you are asked to compute the remainder when the answer is divided by 10009.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line contains the number of cases <b>T</b>. <b>T</b> test cases follow. The format of each test case is:<br/>\nA line containing an expression <i>p</i> for the multi-variable polynomial, as described below in this section, then a space, then follows an integer <b>K</b>.<br/>\nA line with an integer <b>n</b>, the number of words in the dictionary.<br/>\nThen <b>n</b> lines, each with a word, consists of only lower case letters. No word will be repeated in the same test case.</p>\n<p>\nWe always write a polynomial in the form of a sum of terms; each term is a product of variables. We write <i>a</i><sup>t</sup> simply as <i>t</i> <i>a</i>'s concatenated together. For example, <i>a</i><sup>2</sup><i>b</i> is written as <i>aab</i>. Variables in each term are always lexicographically non-decreasing.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output a single line in the form\n<pre>\nCase #X: sum<sub>1</sub> sum<sub>2</sub> ... sum<sub>K</sub>\n</pre>\nwhere <i>X</i> is the case number starting from 1, and sum<sub>i</sub> is the sum of <i>p</i>(<i>S</i>), where <i>S</i> ranges over all i-phrases, modulo 10009.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\nThe string <i>p</i> consists of one or more terms joined by '+'. It will not start nor end with a '+'. There will be at most 5 terms for each <i>p</i>. Each term consists at least 1 and at most 4 lower case letters, sorted in non-decreasing order. No two terms in the same polynomial will be the same.<br/>\nEach word is non-empty, consists only of lower case English letters, and will not be longer than 50 characters. No word will be repeated in the same dictionary.<br/>\n</p>\n\n<h3>Small dataset</h3>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>n</b> &le; 20<br/>\n1 &le; <b>K</b> &le; 5\n</p>\n\n<h3>Large dataset</h3>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>n</b> &le; 100<br/>\n1 &le; <b>K</b> &le; 10\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\nehw+hwww 5\n6\nwhere\nwhen\nwhat\nwhether\nwho\nwhose\na+e+i+o+u 3\n4\napple\norange\nwatermelon\nbanana\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 15 1032 7522 6864 253\nCase #2: 12 96 576\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Alphabetomials","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>0. Drawing the graph</h3>\n<p>\nIt is clear from the statement that this is a graph coloring problem -- on 1000 vertices. But certainly this is not the end of the story. There must be something special that makes this famous NP-complete problem solvable in this contest.\n</p>\n<p>\nRepresent each player with a vertex, and draw an edge between two players if they cannot use the same color. Obviously we can just draw the graph with each player in his position (x, y).<br/>\nSo there are at most 30 rows of players. Can this help? Observing this fact leads to solutions that are good enough for the small dataset, but not for the large tests.<br/>\nOn each row, the edges form a horizontal line segment from the leftmost point to the rightmost. All the other edges are between two adjacent rows. And more importantly, it is not hard to observe and prove the following:\n<ol>\n<li>If there are at least two edges between two adjacent rows, then all these edges together with the horizontal row edges form triangles.</li>\n<li>If you draw all the edges using straight line segments, none of the edges cross each other in the middle.</li>\n</ol>\nSo, surprising or not, the graph is planar! There are special cases where we can handle easily:\n<ul>\n<li>One color is enough if and only if there are no edges.</li>\n<li>In a general graph, it is well known that the graph is 2-colorable if and only if there are no odd cycles. In our problem, it is even simpler than that. One can prove that whenever there is a cycle, there must also exist a triangle. So, the graph is 2-colorable if and only if it is a tree, as well as if and only if there is no triangles.</li>\n</ul>\nOtherwise, the answer is at least 3. But you may also know very well about one of the famous theorems of the past century, the Four Color Theorem: 4 colors is enough to color any planar graph.<br/>\nSo this is a good news: besides the simple special cases, all we need to decide is whether the answer is 3 or 4. Unfortunately it is also known that even this problem is NP-complete in general.\n</p>\n<p>\nAs we mentioned earlier, we are dealing with a special case of even planar graphs. It is mostly triangulated, and nicely positioned in rows with all edges only from adjacent rows. It turns out that there are many solutions to this problem. Let us describe a few in the rest of this writing. In all the solutions, we try to color the graph with just 3 colors A, B,and C, and if this fails, the answer is 4. Also, to simplify our writing, we assume every point has degree at least 3 -- otherwise we can simply remove it without changing the 3-colorability.\n</p>\n<br/>\n<h3>1. The colors are pretty much forced</h3>\n<p>\nPick any triangle. Its vertices must be colored with different colors. We color them with A, B,and C. Now, there might be another triangle <i>next to it</i>. i.e., sharing an edge <i>e</i> with it. In that triangle, two vertices of <i>e</i> are already colored; if the third one is not, its color is decided now!\n</p>\n<p>\nFrom another point of view, this is simply the following: Whenever there is a vertex with two <i>adjacent</i> neighbors colored, we color it with the third color.\n</p>\n<p>\nBecause every color is forced, the answer is 4 as soon as we see a conflict.\n</p>\n<p>\nWe can do this forced coloring almost all the way. It is easy to see we only need to pause a little when there is a cut point. But this is not hard either: the point separates the graph into an upper part and a lower part, as long as we can color both parts with 3 colors, we can paste them together.\n</p>\n<br/>\n<h3>2. The dual graph</h3>\n<p>\nThere is a deeper concept revealed in the solution above. We were actually considering the dual graph of a planar graph, which itself is also planar. Each face (in our problem, each triangle) in the original graph becomes a point, and two points are connected if the two faces share an edge.\n</p>\n<p>\nIf you are familiar with the algorithm that 2-colors a graph and detects odd cycles, you may find it very similar to our solution above. We are going to argue that our original graph is 3-colorable if and only if the dual graph is 2-colorable (with one color for all the clockwise triangles).\n</p>\n<p>\nObserve that if the original graph is 3-colorable, and one triangle gets its three vertices colored A, B, C in clockwise order, then any triangle adjacent to it <i>must</i> have its vertices colored  A, B, C in counter-clockwise order. Thus, the original graph being 3-colorable implies its dual is 2-colorable.\n</p>\n<p>\nThe proof of the reversed direction is also not hard to envisage, but it involves more details and requires some additional conditions on our graph. One easy way to prove it is with induction on rows.\n</p>\n<br/>\n<h3>3. The local property</h3>\n<p>\nThe solution above does not allow a much simpler implementation. But it leads to an even nicer observation. We call a vertex in the original graph an <i>inner vertex</i> if it is surrounded by triangles in all the directions. The following fact gives the simplest solution to our problem:\n<blockquote>\nThe graph is 3-colorable if and only if there is no inner vertex with odd degree.\n</blockquote>\nThe rest of this section is devoted to the proof of this fact. If you feel that some of the claims about the planar graph and its dual are not obvious, try to draw some and convince yourself.\n</p>\n<p>\nAny inner vertex <i>v</i> with degree <i>d</i> is surrounded by <i>d</i> triangles sharing the same vertex. In the dual, they give a cycle of length <i>d</i> that enclose <i>v</i> in the middle.  \n</p>\n<p>\nOne direction of the proof is easier. If <i>v</i> has odd degree, then we see an odd cycle in the dual, therefore the original graph is not 3-colorable.\n</p>\n<p>\nNow assume there is any odd cycle, let us pick <i>C</i> -- the one with the <i>smallest enclosing area</i>. We claim that <i>C</i> must enclose only one inner vertex, and therefore we find an inner point with odd degree. This can be proved in several ways with some details. Basically, if there are two inner vertices enclosed, one can find a path that separates them and hit <i>C</i> in two places. This divides the enclosing area of <i>C</i> into two smaller areas, and it is not hard to see one of the areas must be enclosed by an odd cycle. This contradicts the assumption that <i>C</i> is the odd cycle with smallest area, and completes the sketched proof of our short solution.\n</p>\n<p>\nIn the picture below, there is a big cycle with length 9, and <i>v</i> is an inner vertex surrounded by a cycle with length 5.\n<br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U38npq6qkoWtv3-x4kKYX7mxZkRd1eVKSPvFkwS2UseoaTyXW4om3XuH8ePKnQ-T7FAjpvYIRI/football.png\"/>\n<br/><br/>\n</p>\n<br/>\n<h3>4. Other solutions</h3>\nWe mention two brute-force solutions that are good enough for the small dataset. In order to use them for the large dataset, one needs to optimize a great deal, and possibly just discover one of keys for the polynomial solutions as mentioned above.\n<p>\nAgain, we look at the original graph. We assume the graph is connected, and every vertex has degree at least 3.\n</p>\n<p>\nNotice that there are at most 30 rows. One can fix the color of the first vertex in each row. There are 2<sup>rows</sup> ways of doing this (as opposed to 3<sup>rows</sup>). Once this is fixed, all the rest of the coloring is determined, for a reason similar to the one explained in Section 1.\n</p>\n<p>\nAnother solution is dynamic programming: do a sweep from the right to the left, and remember the color of the first vertex to the right on each row. Notice that you cannot do this from left to right, since knowing the color of only one vertex on a row is not enough in that direction. \n</p>\n<br/>\n<h3>More information</h3>\n<p>\n<a href=\"http://www.google.com/search?q=graph+coloring\" target=\"_blank\">Graph coloring</a> - \n<a href=\"http://www.google.com/search?q=four+color+theorem\" target=\"_blank\">Four color theorem</a> - \n<a href=\"http://www.google.com/search?q=dual+graph\" target=\"_blank\">Dual graph</a>\n</p>\n<p> The solution with the local property resembles very much a theorem of Heawood from 1898: that a maximal planar graph is 3-colorable if and only if every degree is even. A more general theorem, which implies our solution, can be found in the paper <i>A new 3-color criterion for planar graphs</i> by Krzysztof Diks, Lukasz Kowalik, and Maciej Kurowski.\n</p>\n\n","id":"0000000000433158","statement":"<h3>Problem</h3>\n<p>\nA football team will be standing in rows to have a photograph taken.  The location of each player will be given by two integers x and y, where y gives the number of the row, and x gives the distance of the player from the left edge of the row.  The x values will be all different.\n</p>\n\n<p>\nIn order to make the photo more interesting, you're going to make sure players who are near each other have shirts of different colors.  To do this, you set the following rule:<br>\nFor each player P:\n<ul>\n<li>The closest player to the right of P in the same row, if there is such a player, must have a different shirt color.\n<li>The closest player to the right of P in the previous row, if there is such a player, must have a different shirt color.\n<li>The closest player to the right of P in the next row, if there is such a player, must have a different shirt color.\n</ul>\n</p>\n\n<p>\nMore formally, if there is a player at (x1,y1) and (x2,y2), where x1&lt;x2, then those two players must have different shirt colors if:\n<ul>\n<li> y1 - 1 &le; y2 &le; y1 + 1, and\n<li> there is no x3 such that there is a player at (x3, y2) and x1 &lt; x3 &lt; x2.\n</ul>\n</p>\n\n<p>\nFind the minimum number of distinct shirt colors required so that this is possible.\n</p>\n\n<h3>Input</h3>\n<p>The first line of input contains a single integer <b>T</b>, the number of test cases. Each test case starts with a line that contains an integer <b>N</b>, the number of players, followed by <b>N</b> lines of the form\n<pre>x y</pre> each specifying the position of one player.\n</p>\n\n<h3>Output</h3>\n<p>For each test case, output\n<pre>Case #X: c</pre>\nwhere <b>X</b> is the test case number, starting from 1, and <b>c</b> is the minimum number of colors required.\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100<br>\n1 &le; <b>x</b> &le; 1000<br>\nThe values of x will all be different. \n</p>\n\n<h3>Small dataset</h3>\n<p>\n1 &le; <b>y</b> &le; 15<br>\n1 &le; <b>N</b> &le; 100<br>\n</p>\n<h3>Large dataset</h3>\n<p>\n1 &le; <b>y</b> &le; 30<br>\n1 &le; <b>N</b> &le; 1000<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n10 10\n8 15\n12 7\n5\n1 1\n2 1\n3 1\n4 1\n5 1\n3\n1 1\n2 2\n3 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 2\nCase #3: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Football Team","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000004329f8","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2009"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
