{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1304809200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432f3a","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nGoogle Code Jam 2011 is off to a huge start, with record-setting numbers across the board: we had a 10,336 qualifiers, out of 14,397 people who downloaded at least one input and 21,940 people who logged into the dashboard.  Our contestants hailed from 130 different countries, and used 62 languages, though we aren't sure we'd recommend all of them in later rounds.  This year there seems to be something of a competition to see who can use the most programming languages; contestant <b>foxlit</b> is tracking them on his site at <a href=\"http://www.go-hero.net/jam/11/multilang\" target=\"_blank\">http://www.go-hero.net/jam/11/multilang</a> (warning: not all programming languages have family-friendly names).\n</p>\n\n<p>\nWe hope that you enjoyed the problems. Many contestants noticed that three of them had references to games. That wasn't planned; the judges are just playful people by nature.\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Bot Trust</i> Written and prepared by David Arthur.</p>\n<p>Problem B. <i>Magicka</i> Written and prepared by Bartholomew Furrow.</p>\n<p>Problem C. <i>Candy Splitting</i> Written and prepared by Onufry Wojtaszczyk and Jorge Bernadas Saragoza.</p>\n<p>Problem D. <i>GoroSort</i> Written and prepared by Igor Naverniouk.</p>\n<p>Contest analysis presented by David Arthur, Bartholomew Furrow and Petr Mitrichev.</p>\n<p>Solutions and other problem preparation by Patrick Nguyen, Kuang-che Wu, Cosmin Negruseri, Luka Kalinovcic, Greg Tener and Tomek Czajka.</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1304722800000,"tasks":[{"analysis":"\n<p>\nThis problem can be solved with a simulation.  First, we have to remember what elements combine to make other elements.  A map of some sort, like a hash map, is a great way of doing this.  Next we have to track the opposed elements, remembering that one element can be opposed to multiple other elements; a set of pairs, while not particularly efficient for this purpose, will do the trick.\n</p>\n<p>\nFinally, the simulation itself.  For each character, first we check to see if it combines with the last item on the element list, and combine it if so.  If it doesn't combine, then we iterate through the elements already in the list and see if it's opposed to any of them -- if so, we clear the list.  Finally, if neither of those conditions was met, we append it to the list.  Here is some Pythonesque pseudocode that solves the problem:\n</p>\n<pre>\n# Let combo_list contain all the combinations as 3-letter strs.\n# Let opposed_list contain all the opposed elements as 2-letter strs.\n# Let invoke be a str containing the elements to invoke.\ncombos = dict()\nopposed = dict()\nfor x in combo_list:\n  combos[x[0] + x[1]] = x[2]\n  combos[x[1] + x[0]] = x[2]\nfor x in opposed_list:\n  opposed.add(x[0] + x[1])\n  opposed.add(x[1] + x[0])\n# Now combos contains a mapping from each pair to the thing it\n# creates.  If one of the combinations was \"ABC\", then\n# combos[\"AB\"] = \"C\" and combos[\"BA\"] = \"C\".\n# opposed is filled in a similar way.\n\nelement_list = []\nfor element in invoke:\n  # If element_list isn't empty, the last element might combine\n  # with the element being invoked.\n  if element_list:\n    last_two = element_list[-1] + element\n    if last_two in combos:\n      element_list[-1] = combos[last_two]\n    continue\n\n  # Now we iterate through element_list to see if anything there\n  # is opposed to the element being invoked.\n  wipe_list = False\n  for e in element_list:\n    if (e + element) in opposed:\n      wipe_list = True\n  if wipe_list:\n    element_list = []\n    continue\n\n  # There was no combination and no erasing: just append the\n  # element to the list.\n  element_list.append(element)\n</pre>","id":"00000000004329fb","statement":"<h3>Introduction</h3>\n<p>\nMagicka&trade; is an action-adventure game developed by Arrowhead Game Studios.  In Magicka you play a wizard, invoking and combining elements to create Magicks.  This problem has a similar idea, but it does not assume that you have played Magicka.\n</p>\n<p>\nNote: \"invoke\" means \"call on.\"  For this problem, it is a technical term and you don't need to know its normal English meaning.\n</p>\n<h3>Problem</h3>\n<p>\nAs a wizard, you can <b>invoke</b> eight elements, which are the \"base\" elements.  Each base element is a single character from {Q, W, E, R, A, S, D, F}.  When you invoke an element, it gets appended to your <b>element list</b>.  For example: if you invoke W and then invoke A, (we'll call that \"invoking WA\" for short) then your element list will be [W, A].\n</p>\n<p>\nWe will specify pairs of base elements that <b>combine</b> to form non-base elements (the other 18 capital letters).  For example, Q and F might combine to form T.  If the two elements from a pair appear at the end of the element list, then both elements of the pair will be immediately removed, and they will be replaced by the element they form.  In the example above, if the element list looks like [A, Q, F] or [A, F, Q] at any point, it will become [A, T].\n</p>\n<p>\nWe will specify pairs of base elements that are <b>opposed</b> to each other.  After you invoke an element, if it isn't immediately combined to form another element, and it is opposed to something in your element list, then your whole element list will be cleared.\n</p>\n<p>\nFor example, suppose Q and F combine to make T.  R and F are opposed to each other.  Then invoking the following things (in order, from left to right) will have the following results:\n</p>\n<ul>\n<li>QF &rarr; [T]  (Q and F combine to form T)</li>\n<li>QEF &rarr; [Q, E, F] (Q and F can't combine because they were never at the end of the element list together)</li>\n<li>RFE &rarr; [E] (F and R are opposed, so the list is cleared; then E is invoked)</li>\n<li>REF &rarr; [] (F and R are opposed, so the list is cleared)</li>\n<li>RQF &rarr; [R, T] (QF combine to make T, so the list is not cleared)</li>\n<li>RFQ &rarr; [Q] (F and R are opposed, so the list is cleared)</li>\n</ul>\n<p>\nGiven a list of elements to invoke, what will be in the element list when you're done?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of a single line, containing the following space-separated elements in order:\n</p>\n<p>\nFirst an integer <b>C</b>, followed by <b>C</b> strings, each containing three characters: two base elements followed by a non-base element.  This indicates that the two base elements combine to form the non-base element.  Next will come an integer <b>D</b>, followed by <b>D</b> strings, each containing two characters: two base elements that are opposed to each other.  Finally there will be an integer <b>N</b>, followed by a single string containing <b>N</b> characters: the series of base elements you are to invoke.  You will invoke them in the order they appear in the string (leftmost character first, and so on), one at a time.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is a list in the format \"[e<sub>0</sub>, e<sub>1</sub>, ...]\" where e<sub>i</sub> is the i<sup>th</sup> element of the final element list.  Please see the sample output for examples.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\nEach pair of base elements may only appear together in one combination, though they may appear in a combination and also be opposed to each other.<br/>\nNo base element may be opposed to itself.<br/>\nUnlike in the computer game Magicka, there is no limit to the length of the element list.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n0 &le; <b>C</b> &le; 1.<br/>\n0 &le; <b>D</b> &le; 1.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n0 &le; <b>C</b> &le; 36.<br/>\n0 &le; <b>D</b> &le; 28.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n0 0 2 EA\n1 QRI 0 4 RRQR\n1 QFT 1 QF 7 FAQFDFQ\n1 EEZ 1 QE 7 QEEEERA\n0 1 QW 2 QW\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: [E, A]\nCase #2: [R, I, R]\nCase #3: [F, D, T]\nCase #4: [Z, E, R, A]\nCase #5: []\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<p>\nMagicka&trade; is a trademark of Paradox Interactive AB.  Paradox Interactive AB does not endorse and has no involvement with Google Code Jam.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Magicka","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>The main step needed to solve this problem is to understand Patrick's strange addition algorithm. For example, can we describe what happens when Patrick adds up several numbers instead of just two? It turns out we can: we should write all numbers in binary, align them by their least significant bit, and write 1 in those positions where we have an <i>odd</i> number of 1 bits in the summands (the numbers being added).</p>\n<p>Consider this example: suppose Patrick needs to add 5, 7 and 9 together. First, he adds up 5 and 7 by writing them in binary and adding digit-by-digit without carry, as described in the problem statement:</p>\n<pre>\n  101\n+ 111\n-----\n  010\n</pre>\n<p>The result is 010 in binary, which is 2. Now, he adds up 2 and 9:</p>\n<pre>\n  0010\n+ 1001\n------\n  1011\n</pre>\n<p>The result is 1011 in binary, which is 11. It is most instructive to look at what happened to the least significant bit: after adding up two of the numbers, we had a 0 in the least significant bit since both of the summands had a 1 there. However, we have a 1 in the least significant bit of the overall result since the third number had a 1 there as well. It's not hard to see that this generalizes as described above: for any bit, it will be equal to 1 in the overall sum if and only if this bit is set to 1 in an odd number of summands.</p>\n<p>Having established that, we can now understand Sean's task better. He needs to separate the given set of numbers into two parts in such a way that for every bit position, either:</p>\n<ul>\n<li> In both parts, an odd number of summands have this bit set to 1, so that the corresponding bit in the sum is 1 for both parts, or</li>\n<li> In both parts, an even number of summands have this bit set to 1, so that the corresponding bit in the sum is 0 for both parts.</li>\n</ul>\n<p>But saying that we need two numbers to be either both odd, or both even, is equivalent to saying that their sum must be even!</p>\n<p>That allows us to reformulate Sean's task simply as: he needs to separate the given set of numbers into two parts in such a way that for every bit position, an even number of summands have the bit set to 1 across both parts put together. Suddenly, we understand that this condition doesn't rely on the way we separate the numbers into two parts at all! Either it is true for every bit position that an even number of all summands have the bit set to 1, in which case any separation into two non-empty piles will make Patrick happy, or there is some bit which is 1 in an odd number of summands, in which case there's no way to make Patrick happy.</p>\n<p>For example, suppose Sean has pieces of candy with values 5, 7, 9 and 11. If he separates them into 5 and 7 for himself, and 9 and 11 for Patrick, Patrick will add 5 and 7 as 5+7=101<sub>2</sub>+111<sub>2</sub>=010<sub>2</sub>=2, and 9 and 11 as 9+11=1001<sub>2</sub>+1011<sub>2</sub>=0010<sub>2</sub>=2, so Patrick is happy. But even if Sean takes 7, 9 and 11 and leaves just 5 to Patrick, Patrick will add 7, 9 and 11 as 7+9+11=0111<sub>2</sub>+1001<sub>2</sub>+1011<sub>2</sub>=0101<sub>2</sub>=5, so he is still happy! It's not difficult to verify that in all other cases Patrick is happy as well.</p>\n<p>All the above reasoning can be made simpler if you notice that Patrick's strange addition is exactly <a href=\"http://www.google.com/search?q=bitwise+exclusive+or\" target=\"_blank\">bitwise exclusive or</a>. The condition for Patrick's happiness can be reformulated as the bitwise exclusive or of all candy values being equal to zero. In many programming languages, bitwise exclusive or is already built in with the \"^\" operator, making this very easy to check!</p>\n<p>Now, how does the overall solution for the problem work? First, we need to check if Patrick will be happy - as shown above, this does not depend on Sean's piles. If not, then we just output \"NO\" for this testcase. If yes, then Sean should maximize his pile, and this is achieved by taking all pieces of candy except the one with the smallest value.</p>\n","id":"0000000000432b2f","statement":"<h3>Problem</h3>\n\n<p>\nSean and Patrick are brothers who just got a nice bag of candy from their parents.  Each piece of candy has some positive integer value, and the children want to divide the candy between them.   First, Sean will split the candy into two piles, and choose one to give to Patrick. Then Patrick will try to calculate the value of each pile, where the value of a pile is the sum of the values of all pieces of candy in that pile; if he decides the piles don't have equal value, he will start crying.\n</p>\n\n<p>\nUnfortunately, Patrick is very young and doesn't know how to add properly.  He <i>almost</i> knows how to add numbers in binary; but when he adds two 1s together, he always forgets to carry the remainder to the next bit. For example, if he wants to sum 12 (1100 in binary) and 5 (101 in binary), he will add the two rightmost bits correctly, but in the third bit he will forget to carry the remainder to the next bit:\n</p>\n\n<pre>\n  1100\n+ 0101\n------\n  1001\n</pre>\n\n<p>\nSo after adding the last bit without the carry from the third bit, the final result is 9 (1001 in binary).  Here are some other examples of Patrick's math skills:\n</p>\n\n<pre>\n5 + 4 = 1\n7 + 9 = 14\n50 + 10 = 56\n</pre>\n\n<p>\nSean is very good at adding, and he wants to take as much value as he can without causing his little brother to cry.  If it's possible, he will split the bag of candy into two non-empty piles such that Patrick thinks that both have the same value. Given the values of all pieces of candy in the bag, we would like to know if this is possible; and, if it's possible, determine the maximum possible value of Sean's pile.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case is described in two lines. The first line contains a single integer <b>N</b>, denoting the number of candies in the bag. The next line contains the <b>N</b> integers <b>C<sub>i</sub></b> separated by single spaces, which denote the value of each piece of candy in the bag.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1). If it is impossible for Sean to keep Patrick from crying, y should be the word \"NO\". Otherwise, y should be the value of the pile of candies that Sean will keep.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>C<sub>i</sub></b> &le; 10<sup>6</sup>.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 15.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 1000.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n1 2 3 4 5\n3\n3 5 6\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: NO\nCase #2: 11\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Candy Splitting","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>The Solution</h3>\n\n<p>\nThis problem is very mathematical in nature, requiring a lot of thought and only a little code to solve correctly. We put it as a problem on the Qualifying Round to give you something different to try without having to worry about time pressure or advancement. We hope you enjoyed it!\n</p>\n\n<p>\nFor an arbitrary array A, let n(A) be the number of elements that are not already in the correct position. It turns out that the answer you are looking for is simply n(A). Once you realize this, it is easy to calculate with a simple loop, but how do you prove it?\n</p>\n<br/>\n\n<h3>The Proof</h3>\n\n<p>\nLet's first show that the expected number of hits is never more than n(A). Suppose Goro always holds down only those elements that are already in position, and then he randomly permutes the rest. Let x(A) be the expected number of hits required for him to sort A using this strategy.\n</p>\n\n<p>\n<b>Lemma:</b> x(A) = n(A) for all A.\n</p>\n\n<p>\nWe prove this by induction on n(A). If n(A) = 0, then the array is already sorted, and we're done. To set up the induction, let's suppose we have proven the lemma already for smaller values of n(A) and we are now trying to prove it for A. Let p<sub>t</sub> be the probability that exactly t elements are still out of position after the first hit, and let x'<sub>t</sub> be the expected number of hits required in this case. We make three observations:\n</p>\n<ul>\n<li>p<sub>0</sub> * 0 + p<sub>1</sub> * 1 + p<sub>2</sub> * 2 + ... +  p<sub>N</sub> * N = N - 1. In English, this is saying that the <i>expected</i> number of elements that are out of position after the first hit is exactly N - 1, or equivalently, the expected number of elements that are put into position by the first hit is exactly 1. This follows from \"linearity of expectation\": Goro is permuting N elements; each one has probability exactly 1/N of ending up in the correct position, and hence, the expected number of elements that end up in the correct position is N * 1/N = 1.</li>\n<li>x'<sub>t</sub> = t for t &le; N - 1. This is true by the inductive hypothesis.</li>\n<li>x'<sub>N</sub> = x(A). If no elements are put into the correct position by the first hit, then we will just randomly permute them all again in the next step, so nothing has changed, and hence x'<sub>N</sub> = x(A).</li>\n</ul>\n<p>\nNow let's write down a formula for x(A):\n</p>\n\n<p>\n1 + p<sub>0</sub> * x'<sub>0</sub> + p<sub>1</sub> * x'<sub>1</sub> + ... + p<sub>N</sub> * x'<sub>N</sub><br/>\n= 1 + p<sub>0</sub> * 0 + p<sub>1</sub> * 1 + ... + p<sub>N</sub> * N + p<sub>N</sub> * (x(A) - N)<br/>\n= N + p<sub>N</sub> * (x(A) - N),\n</p>\n\n<p>\nwhich simplifies to (N - x(A)) * (1 - p<sub>N</sub>) = 0. Since p<sub>N</sub> &lt; 1, we must have x(A) = N, and the lemma is proven.\n</p>\n<br/>\n\n<p>\nTo complete the proof, we need to calculate y(A), the expected number of hits required for Goro to sort A if he uses the (still unknown) optimal strategy. Since y(A) &le; x(A) by definition, we have already proven y(A) &le; n(A).\n</p>\n\n<p>\nTo conversely prove n(A) &le; y(A), it would be nice to just extend the proof of the previous lemma. There is one big technical issue though: it is possible for n(A) to go up if Goro doesn't hold down enough elements, and so it is tricky to set up an induction on n(A). We'll resolve this by having a separate proof for this part, and this time use a slightly different induction hypothesis. We can then follow the previous argument very closely.\n</p>\n\n<p>\n<b>Lemma 2:</b> Let K be a non-negative integer. Then for any k &le; K, the statement y(A) = k is equivalent to the statement n(A) = k.\n</p>\n\n<p>\nWe will prove this by induction on K. Both y(A) = 0 and n(A) = 0 are equivalent to the array already being sorted, so the K = 0 case is clear. Now, let's suppose we have proven the lemma for K already, and are trying to prove it for K+1. Choose A such that y(A) is the smallest possible value larger than K and consider the optimal strategy for Goro. Let T be the number of elements that are either (a) not in the correct position in A, or (b) permuted when Goro hits the table. Define p<sub>i</sub> and x'<sub>i</sub> as we did before. Note that T &ge; n(A) &ge; K+1 by the inductive hypothesis.\n</p>\n\n<p>\nAs in the previous lemma, we can now prove the following:\n</p>\n\n<ul>\n<li> p<sub>0</sub> * 0 + p<sub>1</sub> * 1 + p<sub>2</sub> * 2 + ... p<sub>T</sub> * T &ge; T - 1.</li>\n<li> x'<sub>i</sub> = i for i &le; K. This follows directly from the inductive hypothesis.</li>\n<li> x'<sub>i</sub> &ge; y(A) for i &gt; K. By the inductive hypothesis, n(A') &gt; K implies y(A') &gt; K, which then implies y(A') &ge; y(A).</li>\n</ul>\n\n<p>\nAs before, we can now write y(A) as\n</p>\n\n<p>\n1 + p<sub>0</sub> * x'<sub>0</sub> + p<sub>1</sub> * x'<sub>1</sub> + ... p<sub>T</sub> * x'<sub>T</sub><br/>\n&ge; 1 + (p<sub>0</sub> * 0 + p<sub>1</sub> * 1 + ... + p<sub>T</sub> * T) + (p<sub>K+1</sub> + p<sub>K+2</sub> + ... + p<sub>T</sub>) * (y(A) - T)<br/>\n&ge; T + (p<sub>K+1</sub> + p<sub>K+2</sub> + ... + p<sub>T</sub>) * (y(A) - T)\n</p>\n\n<p>\nwhich simplifies to (y(A) - T) * (1 - p<sub>K+1</sub> - ... - p<sub>T</sub>) &ge; 0. The second term has to be positive (if not, then y(A) &ge; min(x'<sub>K+1</sub>, x'<sub>K+2</sub>, ...) + 1, which contradicts the third bullet point above is therefore impossible), so we must have y(A) &ge; T &ge; n(A) &ge; K+1. Equality holds only if n(A) = K+1. The first lemma guarantees y(A) &le; x(A) &le; K+1 in this case, and the proof is complete!\n</p>\n\n<br/>\n\n<h3>Comments</h3>\n\n<ul>\n\n<li> If you go over the proof carefully, you can see there are two things Goro needs to do in order to be optimal. (1) He needs to always hold down elements that are already in the correct position, and (2) he needs to ensure that for  each element x that is permuted, the element in x's correct position is also permuted. This means he actually has some choice about what to do. </li>\n\n<li> On a programming contest, of course you do not need to work through a formal proof to implement a correct solution. The best contestants can solve this kind of problem by looking at small examples to see a pattern, and then using intuitive reasoning to see what's going on without formalizing everything. Mastering this kind of reasoning is a difficult art though! </li>\n\n</ul>\n","id":"0000000000432ccf","statement":"<h3>Problem</h3>\n<p>\nGoro has 4 arms. Goro is very strong. You don't mess with Goro. Goro needs to sort an array of <b>N</b> different integers. Algorithms are not Goro's strength; strength is Goro's strength. Goro's plan is to use the fingers on two of his hands to hold down several elements of the array and hit the table with his third and fourth fists as hard as possible. This will make the unsecured elements of the array fly up into the air, get shuffled randomly, and fall back down into the empty array locations.\n</p>\n\n<p>\nGoro wants to sort the array as quickly as possible. How many hits will it take Goro to sort the given array, on average, if he acts intelligently when choosing which elements of the array to hold down before each hit of the table?  Goro has an infinite number of fingers on the two hands he uses to hold down the array.\n</p>\n\n<p>\nMore precisely, before each hit, Goro may choose any subset of the elements of the array to freeze in place. He may choose differently depending on the outcomes of previous hits. Each hit permutes the unfrozen elements uniformly at random. Each permutation is equally likely.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one will consist of two lines. The first line will give the number <b>N</b>. The second line will list the <b>N</b> elements of the array in their initial order.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>x</b>: <b>y</b>\", where <b>x</b> is the case number (starting from 1) and <b>y</b> is the expected number of hit-the-table operations when following the best hold-down strategy. Answers with an absolute or relative error of at most 10<sup>-6</sup> will be considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100;<br>\nThe second line of each test case will contain a permutation of the <b>N</b>\nsmallest positive integers.<br>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 10;<br>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000;<br>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2\n2 1\n3\n1 3 2\n4\n2 1 4 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2.000000\nCase #2: 2.000000\nCase #3: 4.000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<h3>Explanation</h3>\nIn test case #3, one possible strategy is to hold down the two leftmost elements first. Elements 3 and 4 will be free to move. After a table hit, they will land in the correct order [3, 4] with probability 1/2 and in the wrong order [4, 3] with probability 1/2. Therefore, on average it will take 2 hits to arrange them in the correct order. After that, Goro can hold down elements 3 and 4 and hit the table until 1 and 2 land in the correct order, which will take another 2 hits, on average. The total is then <nobr>2 + 2 = 4</nobr> hits.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"GoroSort","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n<i>BAM! Robots gave us 6 extra seconds of cooperation. Good job, robots!</i><br/>\n&nbsp;&nbsp;&nbsp;-- Cave Johnson (Portal 2)\n</p>\n<br/>\n\n<p>\nHopefully your robots were more focused on teamwork than Cave Johnson's were, or you would never get all the buttons pressed. Just be glad there were no mashy spike plates or potatoes to contend with! Perhaps in the finals...\n</p>\n\n<p>\nAnyway, if you think about this problem from the perspective of a single robot, the strategy should be pretty intuitive: always move towards the next button and then push it as soon as it comes up in the sequence.\n</p>\n\n<p>\nSo the most natural solution to this problem is a straight simulation:\n</p>\n<ul>\n<li>Keep track of which buttons have been pressed, and look ahead in the sequence to figure out which button is next for each robot.</li>\n<li>One second at a time, have each robot move towards its next button.</li>\n<li>Once it gets to the button, the robot should push it if it's next in the sequence, and just wait otherwise.</li>\n</ul>\n<p>\nAt most 100 buttons needs to be pressed altogether and the distance between buttons is at most 100, so this solution will run plenty fast.\n</p>\n\n<p>\nIf you get stuck on the implementation, remember that you can see other contestants' source code. There is no better way to learn!\n</p>\n","id":"000000000043324b","statement":"<h3>Problem</h3>\n<p>\nBlue and Orange are friendly robots. An evil computer mastermind has locked them up in separate hallways to test them, and then possibly give them cake.\n</p>\n\n<p>\nEach hallway contains 100 buttons labeled with the positive integers {1, 2, ..., 100}. Button k is always k meters from the start of the hallway, and the robots both begin at button 1. Over the period of one second, a robot can walk one meter in either direction, or it can press the button at its position once, or it can stay at its position and not press the button. To complete the test, the robots need to push a certain sequence of buttons in a certain order. Both robots know the full sequence in advance. How fast can they complete it?\n</p>\n\n<p>\nFor example, let's consider the following button sequence:\n</p>\n\n<p><code>&nbsp;&nbsp;&nbsp;O 2, B 1, B 2, O 4</code></p>\n\n<p>\nHere, <code>O 2</code> means button 2 in Orange's hallway, <code>B 1</code> means button 1 in Blue's hallway, and so on. The robots can push this sequence of buttons in 6 seconds using the strategy shown below:\n</p>\n<pre>\nTime | Orange           | Blue\n-----+------------------+-----------------\n  1  | Move to button 2 | Stay at button 1\n  2  | Push button 2    | Stay at button 1\n  3  | Move to button 3 | Push button 1\n  4  | Move to button 4 | Move to button 2\n  5  | Stay at button 4 | Push button 2\n  6  | Push button 4    | Stay at button 2\n</pre>\n<p>\nNote that Blue has to wait until Orange has completely finished pushing <code>O 2</code> before it can start pushing <code>B 1</code>.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\n</p>\n\n<p>\nEach test case consists of a single line beginning with a positive integer <b>N</b>, representing the number of buttons that need to be pressed. This is followed by <b>N</b> terms of the form \"<b>R</b><sub>i</sub> <b>P</b><sub>i</sub>\" where <b>R</b><sub>i</sub> is a robot color (always 'O' or 'B'), and <b>P</b><sub>i</sub> is a button position.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the minimum number of seconds required for the robots to push the given buttons, in order.\n</p>\n\n<h3>Limits</h3>\n\n<p>\n1 &le; <b>P</b><sub>i</sub> &le; 100 for all i.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 20.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 O 2 B 1 B 2 O 4\n3 O 5 O 8 B 100\n2 B 2 B 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 6\nCase #2: 100\nCase #3: 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Bot Trust","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432f3a","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2011"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
