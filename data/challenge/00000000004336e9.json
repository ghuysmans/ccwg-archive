{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1429327800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000004336e9","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1A has 5686 contestants who downloaded at least one input. Contestants faced three challenging problems: Mushroom Monster where Bartholomew wants to determine Kaylin’s minimum rate of eating mushrooms using two different methods (based on a true story!). With 98% correct attempts on the Large input. Haircut was a tricky binary search problem, with the danger of off-by-one errors, and unlike problem A, had only 64% correct attempts of the Large input. The toughest problem was Logging for which contestants needed computational geometry. Most contestants needed everything but C-large to advance, although some solved all of C or C-small plus all of B, or just solved all of A and B very fast.\n</p>\n\n<p>\nAt the end of the day, 88% of our contestants solved at least one input, and 323 people got everything right (That is really a huge number!).\n</p>\n\n<p>\nWe hope everybody enjoyed the round! Congratulations to the Top 1000, who have now made it to Round 2; and to everyone else, we'll see you in Rounds 1B and 1C!\n</p>\n\n<hr>\n\n<p>\nCast\n</p>\n<p>\nProblem A. <i>Mushroom Monster</i> written by Bartholomew Furrow, prepared by Greg Tener, analysis written by Felix Halim.\n</p>\n<p>\nProblem B. <i>Haircut</i> written by Ian Tullis, prepared by Steve Thomas, analysis written by Artur Satayev.\n</p>\n<p>\nProblem C. <i>Logging</i> written by John Dethridge, prepared by David Spies, analysis written by John Dethridge.\n</p>\n\n<p>\nSolutions and other problem preparations and reviews by Ahmed Aly, Chieu Nguyen, David Gómez Cermeño, David Spies, Dustin Tseng, Felix Halim, Ian Tullis, Igor Naverniouk, Ilham Kurnia, Jackson Gatenby, John Dethridge, Jonathan Shen, Luis Giro Valdes, Risan, Taman (Muhammed) Islam, and Topraj Gurung.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1429318800000,"tasks":[{"analysis":"We describe a few algorithms that solve the problem, of increasing efficiency.\n<h2>Direct simulation</h2>\n<p>\nIterate over each minute, from the shop opening at time T = 0 until the last customer is served. At time T assign new customers to all available barbers (a barber is available if T is multiple of his M). Finally, report the barber who serves you.\n</p>\n<pre>\npublic int naiveGetBarberNumber(int N) {\n  int customer = 1;\n  for (int T = 0; ; T++) {\n    for (int barber = 0; barber &lt; B; barber++) {\n      if (T % M[barber] == 0) {\n        if (customer == N) return barber;\n        customer++;\n      }\n    }\n  }\n}\n</pre>\n<p>\nThis algorithm has time complexity O(N * max(M) * B), so it will be very slow, even for a small input, since N can be as large as 1,000,000,000.\n\n<p>\n<h2>Exploit periodicity</h2>\n<p>\nConsider the case where there are two barbers B1 and B2, who take 2 and 3 minutes respectively to cut a customer's hair.\n</p>\n<p>\n\n<table>\n<tr>\n<td>Time</td>\n<td>Events</td>\n</tr>\n<tr>\n<td>T = 0 &nbsp; </td>\n<td>Both barbers are ready to serve customers.<br>\nB1 serves customer #1 and B2 serves customer #2</td>\n</tr>\n<tr>\n<td>T = 2</td>\n<td>B1 serves customer #3</td>\n</tr>\n<tr>\n<td>T = 3</td>\n<td>B2 serves customer #4</td>\n</tr>\n<tr>\n<td>T = 4</td>\n<td>B1 serves customer #5</td>\n</tr>\n<tr>\n<td>T = 6</td>\n<td>Both barbers are ready to serve customers.<br>\nB1 serves customer #6 and B2 serves customer #7</td>\n</tr>\n</table>\n</p>\n<p>\nAt T = 6, both barbers have become available, just as they were at T = 0.  So we will see the same pattern of availability for the next 6 minutes as we did for the first 6 minutes &mdash;  at T = 2 + 6, B1 will serve customer #(3+5); at T = 3 + 6, B2 will serve customer #(4+5), and so on until T = 6 + 6, at which point the process starts repeating itself again.\n</p>\n<p>\nWhat's so special about 6? It's the <a href=\"http://en.wikipedia.org/wiki/Least_common_multiple\" target=\"_blank\">least common multiple (LCM)</a> of M1 = 2 and M2 = 3. At time T = LCM(M1, M2) = 6 each barber is available, because T % M = 0 for every barber.\nWe can compute the LCM of all Ms as follows: LCM(M1, M2, M3, ...) = LCM(M1, LCM(M2, M3, M4, …)) and the least common multiple of two numbers is LCM(A, B) = A * B / GCD(A, B).\n</p>\n<p>\nWe can exploit the fact that the whole process is periodic and only simulate for a small number of customers. For example, say M1 = 2, M2 = 3, and you are N = 14th in line. We already know that we have a period of LCM(2, 3) = 6. During one phase B1 serves LCM(2, 3) / M1 = 3 customers and B2 serves LCM(2, 3) / M2 = 2 customers, i.e. in total 5 customers per phase are served in the shop. Since N = 14, you will be served in the 3rd phase. When the third phase starts you are going to be 4th in line, because a total of 10 customers have been served in the previous two phases. Finally, to figure out your barber's number, we can naively simulate your phase, similar to what we did in the first solution.\n</p>\n<p>\nSince we are only simulating a single phase, we only really need to simulate at most LCM(M1, M2, M3, …) minutes. So our improved algorithm has time complexity O(B * LCM(M1, M2, M3, …)).  Note that the LCM of all Ms is not going to exceed max(M)^B, i.e. LCM of all Ms is less than 25^5 for the small input. \n</p>\n<pre>\npublic int slowGetBarberNumber(int N) {\n  int period = M[0];\n  for (int i = 1; i &lt; B; i++)\n    period = period / gcd(period, M[i]) * M[i];\n  int customers_per_phase = 0;\n  for (int i = 0; i &lt; B; i++)\n    customers_per_phase += period / M[i];\n  int N_in_my_phase = N % customers_per_phase;\n  return naiveGetBarberNumber(N_in_my_phase != 0\n    ? N_in_my_phase : customers_per_phase);\n}\n</pre>\n<p>\nFor the large input, B and Ms can be as high as 10,000, so the LCM of them can get very large, and this approach will not work.\n</p>\n<h2>Binary Search</h2>\n\n<p>\nFor a given time T, it is easy to compute the number of customers who have been assigned to a barber up to and including at time T.  The number of customers who have been assigned to barber i is T/M_i + 1 (rounded down), so we can just sum these values for all the barbers.\n\n</p>\n<pre>\npublic int countServedCustomers(long T) {\n  if (T &lt; 0) return 0;\n  int served_customers = 0;\n  for (int barber = 0; barber &lt; B; barber++)\n    served_customers += T / M[barber] + 1;\n  return served_customers;\n}\n</pre>\n<p>\nThis means we can use a binary search to figure out the time T when you are going to be served. After that, all you are left to do is figure out which of the available barbers at time T is going to serve you.\n</p>\n<p>\nKeep in mind that at time T multiple barbers may become available, so you have to account for the customers that are ahead of you in line and are going to be served at the same time. Since you know that you will be served at time T, the number of potential customers ahead of you that are going to be served at time T is less than the number of available barbers. We can then simulate that, given that we know the number of customers that are going to be served up to and including time T-1. More precisely, the number of customers to be seated in the barber chair at time T is equal to countServedCustomer(T) - countServedCustomers(T-1).\n</p>\n<h3>What should the bounds for the binary search be?</h3>\n<p>\nFor the upper bound, imagine a worst-case scenario: every customer ahead of you is served by the slowest and the only available barber. Meaning you are guaranteed to be served after max(M)*N minutes.  For the lower bound, in the best case you are going to be served at the time the shop opens.\n</p>\n<p>\nThe implementation below assumes that you always will have been served at T = high or earlier, while at T = low you have not been served yet.  So initially we want low to be -1, not 0.\n</p>\n<p>\nThe final complexity of this solution is O(B * log(N * max(M))).\n</p>\n<pre>\npublic int fastGetBarberNumber(int N) {\n  long low = -1, high = 10000L*N;\n  while (low + 1 &lt; high) {\n    long mid = (low + high) / 2;\n    if (countServedCustomers(mid) &lt; N)\n      low = mid;\n    else\n      high = mid;\n  }\n  long T = high;\n  int customers_served_before = \n    countServedCustomers(T - 1);\n  int customers_to_be_served = \n    N - customers_served_before;\n  for (int barber = 0; barber &lt; B; barber++) \n    // Is the barber available at time T?\n    if (T % M[barber] == 0) {\n      customers_to_be_served--;\n      if (customers_to_be_served == 0)\n        return barber;\n    }\n}\n</pre>","id":"0000000000433602","statement":"<h3>Problem</h3>\n<p>\nYou are waiting in a long line to get a haircut at a trendy barber shop. The shop has <b>B</b> barbers on duty, and they are numbered 1 through <b>B</b>. It always takes the <b>k</b>th barber exactly <b>M<sub>k</sub></b> minutes to cut a customer's hair, and a barber can only cut one customer's hair at a time. Once a barber finishes cutting hair, he is immediately free to help another customer.<br>\n<br>\nWhile the shop is open, the customer at the head of the queue always goes to the lowest-numbered barber who is available. When no barber is available, that customer waits until at least one becomes available.<br>\n<br>\nYou are the <b>N</b>th person in line, and the shop has just opened. Which barber will cut your hair?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow; each consists of two lines. The first contains two space-separated integers <b>B</b> and <b>N</b> -- the number of barbers and your place in line. The customer at the head of the line is number 1, the next one is number 2, and so on. The second line contains <nobr><b>M<sub>1</sub></b>, <b>M<sub>2</sub></b>, ..., <b>M<sub>B</sub></b>.</nobr>\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the number of the barber who will cut your hair.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>B</b> &le; 5.<br/>\n1 &le; <b>M<sub>k</sub></b> &le; 25.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>B</b> &le; 1000.<br/>\n1 &le; <b>M<sub>k</sub></b> &le; 100000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 4\n10 5\n3 12\n7 7 7\n3 8\n4 2 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 3\nCase #3: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\nIn Case #1, you are the fourth person in line, and barbers 1 and 2 take 10 and 5 minutes, respectively, to cut hair. When the shop opens, the first customer immediately has the choice of barbers 1 and 2, and she will choose the lowest-numbered barber, 1. The second customer will immediately be served by barber 2. The third customer will wait since there are no more free barbers. After 5 minutes, barber 2 will finish cutting the second customer's hair, and will serve the third customer. After 10 minutes, both barbers 1 and 2 will finish; you are next in line, and you will have the choice of barbers 1 and 2, and will choose 1.\n</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Haircut","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nEach method can be solved independently because they answer different questions. With the first method, Kaylin can eat any number of mushroom pieces at any time. Since the only way mushrooms can leave the plate is by being eaten, whenever we see a decrease in the number of mushrooms (in an interval) it must be because they were eaten by Kaylin. The minimum number of mushrooms Kaylin could have eaten using this method is the sum of the observable decreases for each interval. Since we only care about how many mushrooms Kaylin ate, we do not need to calculate how many mushrooms Bartholomew added.\n</p>\n<p>\nWith the second method, Kaylin always eats mushrooms at a constant rate whenever there are mushrooms on her plate. For each interval, we can observe Kaylin’s eat-rate (i.e., the decrease of the number of mushrooms for that time interval). Since we want to find the minimum number of mushrooms Kaylin could have eaten, <b>we should find Kaylin’s minimum eat-rate</b>. Since the eat-rate must be constant for each interval from the beginning until the end, <b>only the highest observable eat-rate makes sense</b>.  It may appear that Kaylin eats fewer mushrooms than her eat-rate in some intervals, either because her plate becomes empty during the interval and she stops eating, or because Bartholomew added more mushrooms during the interval.\n</p>\n<p>\nThe number of mushrooms Kaylin could have eaten using the second method is the sum of min(M[i], <b>max_rate</b>) for all intervals i, where M[i] is the number of mushrooms at the beginning of interval i and <b>max_rate</b> is the highest observable eat-rate. That is, if at the beginning of the interval the number of mushrooms is larger than the maximum eat-rate, Kaylin can only eat <b>max_rate</b> mushrooms, otherwise Kaylin can only eat M[i] mushrooms and the plate becomes empty until the end of that interval. Note that we don’t care about the number of mushrooms at the end of an interval. Since we want to minimize the eat-rate, we should assume that Bartholomew puts in mushrooms instantaneously at the end of the interval to maximize Kaylin’s idle time.\n</p>\n<p>\nBelow is a sample implementation in Python:\n</p>\n<pre>\ndef first_method(M, N):\n  min_eat = 0\n  for i in range(1, N):\n    min_eat += max(0, M[i - 1] - M[i])\n  return min_eat\n\ndef second_method(M, N):\n  max_rate = 0\n  for i in range(1, N):\n    max_rate = max(max_rate, M[i - 1] - M[i])\n\n  min_eat = 0\n  # exclude the last mushroom\n  for i in range(0, N - 1):\n    min_eat += min(M[i], max_rate)\n  return min_eat\n\nfor tc in range(int(input())):\n  N = int(input())\n  M = map(int, raw_input().split())\n  print \"Case #%d: %d %d\" % (tc + 1,\n    first_method(M, N), second_method(M, N))\n</pre>","id":"0000000000433792","statement":"<h3>Problem</h3>\n<p>\nKaylin loves mushrooms. Put them on her plate and she'll eat them up! In this problem she's eating a plate of mushrooms, and Bartholomew is putting more pieces on her plate.\n</p>\n<p>\nIn this problem, we'll look at how many pieces of mushroom are on her plate at 10-second intervals. Bartholomew could put any non-negative integer number of mushroom pieces down at any time, and the only way they can leave the plate is by being eaten.\n</p>\n<p>\nFigure out the minimum number of mushrooms that Kaylin could have eaten using two different methods of computation:\n<ol>\n<li>Assume Kaylin could eat any number of mushroom pieces at any time.\n<li>Assume that, starting with the first time we look at the plate, Kaylin eats mushrooms at a constant rate whenever there are mushrooms on her plate.\n</ol>\n<p>\nFor example, if the input is <code>10 5 15 5</code>:\n</p>\n<p>\nWith the first method, Kaylin must have eaten at least 15 mushroom pieces: first she eats 5, then 10 more are put on her plate, then she eats another 10. There's no way she could have eaten fewer pieces.\n</p>\n<p>\nWith the second method, Kaylin must have eaten at least 25 mushroom pieces. We can determine that she must eat mushrooms at a rate of at least 1 piece per second. She starts with 10 pieces on her plate. In the first 10 seconds, she eats 10 pieces, and 5 more are put on her plate. In the next 5 seconds, she eats 5 pieces, then her plate stays empty for 5 seconds, and then Bartholomew puts 15 more pieces on her plate. Then she eats 10 pieces in the last 10 seconds.\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each will consist of one line containing a single integer <b>N</b>, followed by a line containing <b>N</b> space-separated integers <b>m</b><sub>i</sub>; the number of mushrooms on Kaylin's plate at the start, and at 10-second intervals.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y z\", where x is the test case number (starting from 1), y is the minimum number of mushrooms Kaylin could have eaten using the first method of computation, and z is the minimum number of mushrooms Kaylin could have eaten using the second method of computation.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n2 &le; <b>N</b> &le; 10.<br/>\n0 &le; <b>m</b><sub>i</sub> &le; 100.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n2 &le; <b>N</b> &le; 1000.<br/>\n0 &le; <b>m</b><sub>i</sub> &le; 10000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n4\n10 5 15 5\n2\n100 100\n8\n81 81 81 81 81 81 81 0\n6\n23 90 40 0 100 9\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 15 25\nCase #2: 0 0\nCase #3: 81 567\nCase #4: 181 244\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":8}],"title":"Mushroom Monster","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIf there is only one tree in the forest, then obviously there is no need to cut anything down, and the answer for that tree is zero.\n</p>\n\n<p>\nOtherwise, let's assume we have cut down some trees so that a given point P is on the boundary.  If we follow the boundary clockwise from P, we will reach another boundary point Q.  Imagine we are standing at P and looking along the boundary line towards Q.  There can be no trees still standing to the left of this line, otherwise this would not be the boundary.\n</p>\n\n<p>\nThis suggests an algorithm for determining the minimum number of trees to cut down &mdash; for each point P, try each other point as a candidate for the next point around the boundary, Q; then check how many points lie on the left of the line PQ.  The size of the smallest of those sets of points is the best answer:\n</p>\n\n<pre>\nFor each point P\n  Let M = N-1\n  For each point Q &ne; P\n    Let Temp = 0\n    For each point R &ne; P, Q\n      If R is to the left of the line PQ\n        Temp = Temp + 1\n    If Temp &lt; M\n      M = Temp\n  Output M\n</pre>\n\n<p>\nCutting down all the trees to the left of PQ for some Q is sufficient to produce a valid solution, because no matter where the remaining trees are, P will be on the boundary.  We can also be sure that this method will find the minimal solution, since whatever the minimal solution is, it will have some point Q which is the next along the boundary, and we have cut down the minimal number of trees to make that so.\n</p>\n\t\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1cqndLzCJvGloykxTURmcRRqjO67TiFyGAxElSvRw0AY5SYFR3D-tmuUTYq4Q1Ts8b8jf82A/cv_hull.png\"><br>\n<b>Figure 1</b>\n\n<p>\nConsider the case in figure 1.  Point #4 is already on the boundary, with Q equal to point #2, and we can see that there are no points to the left of the line PQ that we need to cut down, so the answer for point #4 is 0.\n</p>\n\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U06gma0iqPzVCBuzLa5h_1AiFhGuu1fikbKzGMKcnpJY8F5OgLxMXSkbtzke_eZVDumQKIh/cv_cut.png\"><br>\n<b>Figure 2</b>\n\n<p>\nHowever, if P is point #5, then P is not already on the boundary.  When we choose Q to be point #3, as in Figure 2, we find that there are two points to the left of the line PQ: point #2 and point #4.  Cutting down those two trees will put P on the boundary.\n</p>\n\n<p>\nHowever, this is not the minimal solution &mdash; when we try point #2 for Q, we will find a better solution, since only point #4 will need to be cut down.\n</p>\n\n<p>\nThis algorithm takes time O(N^3).  But we can do better than this.\n</p>\n\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3k0YXksOF0x-XY5er0UNJCKjs6ISI4v1E6jcvTPEMekD1pWyH86hnLtc52-UVz26sne9cnBUT5Aw/cv_window1.png\"><br>\n<b>Figure 3</b>\n\n<p>\nFor each new point P, build an array S containing all the other points.  Sort S by the angle of the line from P to that point.  Now, we can try each possible point Q &ne; P by iterating through S, which gives an ordering of the points which moves counter-clockwise around P.\n</p>\n\n<p>\nThe advantage of this method is that for any choice of Q, all the points which lie to the left of the line PQ will occur after Q in the list S.  So we can represent our current choice of Q and the set of points which lie to the left of PQ together as a \"window\" of points, implemented as two pointers into S &mdash; a \"tail\" pointer which points to <b>Q</b>, and a \"head\" pointer which points to the last point after <b>Q</b> which lies to the left of PQ.  We call this point <b>R</b> in the diagrams.\n</p>\n\n<p>\nIn figure 3, we can see the state of this window for P = #1, Q = #2, R = #6.  The tail of the window (in red) is at point #2, and the head of the window (in blue) is at point #6.  The points #3, #4, #5, #6 are the ones which are to the left of PQ, so this choice of Q gives us a candidate solution which requires 4 trees to be cut down.\n</p>\n\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1dU89wkVIPaqb44WEQfo-_eid9_gdH58W6xiiSYGf1U7E2pMjS2VZB7pUydjdA90m3raGAOHHEUw/cv_window2.png\"><br>\n<b>Figure 4</b>\n\n\n<p>\nTo update the position of the window for the next choice of Q, we need to do two things &mdash; move the tail ahead one point to the new choice of Q, and scan forward from the current position of the head pointer to find the new choice for R.  In Figure 4, we can see that the tail has moved to point #3, and the head has moved to point #8.  We now have a candidate solution which requires cutting down 5 trees (#4, #5, #6, #7, #8).\n</p>\n\n<p>\nSince the tail of the window iterates through each point once, and the head of the window iterates through each point at most twice, this part of the algorithm takes <b>O(N)</b> time for each choice of <b>P</b>.\n</p>\n\n<p>\nSorting the points takes <b>O(N&nbsp;log&nbsp;N)</b> time for each choice of <b>P</b>, so in total this solution takes <b>O(N^2&nbsp;log&nbsp;N)</b> time.\n</p>\n\n<p>\nThere are a few things to be careful of when implementing this algorithm:\n<ul>\n<li>The head of the window will reach the end of S before the tail does.  The head pointer then needs to wrap around to the start of S again, to include all the points to the left of PQ.  For example, when Q = #6, the head of the window is #11.  Then when Q advances to #7, the head of the window needs to wrap around to #2, which is at the start of the list, because point #2 is to the left of the line PQ.</li>\n<li>There may be no points to the left of PQ at all; for example, if P=#4, and Q=#2.  A simple way to deal with this case is to have the head of the window equal to the tail.  The calculation of the number of trees to cut down should naturally give zero.  Then, when we advance the tail of the window by one point, also advance the head if it was at the same point.</li>\n<li>There may be more than one point at the same angle from P.  This case is handled automatically.  The points that are at the same angle will occur consecutively in S.  When we choose the last such point as Q, we will correctly calculate the number of trees that need to be cut down.  For the other points at the same angle, we will mistakenly think that extra trees need to be cut down, but we will still find the minimum, so we needn't write extra code to handle this case.</li>\n<li>When updating the position of the head of the window, we need to stop when the next point will be at an angle &pi; or more greater than the angle of Q.  Floating point numbers are imprecise, so we need to use an <a href=\"https://www.google.com/search?q=floating+point+comparison+epsilon\" target=\"_blank\">epsilon</a> when doing comparisons in these calculations.  The largest difference in angle between two points is approximately 1.25 * 10<sup>-13</sup> radians.  64-bit floating point values have easily enough precision to represent angles with this difference, so using these with an epsilon of 10<sup>-13</sup> will work.</li>\n</ul>\n</p>\n\n<p>\nBurunduk1, who won round 1A and had the fastest time for this problem, used an implementation of this algorithm.\n</p>\n","id":"0000000000433d3a","statement":"<h3>Problem</h3>\n\n<p>\nA certain forest consists of <b>N</b> trees, each of which is inhabited by a squirrel.\n</p>\n\n<p>\nThe <b>boundary</b> of the forest is the convex polygon of smallest area which\ncontains every tree, as if a giant rubber band had been stretched around the\noutside of the forest.\n</p>\n\n<p>\nFormally, every tree is a single point in two-dimensional space with unique coordinates\n(<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>), and the boundary is the convex hull of those points.\n</p>\n\n<p>\nSome trees are <b>on the boundary</b> of the forest, which means they are on an edge or\na corner of the polygon.\nThe squirrels wonder how close their trees are to being on the boundary of the forest.\n</p>\n\n<p>\nOne at a time, each squirrel climbs down from its tree, examines the forest, and\ndetermines the minimum number of trees that would need to be cut down for\nits own tree to be on the boundary.\nIt then writes that number down on a log.\n</p>\n\n<p>\nDetermine the list of numbers written on the log.\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow; each consists of a single line with an integer <b>N</b>, the number of trees, followed by <b>N</b> lines with two space-separated integers <b>X<sub>i</sub></b> and <b>Y<sub>i</sub></b>, the coordinates of each tree. No two trees will have the same coordinates.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x:\", followed by <b>N</b> lines with one integer each, where line <b>i</b> contains the number of trees that the squirrel living in tree <b>i</b> would need to cut down.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n-10<sup>6</sup> &le; <b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 15.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>T</b> &le; 14.<br/>\n1 &le; <b>N</b> &le; 3000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n0 0\n10 0\n10 10\n0 10\n5 5\n9\n0 0\n5 0\n10 0\n0 5\n5 5\n10 5\n0 10\n5 10\n10 10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n0\n0\n0\n0\n1\nCase #2:\n0\n0\n0\n0\n3\n0\n0\n0\n0\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn the first sample case, there are four trees forming a square, and a fifth tree inside the square.  Since the first four trees are already on the boundary, the squirrels for those trees each write down 0.  Since one tree needs to be cut down for the fifth tree to be on the boundary, the fifth squirrel writes down 1.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":18},{"type":2,"type__str":"HIDDEN","value":34}],"title":"Logging","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000004336e9","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2015"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
