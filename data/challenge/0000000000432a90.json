{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1399141800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432a90","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>Round 1B was one of the biggest non-qualification rounds so far, with <b>8268</b> contestants who downloaded at least one input. Contestants faced three challenging problems: <i>The Repeater</i> was the easiest problem, where some of the contestants got stuck for some time to trying to see the pattern and get the intuition for the problem, and <b>41%</b> of attempts on the large input failed. <i>New Lottery Game</i> was a standard Dynamic Programming problem, most of the contestants used DP to solve this problem. There is another approach which is discussed in the analysis. For New Lottery Game, <b>74%</b> of attempts on the large input failed. The toughest problem of all was <i>The Bored Traveling Salesman</i> where even its small input could not be implemented easily compared to other problems. Therefore only <b>700</b> contestants got it “Correct!” while about <b>36%</b> of attempts on the large input failed.</p>\n\n<p>\nAt the end of the day, <b>89%</b> of the contestants solved at least one input (small or large), and <b>129</b> people got everything right.\n</p>\n\n<p>\nWe hope everybody enjoyed the round! Congratulations to the Top 1000 who have now made it to Round 2.\n</p>\n\n\n<hr>\nCast:<br>\n\n<p>\nProblem A. <i>The Repeater</i> Written and Prepared by Ahmed Aly. <br>\nProblem B. <i>New Lottery Game</i> Written by Luis Giro Valdes. Prepared by Andrés Mejía.<br>\nProblem C. <i>The Bored Traveling Salesman</i> Written by Steve Thomas. Prepared by Steve Thomas and Jonathan Shen.\n</p>\n\n<p>\nContest analysis presented by Felix Halim, Jonathan Paulson, Mahbubul Hasan, Mohammad Kotb, Timothy Loh, Topraj Gurung, and Zong-Sian Li.\n</p>\n\n<p>\nSolutions and other problem preparation by Carlos Guía, John Dethridge, Khaled Hafez, Nikolay Kurtov, Patrick Nguyen, Rahul Gulati, and Sean Henderson.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1399132800000,"tasks":[{"analysis":"<p>\nLet us first examine the winning condition for Omar. For this we will consider the following example:\n<pre>\n3\naabcaa\nabbcaa\nabccaa\n</pre>\n</p>\n<p>\nWe represent the given strings by borrowing an idea from Run-length Encoding. Using the idea from this encoding the string “aabcda” can be represented as “2:a, 1:b, 1:c, 1:d, 1:a”. The representation shows an ordered list of pairs of frequency and the corresponding character, let’s call it the <b><i>frequency string</i></b>. Similarly, we can figure out the frequency strings for all the original strings. The frequency strings for the strings in the example are listed below:\n<pre>\naabcaa  -&gt;  2:a, 1:b, 1:c, 2:a\nabbcaa  -&gt;  1:a, 2:b, 1:c, 2:a\nabccaa  -&gt;  1:a, 1:b, 2:c, 2:a\n</pre>\nNote that in the problem, an action is defined as either (i) repeating a character, or (ii) deleting a repeated character. In the frequency string, our allowed actions can be re-stated as follows. The first action is similar to increasing the frequency of a character, while the second action is similar to decreasing the frequency of a character. However note we can not decrease the frequency of a character below 1. Given these strings, we notice that Omar will win when the ordered list of characters (excluding the frequencies) are identical. Otherwise, Fegla will win as the allowed actions can only increase the frequency of a character in the encoded frequency string or decrease the frequency (but it is never allowed to go below 1). So if the ordered list of characters of any two strings do not match it will not be possible for Omar to win.\n</p>\n<p>\nSo we know how to figure out if Omar can win or not, we are now interested in the minimum number of actions to win the game. Notice that the actions performed on the i<sup>th</sup> character in the frequency strings can be applied independently from characters in other positions in the frequency strings. Thus, we can process a set of characters at position i before processing the characters in the next position. For the example above, we can solve the leading “a” first, then “b”, then “c”, and finally the trailing “a”. From hereon, we will describe solving for one character (at the i<sup>th</sup> position) in the frequency strings. All other characters can be solved in the same way.\n</p>\n<h4>\n<b>\nBrute force algorithm:\n</b>\n</h4>\n<p>\nIn the brute force solution, we will try all possible frequencies for a single character, that is for the character “a”, we will try all possible frequencies of “a” which are “1:a”, then “2:a”, then “3:a”, etc. We call each frequency we try the <b>target frequency</b>. In this problem, as the length of the string is only upto a 100 therefore we can try all possible frequencies from 1 through 100. For each target frequency, we can compute the sum of total actions (which will be the absolute difference between the frequency of that character and the target frequency) and maintain the target frequency that gives us the minimum sum of total actions.\n</p>\n<p>\nThe time complexity for the brute force algorithm is O(<b>L*N*X</b>), where <b>L</b> is the maximum length of any string, <b>N</b> is the number of strings, and <b>X</b> is the number of characters in the frequency string.\n</p>\n<p>\nThis solution should be sufficient to solve the provided small and large data set.\n</p>\n<h4>\n<b>\nEfficient algorithm:\n</b>\n</h4>\n<p>\nIn the brute force solution, we tried all possible frequencies for a single character. But we don’t need to do so, we can just try only one target frequency!\n</p>\n<p>\nWe would like to point out that intuitively, one might think that the <b>mean</b> would be the target frequency. Let’s go through an example. Suppose we are given the frequencies {1, 1, 100}. The mean is 34. The sum of absolute differences from the provided frequencies to the target frequency is 33 + 33 + 66 = 132. But what if the target frequency was 30 instead of 34? Then the sum of absolute differences is 128, which is less than 132! In fact, if we tried all possible values for the target frequency (from 1 through 100), we would find that the minimum is at 1 with a sum of 99. In fact, it is the <b>median</b> that minimizes sum of absolute differences (1 is the median of {1, 1, 100}).\n</p>\n<p>\nIn our example above, the frequencies for leading “a” are {2, 1, 1}, for “b” are {1, 2, 1}, for “c” are {1, 1, 2}, and for trailing “a” are {2, 2, 2}. Therefore for the leading “a”, we would use the median which is 1 as the target frequency. Similarly for “b” and “c” we use 1, while for the trailing “a” the target frequency is 2.\n</p>\n<p>\nYou might be wondering why the median is the right target frequency, we refer to an excellent <a href=\"http://www.quora.com/Why-does-the-median-minimize-the-sum-of-absolute-deviations\" target=\"_blank\">explanation</a> by Michal Forišek to the question “Why does the median minimize the sum of absolute deviations?” which we quote here:\n</p>\n<p>\n<blockquote>\n<i>\n<p>\nImagine the given values as trees along a road. The quantity you are trying to minimize is the sum of distances between you and each of the trees.\n</p>\n<p>\nSuppose that you are standing at the median, and you know the current value of the sum. How will it change if you move in either direction? Note that regardless of which direction you choose, in each moment you will be moving away from at least half of the trees, and towards at most half of the trees. Therefore, the sum of distances can never decrease -- and that means the sum of distances at the beginning had to be optimal.\n</p>\n</i>\n</blockquote>\n</p>\n<p>\nIn the explanation above, minimizing the sum of absolute deviations is equivalent to minimizing the total actions required to convert any i<sup>th</sup> character in the frequency string to a target frequency in our problem.\n</p>","id":"0000000000432adf","statement":"<h3>Problem</h3>\n<p>\nFegla and Omar like to play games every day. But now they are bored of all games, and they would like to play a new game. So they decided to invent their own game called \"The Repeater\".\n</p>\n<p>\nThey invented a 2 player game. Fegla writes down <b>N</b> strings. Omar's task is to make all the strings identical, if possible, using the minimum number of actions (possibly 0 actions) of the following two types:\n<ul>\n<li>Select any character in any of the strings and repeat it (add another instance of this character exactly after it). For example, in a single move Omar can change \"abc\" to \"abbc\" (by repeating the character 'b').</li>\n<li>Select any two adjacent and identical characters in any of the strings, and delete one of them. For example, in a single move Omar can change \"abbc\" to \"abc\" (delete one of the 'b' characters), but can't convert it to \"bbc\".</li>\n</ul>\n</p>\n<p>\nThe 2 actions are independent; it's not necessary that an action of the first type should be followed by an action of the second type (or vice versa).\n</p>\n<p>\nHelp Omar to win this game by writing a program to find if it is possible to make the given strings identical, and to find the minimum number of moves if it is possible.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.  Each test case starts with a line containing an integer <b>N</b> which is the number of strings. Followed by <b>N</b> lines, each line contains a non-empty string (each string will consist of lower case English characters only, from 'a' to 'z').\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of moves to make the strings identical. If there is no possible way to make all strings identical, print \"Fegla Won\" (quotes for clarity).\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; length of each string &le; 100.\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n<b>N</b> = 2.\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n2 &le; <b>N</b> &le; 100.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2\nmmaw\nmaw\n2\ngcj\ncj\n3\naaabbb\nab\naabb\n2\nabc\nabc\n3\naabc\nabbc\nabcc\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: Fegla Won\nCase #3: 4\nCase #4: 0\nCase #5: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":13}],"title":"The Repeater","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIn this problem, we are given three positive integers <b>A</b>, <b>B</b> and <b>K</b>. We are asked to calculate the number of pairs of integers (<b>a</b>, <b>b</b>) such that:\n<ol>\n<li>\n0 ≤ a &lt; A\n</li>\n<li>\n0 ≤ b &lt; B\n</li>\n<li>\n(a AND b) &lt; K (denote AND means bitwise-AND of a and b).\n</li>\n</ol>\nWe will refer to the set of valid pairs as <b>S(A, B, K)</b>, and the number of valid pairs as <b>f(A, B, K)</b>.\n</p>\n\n<h3>\n<b>\nSolving the small dataset\n</b>\n</h3>\n<p>\nFor the small dataset, we can simply enumerate all pairs (a, b) that meet the first two constraints and count how many match the third constraint. Most programming languages have the  built-in bitwise-AND operation, usually as the character “&amp;”. This procedure will have a time complexity of O(<b>AB</b>), which is sufficient for the small dataset. Following is a sample implementation in Python 3:\n</p>\n<code><pre>\ndef f(A, B, K):\n  return len([(a, b) for a in range(A) for b in range(B) if (a &amp; b) &lt; K])\n</pre></code>\n\n<h3>\n<b>\nSolving the large dataset\n</b>\n</h3>\n<p>\nWe present two approaches for solving the large dataset in this problem. The first one is a standard Dynamic Programming solution (DP on digits/bits) that can be applied to different problems which are of a similar flavor. The second approach divides the search space into different sets, and computes the size of each set recursively.\n</p>\n\n<h3>\n<b>\nFirst approach\n</b>\n</h3>\n<p>\nBefore delving into the actual solution, let us start thinking about a simpler problem: given an integer <b>M</b>, write a recursive function to count all non-negative integers <b>m</b> where 0 ≤ m &lt; M. The answer is trivially M, but bear with us as our intent for this simpler problem is to build an intuition for the Dynamic Programming (DP) function which will be similar to the DP function we will write for the actual problem.\n</p>\n\n<p>\nThe core idea is based on counting the number of ways to generate the bits for the number m, such that they are always less than or equal to M but then we only count those that are strictly less than m. We can start by generating the bits of m from the most significant bit to the least significant bit, and for each bit position, generating only the feasible values. Note that the feasible values for the i-th bit can sometimes be both 0 and 1, or only 0.\n</p>\n\n<p>\nLet’s say M is 29 (which is 11101<sub>2</sub> in binary). The most significant bit is the bit at the fourth position and the least significant bit is at the zeroth position as shown here:\n</p>\n\n<code><pre>\n11101 (M = 29)\n^^^^^\n|||||\n43210 (bit positions 4, 3, 2, 1, 0)\n</pre></code>\n\n<p>\nWe will refer to the i-th bit as m<sub>i</sub>. Let’s say we have generated value 1 for m<sub>4</sub>, value 0 for m<sub>3</sub>, and we want to generate the feasible values for the bit at position i = 2. We can represent our current state as: 10cyy, where 1 and 0 are the values we have chosen, ‘c’ is the current (i-th) bit we want to generate and ‘y’ denotes the bits we will try to generate in the future. We call the bits to the left of position i as prefix. The prefix for the partially generated m<sub>i</sub> = 10cyy is 10 (where i = 2). Now we explain the rules which help us decide the feasible values to use for the i-th bit c:\n<ul>\n<li>\nRule 1: we can always use value 0 for bit at position i.\n</li>\n<li>\nWe can use value 1 for bit at position i if either:\n<ul>\n<li>\nRule 2a: The prefix of the bits before position i in m (which is already generated) is less than the prefix of the bits before position i in M, or\n</li>\n<li>\nRule 2b: The i-th bit of M is 1.\n</li>\n</ul>\n</li>\n</ul>\nUsing the above rules, we can ensure that the prefix generated for m before position i will never be greater than the prefix of M before position i. Let’s explore two scenarios which touch the above rules:\n<ol>\n<li>\nLet’s say our current state is m = 10cyy as before. We want to determine candidate values for ‘c’. In this case, the prefix is 10, and M’s prefix is 11 therefore both values 0 and 1 are feasible. Value 0 is always feasible (Rule 1) while from Rule 2a, value 1 is feasible.\n</li>\n<li>\nIf our current state is m = 11cyy, then both values 0 and 1 are feasible since value 0 is always feasible (Rule 1) while from Rule 2b, value 1 is feasible.\n</li>\n<li>\nIf our current state is m = 111cy, then only value 0 is feasible (Rule 1) but value 1 is not feasible since neither Rule 2a nor Rule 2b can be satisfied.\n</li>\n</ol>\n\n<p>\nNote that as soon as the current prefix of m before position i is less than the prefix of M before position i, we can use both values 0 and 1 for the rest of the bit positions from i down to 0. Remember that we generate the bits from the most significant bit to the lowest (i.e., decreasing i).\n</p>\n\n<p>\nWe now proceed with describing the implementation. We define a recursive function count(i, lessM, M), where i is the i-th bit being generated and lessM is a boolean which denotes whether the prefix of m before position i is less than the prefix of M before position i.\n</p>\n\n<p>\nAs noted earlier, we start generating the number from the most significant bit (the leftmost bit) to the least significant bit (the rightmost bit). Therefore, the base case is when i is -1 which implies we have successfully constructed a whole number m. For the base case we return 1 if the generated number m is less than M otherwise we return 0 (since we only want to count such m that is strictly less than M).\n</p>\n\n<p>\nWe can do Dynamic Programming by caching (memoizing) on the parameters i and lessM and the result. Here is a sample implementation in Python 3 (note that lru_cache provides the required memoization):\n</p>\n\n<code><pre>\nfrom functools import lru_cache\n\ndef getBit(num, i):\n  return (num &gt;&gt; i) &amp; 1  # Returns the i-th bit value of num.\n\n@lru_cache(maxsize = None)\ndef count(i, lessM, M):\n  if i == -1:  # The base case.\n    return lessM  # only count if it is strictly less than M.\n\n  maxM = lessM or getBit(M, i) == 1\n\n  res = count(i - 1, maxM, M)  # Value 0 is always feasible. See (1) below.\n\n  if maxM: # Value 1 is feasible if maxM is true. See (2) below.\n    res += count(i - 1, lessM, M)  # See (3) below.\n\n  return res\n\n# Prints how many non-negative numbers that are less than 123456789\nprint(count(31, False, 123456789))\n</pre></code>\n\n<p>\nNotes:\n<br>\n(1): To compute the boolean value of lessM for the next bit of m in the recurrence, we look at the value of the current lessM. If the current lessM is already true, then lessM for the next bit in the recurrence will also be true. Another case when lessM for the next bit is true is when the i-th bit of M is equal to 1. Since we pick value 0 for the current (i-th) bit in m and it is less than the i-th bit of M (which is 1), it means that lessM is true for the next bit. maxM captures what we described just now, therefore the next value for lessM for the next bit in the recursion is set to maxM.\n<br>\n(2): Value 1 is feasible if lessM is true (which means we are free to use both values 0 and 1) or the i-th bit of M is 1 (which means we are still generating feasible partial number m that is less than or equal to M).\n<br>\n(3): The value for lessM in the next bit can only be true if lessM is previously true. If the current lessM is false, then we know that the i-th bit of M is 1. Since we picked value 1 for the current bit, the next value for lessM will not change (since 1 is not less than 1).\n</p>\n\n<p>\nNow, with the above intuition for generating non-negative numbers that are less than M, we can generalize it to count all possible pairs (a,b) that are less than A and B respectively and where the bitwise ANDing of the pair (a,b) is less than K. We enumerate all possible values for current bit in a and b (i.e. the 4 possible values (0, 0), (0, 1), (1, 0), (1, 1)) and add new constraints to ensure that the bitwise ANDing of the pair (a,b) &lt; K.\n</p>\n\n<p>\nThe code for the original problem is of a similar style as in the simpler problem. The code is presented below. The purpose of the variable lessA is equivalent to lessM, similar for lessB and lessK. We try to generate all feasible values for a and b and keep k in check (see the following notes).\n</p>\n<code><pre>\n@lru_cache(maxsize = None)\ndef countPairs(i, lessA, lessB, lessK, A, B, K):\n  if i == -1:  # The base case.\n    return lessA and lessB and lessK  # Count those that are strictly less.\n\n  maxA = lessA or getBit(A, i) == 1\n  maxB = lessB or getBit(B, i) == 1\n  maxK = lessK or getBit(K, i) == 1\n\n  # Use value 0 for a, b, and k which is always possible. See (1).\n  count = countPairs(i - 1, maxA, maxB, maxK, A, B, K)\n\n  if maxA:  # Use value 1 for a, and 0 for b and k. See (2).\n    count += countPairs(i - 1, lessA, maxB, maxK, A, B, K)\n\n  if maxB:  # Use value 1 for b, and 0 for a and k. See (3)\n    count += countPairs(i - 1, maxA, lessB, maxK, A, B, K)\n\n  if maxA and maxB and maxK:  # Use value 1 for a, b, and k. See (4)\n    count += countPairs(i - 1, lessA, lessB, lessK, A, B, K)\n\n  return count\n</pre></code>\n\n<p>\nNotes:\n<br>\n(1): If we choose 0 for a and 0 for b, the value for k should be 0 since 0 &amp; 0 = 0\n<br>\n(2): If we choose 1 for a and 0 for b, the value for k should be 0 since 0 &amp; 1 = 0\n<br>\n(3): If we choose 0 for a and 1 for b, the value for k should be 0 since 1 &amp; 0 = 0\n<br>\n(4): If we choose 1 for a and 1 for b, the value for k should be 1 since 1 &amp; 1 = 1\n</p>\n\n<p>\nTo avoid overflows, you should take care to use 64-bit integers. Also, this solution pattern is a standard way to solve these kinds of problems and can be generalized to any number system (and not just base 2 as was the case in our problem).\n</p>\n\n<p>\nThe complexity of this solution is based on the size of the DP table which here is 31 * 2 * 2 * 2.\n</p>\n\n<h3>\n<b>\nSecond approach\n</b>\n</h3>\n<p>\nWe can group the pairs (a, b) in <b>S(A, B, K)</b> based on whether a and b are odd or even, i.e. have the least significant bit set. Each such pair will be accounted for in one of the four sets below (written using set-builder notation), so summing up the sizes of the four sets will give us the value <b>f(A, B, K)</b>.\n</p>\n<ol>\n<li>\n{(a/2, b/2) | (a, b) ∈ S(A, B, K) &amp;&amp; a even &amp;&amp; b even}<br>\n= S(ceil(A/2), ceil(B/2), ceil(K/2))\n</li>\n<li>\n{(a/2, (b-1)/2) | (a, b) ∈ S(A, B, K) &amp;&amp; a even &amp;&amp; b odd}<br>\n= S(ceil(A/2), floor(B/2), ceil(K/2))\n</li>\n<li>\n{((a-1)/2, b/2) | (a, b) ∈ S(A, B, K) &amp;&amp; a odd &amp;&amp; b even}<br>\n= S(floor(A/2), ceil(B/2), ceil(K/2))\n</li>\n<li>\n{((a-1)/2, (b-1)/2) | (a, b) ∈ S(A, B, K) &amp;&amp; a odd &amp;&amp; b odd}<br>\n= S(floor(A/2), floor(B/2), floor(K/2))\n</li>\n</ol>\n\n<p>\nNote that in the 4 sets, the values for ‘k’ are forced. If ‘a’ or ‘b’ is even, ‘k’ will also be even while if both ‘a’ and ‘b’ are odd, then ‘k’ is also odd (because of the bitwise ANDing).\n</p>\n\n<p>\nLet us provide more intuition on the 4 sets. We show it with an example where we list even numbers. If A is odd, e.g. 7 then the possible ‘a’ values that are even are 0, 2, 4, 6. If A is even, e.g. 8 then the possible ‘a’ values that are even are also 0, 2, 4, 6. The numbers in their binary representation are 000, 010, 100, 110. The 4 sets is akin to fixing (or eliminating) the least significant bit (i.e. by shifting right by 1, i.e. a&gt;&gt;1) which results in the set: 00,01,10,11 i.e. values 0, 1, 2, 3. The new value for A here is 4 (i.e. first integer greater than 0, 1, 2, 3). We generalize and say the following: If we are considering even values for ‘a’, then the new A is given by (A+1)&gt;&gt;1 (which is also ceil(A/2)). By going through a similar exercise for when ‘a’ is odd and A is odd or even (which we leave to the reader), we find the new A is given by A&gt;&gt;1 (which is also floor(A/2)).\n</p>\n\n<p>\nThe 4 sets give us a simple recursive procedure to compute <b>f(A, B, K)</b>, as the sizes of the sets on the right hand side of the equations are simply calls to f. The appropriate base cases here are <b>f(1, 1, K)</b> = 1 and <b>f(A, B, K)</b> = 0 if any of A, B, K are equal to zero.  To turn this recursive procedure into an efficient algorithm, we can memoize computed values. This means that after computing some <b>f(A, B, K)</b>, we cache the result so future computations with the same values will take constant time.\n</p>\n<p>\nSample implementation in Python 3:\n</p>\n<code><pre>\n@lru_cache(maxsize = None)\ndef f(A, B, K):\n    if A == 0 or B == 0 or K == 0:\n        return 0\n    if A == B == 1:\n        return 1\n    return f((A+1)&gt;&gt;1, (B+1)&gt;&gt;1, (K+1)&gt;&gt;1) + \\\n           f((A+1)&gt;&gt;1, B&gt;&gt;1, (K+1)&gt;&gt;1) + \\\n           f(A&gt;&gt;1, (B+1)&gt;&gt;1, (K+1)&gt;&gt;1) + \\\n           f(A&gt;&gt;1, B&gt;&gt;1, K&gt;&gt;1)\n</pre></code>\n<h3>\n<b>\nComplexity Analysis\n</b>\n</h3>\n<p>\nIt can be shown by induction that a recursive call <b>f(A’, B’, K’)</b> of recursive depth <b>n</b> has <b></b>A’ equal to either floor(A / 2<sup>n</sup>) or 1+floor(A / 2<sup>n</sup>), and that B’ and K’ satisfy similar relations. From this, we can see that at a given recursive depth there are at most 8 different calls to f. Due to our chosen base cases, we can also see that the maximum recursion depth is O(<b>log(max(A, B))</b>). We conclude that the algorithm is O(<b>log(max(A, B))</b>).\n</p>","id":"0000000000433096","statement":"<h3>New Lottery Game</h3>\n<p>\nThe Lottery is changing! The Lottery used to have a machine to generate a random winning number. But due to cheating problems, the Lottery has decided to add another machine. The new winning number will be the result of the bitwise-AND operation between the two random numbers generated by the two machines.\n\n<p>\nTo find the bitwise-AND of X and Y, write them both in binary; then a bit in the result in binary has a 1 if the corresponding bits of X and Y were both 1, and a 0 otherwise. In most programming languages, the bitwise-AND of X and Y is written X&amp;Y.\n\n<p>\nFor example:<br/>\n&nbsp;&nbsp;&nbsp;The old machine generates the number 7 = 0111.<br/>\n&nbsp;&nbsp;&nbsp;The new machine generates the number 11 = 1011.<br/>\n&nbsp;&nbsp;&nbsp;The winning number will be (7 AND 11) = (0111 AND 1011) = 0011 = 3.<br/>\n<br/>\n\nWith this measure, the Lottery expects to reduce the cases of fraudulent claims, but unfortunately an employee from the Lottery company has leaked the following information: the old machine will always generate a non-negative integer less than <b>A</b> and the new one will always generate a non-negative integer less than <b>B</b>.\n<br/><br/>\n Catalina wants to win this lottery and to give it a try she decided to buy all non-negative integers less than <b>K</b>.\n<br/><br/>\n Given <b>A</b>, <b>B</b> and <b>K</b>, Catalina would like to know in how many different ways the machines can generate a pair of numbers that will make her a winner.\n<br/><br/>\nCould you help her?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow, each line with three numbers <b>A</b> <b>B</b> <b>K</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the number of possible pairs that the machines can generate to make Catalina a winner.\n</p>\n\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n\n1 &le; <b>A</b> &le; 1000.<br/>\n1 &le; <b>B</b> &le; 1000.<br/>\n1 &le; <b>K</b> &le; 1000.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>A</b> &le; 10<sup>9</sup>.<br/>\n1 &le; <b>B</b> &le; 10<sup>9</sup>.<br/>\n1 &le; <b>K</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n3 4 2\n4 5 2\n7 8 5\n45 56 35\n103 143 88\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 10\nCase #2: 16\nCase #3: 52\nCase #4: 2411\nCase #5: 14377\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn the first test case, these are the 10 possible pairs generated by the old and new machine respectively that will make her a winner: &lt;0,0&gt;, &lt;0,1&gt;, &lt;0,2&gt;, &lt;0,3&gt;, &lt;1,0&gt;, &lt;1,1&gt;, &lt;1,2&gt;, &lt;1,3&gt;, &lt;2,0&gt; and &lt;2,1&gt;. Notice that &lt;0,1&gt; is not the same as &lt;1,0&gt;. Also, although the pair &lt;2, 2&gt; could be generated by the machines it wouldn't make Catalina win since (2 AND 2) = 2 and she only bought the numbers 0 and 1.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":24}],"title":"New Lottery Game","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nWe can model this problem as a graph problem where the cities are nodes in the graph and the bidirectional flight tickets between cities are the bidirectional edges connecting the nodes. Each node has a distinct zip code number. The given constraints on the tickets and how it should be used can be modelled as a modified <a href=\"http://en.wikipedia.org/wiki/Depth-first_search\" target=\"_blank\">depth-first-search</a>-like traversal where: when we visit a node, we are not required to visit all of its neighbors but in the end all nodes must be visited. When a node is visited, its zip code is printed (i.e., pre-order traversal). When all nodes have been visited, the printed (concatenated) zip codes must form the smallest number possible.\n</p>\n\n<h3>\n<b>Brute Force Solution:</b>\n</h3>\n<p>\nThe small input has at most 8 nodes. It is small enough that we can try all possible paths according to the rules (including all possible starting nodes), and pick the one with the smallest number (of concatenated zip codes). The brute force solution can have a time complexity of O(<b>N! * N</b>), where <b>N!</b> comes from having to potentially list all possible permutation of cities and for each permutation we can check its validity in O(<b>N</b>). As the large input can have up to 50 cities, this algorithm will be too slow. Therefore we propose an alternative solution to handle the large input.\n</p>\n\n<h3>\n<b>Greedy Solution:</b>\n</h3>\n<p>\nWe can rank nodes based on its zip codes (i.e., the smallest node is the node with the smallest zip code). Since all of the zip codes are the same length, we can think of each zip code as a single digit number and to form the smallest concatenated digits we can just greedily concatenate the digits in increasing order. This means that the node with the smallest zip code should be the first node to be visited (i.e., the source node for the traversal). Thus, to minimize the final concatenated number, we should always visit the <b>next smallest feasible node</b> (we will discuss node feasibility later). Note that it is always possible to complete the traversal from the smallest node (or any node) since the input graph is connected.\n</p>\n\n<p>\nBefore we provide the pseudocode of the greedy algorithm, let’s define some variables. We provide examples that make use of these variables in subsequent paragraphs:\n<ul>\n<li>\nDEAD: The set of nodes we’ve already visited and left (which we may never visit again).\n</li>\n<li>\nACTIVE: The stack of nodes along our current path (originating from the source node).\n</li>\n<li>\nHEAD: The node at the top of the ACTIVE stack, which is the node we are currently on.\n</li>\n</ul>\n</p>\n\n<p>\nAt each step, we may either:\n<ul>\n<li>\nVisit some not-yet-visited neighbor of HEAD, which adds the newly visited node to the top of the ACTIVE stack and make it as the new HEAD. This action is analogous to flying to a new city for the first time. Note that when we visit a new city, we should concatenate its zip code to our final answer.\n</li>\n<li>\nLeave HEAD, which pops HEAD from the ACTIVE stack and moves it to the DEAD set. This action is analogous to taking the return flight from HEAD using the return ticket used to visit HEAD. Note that we do not concatenate the city’s zip code to the final answer when leaving the city.\n</li>\n</ul>\n</p>\n\n<p>\nWith that, we are ready to present the pseudocode for our greedy algorithm:\n</p>\n<code><pre>\n  root = the node with smallest zip code\n  DEAD = new Set()\n  ACTIVE = new Stack()\n  ACTIVE.push(root)\n  answer = “”\n  concatenate zipcode[root] to answer\n  while ACTIVE is not empty:\n    HEAD = ACTIVE.peek()\n    next = <b>next_smallest_feasible_node_to_visit()</b>\n    if next is EMPTY or no flight from HEAD to next:\n      # leave the HEAD node\n      insert HEAD to the DEAD set\n      ACTIVE.pop()\n    else:\n      # visit the next node\n      ACTIVE.push(next)\n      concatenate zipcode[next] to answer\n  print answer\n</pre></code>\n\n<p>\nNow, the hard part is: how do we compute the <b>next_smallest_feasible_node_to_visit()</b>? We first demonstrate it with an example.\n</p>\n\n<p>\nSuppose we have a graph and we start traversing from the source node <b>S</b> (which has the smallest zip code). Suppose the next nodes with smallest zip codes are nodes <b>A</b>, <b>B</b>, <b>C</b> in that order and A is connected to S, B is connected to A, and C is connected to B. Then the greedy algorithm will go from S -&gt; A -&gt; B -&gt; C. The figure below shows the current state of the traversal and the rest of the graph. Nodes S, A, B, C are in the ACTIVE stack where C is the HEAD:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0egR6C2S65S2Fc_QZfTroBnJf9PWSBQr8XTjSjQnwqRPR3YzmS7M5lmLsUGN80d_KhDQ/tsp2.png\">\n<p>\nHow do we pick the next smallest feasible node to visit from C? Could we arbitrarily pick a node that is connected to the ACTIVE stack then decide to visit that node next? Actually not. We investigate the following three scenarios to clarify why we cannot arbitrarily pick a node connected to the ACTIVE stack.\n</p>\n<ul>\n<li>\nScenario 1: Z’s zip code is smaller than both X and Y\n<br>\nIn this case, we cannot visit Z as the next node since it requires us to travel back from C -&gt; B -&gt; A -&gt; S, then visit Z. This will put nodes C, B, A in the DEAD set. This becomes a problem for node X since it has not yet been visited and now there is no way to reach node X from any ACTIVE nodes (note that as we cannot visit the DEAD nodes therefore the DEAD nodes A, B, C disconnect X from S, Z and Y). Thus, node Z is not feasible as the next node to be visited next (after C).\n</li>\n<li>\nScenario 2: X’s zip code is smaller than Y’s, and Y’s is smaller than Z’s\n<br>\nIn this case, we can directly visit X from the currently active node C. Then, we can visit the next smallest node Y by traveling back from X -&gt; C -&gt; B -&gt; Y. Finally, we visit the next smallest node Z directly from Y. After that, we can go back all the way to S via Z -&gt; Y -&gt; B -&gt; A -&gt; S to complete the traversal.\n</li>\n<li>\nScenario 3: Y’s zip code is smaller than X’s, and X’s is smaller than Z’s\n<br>\nIn this case, we can visit the next smallest node Y by travelling back from C -&gt; B -&gt; Y  while putting node C in the DEAD set. The next smallest node X can still be reached by traveling back from Y -&gt; B -&gt; A -&gt; X and putting nodes B and Y in the DEAD set. Finally, the next smallest node Z can be visited by travelling back from X -&gt; A -&gt; S -&gt; Z.\n</li>\n</ul>\n<p>\nFrom the scenarios above, we know that Z is not feasible as the next node but both X and Y are feasible and we can visit the one with the smaller zip code first.\n</p>\n\n<p>\nIn general, we need to be able to figure out if a node is feasible as the next node. To do so, we can instead ask when is a node not feasible as the next node. It is not a feasible node if by visiting that node, some nodes that are not-yet-visited become unreachable from the nodes in the ACTIVE stack (i.e., they can never be visited later because they are disconnected from the ACTIVE set due to some nodes that will be placed in the DEAD set when taking the return flight as in Scenario 1). Observe that nodes that are still reachable from nodes in the ACTIVE stack can still be visited later.\n</p>\n\n<p>\nTo check whether the not-yet-visited nodes are still reachable from the ACTIVE nodes, we can do a connectivity check (via breadth-first-search or depth-first-search) from the source node to all the not-yet-visited nodes, avoiding the DEAD nodes. Note that since all ACTIVE nodes are all connected to the source node, doing the connectivity check from the source node is equivalent to doing the connectivity check from all ACTIVE nodes.\n</p>\n\n<p>\nNow, we are ready to devise an iterative algorithm to find the feasible nodes and pick the smallest node. Referring to our example above, in this iterative algorithm we will generate X, Y and Z in that order. The algorithm will terminate when we reach Z (please refer to Scenario 1 for the reason). Note that when this algorithm returns, it should not alter the ACTIVE stack and the DEAD set. Therefore, when running this algorithm we can either make a local copy of the ACTIVE stack and the DEAD set, or restore the changes we made (if we run this algorithm in place). The iterative algorithm is as follows:\n</p>\n<ol>\n<li>\nCheck the neighbors of the current HEAD and record the next smallest node to visit.\n</li>\n<li>\nTry to abandon the current HEAD node and take the return flight to the previous node in the ACTIVE stack. If it is not possible to abandon this HEAD (i.e., it makes some not-yet-visited nodes unreachable), then we stop and return the smallest node we recorded. Otherwise, we take the return ticket from HEAD (abandon the current HEAD) and keep on looping by going to step 1.\n</li>\n</ol>\n\n<p>\nThe following pseudocode shows one way to implement the above algorithm (with in place modification of the ACTIVE stack and DEAD set, and restoration of the changes before returning):\n</p>\n<code><pre>\n  def next_smallest_feasible_node_to_visit():\n    temp = new Stack()\n    best = EMPTY\n    while ACTIVE is not empty:\n      HEAD = ACTIVE.top()\n      # Check the neighbors of HEAD and record the \n      # next smallest node as best.\n      for each neighbor i of HEAD that is not-yet-visited:\n        if best == EMPTY or zipcode[i] &lt; zipcode[best]:\n          best = i\n\n      # Abandon HEAD and go back up in the ACTIVE stack.\n      insert HEAD to the DEAD set\n      temp.push(HEAD)\n      ACTIVE.pop()\n\n      if there exists a not-yet-visited node that \\\n        is not reachable from the source node:\n        break\n\n    # Restore the ACTIVE nodes and the DEAD set.\n    while temp is not empty:\n      HEAD = temp.top()\n      remove HEAD from the DEAD set\n      temp.pop()\n      ACTIVE.push(HEAD)\n\n    return best\n</pre></code>\n\n<p>\nHow fast is this greedy algorithm? The greedy algorithm calls the search for the next smallest feasible node routine N times. Each search runs through all the nodes in the ACTIVE stack with at most O(<b>N</b>) nodes. For each node in the ACTIVE stack, we perform one connectivity check that takes O(<b>N</b>) time, and we loop through all of the node’s O(<b>N</b>) children. Therefore overall, it is O(<b>N<sup>3</sup></b>), which fits easily into the time limits.\n</p>","id":"00000000004331a4","statement":"<h3>Problem</h3>\n<p>\nYour boss is sending you out on an international sales trip. What joy!\n</p>\n<p>\nYou have <b>N</b> cities (numbered from 1 to <b>N</b>) to visit and can get to them using a set of bidirectional flights that go between the cities.\n</p>\n<p>\nAll of the cities must be visited at least once. To do this you can book any number of tickets, subject to the following conditions:\n<ul>\n<li>Each ticket consists of 2 flights, one from a specific city <b>X</b> to another specific city <b>Y</b> (this is called the <b>outbound</b> flight), and the other one from city <b>Y</b> to city <b>X</b> (this is called the <b>return</b> flight).</li>\n<li>You must use the outbound flight before the corresponding return flight (you can use other flights in between).</li>\n<li>At most 1 outbound flight going to each city, although there is no limit on the return flights (multiple return flights can go to the same city).</li>\n<li>You must use all flights which belong to the tickets you booked.</li>\n<li>You can otherwise visit the cities in any order you like.</li>\n<li>You can start your trip from any city you choose. You may not take an outbound flight to your starting city.</li>\n</ul>\n</p>\n<p>\nNow you could try to minimize the total distance travelled, but you did that last time, so that would be boring. Instead you noticed that each city has a distinct 5 digit ZIP (postal) code. When you visit a city for the first time (this includes the city which you start from) you write down the zip code and concatenate these into one large number (concatenate them in the order which you visited each city for the first time). What is the smallest number you can achieve?\n</p>\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.\n<p>Each test case starts with a single line containing two integers: the number of cities <b>N</b> and the number of possible bidirectional flights <b>M</b>.\n</p>\n<p><b>N</b> lines then follow, with the i-th line containing the 5-digit zip code of the i-th city. No ZIP code will have leading zeros and all ZIP codes in each test case will be distinct.\n</p>\n<p>\n<b>M</b> lines then follow, each containing two integers <b>i</b> and <b>j</b> (1 &le; <b>i</b> &lt; <b>j</b> &le; <b>N</b>) indicating that a bidirectional flight exists between the <b>i</b>-th city and the <b>j</b>-th city. All flights will be distinct within each test case.\n</p>\n<p>\nIt is guaranteed that you can visit every city following the rules above.\n</p>\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the smallest number you can achieve by concatenating the ZIP codes along your trip.\n</p>\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &le; <b>M</b> &le; <b>N</b> * (<b>N</b> - 1) / 2.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 8.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3 2\n10001\n20000\n10000\n1 2\n2 3\n5 4\n36642\n28444\n50012\n29651\n10953\n1 4\n2 3\n2 5\n4 5\n5 5\n36642\n28444\n50012\n29651\n10953\n1 2\n1 4\n2 3\n2 5\n4 5\n6 6\n10001\n10002\n10003\n10004\n10005\n10006\n1 2\n1 6\n2 3\n2 4\n3 5\n4 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 100002000010001\nCase #2: 1095328444500122965136642\nCase #3: 1095328444366422965150012\nCase #4: 100011000210003100041000510006\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h4>Explanation</h4>\n<p>\nIn the last sample test case, the following is the sequence of what you should do to achieve the smallest number:\n<ol>\n<li>Start from city 1, write 10001.</li>\n<li>Outbound flight from 1 to 2, write 10002.</li>\n<li>Outbound flight from 2 to 3, write 10003.</li>\n<li>Return flight from 3 to 2.</li>\n<li>Outbound flight from 2 to 4, write 10004.</li>\n<li>Outbound flight from 4 to 5, write 10005.</li>\n<li>Return flight from 5 to 4.</li>\n<li>Return flight from 4 to 2.</li>\n<li>Return flight from 2 to 1.</li>\n<li>Outbound flight from 1 to 6, write 10006.</li>\n<li>Return flight from 6 to 1.</li>\n</ol>\n</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":30}],"title":"The Bored Traveling Salesman","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432a90","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2014"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
