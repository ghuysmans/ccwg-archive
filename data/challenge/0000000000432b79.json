{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1216335600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432b79","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  This was the inaugural round for Google Code Jam 2008, and the first real\n  contest run on our own platform!  Over 11044 people competed, and 6744 of\n  them solved at least one full problem to advance to Round 1.  576\n  participants solved all the datasets correctly, including our fun little\n  geometry problem.\n</p><p>\n  We had competitors from 118 different countries, 104 of which had at least\n  one qualifier; India, the United States and China were the top three in\n  participants.\n</p><p>\n  And finally, perhaps the most exciting fact about our qualification round:\n  contestants used over 40 programming languages to solve the problems.\n</p><p>\n  We hope you liked the problems! Congratulations to the people who qualified,\n  and good luck in the remaining rounds!\n</p>\n<hr>\n<p>\n  <b>Credits</b>\n</p><p>\n  Problem A. <i>Saving the Universe</i>\n  Written by Mohamed Eldawy. Prepared by Patrick Nguyen.\n</p><p>\n  Problem B. <i>Train Timetable</i>\n  Written by William Rucklidge. Prepared by Cosmin Negruseri, Ante Derek, and\n  Igor Naverniouk.\n</p><p>\n  Problem C. <i>Fly Swatter</i>\n  Written by Andrew Warner. Prepared by Marius Andrei and Igor Naverniouk.\n</p><p>\n  Contest analysis presented by Cosmin Negruseri and Xiaomin Chen.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1216249200000,"tasks":[{"analysis":"<p>\n  The first task in the new Google Code Jam is about, no surprise, search\n  engines, and also, the grandiose feat of saving the universe in a\n  parsimonious way. However, putting all the fancies aside, the problem itself\n  is easy.\n</p><p>\n  List all queries one by one, and break them up into segments.  Each segment\n  will be an interval where we use one search engine, and when we cross from\n  one segment to another we will switch the search engine we use.  What can you\n  say about each segment? Well, one thing for sure is:\n  <blockquote>\n    Never ever ever have all <b>S</b> different search engines appear as\n    queries in one segment. (*)\n  </blockquote>\n  Why is this?  Because if all <b>S</b> names appeared in one segment, then any\n  search engine used for that segment will encounter at least one query that is\n  the same as its name, thus exploding the universe!\n</p><p>\n  Working in the opposite direction, (*) is all we need to achieve; as long as\n  you can partition the list of queries into such segments, it corresponds to a\n  plan of saving the universe. You don't even care about which engine is used\n  for one segment; any engine not appearing as a query on that segment will do.\n  However, you might sometimes pick the same engine for two consecutive\n  segments, laughing at yourself when you realize it; why don't I just join the\n  two segments into one? Because your task is to use as few segments as\n  possible, it is obvious that you want to make each segment as long as\n  possible.\n</p><p>\n  This leads to the greedy solution: Starting from the first query, add one\n  query at a time to the current segment until the names of all <b>S</b> search\n  engines have been encountered.  Then we continue this process in a new\n  segment until all queries are processed.\n</p><p>\n  Sample code in C++, where <b>st</b> is the set of queries in the current\n  segment, <b>q</b> is the next query, and <b>count</b> is the number of\n  switches.\n</p>\n<pre>\nst.clear();\ncount = 0;\nfor (int i=0; i&lt;Q; i++) {\n  getline(cin, q);\n  if (st.find(q) == st.end()) {\n    if (st.size() == S-1) {\n      st.clear();\n      count++;\n    }\n    st.insert(q);\n  }\n}\n</pre>\n<p>\n  If <b>st</b> is a hashset, you expect the solution run in O(n) time. Note\n  that this solution uses the fact that each query will be a search engine name\n  and so we can ignore the list of names provided in the input.\n</p><p>\n  Let us justify that the greedy approach always gives the optimal answer.\n  Think of the procedure as Q steps, and we want to show that, for each i,\n  there is (at least) one optimal choice which agrees with us on the first i\n  steps. We do this inductively for i = 0, then i = 1, and so on.  The\n  proposition for i = Q when proven true will imply that our algorithm is\n  correct.\n</p><p>\n  So, the key points in the inductive step i:<br>\n  <ol>\n  <li>\n    If adding the next query will explode the universe, we must start a new\n    segment. Any optimal choice agrees with us for the first (i-1) steps must\n    also do that.\n  </li>\n  <li>\n    If adding the next query will not explode the universe, we do not start a\n    new segment. We know there is an optimal solution R agreed with us for\n    (i-1) steps. Even if in R a new segment is started at step i, we can modify\n    it a little bit. Let R' be the plan that agrees with R, but instead of\n    starting a new segment on the i-th step, we delay this to the (i+1)st. It\n    is clear that R' will also make the universe safe, and has no more switches\n    than R does. So, R' is also an optimal solution, and agrees with our choice\n    for the first i steps.\n  </li>\n  </ol>\n</p><p>\n  The similar lines of justifications work for many greedy algorithms,\n  including the well beloved minimum spanning trees.\n</p>\n","id":"000000000043290d","statement":"<h3>Problem</h3>\n<p>\n  The urban legend goes that if you go to the Google homepage and search for\n  \"Google\", the universe will implode. We have a secret to share... It is true!\n  Please don't try it, or tell anyone. All right, maybe not. We are just\n  kidding.\n</p><p>\n  The same is not true for a universe far far away. In that universe, if you\n  search on any search engine for that search engine's name, the universe does\n  implode!\n</p><p>\n  To combat this, people came up with an interesting solution. All queries are\n  pooled together. They are passed to a central system that decides which query\n  goes to which search engine.  The central system sends a series of queries to\n  one search engine, and can switch to another at any time.  Queries must be\n  processed in the order they're received.  The central system must never send\n  a query to a search engine whose name matches the query.  In order to reduce\n  costs, the number of switches should be minimized.\n</p><p>\n  Your task is to tell us how many times the central system will have to switch\n  between search engines, assuming that we program it optimally.\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input file contains the number of cases, <b>N</b>.\n  <b>N</b> test cases follow.\n</p><p>\n  Each case starts with the number <b>S</b> -- the number of search engines.\n  The next <b>S</b> lines each contain the name of a search engine. Each search\n  engine name is no more than one hundred characters long and contains only\n  uppercase letters, lowercase letters, spaces, and numbers. There will not be\n  two search engines with the same name.\n</p><p>\n  The following line contains a number <b>Q</b> -- the number of incoming\n  queries. The next <b>Q</b> lines will each contain a query. Each query will\n  be the name of a search engine in the case.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each input case, you should output:\n  <pre>Case #<b>X</b>: <b>Y</b></pre>\n  where <b>X</b> is the number of the test case and <b>Y</b> is the number of\n  search engine switches.\n\n  Do not count the initial choice of a search engine as a switch.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  0 &lt; <b>N</b> &le; 20\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  2 &le; <b>S</b> &le; 10<br>\n  0 &le; <b>Q</b> &le; 100\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  2 &le; <b>S</b> &le; 100<br>\n  0 &le; <b>Q</b> &le; 1000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\nYeehaw\nNSM\nDont Ask\nB9\nGoogol\n10\nYeehaw\nYeehaw\nGoogol\nB9\nGoogol\nNSM\nB9\nNSM\nDont Ask\nGoogol\n5\nYeehaw\nNSM\nDont Ask\nB9\nGoogol\n7\nGoogol\nDont Ask\nNSM\nNSM\nYeehaw\nYeehaw\nGoogol\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In the first case, one possible solution is to start by using Dont Ask, and\n  switch to NSM after query number 8.<br>\n  For the second case, you can use B9, and not need to make any switches.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Saving the Universe","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This was the hardest problem of the set, as we can see from the submission\n  statistics, but 652 people succeeded in solving it correctly.\n</p><p>\n  The first step in solving this problem involves a standard trick. Instead of\n  looking for the region that will hit the fly's circular body, we look for the\n  region where the center of the fly must avoid. The problem is thus\n  transformed into an equivalent one where we thicken the size of the racquet\n  to <b>t</b> + <b>f</b> and the radius of the strings from <b>r</b> to\n  <b>r</b> + <b>f</b>. And we consider the fly to be simply a single point,\n  only focusing on its center.\n</p><p>\n  Now the main problem is to find the area of the holes (the areas between the\n  strings, or between the strings and the racquet), and divide it by the area\n  of the disc corresponding to the original racquet. It is easy to see this\n  gives the probability that the racquet <i>does not</i> hit the fly.\n</p><p>\n  A simplifying observation is that we can just look at the first quadrant of\n  the circle, because the racquet is symmetrical.\n</p><p>\n  Now we can go through each square gap in the racquet and check a few cases.\n  Each case consists in computing the area of intersection between the square\n  and the circle representing the inside of the racquet.  The case where the\n  square is totally inside or totally outside the circle is easy. The cases\n  left when one corner, two or three corners of the square are inside the\n  circle and the other corners are outside. There are no other cases because we\n  just look at the intersection of a quarter of the circle with small squares.\n</p><p>\n  Each of these cases can be solved by splitting the intersection area into\n  triangles and a <a href=\"http://mathworld.wolfram.com/CircularSegment.html\"\n  target=\"_blank\">circular segment</a>.\n  Here's some code that does this:\n</p>\n<pre>\ndouble circle_segment(double rad, double th) {\n  return rad*rad*(th - sin(th))/2;\n}\n\ndouble rad = R-t-f;\ndouble ar = 0.0;\nfor (double x1 = r+f; x1 &lt; R-t-f; x1 += g+2*r)\nfor (double y1 = r+f; y1 &lt; R-t-f; y1 += g+2*r) {\n  double x2 = x1 + g - 2*f;\n  double y2 = y1 + g - 2*f;\n  if (x2 &lt;= x1 || y2 &lt;= y1) continue;\n  if (x1*x1 + y1*y1 &gt;= rad*rad) continue;\n  if (x2*x2 + y2*y2 &lt;= rad*rad) {\n    // All points are inside circle.\n    ar += (x2-x1)*(y2-y1);\n  } else if (x1*x1 + y2*y2 &gt;= rad*rad &amp;&amp;\n             x2*x2 + y1*y1 &gt;= rad*rad) {\n    // Only (x1,y1) inside circle.\n    ar += circle_segment(rad, acos(x1/rad) - asin(y1/rad)) +\n          (sqrt(rad*rad - x1*x1)-y1) *\n          (sqrt(rad*rad - y1*y1)-x1) / 2;\n  } else if (x1*x1 + y2*y2 &gt;= rad*rad) {\n    // (x1,y1) and (x2,y1) inside circle.\n    ar += circle_segment(rad, acos(x1/rad) - acos(x2/rad)) +\n          (x2-x1) * (sqrt(rad*rad - x1*x1)-y1 +\n                     sqrt(rad*rad - x2*x2)-y1) / 2;\n  } else if (x2*x2 + y1*y1 &gt;= rad*rad) {\n    // (x1,y1) and (x1,y2) inside circle.\n    ar += circle_segment(rad, asin(y2/rad) - asin(y1/rad)) +\n          (y2-y1) * (sqrt(rad*rad - y1*y1)-x1 +\n                     sqrt(rad*rad - y2*y2)-x1) / 2;\n  } else {\n    // All except (x2,y2) inside circle.\n    ar += circle_segment(rad, asin(y2/rad) - acos(x2/rad)) +\n          (x2-x1)*(y2-y1) -\n          (y2-sqrt(rad*rad - x2*x2)) *\n          (x2-sqrt(rad*rad - y2*y2)) / 2;\n  }\n}\nprintf(\"Case #%d: %.6lf\\n\", prob++, 1.0 - ar / (PI*R*R/4));\n\n\n</pre>\n\n<p>\n  This solution takes O(<b>S</b><sup>2</sup>) time, where <b>S</b> is the\n  number of vertical strings of the racquet. It's not hard to come up with an\n  O(<b>S</b>) solution because there are at most 4<b>S</b> border squares which\n  can be found efficiently, but the previous solution was fast enough.\n</p><p>\n  Instead of solving the problem exactly, an iterative solution which\n  approximates the area to the needed precision would have also worked. One\n  such solution uses divide and conquer by splitting the square into four\n  smaller squares and then checking the simple cases where the squares are\n  totally inside or totally outside the square.  In the cases where the circle\n  and square intersect just recurse if the current square is larger than some\n  chosen precision.  An observation is that we can divide every length by the\n  radius of the racquet because it gets canceled in the division between the\n  area of the gaps in the racquet and the disc area.  This observation helps\n  the iterative solution since we can make the number of iterations smaller.\n  Here's some sample code:\n</p>\n<pre>\ndouble intersection(double x1, double y1,\n                    double x2, double y2) {\n  // the normalized radius is 1\n  if (x1*x1 + y1*y1 &gt; 1) {\n    return 0;\n  }\n  if (x2*x2 + y2*y2 &lt; 1) {\n    return (x2-x1) * (y2-y1);\n  }\n  // EPS2 = 1e-6 * 1e-6\n  if ((x2-x1)*(y2-y1) &lt; EPS2) {\n    // this trick helps in doing 10 or 100 times less\n    // iterations than we would need to get the same\n    // precision if we just return 0;\n    return (x2-x1) * (y2-y1) / 2;\n  }\n \n  double mx = (x1 + x2) / 2;\n  double my = (y1 + y2) / 2;\n \n  return intersection(x1, y1, mx, my) +\n    intersection(mx, y1, x2, my) +\n    intersection(x1, my, mx, y2) +\n    intersection(mx, my, x2, y2);\n}\n\n\n</pre>\n","id":"0000000000432f32","statement":"<h3>Problem</h3>\n<p>\n  What are your chances of hitting a fly with a tennis racquet?\n</p><p>\n  To start with, ignore the racquet's handle. Assume the racquet is a perfect\n  ring, of outer radius <b>R</b> and thickness <b>t</b> (so the inner radius of\n  the ring is <b>R</b>&minus;<b>t</b>).\n</p><p>\n  The ring is covered with horizontal and vertical strings. Each string is a\n  cylinder of radius <b>r</b>. Each string is a chord of the ring (a straight\n  line connecting two points of the circle). There is a gap of length <b>g</b>\n  between neighbouring strings. The strings are symmetric with respect to the\n  center of the racquet i.e. there is a pair of strings whose centers meet at\n  the center of the ring.\n</p><p>\n  The fly is a sphere of radius <b>f</b>. Assume that the racquet is moving in\n  a straight line perpendicular to the plane of the ring. Assume also that the\n  fly's center is inside the outer radius of the racquet and is equally likely\n  to be anywhere within that radius. Any overlap between the fly and the\n  racquet (the ring or a string) counts as a hit.\n</p><p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3anzW7i_gc5ww1cj9Bf7oCBismLKGYn1RjDQ-MPDbtiuAQVDbP-qj1w0REWazwFq2TjrQ/test2.png\" />\n</p>\n\n<h3>Input</h3>\n<p>\n  One line containing an integer <b>N</b>, the number of test cases in the\n  input file.\n</p><p>\n  The next <b>N</b> lines will each contain the numbers <b>f</b>, <b>R</b>,\n  <b>t</b>, <b>r</b> and <b>g</b> separated by exactly one space. Also the\n  numbers will have exactly 6 digits after the decimal point.\n</p>\n\n<h3>Output</h3>\n<p>\n  <b>N</b> lines, each of the form \"Case #<b>k</b>: <b>P</b>\", where <b>k</b>\n  is the number of the test case and <b>P</b> is the probability of hitting the\n  fly with a piece of the racquet.\n</p><p>\n  Answers with a relative or absolute error of at most 10<sup>-6</sup> will be\n  considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 60 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  <b>f</b>, <b>R</b>, <b>t</b>, <b>r</b> and <b>g</b> will be positive and smaller or equal to 10000.<br>\n  <b>t</b> &lt; <b>R</b><br>\n  <b>f</b> &lt; <b>R</b><br>\n  <b>r</b> &lt; <b>R</b><br>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 30<br>\n  The total number of strings will be at most 60 (so at most 30 in each direction).\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 100<br>\n  The total number of strings will be at most 2000 (so at most 1000 in each direction).\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n0.250000 1.000000 0.100000 0.010000 0.500000\n0.250000 1.000000 0.100000 0.010000 0.900000\n0.000010 10000.000000 0.000010 0.000010 1000.000000\n0.400000 10000.000000 0.000010 0.000010 700.000000\n1.000000 100.000000 1.000000 1.000000 10.000000\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.000000\nCase #2: 0.910015\nCase #3: 0.000000\nCase #4: 0.002371\nCase #5: 0.573972\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Fly Swatter","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This problem can be solved with a greedy strategy. The simplest way to do\n  this is by scanning through a list of all the trips, sorted by departure\n  time, and keeping track of the set of trains that will be available at each\n  station, and when they will be ready to take a trip.\n</p><p>\n  When we examine a trip, we see if there will be a train ready at the\n  departure station by the departure time.  If there is, then we remove that\n  train from the list of available trains.  If there is not, then our solution\n  will need one new train added for the departure station.  Then we compute\n  when the train taking this trip will be ready at the other station for\n  another trip, and add this train to the set of available trains at the other\n  station.  If a train leaves station A at 12:00 and arrives at station B at\n  13:00, with a 5-minute turnaround time, it will be available for a return\n  journey from B to A at 13:05.\n</p><p>\n  We need to be able to efficiently identify the earliest a train can leave\n  from a station; and update this set of available trains by adding new trains\n  or removing the earliest train.  This can be done using a heap data structure\n  for each station.\n</p><p>\n  Sample Python code provided below that solves a test case for this problem:\n</p>\n<pre>\ndef SolveCase(case_index, case):\n  T, (tripsa, tripsb) = case\n  trips = []\n  for trip in tripsa:\n    trips.append([trip[0], trip[1], 0])\n  for trip in tripsb:\n    trips.append([trip[0], trip[1], 1])\n\n  trips.sort()\n\n  start = [0, 0]\n  trains = [[], []]\n\n  for trip in trips:\n    d = trip[2]\n    if trains[d] and trains[d][0] &lt;= trip[0]:\n      # We're using the earliest train available, and\n      # we have to delete it from this station's trains.\n      heappop(trains[d])\n    else:\n      # No train was available for the current trip,\n      # so we're adding one.\n      start[d] += 1\n    # We add an available train in the arriving station at the\n    # time of arrival plus the turnaround time.\n    heappush(trains[1 - d], trip[1] + T)\n\n  print \"Case #%d: %d %d\" % (case_index, start[0], start[1])\n</pre>\n<p>\n  Luckily Python has methods that implement the heap data structure operations.\n  This solution takes O(n log n) time, where n is the total number of trips,\n  because at each trip we do at most one insert or one delete operation from\n  the heaps, and heap operations take O(log n) time.\n</p>\n","id":"00000000004330f5","statement":"<h3>Problem</h3>\n<p>\n  A train line has two stations on it, A and B.  Trains can take trips from A\n  to B or from B to A multiple times during a day. When a train arrives at B\n  from A (or arrives at A from B), it needs a certain amount of time before it\n  is ready to take the return journey - this is the <i>turnaround time</i>.\n  For example, if a train arrives at 12:00 and the turnaround time is 0\n  minutes, it can leave immediately, at 12:00.\n</p><p>\n  A train timetable specifies departure and arrival time of all trips between A\n  and B. The train company needs to know how many trains have to start the day\n  at A and B in order to make the timetable work: whenever a train is supposed\n  to leave A or B, there must actually be one there ready to go.  There are\n  passing sections on the track, so trains don't necessarily arrive in the same\n  order that they leave.  Trains may not travel on trips that do not appear on\n  the schedule.\n</p>\n\n<h3>Input</h3>\n</p>\n  The first line of input gives the number of cases, <b>N</b>. <b>N</b> test\n  cases follow.\n</p><p>\n  Each case contains a number of lines.  The first line is the turnaround time,\n  <b>T</b>, in minutes. The next line has two numbers on it, <b>NA</b> and\n  <b>NB</b>.  <b>NA</b> is the number of trips from A to B, and <b>NB</b> is\n  the number of trips from B to A.  Then there are <b>NA</b> lines giving the\n  details of the trips from A to B.\n</p><p>\n  Each line contains two fields, giving the HH:MM departure and arrival time\n  for that trip. The departure time for each trip will be earlier than the\n  arrival time. All arrivals and departures occur on the same day. The trips\n  may appear in any order - they are not necessarily sorted by time.  The hour\n  and minute values are both two digits, zero-padded, and are on a 24-hour\n  clock (00:00 through 23:59).\n</p><p>\n  After these <b>NA</b> lines, there are <b>NB</b> lines giving the departure\n  and arrival times for the trips from B to A.\n</p>\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>x</b>: \" followed by\n  the number of trains that must start at A and the number of trains that must\n  start at B.\n</p>\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 20<br>\n  0 &le; <b>NA</b>, <b>NB</b> &le; 20<br>\n  0 &le; <b>T</b> &le; 5\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 100<br>\n  0 &le; <b>NA</b>, <b>NB</b> &le; 100<br>\n  0 &le; <b>T</b> &le; 60\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n3 2\n09:00 12:00\n10:00 13:00\n11:00 12:30\n12:02 15:00\n09:00 10:30\n2\n2 0\n09:00 09:01\n12:00 12:02\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2 2\nCase #2: 2 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Train Timetable","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432b79","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
