{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1275755400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432b7f","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p> Round 2 of the 2010 Google Code Jam was quite challenging - a big step up from some of the Round 1 problems!\n</p>\n<p>\nProblem A was not too hard conceptually, but the unusual diamond shape required our contestants to design their own way of implementation, and this proved to be difficult. Problem B was a dynamic programming puzzle about the upcoming FIFA world cup that required viewing it in the right way to make progress... Fortunately, our contestants were very good at this! Problem C is a wonderful mathematical puzzle with a simple depth first search solution. Our last problem has deep roots in computational geometry, and it required tremendous implementation skill to get everything right during a timed contest. A big congratulations is due to <b>halyavin</b> and <b>bsod</b> for their correct solutions!\n</p>\n<p>\nThe top three contestants were <b>bmerry</b>, <b>ZhukovDmitry</b>, and <b>winger</b>, who all solved 3 and a half problems in around 2 hours. Congratulations to them, as well to all of the 500 advancers to Round 3. There is only one more round to go until the on-site finals in Dublin!\n</p>\n\n<h3>Cast</h3>\n<p>Problem A. <i>Elegant Diamond</i> Written and prepared by Bartholomew Furrow and Igor Naverniouk.</p>\n<p>Problem B. <i>World Cup 2010</i> Written by Xiaomin Chen. Prepared by Ante Derek.</p>\n<p>Problem C. <i>Bacteria</i> Written by Cosmin Negruseri. Prepared by Cosmin Negruseri and John Dethridge.</p>\n<p>Problem D. <i>Grazing Google Goats</i> Written by Cosmin Negruseri. Prepared by John Dethridge and David Arthur.</p>\n<p>Contest analysis presented by David Arthur, Xiaomin Chen, Petr Mitrichev, and Cosmin Negruseri</p>\n<p>Solutions and other problem preparation provided by Derek Kisman and Petr Mitrichev.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1275746400000,"tasks":[{"analysis":"<p>\nThe fact that the input is a set of rectangles is not essential to this problem. We just wanted to limit the amount of data you had to download to test your program. So let us forget about the rectangles, and instead consider any initial configuration of <code>n</code> bacteria on the grid. The challenge here is to compute the answer <i>fast</i>. A turn by turn simulation will not be good enough. We are going to aim for an <code>O(n)</code> solution instead.\n</p>\n\n<h3>Examples</h3>\n<p>\nOne way to start attacking this problem is to look at examples. The Bacteria game is pretty fun to play around with after all! Here are some examples you can try:\n<ul>\n<li>A rectangle of <code>H</code> by <code>W</code> bacteria.</li>\n<li>A <code>H</code> by <code>W</code> rectangle where the bacteria only lie on the four boundary edges.</li>\n<li>Bacteria along a \"type 1\" diagonal (a southwest/northeast diagonal).</li>\n<li>Bacteria along a \"type 2\" diagonal (a northwest/southeast diagonal).</li>\n<li>A random path where each pair of bacteria are connected either horizontally, vertically, or along a type 1 diagonal.</li>\n</ul>\nIf you work out these examples, you should get some inspiration for the general problem. We call a type 1 diagonal higher than another if it is to the north (and hence west) of the other. If the initial configuration is a \"connected piece\" (we will define this more precisely later), we can find the highest type 1 diagonal containing at least one bacterium <code>X + Y = C</code>, the right-most point containing a bacterium <code>X = X<sub>max</sub></code>, and the bottom-most point containing a bacterium <code>Y = Y<sub>max</sub></code>. We claim that after one turn, the configuration will still be a single connected piece, the highest diagonal will become <code>X + Y = C+1</code>, and the max <code>X</code> and <code>Y</code> coordinates will not change. This will continue until the final second when we come down to a single point <code>(X<sub>max</sub>, Y<sub>max</sub>)</code>. So the number of turns before everything disappears is <code>X<sub>max</sub> + Y<sub>max</sub> - C + 1</code>.\n</p>\n<p>\nOne thing we note is that the 3rd and 4th examples behave very differently. In the 3rd example, the number of bacteria decreases by 1 in each turn, while in the 4th, all the bacteria disappear immediately.\n</p>\n<h3>Solution</h3>\n\n<p>\nDefine a graph on the bacteria. Two bacteria are neighbors if they are adjacent on the grid via a horizontal line, a vertical line, or a type 1 diagonal. We begin by finding the connected components of this graph. \n</p>\n<p>\nThis may seem like a simple definition, but it is really the key to solving the whole problem. It is quite similar to the more common graph where each grid node has 8 neighbors, one in each compass direction, except we do not consider the 2 directions along a type 2 diagonal. Remember the 3rd and 4th examples above? If we start with <code>n</code> nodes, there is just one connected component in the former, but <code>n</code> connected components in the latter.\n</p>\n<p>\nWe observe that after each turn, a connected component will give birth to a new connected component (unless it was a single point and disappears), and different components will not become connected together. See the details in the next section.\n</p>\n<p>\nSo, the answer is the maximum elimination time over all the components. For a single piece (i.e., connected component), we find the highest type 1 diagonal <code>X + Y = C</code>, as well as the maximum coordinates <code>X<sub>max</sub></code> and <code>Y<sub>max</sub></code>. The number of turns for that piece to disappear is then <code>X<sub>max</sub> + Y<sub>max</sub> - C + 1</code>.\n</p>\n\n<h3>Justification</h3>\n<p>\nOur solution depends very heavily on several key observations. If you try some examples, you should be able to convince yourself empirically that these observations just have to be true. But in the interest of completeness, we will also sketch out a more formal proof here.\n</p>\n<p>\nIn the following discussion, we will fix a configuration called the <i>old state</i>, and we will consider the <i>new state</i> obtained after one turn. When we talk about a connected piece, we will always assume the non-trivial case where there are at least 2 points in the piece.\n</p>\n<p>\nFor each bacterium in the new state, let us consider the reason why it is there. If it was in the old state, we credit the reason for its existence to the set of itself and its north and/or west neighbor. If it was not in the old state, we credit the reason for its existence only to the set of its north and west neighbors. In both cases, we call such a set the credit set for that single bacterium.\n</p>\n<p>\n<b>Proposition 1.</b> If the old state is a single piece, and the highest type 1 diagonal is <code>X + Y = C</code>, then in the new state, the highest type 1 diagonal will become <code>X + Y = C+1</code>.\n</p>\n<p>\n<i>Proof.</i> Consider a bacterium at position <code>(X, Y)</code> on the top diagonal of the old state. Since this is the top diagonal, that bacterium does not have a north neighbor or a west neighbor, and it will die. In particular, the diagonal <code>X + Y = C</code> will be completely empty in the new state.<br/>\nNow pick the south-most bacterium in the old state on the diagonal <code>X + Y = C</code>. Let its position be <code>(X, C-X)</code>. If there is also a bacterium at position <code>(X+1, C-X-1)</code> in the old state, there will be a bacterium at <code>(X+1, C-X)</code> in the new state (no matter whether it was in the old state or not). Otherwise, since <code>(X, C-X)</code> is part of a connected piece and it's on the highest diagonal, there will be a bacterium at either <code>(X, C-X+1)</code> or <code>(X+1, C-X)</code> in the old state, and by our rules, this bacterium will survive to the new state. Hence, in any case, we find at least one bacterium will be on the diagonal <code>X + Y = C+1</code> in the new state, which proves the proposition.\n</p>\n<p>\nThe following two Propositions can be justified in the same way:\n</p>\n<p>\n<b>Proposition 2.</b> If the old state is a single piece, the maximum <code>X</code> coordinate and the maximum <code>Y</code> coordinate will be unchanged in the new state.\n</p>\n<b>Proposition 3.</b> If the old state is a single connected piece, the new state will be a single connected piece as well.\n</p>\n<p>\nTo see Proposition 3, note that if the old state is connected, then any two credit sets can be joined by some path consisting of horizontal, vertical, and type 1 diagonal segments. As the following picture shows, any possible segment from such a path will give birth to connected segments in the new state:\n<br/><br/>\n&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U33wJutLrEK8GXH-dEq1Dm3MkbnXres5VwHO2SZ8jRKgq3eDKkQXeRzSU4a2nmpGspTW9uTmQ4/bac_sol1.png\">\n<br/><br/><br/>\n</p>\n<p>\nFinally, we are going to prove that different pieces will not be merged together in a turn.\n<p>\n<b>Proposition 4.</b> If two bacteria are neighbors in the new state, then their credit set are all from the same piece in the old state.\n</p>\n<p>\nThis is obviously true if both bacteria are also in the old state. Otherwise, it is one of the cases in the following picture. The two bacteria are the circled points. A blue point indicates that the bacterium was also in the old state, a red point indicates that the bacterium was only in the new state. Then the yellow stars represents the points in the credit sets. In any situation we either reach an impossible configuration, or get to a point where it is clear the credit sets are connected.\n<br/><br/>\n&nbsp;&nbsp;&nbsp;&nbsp;<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3lr3uyKjJczx-32oohRc2DC4_1tdMAd0TciRFx3V3tyI7KbSxvvJ8_idxkLH2XHZpgTlcw7Mc/bac_sol2.png\">\n<br/><br/><br/>\n</p>\n","id":"0000000000432f39","statement":"<h3>Problem</h3>\n<p>\nA number of bacteria lie on an infinite grid of cells, each bacterium in its own cell.\n<p>\nEach second, the following transformations occur (all simultaneously):\n<br/>\n<ol>\n<li> If a bacterium has no neighbor to its north and no neighbor to its west, then it will die.\n<li> If a cell has no bacterium in it, but there are bacteria in the neighboring cells to the north and to the west, then a new bacterium will be born in that cell.\n</ol>\n<p>\nUpon examining the grid, you note that there are a positive, finite number of bacteria in one or more rectangular regions of cells.\n<p>\nDetermine how many seconds will pass before all the bacteria die.\n<p>\nHere is an example of a grid that starts with 6 cells containing bacteria, and takes 6 seconds for all the bacteria to die.  '1's represent cells with bacteria, and '0's represent cells without bacteria.\n<p>\n<pre>\n000010\n011100\n010000\n010000\n000000\n\n000000\n001110\n011000\n010000\n000000\n\n000000\n000110\n001100\n011000\n000000\n\n000000\n000010\n000110\n001100\n000000\n\n000000\n000000\n000010\n000110\n000000\n\n000000\n000000\n000000\n000010\n000000\n\n000000\n000000\n000000\n000000\n000000\n</pre>\n</p>\n\n<h3>Input</h3>\n<p>\nThe input consists of:\n<ul>\n<li> One line containing <b>C</b>, the number of test cases.\n</ul>\nThen for each test case:\n<ul>\n<li> One line containing <b>R</b>, the number of rectangles of cells that initially contain bacteria.\n<li> <b>R</b> lines containing four space-separated integers <b>X</b><sub>1</sub> <b>Y</b><sub>1</sub> <b>X</b><sub>2</sub> <b>Y</b><sub>2</sub>.  This indicates that all the cells with X coordinate between X<sub>1</sub> and X<sub>2</sub>, inclusive, and Y coordinate between Y<sub>1</sub> and Y<sub>2</sub>, inclusive, contain bacteria.\n</ul>\nThe rectangles may overlap.\n<p>\nNorth is in the direction of decreasing Y coordinate.\n<br/>\nWest is in the direction of decreasing X coordinate.\n<br/>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #N: T\", where N is the case number (starting from 1), and T is the number of seconds until the bacteria all die.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>C</b> &le; 100.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>R</b> &le; 10 <br/>\n1 &le; <b>X<sub>1</sub></b> &le; <b>X<sub>2</sub></b> &le; 100 <br/>\n1 &le; <b>Y<sub>1</sub></b> &le; <b>Y<sub>2</sub></b> &le; 100 <br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>R</b> &le; 1000 <br/>\n1 &le; <b>X<sub>1</sub></b> &le; <b>X<sub>2</sub></b> &le; 1000000 <br/>\n1 &le; <b>Y<sub>1</sub></b> &le; <b>Y<sub>2</sub></b> &le; 1000000 <br/>\n<br/>\nThe number of cells initially containing bacteria will be at most 1000000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n3\n5 1 5 1\n2 2 4 2\n2 3 2 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Bacteria","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Reformulation</h3>\n<p>\nIn the analysis, we will turn the picture upside-down. This conforms to the usual convention that the root of a binary tree is drawn on top. This is actually easy to do implementation-wise. We just read the input numbers in reverse order; the element at position 0 is the root, i.e., the final match, and for any node <code>i</code>, its two children are indexed at <code>2i+1</code> and <code>2i+2</code>. In our particular solution, we include nodes for the teams as well as for the matches, so our graph is a rooted complete binary tree, where all the internal nodes are matches, and all the leaves are the teams.\n</p>\n<p>\nPerhaps it is clear that the solution will be dynamic programming on the tree. There are many ways to do it, but some can be much more complicated than others. Let us introduce one solution that is very simple. It is based on the following reformulation of our problem.\n</p>\n<p>\nLet us color a node yellow if we are going to buy the ticket for the corresponding match. For each leaf (a team), the path to it from the root has <code>P</code> internal nodes. We call a plan good if no matter what the outcomes of the matches are, we will never miss more than <code>M[i]</code> matches for team <code>i</code>. We have\n<blockquote>\n(*) A plan is good if and only if for every team <code>i</code>, the path from the root to the leaf corresponding to team i has at least <code>P-M[i]</code> yellow nodes.\n</blockquote>\nThis is indeed a conceptual leap in solving the problem. For in the new form, we no longer need to worry about the outcome of any particular match. And once it is stated, it is very easy to justify. We leave the justification to the readers.\n</p>\n<p>\nSimple solutions for small inputs and large inputs both follow easily from this reformulation.\n</p>\n\n<h3>Small dataset</h3>\n<p>\nFor the small dataset the best plan must be <i>upwards closed</i>, i.e., if a node is yellow, all the nodes on the path from the root to it must all be yellow. One can prove this by using (*) and noting that all the prices are the same, and you can always get a cheaper plan if you push some yellow node upwards.\nSo, one solution for the small dataset looks like this: For each team <code>i</code>, we find the path from root to it, and color the topmost <code>P-M[i]</code> nodes yellow. It can be done in linear time by a simple modification of depth first search.\n</p>\n<p>\nThe justification and the implementation details are a nice piece of dessert. We leave them to the readers.\n</p>\n\n\n<h3>Large dataset</h3>\n<p>\nWe use dynamic programming on the tree. Let us just define the subproblems clearly. For any node <code>a</code> and any number <code>b</code> between 0 and <code>P</code>, let <code>P(a, b)</code> be the problem\n<blockquote>\nIf there are <code>b</code> yellow nodes on the path from the root to <code>a</code> (not including <code>a</code>), what is the cheapest way to color the nodes in the sub-tree rooted at a, such that all the leaves in this sub-tree satisfy the condition in (*)?\n</blockquote>\nAnd we can use a impossibly big answer to indicate that the condition can not be satisfied.\n</p>\n<p>\nOnce the DP is set up, the code follows easily. For each internal node there are just two choices, color it yellow or not. We provide an excerpt from one of the judges' solutions:\n<pre>\ni64 A[1&lt;&lt;11][11];  // answers for the dynamic programming.\ni64 inp[1&lt;&lt;11];    // input, in reversed order.\nint P;\n\n// rooted at a, already buy b tickets from above.\ni64 dp(int a, int b) {\n  i64&amp; r=A[a][b];\n  if(r&gt;=0) return r;\n  if(a&gt;=((1&lt;&lt;P)-1)) {r=(b&gt;=(P-inp[a]))?0:1LL&lt;&lt;40; return r;}\n  r=std::min(\n      inp[a]+dp(2*a+1,b+1)+dp(2*a+2,b+1), \n      dp(2*a+1,b)+dp(2*a+2,b));\n  return r;\n}\n\nint main() {\n  int T;\n  cin&gt;&gt;T;\n  for (int cs=1; cs&lt;=T; ++cs) {\n    cin&gt;&gt;P; int M=(2&lt;&lt;P)-1;\n    for (int i=0; i&lt;M; i++) cin&gt;&gt;inp[M-1-i];\n    memset(A, -1, sizeof(A));\n    cout &lt;&lt; \"Case #\" &lt;&lt; cs &lt;&lt; \": \" &lt;&lt; dp(0, 0) &lt;&lt;endl;\n  }\n  return 0;\n}\n</pre>\n</p>\n\n","id":"00000000004330fe","statement":"<h3>Problem</h3>\n<p>\nAfter four years, it is the World Cup time again and Varva is on his way to South Africa, just in time to catch the second stage of the tournament.\n</p>\n<p>\nIn the second stage (also called the knockout stage), each match always has a winner; the winning team proceeds to the next round while the losing team is eliminated from the tournament. There are 2<sup>P</sup> teams competing in this stage, identified with integers from 0 to 2<sup>P</sup> - 1. The knockout stage consists of P rounds. In each round, each remaining team plays exactly one match. The exact pairs and the order of matches are determined by successively choosing two remaining teams with lowest identifiers and pairing them in a match. After all matches in one round are finished, the next round starts.\n</p>\n<p>\n<br/><br/>\n&nbsp;&nbsp;&nbsp;<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0IMe0Jx2RsOdYLyYL_HdJfpbGdzgHc5qXzQbREghR8XaFGUjwLdYYmLhYoqlS23u-hSjwN/wc2010.png\">\n<br/><br/>\n</p>\n<p>\nIn order to help him decide which matches to see, Varva has compiled a list of constraints based on how much he likes a particular team. Specifically, for each team <code>i</code> he is  <b>willing to miss at most</b> <code>M[i]</code> matches the team plays in the tournament.\n</p>\n<p>\nVarva needs to buy a set of tickets that will guarantee that his preferences are satisfied, regardless of how the matches turn out. Other than that, he just wants to spend as little money as possible. Your goal is to find the <b>minimal amount of money</b> he needs to spend on the tickets.\n</p>\n<p>\nTickets for the matches need to be purchased in advance (before the tournament starts) and the ticket price for each match is known. Note that, in the small input, ticket prices for all matches will be equal, while in the large input, they may be different. \n</p>\n<h3>Example</h3>\n<p>\nA sample tournament schedule along with the ticket prices is given in the figure above. Suppose that the constraints are given by the array <code>M = {1, 2, 3, 2, 1, 0, 1, 3}</code>, the optimal strategy is as follows: Since we can't miss any games of team 5, we'll need to spend  50, 400, and 800 to buy tickets to all the matches team 5 may play in. Now, the constrains for the other teams are also satisfied by these tickets, except for team 0. The best option to fix this is to buy the ticket for team 0's first round match, spending another 100, bringing the total to 1350.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each case starts with a line containing a single integer <b>P</b>. The next line contains 2<sup>P</sup> integers -- the constraints <code>M[0]</code>, ..., <code>M[2<sup>P</sup>-1]</code>.\n<p>\n</p>\nThe following block of <b>P</b> lines contains the ticket prices for all matches: the first line of the block contains 2<sup>P-1</sup> integers -- ticket prices  for first round matches, the second line of the block contains 2<sup>P-2</sup> integers -- ticket prices for second round matches, etc. The last of the <b>P</b> lines contains a single integer -- ticket price for the final match of the World Cup. The prices are listed in the order the matches are played.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the minimal amount of money Varva needs to spend on tickets as described above.\n</p>\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 50<br/>\n1 &le; <b>P</b> &le; 10<br/>\nEach element of <b>M</b> is an integer between 0 and <b>P</b>, inclusive.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nAll the prices are equal to 1.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nAll the prices are integers between 0 and 100000, inclusive.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2\n1 1 0 1\n1 1\n1\n3\n1 2 3 2 1 0 1 3\n100 150 50 90\n500 400\n800\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 1350\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"World Cup 2010","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem is tough from both the implementation side and the algorithm side.    In the analysis, we will begin by explaining some general concepts that show how the task is actually very similar to convex hull. We will then go into the particulars needed to build a solution and to prove that it is right. The resulting code isn't as scary as the length of the analysis makes you think.\n</p>\n<p>\nLet us just focus on one bucket <b>Q</b> at a time. The problem asks us to choose rope lengths: i.e., for each pole position, we need to choose the radius of the circle centered at that pole. The common area will be the intersection of all these circles. It is clear that decreasing the radius of any circle will not increase the intersection. Therefore, we want the lengths to be as small as possible. Obviously, for each pole <b>P</b><sub>i</sub>, <b>P</b><sub>i</sub><b>Q</b> is the smallest length we can pick so that the goat can still reach the bucket. Our main task is to efficiently compute the common intersection area of these circles.\n</p>\n<p>\nFrom the limits of this problem, it is also clear that computing the intersection in &Omega;(<b>N</b><sup>2</sup>) will be too slow. We are aiming for an algorithm that will, for each bucket, compute the intersection in time O(<b>N</b> log <b>N</b>).\n</p>\n<p>\nThe intersection is a convex shape where the boundary consists of arcs of the circles. One can prove in various ways (some of the reason will be obvious below) that each circle will only contribute at most one such arc. We will mostly focus on how to compute these arcs -- to which circle does it belong, where does it stop and where does it start. Once all this is computed, it is relatively easy to get the area.\n</p>\n\n<h3>Some theoretical background</h3>\n<p>\nWhile this section is not absolutely necessary for solving the problem, it will provide some nice insights. Once we have seen the problem from a few different angles, the solution will be conceptually clear and very natural.\n</p>\n<p>\nSo, first of all, note that all the circles we consider pass through a common point <b>Q</b>. If you have not seen it before, it is now our honor to introduce to you the beautiful geometric transformation called <i>inversion</i>. It takes <b>Q</b> as the center. And each point <b>X</b> &ne; <b>Q</b> is mapped to a point <b>X'</b> where <b>QX</b> and <b>QX'</b> are in the same direction, and the lengths satisfy <b>|QX|</b> <b>|QX'|</b> = 1.\n</p>\n<p>\nHere is one very nice property of inversion: Every circle passing through the center point <b>Q</b> is mapped to a line that does not pass <b>Q</b>, and vice versa. And the interior of the circle is mapped to a half-plane that does not include <b>Q</b>. For our problem, the intersection of the <b>N</b> circles is then mapped to the intersection of <b>N</b> half-planes. For more details on inversion, we refer you to the <a href=\"http://en.wikipedia.org/wiki/Inversive_geometry\" target=\"_blank\">Wikipedia page on inversive geometry</a>.\n</p>\n<p>\nWe leave it to the reader to verify that, if the intersection is not empty, then we can rotate the plane such that <b>Q</b> is above all the half-planes. And the intersection of the half-planes is bounded by something called the <i>lower envelope of line arrangements</i>. The segments of the lower envelope are exactly the images of the arcs in the circle intersection from our original problem.\n</p>\n<p>\nThen there is a concept of <i>duality</i> in computational geometry that maps each line <code>y = ax + b</code> to the point <code>(a, -b)</code>. The lower envelope is mapped by this transformation to the upper convex hull of the set of corresponding points.\n</p>\n<p>\nSo, our problem is indeed equivalent to the convex hull problem and the lower envelope of line arrangements problem. Both subjects are well studied and there are simple O(<b>N</b> log <b>N</b>) algorithms for both.\n</p>\n<p>\nOut of these three settings, perhaps the algorithm for line arrangement is the simplest to visualize: Sort the lines by their slopes, and add them one by one. In each step, the existing lower envelope will be cut by the new line in two parts. The time for sorting is O(<b>N</b> log <b>N</b>), and the amortized complexity for the rest is O(<b>N</b>).\n</p>\n\n<h3>Solution to our problem</h3>\n<p>\nThe previous section suggests a couple approaches that begin with explicitly doing an inversion about <b>Q</b>. In this section, we will discuss a direct solution to the problem, where we do not need to view the problem using the transformations from the previous section. Note that it will be in some ways equivalent to the above algorithm we introduced for line arrangements.\n</p>\n<p>\nLet's look from <b>Q</b> along a straight ray. The intersection of this ray with each circle will be either just <b>Q</b>, or a segment between <b>Q</b> and the second intersection point of this ray with the boundary of the circle. That means that in order to build the area required in the problem statement, we need to find the circle \"closest\" to <b>Q</b> in each direction from it. Let's denote each direction by its polar angle, which is defined up to a multiple of 2&pi;.\n</p>\n<p>\nWe start by considering just one circle. Suppose the polar angle of a ray that goes from <b>Q</b> towards the center of that circle is &phi;. When the polar angle of a ray goes from &phi;-&pi;/2 towards &phi;, the distance from <b>Q</b> to the second intersection point with that ray increases from 0 to \nthe diameter of the circle. When the polar angle continues from &phi; towards &phi;+&pi;/2, the distance decreases back to 0. When the polar angle changes from &phi;+&pi;/2 to &phi;+3&pi;/2 (the latter is the same as &phi;-&pi;/2, where we started), the intersection of the ray with the circle is just <b>Q</b>.\n</p>\n<p>\nNow consider two circles, one with center at polar angle &phi; (remember, all polar angles discussed here are relative to <b>Q</b>) , another one with center at polar angle &xi;, and suppose 0 &lt; &phi; - &xi; &lt; &pi;. Then we'll see the following as we turn the ray originating from <b>Q</b>: starting from polar angle &xi;-&pi;/2 until &phi;-&pi;/2 the ray will intersect only the second circle; from &phi;-&pi;/2 the ray will intersect both circles, but the intersection point with the first circle will be closer to <b>Q</b> until the circles intersect; after the intersection and until &xi;+&pi;/2 the ray will still intersect both circles but the second is now closer; and from &xi;+&pi;/2 until &phi;+&pi;/2 the ray will only intersect the first circle.\n</p>\n<p>\nThe important thing about the two circles case discussed above is that in the range of polar angles where the ray intersects both circles (and that's exactly the range we care about in finding the intersection area). The situation is very simple: before the intersection point one circle is closer to <b>Q</b>, after the intersection point another circle is closer to <b>Q</b>.\n</p>\n<p>\nNow suppose we have many circles. First, we find the polar angle of the center of each circle, and thus also find the range of polar angles where a ray going from <b>Q</b> intersects each of the circles. We can then intersect all those ranges of polar angles to obtain a small range [&alpha;, &beta;] of polar angles where the ray would intersect all circles. If this range is empty, then we already know there's no intersection.\n</p>\n<p>\nNow let's start adding circles one by one, starting from the one with the smallest polar angle. You might ask, what does \"smallest\" mean when we're on a circle? Luckily, here we have less than full circle: since all circles intersect all rays in [&alpha;, &beta;] range, the polar angles of all centers are between &beta;-&pi;/2 and &alpha;+&pi;/2. That leaves us a segment of length less than &pi; where we have a definite order.\n</p>\n<p>\nAs we're adding the circles, we'll maintain which circle is closest for each angle from [&alpha;, &beta;]. For example, after adding the first circle it will be the closest for the entire [&alpha;, &beta;] range. Now we add the second circle. Let's say the polar angle of the intersection point between two circles is &gamma;. If you look carefully at the above analysis, you'll find that:</p><ul>\n<li>When &gamma; is less than &alpha;, the first circle is still the closest for the entire [&alpha;, &beta;] .\n<li>When &gamma; is between &alpha; and &beta;, the second circle is the closest for [&alpha;, &gamma;], and the first circle is the closest for [&gamma;, &beta;].\n<li>When &gamma; is more than &beta;, the second circle is now closest for the entire [&alpha;, &beta;] .\n</ul>\n<p>\nHere we rely on the fact that we process circles in increasing order of the polar angle of their center.\n</p>\n<p>\nNow look at the general case. Suppose before adding circle number <code>i</code> we have the following picture: on [&alpha;, &gamma;<sub>1</sub>] circle <code>j<sub>1</sub></code> is the closest; on [&gamma;<sub>1</sub>, &gamma;<sub>2</sub>] circle <code>j<sub>2</sub></code> is the closest; ...; on [&gamma;<sub>k-1</sub>, &beta;] circle <code>j<sub>k</sub></code> is the closest.\n</p>\n<p>\nConsider the polar angle &delta; of the intersection point between circle <code>i</code> and circle <code>j<sub>1</sub></code>. There are 3 ways it could compare with the range where <code>j<sub>1</sub></code> is the closest:\n</p>\n<ul>\n<li>When &delta; is less than &alpha;, it means that circle <code>j<sub>1</sub></code> is closer than circle <code>i</code> on the entire [&alpha; &beta;] segment, and we can just stop processing circle <code>i</code> since it doesn't affect the answer.\n<li>When &delta; is between &alpha; and &gamma;<sub>1</sub>, we now have that circle <code>i</code> is the closest on [&alpha;, &delta;], and circle <code>j<sub>1</sub></code> is the closest on [&delta;, &gamma;<sub>1</sub>]. After doing this change, we can also stop processing circle <code>i</code> since circle <code>j<sub>1</sub></code> will be closer to the center all the remaining way.\n<li>Finally, when &delta; is more than &gamma;<sub>1</sub>, we can forget about circle <code>j<sub>1</sub></code> since circle <code>i</code> is closer than it on the entire [&alpha;, &gamma;<sub>1</sub>]  segment. In that case we continue processing circle <code>i</code> by comparing it with circle <code>j<sub>2</sub></code>, and so on.\n</ul>\n<p>\nThat's it! After we do this processing for all circles, we know the contour of the intersection figure, and we continue by computing its area.\n</p>\n<p>\nThe above algorithm requires a data structure that maintains a list of arcs with integer tags, allowing us to change the first arc, remove the first arc, and add a new first arc. The simplest way to get this data structure is to just use a stack where the first ac would be on the top, and the last one would be on the bottom.\n</p>\n<p>\nThe running time for the above algorithm can be estimated using amortized analysis as follows. When processing each circle, we do at most two \"push to stack\" operations, and one or more \"pop from stack\" operations. That means the total number of push operations is O(<b>N</b>), and since the number of pop operations can't be greater than the number of push operations (there'd be nothing to pop!), it's also O(<b>N</b>), giving us the total runtime of O(<b>N</b>). However, we must also remember the step where we sort all circles by the polar angle of their center, so overall runtime is O(<b>N</b> log <b>N</b>).\n</p>\n<p>\nWe've so far avoided discussing the low-level computational geometry needed for this problem. In the above solution we required two geometric routines: find the polar angle of the other intersection point of two circles which have the first intersection point at origin; and find the area of a figure that is bounded by arcs.\n</p>\n<p>\nThe first routine is straightforward if you can already intersect circles (a useful thing to know how to do!); alternatively, you could derive the formulas for the polar angle directly. The second one is slightly more tricky: first, we split the figure into \"rounded triangles\" with rays going from <b>Q</b> and having polar angles &gamma;<sub>1</sub>, &gamma;<sub>2</sub>, ..., &gamma;<sub>k-1</sub>. Each rounded triangle has two straight sides (one of those might have zero length) and one circular side. We can then split the rounded triangle into the corresponding triangle plus the round part (a sliced off part of a circle). You have probably seen how to compute the area of a triangle before - one good approach is the \"shoelace formula\". To calculate the rounded area, it helps to start with a \"pie slice\" from the center, whose area is a simple fraction of the total circle area, and then add or subtract triangle areas.\n</p>\n<p>\nOf course there is a lot to do here, but that's why we made it Problem #4!\n</p>","id":"0000000000433249","statement":"<h3>Problem</h3>\n\n<p>\nFarmer John has recently acquired a nice herd of <b>N</b> goats for his field. Each goat <code>i</code> will be tied to a pole at some position <b>P</b><sub>i</sub> using a rope of length <b>L</b><sub>i</sub>. This means that the goat will be able to travel anywhere in the field that is within distance <b>L</b><sub>i</sub> of the point <b>P</b><sub>i</sub>, but nowhere else. (The field is large and flat, so you can think of it as an infinite two-dimensional plane.)</p>\n\n<p>Farmer John already has the pole positions picked out from his last herd of goats, but he has to choose the rope lengths. There are two factors that make this decision tricky:\n<ul>\n<li>\nThe goats all need to be able to reach a single water bucket. Farmer John has not yet decided where to place this bucket. He has reduced the choice to a set of positions {<b>Q</b><sub>1</sub>, <b>Q</b><sub>2</sub>, ..., <b>Q</b><sub>M</sub>}, but he is not sure which one to use.\n</li>\n<li>\nThe goats are ill-tempered, and when they get together, they sometimes get in noisy fights. For everyone's peace of mind, Farmer John wants to minimize the area <b>A</b> that can be reached by all the goats.\n</li>\n</ul>\n</p>\n\n<p>\nUnfortunately, Farmer John is not very good at geometry, and he needs your help for this part!\n</p>\n\n<p>\nFor each bucket position <b>Q</b><sub>j</sub>, you should choose rope lengths so as to minimize the area <b>A</b><sub>j</sub> that can be reached by every goat when the bucket is located at position <b>Q</b><sub>j</sub>. You should then calculate each of these areas <b>A</b><sub>j</sub>.\n</p>\n\n<h3>Example</h3>\n\n<p>\nIn the picture below, there are four blue points, corresponding to the pole positions: <b>P</b><sub>1</sub>, <b>P</b><sub>2</sub>, <b>P</b><sub>3</sub>, and <b>P</b><sub>4</sub>. There are also two red points, corresponding to the potential bucket positions: <b>Q</b><sub>1</sub> and <b>Q</b><sub>2</sub>. You need to calculate <b>A</b><sub>1</sub> and <b>A</b><sub>2</sub>, the areas of the two shaded regions.\n</p>\n<p>\n<br/><br/><br/>\n&nbsp;&nbsp;&nbsp;<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1PaTatCPeg7AVGgnbP2QZ16hMZCFaq5dcQw3VEJXKaV5H0k6oBtIDyGgWH1qubYDpJ/ggg.png\">\n<br/><br/><br/>\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case begins with a line containing the integers <b>N</b> and <b>M</b>.\n</p>\n\n<p>\nThe next <b>N</b> lines contain the positions <b>P</b><sub>1</sub>, <b>P</b><sub>2</sub>, ..., <b>P</b><sub>N</sub>, one per line. This is followed by <b>M</b> lines, containing the positions <b>Q</b><sub>1</sub>, <b>Q</b><sub>2</sub>, ..., <b>Q</b><sub>M</sub>, one per line.\n</p>\n\n<p>\nEach of these <b>N</b> + <b>M</b> lines contains the corresponding position's <b>x</b> and <b>y</b> coordinates, separated by a single space.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: <b>A</b><sub>1</sub> <b>A</b><sub>2</sub> ... <b>A</b><sub>M</sub>\", where x is the case number (starting from 1), and <b>A</b><sub>1</sub> <b>A</b><sub>2</sub> ... <b>A</b><sub>M</sub> are the values defined above. Answers with a relative or absolute error of at most 10<sup>-6</sup> will be considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nAll coordinates are integers between -10,000 and 10,000.<br/>\nThe positions <b>P</b><sub>1</sub>, <b>P</b><sub>2</sub></b>, ..., <b>P</b><sub>N</sub>, <b>Q</b><sub>1</sub>, <b>Q</b><sub>2</sub>, ..., <b>Q</b><sub>M</sub> are all distinct and no three are collinear.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n<b>N</b> = 2.<br/>\n1 &le; <b>M</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>T</b> &le; 10.<br/>\n2 &le; <b>N</b> &le; 5,000.<br/>\n1 &le; <b>M</b> &le; 1,000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 3\n0 20\n20 0\n-20 10\n40 20\n0 19\n4 2\n0 0\n100 100\n300 0\n380 90\n400 100\n1000 5\n3 1\n0 0\n10 10\n20 0\n10 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1264.9865911 1713.2741229 0.2939440\nCase #2: 1518.9063729 1193932.9692206\nCase #3: 0.0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Grazing Google Goats","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nOn this very difficult round, even the first problem was pretty challenging. The constraints were fairly small, but it might not be clear how to even get started. After all, there are a lot of ways you can enhance a diamond!\n</p>\n\n<p>\nLet's start off with a slightly simpler question: given a position <code>(c<sub>x</sub>, c<sub>y</sub>)</code>, is it <i>possible</i> to enhance (i.e, extend) the given diamond into an elegant diamond centered at <code>(c<sub>x</sub>, c<sub>y</sub>)</code>? (Note that this center might be either at a number, or at a space between numbers, depending on whether the elegant diamond has even or odd side length.) The resulting diamond\nwould have to be symmetrical about the lines <code>x = c<sub>x</sub></code> and <code>y = c<sub>y</sub></code>. Specifically, this means that for each <code>(x, y)</code>, the values in positions <code>(x, y)</code>, <code>(2c<sub>x</sub> - x, y)</code>, <code>(x, 2c<sub>y</sub> - y)</code>, and <code>(2c<sub>x</sub> - x, 2c<sub>y</sub> - y)</code> all have to be equal. If the starting diamond already has two different values in one of these quartets, there's nothing we can do to change that.\n</p>\n\n<p>\nOtherwise, it turns out that the diamond always can be extended to an elegant diamond with center at <code>(c<sub>x</sub>, c<sub>y</sub>)</code>. For each of the quartets above where we have one value, we have to fill out the remaining values to be equal. After that, we can just enclose everything in a diamond shape and fill all remaining squares with 0. Here's an example:\n</p>\n\n<pre>\n  1\n 2 3\n5 6*6\n 2 3\n  1\n</pre>\n\n<p>\nLet's try to extend this to an elegant diamond centered at the *. First, we fill in all quartets, and then we extend to a proper diamond by adding 0's:\n</p>\n\n<pre>\n                             0\n  1           1 1           1 1\n 2 3         2 3 2         2 3 2\n5 6*6  --&gt;  5 6*6 5  --&gt;  5 6*6 5\n 2 3         2 3 2         2 3 2\n  1           1 1           1 1\n                             0\n</pre>\n\n<p>\nDone!\n</p>\n\n<p>\nThis is pretty clearly the smallest extension with the given center, so all we need to do is try each possible center, and choose the one that gives the\nsmallest possible elegant diamond.\n</p>\n\n<p>\nOf course, there are a lot of possible centers, but there is no need to consider one completely outside of the bounding box of the original diamond. We can always move such a center onto the edge of the bounding box without creating any inconsistencies, and that will lead to a smaller diamond in the end.\n</p>\n\n<p>\nSo in summary: we need to iterate over all possible centers contained within the\noriginal diamond, check if there is an elegant extension with that center, and\nthen take the smallest of these. As always, please take a look at some of the\ncorrect submissions to see some full implementations!\n</p>\n\n<p>\nBy the way, the solution presented here is O(n^4), which is fast enough for this problem. Faster solutions do exist though, and you might enjoy looking for them.\n</p>","id":"0000000000433332","statement":"<h3>Problem</h3>\n<p>\nThe king has hired you to make him an elegant diamond.  An elegant diamond is a two-dimensional object made out of digits that's symmetric about a horizontal and a vertical axis.  For example, the following four shapes are elegant diamonds:\n</p>\n<pre>\n   2       8      3     7\n  3 3     8 8    2 2\n 4 1 4     8      3\n  3 3 \n   2\n</pre>\n<p>\nThese three shapes are diamonds, but are not elegant:\n</p>\n<pre>\n  2       1        3\n 1 1     1 2      1 1\n  1     1 1 1    3 1 3\n         2 1      1 1\n          1        2\n</pre>\n<p>\nThese three shapes are not diamonds:\n<pre>\n  1     2     8   8\n 1 1   222      0\n        2     00000\n</pre>\n<p>\nThe king will start by giving you a diamond, which may not be elegant.  Your job is to make it elegant by  <i>enhancing</i> it, adding digits on to make a bigger diamond.  Because you don't want to spend too much money, you want to do it with as little <i>cost</i> as possible.\n</p>\n<h3>Definitions</h3>\n<p>\nA <b>diamond of size <i>k</i></b> is 2k-1 lines of digits, 0-9, separated by single spaces, organized in the following way:\n<ul>\n  <li>Line i (1 &le; i &le; k) contains k-i spaces, then i digits separated by single spaces.</li>\n  <li>Line i (k &lt; i &lt; 2k) contains i-k spaces, then 2k-i digits separated by single spaces.</li>\n</ul>\n</p>\n<p>\nAn <b>elegant diamond of size <i>k</i></b> is a diamond of size k with the following two symmetry properties:\n<ul>\n  <li>Horizontal symmetry: Let c<sub>i</sub> be the number of digits on line i.  The j<sup>th</sup> digit on line i (where j=1 for the first digit) must be the same as the c<sub>i</sub>+1-j<sup>th</sup> digit.</li>\n  <li>Vertical symmetry: The j<sup>th</sup> digit on line i (where i=1 for the first line) must be the same as the j<sup>th</sup> digit on line 2k-i.</li>\n</ul>\n</p>\n<p>\nA diamond of size k can be <b>enhanced</b> by adding digits to it.  The result of enhancing a diamond of size k has the following properties:\n<ul>\n  <li>The result is a diamond of size &ge; k.</li>\n  <li>The original diamond is part of the result. In other words, there exist some X and some Y such that, for all values of i and j such that the j<sup>th</sup> character of the i<sup>th</sup> line of the original is a digit (as opposed to a space), the j+X<sup>th</sup> character on the i+Y<sup>th</sup> line of the result is also a digit and it's the same as the j<sup>th</sup> character on the i<sup>th</sup> line of the original.\n</ul>\n</p>\n<p>\nThe <b>cost</b> of enhancing a diamond is equal to the number of digits in the result of the enhancement, minus the number of digits in the original diamond.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of a single integer <b>k</b> in a line on its own, followed by a diamond of size <b>k</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the minimum cost required to enhance the given diamond into an elegant diamond.  If the diamond is already elegant, y=0.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>k</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>k</b> &le; 51.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1\n0\n2\n 1\n2 2\n 1\n2\n 1\n1 2\n 1\n3\n  1\n 6 3\n9 5 5\n 6 3\n  1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 0\nCase #3: 5\nCase #4: 7\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Explanation</h3>\n<p>\nThere are four cases.  The first two cases start as elegant diamonds of size 1 and 2, respectively, and don't need to be enhanced; so the cost is 0.  The third case can be enhanced to look like:\n<pre>\n  3\n 1 1\n1 2 1\n 1 1\n  3\n</pre>\nThere are several possible enhancements, but this is one with the lowest possible cost, which is 5.  In the fourth case we can enhance the diamond into the following elegant diamond:\n<pre>\n   9\n  1 1\n 6 3 6\n9 5 5 9\n 6 3 6\n  1 1\n   9\n</pre>\n...for a cost of 7.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":8}],"title":"Elegant Diamond","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432b7f","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2010"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
