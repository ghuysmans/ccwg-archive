{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1659718800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000087762e","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Code Jam 2022 World Finals were exciting until the last second, with\n  many changes at the top of the scoreboard. The problems proved challenging\n  as no problem was solved by everyone, and nobody solved every problem.\n  The first problem,\n  <i>Wonderland Chase</i>, was a classical graph theory problem with a novel observation.\n  <i>Goose, Goose, Ducks?</i> came after as a logic-based problem, something unusual\n  in programming contests. Then, <i>Slide Parade</i> seemed to be about paths,\n  but ended up being a matching problem. The two most valuable problems were\n  <i>Schr&ouml;dinger and Pavlov</i>, a very unusual dynamic programming problem that\n  not many contestants could solve, and <i>Triangles</i>, a hard geometry problem\n  with a simple statement and a complicated solution that no contestant managed to find\n  in time.\n</p><p>\n\n</p><p>\n  We hope that Code Jam 2022 was fun for everyone and gave you a new opportunity\n  to sharpen your problems solving skills. We look forward to seeing everyone\n  back again in 2022 for our twentieth anniversary!\n  Until then, you can keep practicing on our platform with\n  <a href=\"http://codingcompetitions.withgoogle.com/kickstart\" target=\"_blank\">Kick Start</a>.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p>\n<p>\n  Wonderland Chase: Written by Onufry Wojtaszczyk. Prepared by Shubham Avasthi.\n</p><p>\n  Schr&ouml;dinger and Pavlov: Written by Takuto Shigemura and Yui Hosaka. Prepared by Ikumi Hide.\n</p><p>\n  Goose, Goose, Ducks?: Written by Onufry Wojtaszczyk. Prepared by John Dethridge.\n</p><p>\n  Slide Parade: Written by Han-sheng Liu. Prepared by Ian Tullis and Yang Xiao.\n</p><p>\n  Triangles: Written by Pablo Heiber. Prepared by Pablo Heiber and Timothy Buzzelli.\n</p><p>\nSolutions and other problem preparation and review by Artem Iglikov, Bakuri Tsutskhashvili,\nBohdan Pryshchenko, Darcy Best, Harsh Lal, Hsin-Yi Wang, Ian Tullis, Jayasurya,\nJohn Dethridge, Jose Toro, Lazar Todorovic, Luis Santiago Re, Md Mahbubul Hasan,\nMohamed Yosri Ahmed, Nafis Sadique, Nikos Papaspyrou, Nour Yosri, Pablo Heiber,\nPawel Zuczek, Petr Mitrichev, Pi-Hsun Shih, Rayan Dasoriya, Raymond Kang, Salma Mustafa,\nSanchit Malhotra, Sasha Fedorova, Sergiu Pușcaș, Timothy Buzzelli, Ulises Mendez Martinez,\nViktoriia Kovalova, Vinay Khilwani, and Yan Li.\n</p><p>\nAnalysis authors:\n</p><ul>\n  <li>Wonderland Chase: Max Ward.</li>\n  <li>Goose, Goose, Ducks?: Pablo Heiber.</li>\n  <li>Slide Parade: Han-sheng Liu.</li>\n  <li>Schr&ouml;dinger and Pavlov: Pablo Heiber.</li>\n  <li>Triangles: Pablo Heiber.</li>\n</ul>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1659704400000,"tasks":[{"analysis":"<h3>Test Set 1</h3>\n<p>\n  The labyrinths of Wonderland can be viewed as a undirected graph. If Alice can get to a cycle\n  before the Queen can reach her, then Alice will be safe. This is because Alice can always pick\n  a direction of travel away from the Queen around the cycle. Conversely, if Alice cannot get to\n  a cycle before the Queen, then the Queen will catch her after at most $$$2 \\times \\mathbf{J}$$$ moves.\n  Every second move, Alice\n  may move to a node, so after $$$2 \\times \\mathbf{J}$$$ moves Alice must have entered a cycle because\n  otherwise the Queen would have caught Alice.\n</p>\n\n<p>\n  Using these observations, we can formulate a dynamic programming solution. Define a recursive\n  function <code>solution(alice, queen, total_moves)</code> that is true if the Queen can catch\n  Alice in at most <code>total_moves</code> with both moving optimally and false otherwise.\n  The solution to the problem is the minimum value for <code>total_moves</code> such that\n  <code>solution($$$\\mathbf{A}$$$, $$$\\mathbf{Q}$$$, total_moves)</code> is true. If it is never true, then Alice is safe. \n</p>\n\n<p>\n  We can compute <code>solution(alice, queen, total_moves)</code> using a recurrence relation in \n  which we try all moves for the Queen and all moves for Alice in two nested loops calling\n  <code>solution</code> recursively. The Queen is always trying to make the answer true, and\n  Alice is always tryng to make it false.\n</p>\n\n<p>\n  An upper bound on the complexity of our solution is $$$O(\\mathbf{J}^5)$$$, since there are $$$O(\\mathbf{J}^3)$$$\n  states and computing a state requires at most $$$O(\\mathbf{J}^2)$$$ time. A better complexity analysis\n  is possible, but we already know this will be fast enough to pass Test Set 1.\n</p>\n\n<h3>Test Set 2</h3>\n<p>\n  A faster solution is needed for Test Set 2. We will need some more observations. Call a node\n  <i>good</i> when, if Alice reaches it before being caught, Alice will always be safe. That is,\n  if Alice reaches a good node, then regardless of where the Queen is, Alice can always move in a\n  way that is safe. Let's consider an algorithm for finding all good nodes.\n</p>\n<p>\n  Assuming a connected graph, leaves (nodes with degree 1) are never good because Alice can become\n  cornered in them.\n  We can start by deleting them. In fact, if we iteratively remove leaves until there are none left,\n  then all the remaining nodes must be good, since Alice can never be cornered. This algorithm\n  can be implemented in linear time using a queue of leaves and keeping track of the degree\n  of each node throughout deletions.\n</p>\n<p>\n  Define $$$\\mathbf{DA}_u$$$ as the shortest path from Alice's starting node to a node $$$u$$$. Likewise,\n  define $$$\\mathbf{DQ}_u$$$ as the shortest path from the Queen. For a node $$$j$$$,\n  if $$$\\mathbf{DA}_j < \\mathbf{DQ}_j$$$, then Alice can safely reach that node before being caught. We can prove\n  this using a contradiction: if the Queen was able to intercept Alice anywhere on her path, then\n  the Queen must have reached some node on Alice's shortest path before Alice, which would imply\n  that the Queen can reach $$$u$$$ first. Note that $$$\\mathbf{DA}$$$ and $$$\\mathbf{DQ}$$$ can be computed\n  by running one <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">Breadth-First Search</a>\n  (BFS) each and storing the resulting table of distances.\n</p>\n<p>\n  We can use our observations to solve the problem by considering a few cases.\n  Alice will be safe if:\n    <ul>\n      <li>The graph is disconnected, meaning Alice and the queen start in two disconnected\n        components. This can be checked by looking at either $$$\\mathbf{DA}$$$ or $$$\\mathbf{DQ}$$$.</li>\n        <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0ibXL_nMSPyd0As5uBrh-mVpzYfCMU2a2I50CF-_IyTlZbrQSRKnuefWlkiv8X41j4xaHsNwCjusVJFB5Ivrs7it_wyQ/disconnected_graph.png\" alt=\"\"/>\n      <li>Alice can enter a good node $$$j$$$ such that $$$\\mathbf{DA}_j < \\mathbf{DQ}_j$$$.</li>\n        <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1Jsbkf6JFXHBNrCzk652g6a1uG337sqABt57ZeqJH4jGW2D82MEU8flqOIhcl6gLu0OzKPNLh_tg5_iek/loop_graph.png\" alt=\"\"/>\n    </ul>\n</p>\n<p>\n  Otherwise, Alice will get caught. Since Alice's strategy is to maximize\n  the number of moves until she is caught, she will pick the junction that has the maximum \n  distance from the Queen with the condition that she can get to it first ($$$\\mathbf{DA}_j < \\mathbf{DQ}_j$$$). \n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U16t7n7I_kJdW6OEgkczFH8-HUNRAcBv47c18s4tu2uevcJ7rAETD3t-8RLhveyxusaaz2FbdZ5T7Q-PY6Rrg/normal_graph.png\" alt=\"\"/>\n<p>\n  Since the solution requires only three linear passes over the graph (one to find good nodes, and\n  two BFS runs), the total complexity is $$$O(\\mathbf{J} + \\mathbf{C})$$$.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2zZfO1LM2zYwDbywLkJ55v2QlypgNWpTN1zxPKiKqOQLgoRhLYPi3tq_ukel9SyjWrBIgd6xxH/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b9c499","statement":"<h3>Problem</h3>\n\n<p>\nAlice is trapped in Wonderland's labyrinth, being chased by the Queen of Hearts and her\nherald! The labyrinth is a set of $$$\\mathbf{J}$$$ junctions numbered $$$1$$$ through $$$\\mathbf{J}$$$,\nconnected by $$$\\mathbf{C}$$$ bidirectional corridors.\n</p><p>\nAlice and the Queen of Hearts take turns making moves, and each knows the location of the other\nat all times. A move (by either of them) consists of either staying at the current junction or moving to\nanother one that is connected to it by a corridor.\n</p><p>\nThe Queen's herald, however, announces the next move the Queen makes in advance. That means\nthat before anyone makes a move, he announces the Queen's first move. Then, Alice moves first.\nThen, each time the Queen moves, she must respect the previous announcement, and then decide\nher next move so the herald can announce it. Alice hears the announcements, so she always knows the\nQueen's next move before making her own.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0vPhRq6qnHv_9KNWQmoLimCYNvApW3OPiO0AEO4Tj9kWhavpJ_Zk3fttPbi8DDiaX5Tamc1WrnjYlq9B_chjyk5rLRW_9lgbP9QCCj/wonderland_chase_example_1.png\" alt=\"Illustration of Sample Case #1.\"/>\n</p><p>\nIf Alice and the Queen are at the same junction after either of them moves, then Alice is caught.\nOtherwise, the pursuit continues. After $$$10^9$$$ total moves (half of them for Alice and half\nfor the Queen), if Alice and the Queen are not in the same junction, then the Queen will give up\nand Alice will be safe.\n</p><p>\nAlice chooses her moves optimally to escape. If she cannot escape, she chooses her moves to\nmaximize the total number of moves until she is caught. The Queen chooses her moves optimally\nto try to catch Alice in as few total moves as possible.\n</p><p>\nGiven the labyrinth's layout and the initial locations of both the Queen and Alice,\nfind out whether Alice will be caught by the Queen and, if so, in how many moves.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case starts with a line containing four integers $$$\\mathbf{J}$$$, $$$\\mathbf{C}$$$, $$$\\mathbf{A}$$$, and $$$\\mathbf{Q}$$$: the\nnumber of junctions, the number of corridors, the junction where Alice starts, and the junction\nwhere the Queen starts, respectively. Then,\n$$$\\mathbf{C}$$$ lines follow. The $$$i$$$&NoBreak;-&NoBreak;th of these lines contains two integers\n$$$\\mathbf{U_i}$$$ and $$$\\mathbf{V_i}$$$, indicating that the $$$i$$$&NoBreak;-&NoBreak;th corridor bidirectionally connects junctions\n$$$\\mathbf{U_i}$$$ and $$$\\mathbf{V_i}$$$.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is <code>SAFE</code>\nif Alice can avoid being caught for $$$10^9$$$ total moves. Otherwise, $$$y$$$ is the total number of\nmoves (including Alice's and the Queen's) that it takes for the Queen to catch Alice.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n$$$1 \\le \\mathbf{A} \\le \\mathbf{J}$$$.<br/>\n$$$1 \\le \\mathbf{Q} \\le \\mathbf{J}$$$.<br/>\n$$$\\mathbf{A} \\ne \\mathbf{Q}$$$.<br/>\n$$$1 \\le \\mathbf{U_i} \\lt \\mathbf{V_i} \\le \\mathbf{J}$$$, for all $$$i$$$.<br/>\n$$$(\\mathbf{U_i}, \\mathbf{V_i}) \\ne (\\mathbf{U_j}, \\mathbf{V_j})$$$, for all $$$i \\ne j$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 10 seconds.<br/>\n\n$$$2 \\le \\mathbf{J} \\le 30$$$.<br/>\n$$$1 \\le \\mathbf{C} \\le 60$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n\n$$$2 \\le \\mathbf{J} \\le 10^5$$$.<br/>\n$$$1 \\le \\mathbf{C} \\le 2 \\times 10^5$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3rHykrZ_wvInJNAOa5NL2yZQs2R6G1IkHaNmy2MHOHMdmSyxB2t8Gy6Z8vTym8Qlu8fIxs_NPyizr8xjopZEtv12Gpbs5mPQ5fnJJe9vO4/wonderland_chase_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n5 5 5 1\n1 2\n1 3\n2 4\n3 4\n4 5\n5 5 5 2\n1 2\n1 3\n2 4\n3 4\n4 5\n3 1 2 3\n1 3\n2 1 1 2\n1 2\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2qHNQ9CSyJzsi1J1PSICT0aZtGKHYk39xGFGn4n13AMOUiIpLT6vMu42-ojsz3LT2J3Mn12xv247D8Ip1yPFVQMOgifDSWAfSjNDvxBwc4yA/wonderland_chase_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: SAFE\nCase #2: 4\nCase #3: SAFE\nCase #4: 2\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<p>\n  Sample Case #1 is the one pictured in the problem statement. Alice's optimal first move is to move\n  to junction $$$4$$$.\n</p>\n<p>\n  Sample Case #2 is the same as Sample Case #1 but the Queen starts at junction $$$2$$$. The Queen\n  can catch Alice by first announcing a move to junction $$$4$$$. If Alice were to move to junction\n  $$$4$$$&NoBreak;, she would be caught in $$$2$$$ moves. Alice can evade capture for an\n  extra $$$2$$$ moves by staying put and waiting until the Queen then moves to junction $$$5$$$ where she is\n  located.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2UpFivjLMARY7pQjP-QeNmA_bIc46ugiSok9smv7dzjLvQVSaZ0_BbbZXt1FNqUhkRPhkgZaWEyyDgAcXhfSg7LkldONYuM14Kt147/wonderland_chase_example_2.png\" alt=\"Illustration of Sample Case #2.\"/>\n</p>\n<p>\n  In Sample Case #3, the Queen cannot reach Alice no matter what she does.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3WHbDkvVKeVC3jovBZvVmiLDHmomvdEhKlBsCr_kHJeK00uOEnhRZLCTTRGL5t8FHGUjKA0uMBWdMaoiKv2SHmuMo59mLGM6094atv/wonderland_chase_example_3.png\" alt=\"Illustration of Sample Case #3.\"/>\n</p>\n<p>\n  In Sample Case #4, the Queen can begin by announcing that she will move to Alice's current\n  junction. Alice has to move before then. If Alice moves to where the Queen already is, she gets\n  caught immediately; if Alice remains in place, then she gets caught when the Queen moves. The\n  second option is better, since it requires $$$2$$$ total moves (Alice's and the Queen's) instead of\n  $$$1$$$.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3MIyDQKy2nD0WwwmuciMIOgKSPHopF_PLvGU46a9x4HVg2Vk17sw5JLFm-OeOrYDWs815cohhWQA80Y2_c_bB78c2okG58q1Ib77z6/wonderland_chase_example_4.png\" alt=\"Illustration of Sample Case #4.\"/>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Wonderland Chase","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\nIn Test Set 1 there are so few points that we can just try every possible way to assign them\nto triangles. With a maximum of $$$\\mathbf{N}=12$$$ points, there are $$$12! / (3!^4 \\cdot 4!) = 15400$$$\nways of getting $$$3$$$ or $$$4$$$ triangles, even less to get $$$1$$$ or $$$2$$$, and a single\nway to get $$$0$$$, which means there are less than $$$4 \\cdot 15400 + 1 = 61601$$$\nthings to try. For each one, we need to check that every triangle is valid (i.e., made up\nof non-collinear points) and that each pair of triangles meets the definition given in the\nstatement. Since there are very few triangles, this requires quite a bit of code but not\na lot of computation time.\n<h3>Test Set 2</h3>\n<p>\nWe solve this problem by constructively proving the following theorem: a set $$$S$$$ of\n$$$3t$$$ points can be split to form $$$t$$$ triangles that fulfill the conditions of the statement\nif and only if it does not contain a subset of $$$2t + 1$$$ collinear points.\n</p><p>\nThe case where $$$t=1$$$ is trivial. If $$$t \\gt 1$$$ we consider $$$3$$$ different cases. Let\n$$$C$$$ be the largest subset of $$$S$$$ made up of collinear points.\n<ul>\n<li>If $$$|C| \\lt 2t - 1$$$, we find a triangle that is separated from all other points by\n  a line and then recursively solve an instance with less points. Since a triangle can use\n  at most $$$2$$$ points from $$$C$$$, this does not make the remaining set exceed the maximum\n  number of collinear points allowed. One way of finding such a triangle is to get the\n  $$$2$$$ maximal points in the lexicographical order (i.e., ordering by X-coordinate and breaking\n  ties by Y-coordinate) $$$v$$$ and $$$w$$$, and then find the\n  third points $$$x_1$$$ and $$$x_2$$$ that minimize and maximize, respectively, the angle\n  $$$vwx_i$$$, breaking ties by the distance $$$|wx_i|$$$. Then, pick $$$x_1$$$ if the angle\n  is less than $$$\\pi$$$ or $$$x_2$$$ otherwise (in that\n  case, $$$vwx_2$$$ is guaranteed to be greater than $$$\\pi$$$). Notice that this makes The\n  line $$$wx_i$$$ separate the three points from all others (there could be more points over\n  that line, but $$$w$$$ and $$$x_i$$$ are the extreme points over it, so any triangles we can make\n  from the remaining points will not interfere with this triangle).\n</li>\n<li>If $$$|C| \\ge 2t - 1$$$ and $$$|C| \\ne 3$$$, let $$$B, D \\subseteq S$$$ be the subsets of\npoints on each side of the line that goes through $$$C$$$. If neither is empty, assuming without\nloss of generality that $$$|B| \\le |D|$$$, we can match\nthe lexicographically greatest $$$2|B|$$$ points of $$$C$$$, let us call that $$$C'$$$ with\n$$$B$$$ to\nrecursively solve $$$B \\cup C'$$$ and $$$D \\cup (C \\setminus C_1)$$$. Notice that there is a\nseparation line between those two sets, so the recursive solutions do not interfere with each\nother. If one of $$$B$$$ or $$$C$$$ is empty we can take the two lexicographically greatest\npoints in $$$C$$$ and match it with one of the remaining points, as in the previous step,\nsolving the rest recursively. If $$$|C|=2$$$, this makes a single triangle. Otherwise,\n$$$|C| \\gt 3$$$, so after removing two points from $$$C$$$ and one point from $$$S \\setminus C$$$,\nthe requirements of the theorem applies to the remaining points.\n<li>Otherwise, $$$|C|=3$$$ and $$$t=2$$$. If the convex hull of $$$S$$$ has $$$3$$$ vertices,\n  we can use those for one triangle, and the other $$$3$$$ for the other. If the convex hull of\n  $$$S$$$ has $$$5$$$ or $$$6$$$ vertices, it contains at least two from $$$C$$$, so we can use\n  those $$$2$$$ plus a single intermediate or adjacent point to form one triangle, and the\n  rest for the other. If the convex hull of $$$C$$$ has $$$4$$$ points, there are a few\n  cases to consider depending on where the other $$$2$$$ points are located, but all are solvable.\n  Implementation-wise, we can simply try all possible ways to match it, since there is a small\n  amount anyway.\n</li>\n</ul><p>\nBecause of the above, we can do the following: find a largest set of collinear points in the\ninput $$$C$$$. If it is larger than $$$\\lceil 2 \\mathbf{N} / 3 \\rceil$$$, ignore points from it\nto make it equal to that amount. After that, ignore points not in $$$C$$$ to make the set\nof non-ignored points have size multiple of $$$3$$$. We will match all those points into triangles\nusing the above idea. If we keep the points sorted lexicographically, we can implement each step\nfinding a new triangle in linear time, except for the fact that after each step of the first type\nwe may need to recalculate $$$C$$$.\n</p><p>\nTo speed up the calculation of largest subset of collinear points, we can use three techniques.\nThe first two speed it up in complexity, but can be really slow in practice due to a combination\nof large constants and an accumulation of logarithmic factors depending on the exact\nimplementation.\n<ul>\n<li>Calculate all subsets of collinear points and keep them updated and on a priority queue\n  to quickly identify the largest. There are $$$\\mathbf{N}$$$ point removals and each one updates up to\n  $$$\\mathbf{N} - 1$$$ sets, so there are $$$O(\\mathbf{N}^2)$$$ updates overall. If the sets are\n  linked lists and the priority queue is over an array (the sizes are limited to the range\n  $$$1$$$ through $$$\\mathbf{N}$$$), this can be theoretically be done in $$$O(\\mathbf{N}^2)$$$ overall. However,\n  since an initial calculation of $$$C$$$ for the entire input necessitates $$$O(\\mathbf{N}^2 \\log \\mathbf{N})$$$\n  operations, it might be tempting to use less efficient but quicker to code structures.\n</li>\n<li>If $$$|C|$$$ is a lot smaller than the threshold needed to not be in the first case,\n  we can simply take multiple steps of the first case without recalculating. It can be shown\n  that doing this leads to only a logarithmic number of recalculations. Notice that this still\n  makes the overall complexity $$$O(\\mathbf{N}^2 \\log^2 \\mathbf{N})$$$ and it has large constants because\n  the input size before each recalculation is not halved, but reduced by about $$$1/5$$$ in the\n  worst case.\n</li>\n</ul>\n</p><p>\nA simpler and a lot faster way is to not calculate $$$C$$$ explicitly at all. Just keep\ndoing the first case until you detect all remaining points are collinear (this happens\nwhen both $$$vwx_1$$$ and $$$vwx_2$$$ are planar angles). At that point, undo just enough\nof the latest made triangles to make that identified set of collinear points big enough\nto not be in the first case, and continue with the second and third cases. This makes the\noverall time complexity $$$O(\\mathbf{N}^2)$$$ and, not having complicated structures or logarithms\nwith small bases, it does not hide any large constants.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1d5QWuG9OvaF7TYytbYH9k2KYcQWAeRrEegc1hdmPuar3pIOxwkrRg5P5xtQdZGN7JivyNTP07/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b9c555","statement":"<h3>Problem</h3>\n\n<p>\nYou are given a set $$$P$$$ of $$$\\mathbf{N}$$$ distinct points in the two-dimensional plane.\nYou want to find a maximum set of triangles such that:\n</p>\n<ul>\n  <li>Each vertex of a triangle in your set is a point from $$$P$$$ and each point in\n    $$$P$$$ is a vertex of at most one triangle in your set.</li>\n  <li>Each triangle in your set has positive area (i.e., its $$$3$$$ vertices are not collinear).</li>\n  <li>For any two sides of triangles in your set, their intersection is either empty or an\n    endpoint of one of them.</li>\n  <li>For any two triangles in your set, the intersection of the areas strictly inside those triangles\n    is either empty or equal to one of them.</li>\n</ul>\n<p>\nFor example, the set of triangles depicted below meets the definition above.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3Yj1_yEMHu-R7NXjG92d8k3dNNAa-zZpJhvzBYi7kb_JCJnWh1ufawXX3dZjCw_0Bolp0eHvEat2SWKTYnWsHbsXtU/triangles_correct.png\" alt=\"Examples of triangles that meet the definition.\"/>\n</p><p>\nOn the other hand, each pair of a yellow and a red triangle in the picture below\ndoes not meet the definition.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U03A0UwWhSFhkbe4tf47egTVQeFkjU7mPnXS8YOZh_M7DRE2C702gi6VsN_V5e8Htx3zhbgwqj8KtzdOY8YsOmdTA/triangles_wrong.png\" alt=\"Several pairs of triangles that do not meet the definition.\"/>\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case starts with a line containing a single integer $$$\\mathbf{N}$$$. Then, $$$\\mathbf{N}$$$ lines follow.\nThe $$$i$$$-th of these lines contains two integers $$$\\mathbf{X_i}$$$ and $$$\\mathbf{Y_i}$$$ representing the coordinates\nof the $$$i$$$-th point.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is the maximum\nsize of a set of triangles with the desired properties. Then,\noutput $$$y$$$ more lines. The $$$j$$$-th\nof those lines must contain $$$p_j\\ q_j\\ r_j$$$ representing that the $$$j$$$&NoBreak;-&NoBreak;th triangle in your\nproposed set has the $$$p_j$$$-th, $$$q_j$$$-th, and $$$r_j$$$-th points in the input as vertices.\nPoints in the input are numbered starting from $$$1$$$.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 15 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n$$$-10^9 \\le \\mathbf{X_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n$$$-10^9 \\le \\mathbf{Y_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n$$$(\\mathbf{X_i}, \\mathbf{Y_i}) \\neq (\\mathbf{X_j}, \\mathbf{Y_j})$$$, for all $$$i \\neq j$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\n$$$3 \\le \\mathbf{N} \\le 12$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n\n$$$3 \\le \\mathbf{N} \\le 3000$$$.<br/>\n</p>\n\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0Obc_rjD90A5tvXNDzF3Y3Ba_XeQnxoOUriEIw4UBFv8I7ylx5cdqnqQP41PNSmruZRh6r1FD269a1j0yc2KamI31RJCMuy5I/triangles_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n9\n8 2\n10 2\n2 0\n0 5\n2 3\n10 4\n10 0\n8 3\n2 4\n7\n0 0\n0 3\n3 0\n0 1\n1 0\n1 1\n2 2\n3\n0 0\n0 1\n0 2\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2McnDIeRCTXNL9TogyjSEoKZNptQFoZYcBQEKbP58c0PwN1kYFOi05_A-pGhWToK_zW603TDzOnOlrVzIhgn2_qlyM95irSm4B/triangles_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 3\n3 4 5\n1 7 9\n6 2 8\nCase #2: 2\n2 3 1\n6 5 4\nCase #3: 0\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Sample Case #1 is illustrated below. Notice that there are other valid ways to construct\n  a maximum number of triangles.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2euA59OUuA9dFiACgQJy761mrfBJshUcPtFMSlMS4RKuaICSUavGeMzA74D2OV8djDABD7yCnz4Z4jMa3LZnpl1nLvww/triangles_sample_1.png\" alt=\"Illustration of the input and output of Sample Case #1\"/>\n</p><p>\nSample Case #2 is illustrated below. As before, there are other valid ways to construct $$$2$$$\ntriangles.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0ZnPg-f-YXM9XhZRAeXeNerijSgLlo36d7uVA4u6jHj21N1CBSAClzgMtjJWF-ELWCR4NUFDY2FuOIRC81YBhGISVoXA/triangles_sample_2.png\" alt=\"Illustration of the input and output of Sample Case #2\"/>\n</p><p>\n  In Sample Case #3, the $$$3$$$ given points are collinear, so it is not possible to\n  make a valid triangle with them.\n</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":42}],"title":"Triangles","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe difficulty of this problem resides on the fact that the state of a box can affect outcomes\nlong after the dog passed them by blocking or not blocking a tunnel. We deal with that difficulty\nby remembering the state of boxes. Of course, there are way too many boxes to remember the entire\nstate, so we compress it to a smaller amount of information that is manageable. How we do that\nis different for each test set.\n</p>\n<h3>Test Set 1</h3>\n<p>\nIn Test Set 1, all tunnels go to nearby boxes. That means once the dog is at box number $$$i$$$,\nthe state of boxes with numbers lower than $$$i-5$$$ cannot affect the outcome anymore. So, we\ncan do a <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\" target=\"_blank\">dynamic\nprogramming</a> solution that computes the probability that there is a cat at box $$$i$$$ given\nthe state of the $$$k$$$ closest boxes. That is only $$$O(\\mathbf{N} \\times 2^k)$$$ states, and because\n$$$k$$$ is bounded by only $$$10$$$ for Test Set 1, that is small enough to solve the problem.\n</p>\n<h3>Test Set 2</h3>\n<p>\nFor Test Set 2, the number of close boxes that we may need to remember is not bounded by a small\nnumber, so we cannot use a solution exponential in it. Let us consider a\n<a href=\"https://en.wikipedia.org/wiki/Directed_graph\" target=\"_blank\">directed graph</a>\nwith boxes as the nodes and tunnels as directed edges. Because it has the same number of\nnodes and edges, it is a\n<a href=\"https://en.wikipedia.org/wiki/Pseudoforest#Graphs_of_functions\" target=\"_blank\">\nfunctional graph</a>. Functional graphs look like forests except they have cycles as the \"roots\".\nNotice that only the connected component of the underlying undirected graph that contains the last\nbox matters for the final answer (boxes in other components do not affect whether or not\nthere is a cat in the last box). So, we can discard all other components and assume moving\nforward the graph is connected, so it's actually a functional graph with a single cycle.\n</p><p>\nAs a thought exercise, let us assume the tunnels graph is actually a directed tree instead\n(one tunnel is removed). In this case, we can solve the problem by simulating the dog run and\nremembering things in a smart way. We maintain a forest of the nodes corresponding to every box\nand the tunnels that may have been used so far, that is, tunnels coming out of boxes that\nthe dog already passed. For each node, we compute the probability that a cat is there. The\nprobabilities of a cat being in any two boxes are independent if they are on\ndifferent trees of this forest, but otherwise they might not be.\n</p><p>\nWe start with the forest with all nodes and no edges. Probabilities for each node start at\n$$$0$$$, $$$1/2$$$c or $$$1$$$ depending on whether the box is empty, unknown, or contains a cat,\nrespectively. Then, when we simulate the dog\npassing through box $$$i$$$, that adds one edge to the forest, which merges two trees. Because\nthe probability of the roots of those trees are independent up to this step, we can calculate the\nprobability of the tunnel being used by multiplying the probability that there is a cat in box\n$$$i$$$ and no cat in the destination box. Then, we update all probabilities as the weigthed\naverage of the outcome of both cases (a cat running through the new tunnel or not).\n</p><p>\nTo make the approach above work for an actual functional graph instead of a tree, we need to\ndeal with the sole cycle. We can do this by branching out when we add the first edge of the\ncycle to the forest (that is, when the dog runs through the box with the smallest number from\namong those in the cycle). Instead of merging those two components, we consider all $$$4$$$ cases\nfor the state of the two boxes at the endpoints of the tunnel. For each one, we can compute\nits probability with a multiplication as before, because at this points the two endpoint\nprobabilities are independent. Then, instead of merging the two components, we start $$$4$$$\ncomputations, one for each case, but in all of them the components are kept separated.\nAt the end, we have $$$4$$$ results for the last box. The final result is the weighted average\nof that box where the weights are the probabilities of each case that we calculated when forking\nthe computation.\n</p>\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3k9ElT1pSf6rkeODFZIvQ9mWgQuphjve_a7063_QTXF3y6Ydl1_VZr_PZeaVSevsr95MKh6nm4/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b9c73a","statement":"<h3>Problem</h3>\n<p>\n<i>The story, all names, characters, and incidents portrayed in this problem statement are\nfictitious. No identification with actual persons is intended or should be inferred.</i>\n</p><p>\nIt is 1935 and a meeting between two Nobel prize winners is producing astonishing results.\nSchr&ouml;dinger, a famous physicist, invited Pavlov, a famous physiologist, to see his experiments\nwith cats in boxes. Pavlov brought his dog with him to keep up with his own\nresearch, and the combination proved interesting, to say the least.\n</p><p>\nSchr&ouml;dinger had a row of $$$\\mathbf{N}$$$ boxes. Some boxes definitely contain a cat, some boxes definitely\ndo not contain a cat, and some boxes may or may not contain a cat. Each box is only big enough\nto hold a single cat. Each box is also equipped with a special quantum tunnel, that allows\nthe cat in the box to move to some other specific box if the destination was empty. The tunnels\nwork in a single direction.\n</p><p>\nCats are usually mellow and quiet and do not use the tunnels unless they become startled. When a\nthird unannounced guest rings the bell, Pavlov's dog gets excited immediately and starts\nrunning and barking. The dog starts at box $$$1$$$ and runs towards box $$$\\mathbf{N}$$$. \nAs the dog runs, it passes right next to each box, one at a time. When\nit passes next to a box that contains a cat, the cat in that box becomes startled. The\nstartled cat checks the available tunnel and, if the destination box is empty, uses it to escape.\nIf the destination box is occupied, the cat stays in its current box. The same cat can be startled\nmore than once if they move to a box the dog will get to afterwards, and will proceed in the same\nway every time it is startled (using only the newly available tunnel each subsequent time).\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U26hdzSVIow2QHqgYNJ6yyEkpJ3MJudpuxBcFw6wTvSlxxzu25wrxgCHFZv2qwnmj9-cAhVBXHcK-7ml-aPQGrVZK2QJwvLU3I/schrodinger_and_pavlov.png\" alt=\"Illustration of Sample Case #1 with a dog shown walking from left to right.\" style=\"width: 100%; min-width: 400px; max-width: 800px;\"/>\n</p><p>\nAfter Pavlov's dog finally stops right next to the last box, Pavlov asks Schr&ouml;dinger whether\nthere is a cat in that last box. Schr&ouml;dinger, true to his fame, replies that he does not know.\nPavlov notices that the answer may depend on whether or not there were cats in the unknown boxes.\nMoreover, he also notices that because there are $$$k$$$ unknown boxes, there are $$$2^k$$$\npossible <i>initial configurations</i>, one for each combination of statuses of the unknown\nboxes. Pavlov tells Schr&ouml;dinger that they should try to calculate how\nmany of the $$$2^k$$$ initial configurations would result in having a cat in the last box. You are\nasked to recreate that calculation. Since the output can be a really big number, we only ask you to\noutput the remainder of dividing the result by the prime $$$10^9+7$$$ ($$$1000000007$$$).\n</p><p>\n<i>Neither cats, nor dogs, nor Nobel prize winners were harmed in the making of this problem\n  statement.</i>\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow, each\ndescribed by exactly three lines. The first line of a test case contains a single integer\n$$$\\mathbf{N}$$$, the number of boxes in Schr&ouml;dinger's experiment. Boxes are numbered between $$$1$$$\nand $$$\\mathbf{N}$$$, in the order Pavlov's dog passes them by. The second line of a test case\ncontains a single string $$$\\mathbf{S}$$$ of $$$\\mathbf{N}$$$ characters. The $$$i$$$-th character of $$$\\mathbf{S}$$$ (counting\nfrom left to right) represents the contents of box $$$i$$$: it is an\nuppercase '<code>C</code>' if the box contains a cat, a period '<code>.</code>' if the\nbox does not contain a cat and a question mark '<code>?</code>' if it is unknown whether\nthe box contains a cat or not. The third line of a test case contains $$$\\mathbf{N}$$$ integers\n$$$\\mathbf{B_1}, \\mathbf{B_2}, \\dots, \\mathbf{B_N}$$$, representing that there is a tunnel going out of box $$$i$$$\nand into box $$$\\mathbf{B_i}$$$, for all $$$i$$$.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is the number of initial\nconfigurations that would result\nin a cat being in the last box and unable to escape despite hearing the barking, modulo the prime\n $$$10^9+7$$$ ($$$1000000007$$$).\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 10 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 1234$$$.<br/>\nthe length of $$$\\mathbf{S} = \\mathbf{N}$$$.<br/>\nEach character of $$$\\mathbf{S}$$$ is either an upper case '<code>C</code>', a period '<code>.</code>' or\n  a question mark '<code>?</code>'.<br/>\n$$$1 \\le \\mathbf{B_i} \\le \\mathbf{N}$$$, for all $$$i$$$.<br/>\n$$$\\mathbf{B_i} \\neq i$$$, for all $$$i$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\n$$$1 \\le \\mathbf{N} \\le 100$$$.<br/>\n$$$i - 5 \\le \\mathbf{B_i} \\le i + 5$$$, for all $$$i$$$.\n  (All tunnels connect to nearby boxes.)<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n\n$$$1 \\le \\mathbf{N} \\le 5000$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3xrDSI_O5BX9S-d1utYxhnDAVcIU3uvru4_iU6LlA_rWqECal5bfzoGc0hQvaOfmNsxujgxhq60CO_wnPGWwH8KIVr5bMuVBoYKVzKNejo_yYD-1A/schrdinger_and_pavlov_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n4\n??.C\n2 3 1 3\n4\n????\n2 3 1 3\n6\n?.????\n6 6 6 6 6 5\n34\n????????????????????????????????CC\n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 33\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1PVh5lsLBQi_tS1NlZlFv0LWLx-SOZP6kaCQ-i02E3ogOzxaREiuROuNcelk-grofpP2CRG1YqPsKa79TyCE_KdPcE6i-4Z5G3VFHih1WD7DqbYU5a/schrdinger_and_pavlov_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 1\nCase #2: 2\nCase #3: 15\nCase #4: 294967268\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Sample Case #1 is illustrated in the problem statement. There are $$$4$$$ possible configurations:\n<ul>\n<li><code>...C</code>: the dog runs through the first $$$3$$$ boxes without changing anything\n  because there is no cat there. Then, when it gets to the last box, the cat hears it and escapes\n  to box 3. Therefore, there is no cat in the last box in this case.</li>\n<li><code>C..C</code>: when the dog barks near box $$$1$$$, that startles the cat that\n  goes through the tunnel to get to box $$$2$$$, which was empty. Then, the same cat\n  gets startled again when the dog barks near box $$$2$$$ and gets to box $$$3$$$. And when\n  the dog barks next to box $$$3$$$, the cat hears it and returns to box $$$1$$$. Therefore,\n  when the dog gets to box $$$4$$$ and the other cats hears it, box $$$3$$$ is empty so the\n  cat escapes and the last box ends up empty.</li>\n<li><code>.C.C</code>: This case is very similar to the previous one. After the dog goes through\n  the first box and nothing happens, the state is the same as before, so the ultimate result\n  is the same: last box empty.</li>\n<li><code>CC.C</code>: In this case, the cat in the first box cannot escape when it hears the\n  dog, so it remains in box $$$1$$$. Then, when the cat in box $$$2$$$ gets startled it escapes to\n  box $$$3$$$ leaving a state of <code>C.CC</code>. When the dog gets to the box $$$3$$$, the cat\n  currently there cannot escape to box $$$1$$$ so the state remains the same. Finally, when the\n  dog gets to the last box, the cat that is there cannot escape because box $$$3$$$ is occupied\n  this time. So, in this case, the last box ends up with a cat after the dog ends its journey.</li>\n</ul>\n  Out of the $$$4$$$ possibilities, only $$$1$$$ (the last one) ends up with a cat in the last box,\n  so the answer is $$$1$$$.\n</p><p>\n  In Sample Case #2, the tunnels are set up the same as in Sample Case #1. Since no tunnel ends\n  at the last box, the configurations that start with no cat at the last box will also not end with\n  a cat there, so we do not need to count them. Then, we have $$$8$$$ additional configurations. The\n  $$$4$$$ we considered for Sample Case #1, out of which only $$$1$$$ ends up with a cat at the last\n  box. The remaining $$$4$$$ configurations are: <code>..CC</code>, <code>C.CC</code>,\n  <code>.CCC</code>, <code>CCCC</code>. From these additional $$$4$$$ configurations, only in the\n  last one listed a cat ends up in the last box, for a total of $$$2$$$ overall.\n</p><p>\n  In Sample Case #3, notice that for a cat to remain in the last box after the dog barks near it,\n  both that box and box $$$5$$$ must be occupied then (otherwise, either there is no cat in the\n  last box, or it will escape to box $$$5$$$). Since there is no tunnel going into box $$$5$$$,\n  a cat must start there. As long as there is another cat in any other box, box $$$6$$$ will get\n  (or remain) occupied before the cat in box $$$5$$$ gets an opportunity to escape, so all of those\n  will end up with a cat in the last box. As we argued before, a single cat is not enough. Thus,\n  we need to count the number of configurations with a cat in box $$$5$$$ and at least one other cat.\n  There are $$$2^4$$$ configurations with a cat in box $$$5$$$, and out of those, only $$$1$$$ has\n  no other cat, so the answer is $$$2^4-1=15$$$.\n</p><p>\n  In Sample Case #4, in all of the $$$2^k$$$ ways in which the $$$k$$$ unknown boxes may exist\n  a cat would be left in the last box.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":42}],"title":"Schrödinger and Pavlov","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  In this problem, we are given a simple graph $$$G$$$.\n  We are required to find a sufficiently-small circuit that passes through each edge at least once, and passes through all\n  vertices the same number of times.\n<p>\n  Let the input graph be $$$G = (V, E)$$$.<br>\n  $$$V = \\{1, 2, ..., B\\}$$$, $$$E = \\{(X_1, Y_1), (X_2, Y_2), ..., (X_S, Y_S)\\}$$$.\n<p>\n  If the circuit exists, let $$$k$$$ be the number of times that each vertex is passed through.\n  Collecting the edges in the circuit forms a multigraph $$$G' = (V, E')$$$, where $$$E'$$$ is a multiset.\n  $$$G'$$$ has the following properties:\n  <ul>\n    <li>The underlying set of $$$E'$$$ is $$$E$$$. Which means\n    <ul>\n      <li>Each edge in $$$E$$$ appears at least once in $$$E'$$$.\n      <li>Each edge in $$$E'$$$ appears in $$$E$$$.\n    </ul>\n    <li>For each node $$$v$$$, $$$indegree(v) = outdegree(v) = k$$$.\n  </ul>\n<p>\n  On the other hand, if we could find a multigraph $$$G'$$$ satisfying the above properties for some $$$k$$$,\n  then we could compute an answer from $$$G'$$$ with an Eulerian circuit construction algorithm.\n  An Eulerian circuit is a circuit that visits each edge in a graph exactly once.\n  In the following solutions, we will focus on finding a $$$G'$$$ via different approaches.\n<p>\n  Let $$$L$$$ be the output limit $$$10^6$$$.\n  Note that $$$L$$$ is also a significant factor while analyzing the complexity.\n\n<h3>\n  $$$O(L\\mathbf{BS})$$$ approach\n</h3>\n<p>\n  In this approach, we will use a max-flow algorithm to find a set of valid multiplicities $$$d_i$$$ for each $$$(X_i, Y_i)$$$ in $$$E$$$.\n  i.e. $$$(X_i, Y_i)$$$ appears $$$d_i$$$ times in $$$E'$$$.\n<p>\n  Note that the total number of edges in the cycle would be $$$k\\mathbf{B}$$$, so the upper bound of $$$k$$$ is $$$\\dfrac{L}{\\mathbf{B}}$$$.\n  Enumerating all possible $$$d_i$$$ is not feasible, but we can try all possible values of $$$k$$$, and see if\n  a set of valid $$$d_i$$$ can be generated under the fixed $$$k$$$.\n  Once we find a set of valid $$$d_i$$$, then $$$G'$$$ is also determined.\n<p>\n  This can be reduced to a <a href=\"https://en.wikipedia.org/wiki/Maximum_flow_problem\" target=\"_blank\">maximum flow problem</a>.\n  We will construct a flow network with source $$$s$$$ and sink $$$t$$$ to help us find a valid set of $$$d_i$$$.\n<p>\n  The vertices of the flow network are:\n  <ul>\n    <li> The source $$$s$$$.\n    <li> The sink $$$t$$$.\n    <li> A node $$$in_v$$$ for each $$$v$$$ in $$$V$$$.\n    <li> A node $$$out_v$$$ for each $$$v$$$ in $$$V$$$.\n  </ul>\n  There are $$$(2\\mathbf{B}+2)$$$ vertices in the network in total.\n<p>\n  The edges of the flow network are:\n  <ul>\n    <li> $$$(s, out_v)$$$ for each $$$v$$$ in $$$V$$$, with capacity $$$k$$$.\n    <li> $$$(out_u, in_v)$$$ for each $$$(u, v)$$$ in $$$E$$$. No capacity limit, but the lower bound of flow is 1.\n    <li> $$$(in_v, t)$$$ for each $$$v$$$ in $$$V$$$, with capacity $$$k$$$.\n  </ul>\n  There are $$$(\\mathbf{S}+2\\mathbf{B})$$$ edges in the network in total.\n<p>\n  The amount of flow through $$$in_v$$$ ($$$out_v$$$, <i>resp.</i>) indicates the indegree (outdegree, <i>resp.</i>) of vertex $$$v$$$ in $$$G'$$$.\n  The amount of flow on $$$(out_u, in_v)$$$ indicates the multiplicity of edge $$$(u, v)$$$.\n<p>\n  Now we search for the maximum flow on the graph.\n  If the total flow is $$$k\\mathbf{B}$$$ (the maximum possible), then the amount of flow through\n\t$$$in_v$$$ and $$$out_v$$$ is $$$k$$$ for each $$$v$$$,\n  and we have found a valid set of multiplicities $$$d_i$$$.\n  We can then construct $$$G' = (V, E')$$$ with those multiplicities, find an Eulerian circuit in $$$G'$$$, and output that circuit.\n<p>\n  On the other hand, if we don't find such a flow for any possible $$$k$$$, then we output IMPOSSIBLE.\n<p>\n  Now let's analyze the time complexity of this solution.\n  In this solution, we run a maximum flow algorithm for each $$$k$$$.\n  There are $$$\\dfrac{L}{\\mathbf{B}}$$$ possibilities of $$$k$$$, and the graph has at most $$$O(\\mathbf{B})$$$ vertices and $$$O(\\mathbf{S})$$$ edges.\n  Thus the total time complexity is $$$O(L\\mathbf{BS})$$$,\n  assuming <a href=\"https://en.wikipedia.org/wiki/Dinic%27s_algorithm\" target=\"_blank\">Dinic's $$$O(\\mathbf{B^2S})$$$ algorithm</a> is chosen for solving maximum-flow.  This can be made faster by computing a maximum\n\tflow for each $$$k$$$ by starting with the flow found for the previous value of $$$k$$$.\n\n</p>\n\n<h3>\n  $$$O(\\mathbf{S^2})$$$ approach\n</h3>\n<p>\n\nThe previous algorithm could be somewhat slow.\nIt would be good if we could generate a graph $$$G'$$$ more directly.\nConsider this simple iterative algorithm that produces a $$$G'$$$:\n\n<ul>\n    <li>Choose an edge (u, v) that is not yet in $$$G'$$$.</li>\n    <li>Add edges on a path from building 1 to building u to $$$G'$$$.</li>\n    <li>Add the edge (u, v) to $$$G'$$$.</li>\n    <li>Add edges on a path from building v to building 1 to $$$G'$$$.</li>\n    <li>Repeat until each edge occurs at least once in $$$G'$$$.</li>\n</ul>\n<p>\n\nThe $$$G'$$$ produced by this algorithm is able to produce a circuit, since we can simply follow\nthe edges in the same order they were added.\nBut the buildings would not necessarily be visited an equal number of times.\nSo, it would be good if we could do the following instead:\n\n<ul>\n    <li>Choose an edge $$$(u,v)$$$ that is not yet in $$$G'$$$.</li>\n\t  <li>Find a set $$$A$$$ of edges,\n\t\t\tsuch that the indegree and outdegree of each node is equal in $$$A$$$,\n\t\t\tand $$$A$$$ includes $$$(u, v)$$$.</li>\n\t  <li>Add $$$A$$$ to $$$G'$$$.</li>\n    <li>Repeat until each edge occurs at least once in $$$G'$$$.</li>\n</ul>\n<p>\n\nIf this succeeds, it would yield a $$$G'$$$ with all the required properties we listed earlier.\nAlso, if every set $$$A$$$ found in the algorithm was as small as possible,\nthat is, if the indegree and outdegree of each node in each $$$A$$$ was $$$1$$$,\nthen the total number of edges in $$$G'$$$ would be at most $$$SB$$$, which is at most\n$$$10^6$$$, which conveniently is the limit in the problem!\n<p>\n\nNow, the question arises &mdash; if the problem is possible, can we always find such a set $$$A$$$\nfor any edge $$$(u,v)$$$?  We can show that we can.\n<p>\n\nThe problem of finding a set $$$A$$$ of edges can be reduced to finding a perfect bipartite matching,\non a graph similar to the flow graph in the previous solution.\n\n<p>\n  The bipartite graph consists of vertices $$$(s_1, s_2, \\dots s_\\mathbf{B})$$$ and $$$(t_1, t_2, \\dots t_\\mathbf{B})$$$.\n  There is an edge $$$(s_u, t_v)$$$ if and only if $$$(u, v)$$$ is in $$$G$$$.  If we use an edge\n\tin the perfect matching, then we add the corresponding edge in $$$G$$$ to $$$A$$$.\n<p>\n  We need to show that a perfect matching exists in this graph if the problem instance is possible.\n\tTo do that, we apply\n\t<a href=\"https://en.wikipedia.org/wiki/Hall%27s_marriage_theorem\" target=\"_blank\">Hall's marriage theorem</a>,\n\twhich is a common technique for proving whether a graph has a perfect matching.\n<p>\n  What we need to prove to use the theorem is the following: if there is a solution to the problem,\n\tthen for any subset $$$S$$$ of the nodes$$$(s_1, s_2, \\dots s_\\mathbf{B})$$$,\n  let $$$T$$$ be the set of all nodes adjacent to a node in $$$S$$$.\n\tThen $$$|S| \\leq |T|$$$.\n\t(We must also show that a similar result holds if we start with a subset of the nodes\n\t$$$(t_1, t_2, \\dots t_\\mathbf{B})$$$, but the proof for that is the same.)\n<p>\n\tAssume there is a solution to the problem, which has a corresponding multigraph $$$G'$$$, in which\n\tthe indegree and outdegree of each node is $$$k$$$.\n<p>\n\tFor each $$$i$$$, let $$$g(s_i)$$$ be the number of edges in $$$G'$$$ whose tail is node $$$i$$$.\n<p>\n\tFor each $$$i$$$, let $$$g(t_i)$$$ be the number of edges in $$$G'$$$ whose head is node $$$i$$$.\n<p>\n\tNow for any pair of $$$S$$$ and $$$T$$$ above,\n  $$$\\begin{equation} \\sum_{s \\in S}{g(s)} \\leq \\sum_{t \\in T}{g(t)} \\end{equation}$$$\n\tsince the edges\tin $$$G'$$$ whose head is in $$$T$$$ must include all the edges in $$$G'$$$ whose\n\ttail is in $$$S$$$, plus possibly some more.\n\tBut because $$$G'$$$ corresponds to a solution, the values of $$$g$$$ must all be equal to $$$k$$$.\n\tSo we can conclude that $$$|S| \\leq |T|$$$ as required.\n<p>\n\tBut this is not exactly the bipartite matching problem we need to solve - we need to include some\n\tfixed edge $$$(s_u, t_v)$$$ in the matching each time.  So remove all other edges adjacent to\n\t$$$s_u$$$ or $$$t_v$$$ from the bipartite graph, and now define $$$g$$$ as follows:\n<p>\n\tFor each $$$i$$$, let $$$g(s_i)$$$ be the number of edges in $$$G'$$$ whose tail is node $$$i$$$,\n\texcluding those edges\tdeleted from the bipartite graph.\n<p>\n\tFor each $$$i$$$, let $$$g(t_i)$$$ be the number of edges in $$$G'$$$ whose head is node $$$i$$$,\n\texcluding those edges\tdeleted from the bipartite graph.\n<p>\n\tConsider a set $$$S$$$ which does not contain $$$s_u$$$.\n<p>\n\t$$$\\begin{equation} k|S|-k \\lt \\sum_{s \\in S}{g(s)}\\end{equation}$$$, since less than $$$k$$$\n\tedges were removed from the graph.\n\tAlso, $$$\\begin{equation} \\sum_{t \\in T}{g(t)} \\leq k|T| \\end{equation}$$$ since $$$k$$$ is still\n\tthe maximum value of any $$$g(t)$$$.\n\tWe still have $$$\\begin{equation} \\sum_{s \\in S}{g(s)} \\leq \\sum_{t \\in T}{g(t)} \\end{equation}$$$\n\tas before, so\n<p>\n\t$$$\\begin{equation} k|S|-k \\lt \\sum_{s \\in S}{g(s)} \\leq \\sum_{t \\in T}{g(t)} \\leq k|T| \\end{equation}$$$\n<p>\n\t$$$\\begin{equation}\\therefore k|S|-k \\lt k|T| \\end{equation}$$$\n<p>\n\t$$$\\begin{equation}\\therefore |S|-1 \\lt |T| \\end{equation}$$$\n<p>\n\t$$$\\begin{equation}\\therefore |S| \\leq |T| \\end{equation}$$$ as required.\n<p>\n\tThe same result holds for sets $$$S$$$ which do contain $$$s_u$$$, since we simply match $$$s_u$$$\n\twith $$$t_v$$$ and are left with a set $$$S$$$ without $$$s_u$$$ and we can proceed as above.\n<p>\n  If we fail to find a perfect matching for any edge $$$(s_u, t_v)$$$,\n  then we can deduce that it's impossible to find a solution to the problem.\n<p>\n\tThis application of Hall's marriage theorem is also known as\n\t<a href=\"https://en.wikipedia.org/wiki/Birkhoff_algorithm\" target=\"_blank\">Birkhoff's theorem</a>\n\ton\n\t<a href = https://en.wikipedia.org/wiki/Doubly_stochastic_matrix>doubly stochastic matrices</a>.\n<p>\n  In the current approach, we find a perfect matching on $$$\\mathbf{S}$$$ different bipartite graphs.\n  Each of them has $$$O(\\mathbf{B})$$$ vertices and $$$O(\\mathbf{S})$$$ edges.\n  The total time complexity is $$$O(\\mathbf{BS^2})$$$ if we use a flow-based algorithm.\n<p>\n  However, this approach can still be optimized further.\n  We can make use of a previous result to avoid re-calculating the whole matching every time.\n<p>\n  We first find an arbitrary perfect matching as the base matching.\n  Then, for each edge $$$(s_u, t_v)$$$, if it's not in the base matching, we remove the edges from\n\tthe matching that\twere adjacent to $$$s_u$$$ and $$$t_v$$$, and add the edge $$$(s_u, t_v)$$$.\n  This would make exactly two vertices unmatched (those who originally matched with $$$s_u$$$ and $$$t_v$$$ in the base matching),\n  and we could find the new matching by searching for an augmenting path between the two unmatched vertices.\n<p>\n  Finding the base matching takes $$$O(\\mathbf{BS})$$$ time, and for each edge $$$(s_u, t_v)$$$, it takes $$$O(\\mathbf{S})$$$ time to find an augmenting path.\n  There are $$$\\mathbf{S}$$$ edges in the bipartite graph, so the total time complexity is $$$O(S^2)$$$.\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2EH4-hEQuv6GQOU9WGaujeKqWK1tpsHF0Ss8GiWY20XenMzaZOELLK6R6LJok5wFP5cMD8fZUB/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b9cb13","statement":"<h3>Problem</h3>\n\n<p>\nGooli is a huge company that owns $$$\\mathbf{B}$$$ buildings in a hilly area, numbered $$$1$$$ through $$$\\mathbf{B}$$$. Six years ago, Gooli\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000201bef/0000000000201d18\" target=\"_blank\">\nbuilt slides</a> that allowed employees to go from one building to another.\nEach slide allows anyone to go from the slide's origin building to the slide's destination\nbuilding, but not the other way around.\nGooli's CEO is very proud of their slides and wants to organize a parade through the slides.\nShe has tasked Melek, Gooli's Head of Transportation and a problem-solving enthusiast, with\ndesigning the parade's route.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3iK_tj52ZxLl8ZB6ffJF2mScvkUAEjzF8U9_dn1xjm-rdDzNYKQpWz4MjjzaCc__qj-ayJRnWJ094CmjP4el0JxXBrdRj13RI/slide_parade_example_5.png\" alt=\"Illustration of Sample Case #5.\"/>\n</p><p>\nShe has some requirements for the parade route in mind:\n</p>\n<ul>\n  <li>It must start and end at building $$$1$$$, where her office is located.</li>\n  <li>It must visit each building the same number of times. Being in building $$$1$$$ at the\n    start of the route does not count as a visit.</li>\n  <li>It must use each slide at least once.</li>\n  <li>It must have at most $$$10^6$$$ steps.</li>\n</ul>\n<p>\nGiven the layout of buildings and slides, help Melek find a route that satisfies\nall of the CEO's requirements, if one exists.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case starts with a line containing two integers $$$\\mathbf{B}$$$ and $$$\\mathbf{S}$$$: the\nnumber of buildings and slides, respectively.\nThen, $$$\\mathbf{S}$$$ lines follow. The $$$i$$$&NoBreak;-&NoBreak;th of these lines contains two integers\n$$$\\mathbf{U_i}$$$ and $$$\\mathbf{V_i}$$$, indicating that the $$$i$$$&NoBreak;-&NoBreak;th slide goes from\nbuilding $$$\\mathbf{U_i}$$$ to building $$$\\mathbf{V_i}$$$.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1). If there is no route that\nfulfills all the requirements, $$$y$$$ must be <code>IMPOSSIBLE</code>. If there is,\n$$$y$$$ must be an integer between $$$\\mathbf{S}+1$$$ and $$$10^6+1$$$, inclusive,\nrepresenting the length of one such route you want to exhibit. In that case,\noutput another line containing $$$y$$$ integers $$$z_1\\ z_2\\ \\dots\\ z_y$$$,\nwhere $$$z_j$$$ is the\n$$$j$$$&NoBreak;-&NoBreak;th building in your proposed route. Notice that\n$$$z_1 = z_y = 1$$$ and that each building must appear the same number of times among\nthe $$$z_j$$$, except for building $$$1$$$, which appears exactly one extra time.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n$$$1 \\le \\mathbf{U_i} \\le \\mathbf{B}$$$, for all $$$i$$$.<br/>\n$$$1 \\le \\mathbf{V_i} \\le \\mathbf{B}$$$, for all $$$i$$$.<br/>\n$$$\\mathbf{U_i} \\ne \\mathbf{V_i}$$$, for all $$$i$$$.<br/>\n$$$(\\mathbf{U_i}, \\mathbf{V_i}) \\neq (\\mathbf{U_j}, \\mathbf{V_j})$$$, for all $$$i \\neq j$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 10 seconds.<br/>\n\n$$$2 \\le \\mathbf{B} \\le 10$$$.<br/>\n$$$2 \\le \\mathbf{S} \\le 10$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n\n$$$2 \\le \\mathbf{B} \\le 200$$$.<br/>\n$$$2 \\le \\mathbf{S} \\le 5000$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3mzGdsQsqYtQJ1fQ0E10OmLEDk4649f6EiV971hgcc9_NtEX9hnD2AAh-3pXcBO1CN9vkegtIbm8iP0cSjw6Zgh8tyOHTe3DE2ugk/slide_parade_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">5\n2 2\n2 1\n1 2\n3 4\n2 3\n1 2\n3 2\n1 3\n3 6\n1 2\n1 3\n2 1\n2 3\n3 1\n3 2\n3 4\n1 2\n2 1\n1 3\n3 1\n4 6\n1 2\n1 4\n2 3\n3 2\n3 4\n4 1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2qqgPqupjiwjw59_MdMe5W_l72Nq2yUbhmm8Tyv4ARjho-ImkgwPsL_bS1NJ0007MySGcOjui6eOlKdY_3nNBuJSC-CPwqEnEK6TPE/slide_parade_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 7\n1 2 1 2 1 2 1\nCase #2: IMPOSSIBLE\nCase #3: 7\n1 2 3 1 3 2 1\nCase #4: IMPOSSIBLE\nCase #5: 9\n1 4 1 2 3 2 3 4 1\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, another acceptable parade route is one that goes from building $$$1$$$ to\n  building $$$2$$$ and then back for a total of $$$2$$$ steps.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2DggyBugmuELIs18F3xqZW02Ar7fuQ2_C9wR_5-3AkXyqTeM-4oEdACqTXy81PFjzRUrUSsTiWFPpMwqJbwufCJ0u3_9PnY3I/slide_parade_example_1.png\" alt=\"Illustration of Sample Case #1.\"/>\n</p><p>\n  In Sample Case #2, there are no slides leading to building $$$1$$$, so no valid parade can exist.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2X3wqxl8PcYGgOj1j04I7gtPcG_RgYm5DCMhb6neFKzz9a113aOeEsOhV7fehnQMA05AYLMgrhuB8a7s2Fvtdl-aY8qSf_x_s/slide_parade_example_2.png\" alt=\"Illustration of Sample Case #2.\"/>\n</p><p>\n  In Sample Case #3, the parade route the sample output exhibits goes through each building twice.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2ojL_uYZlpaF0Mz5mGCZVcu1Q_icpWojzIyBnOoJUrhltH9SzKecuhyjw9d4rrPVnwBfYtwkUwu_ZKh_EQsFeNi2Mvfssb31I/slide_parade_example_3.png\" alt=\"Illustration of Sample Case #3.\"/>\n</p><p>\n  Sample Case #4 is pictured below.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U37spoDZ8lk2fVo_Y9OJQanVPcXyIih23A6GbVCO72i6gt5rwQVmNXyr0pQAgaXWOyhzoK2-NBWQ9NcvZggIDxMac3_M8C7WsQ/slide_parade_example_4.png\" alt=\"Illustration of Sample Case #4.\"/>\n</p><p>\n  Sample Case #5 is the one illustrated in the problem statement. In the parade route in the sample output,\n  the slides from $$$2$$$ to $$$3$$$ and\n  from $$$4$$$ to $$$1$$$ are used twice, but the rest of the slides are used only once each.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Slide Parade","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n<a href=\"https://en.wikipedia.org/wiki/Consistency\" target=\"_blank\">Consistency</a>\nin this problem has a property which is not true for most typical logic systems, in that\na set of statements is consistent if and only if each subset of size $$$2$$$ of it is consistent.\nThe left to right implication is trivial, but the converse is not, so let us prove it.\n</p><p>\nAssume you have a set of statements $$$S$$$ such that any two of them are consistent. Then, for\neach bird $$$b$$$, consider all statements that state that $$$b$$$ is at a specific point in\ntime and space. If we sort all those points by time and\n<a href=\"https://en.wikipedia.org/wiki/Linear_interpolation\" target=\"_blank\">linearly\ninterpolate</a> between\nconsecutive points, we obtain a path for $$$b$$$ that is consistent with all statements in $$$S$$$.\nNotice that, because any pair of statements is consistent &mdash; in particular, pairs of consecutive\nstatements &mdash; the linear interpolation part does not exceed the maximum speed. In this way,\nwe can obtain a path for each mentioned bird, all of which are consistent with all statements.\nThen, by definition, $$$S$$$ is consistent.\n</p><p>\nMeetings also state \"this bird was at this time-space point\" for birds that are ducks.\nThus, an analogous reasoning shows that a set of statements and known ducks is consistent\nwith the meetings if and only if they are pairwise consistent. Since the meetings are pairwise\nconsistent according to the limits, this leaves only pairs of two statements and pairs of\na statement a meeting to check.\n</p><p>\nAt this point, with the limits in Test Set 1 being so small, we can simply try everything. We know\nthere is at least one duck, so start by trying every bird as \"the first duck\". Within each option,\ngo through statements and check them against meetings\n(if they involve a known duck) and against previous statements. If a statement contradicts a\nmeeting, the issuer of that statement must be a duck. If a statement contradicts a previous\nstatement, then the issuer of such previous statement must be a duck (since ducks cannot contradict\ngeese). Each time we find a new duck, we start checking everything again. When we go through all\nstatements without finding any contradictions with our current set of ducks, we are done and we\nhave a candidate set of ducks. Notice that all birds being ducks is always a valid answer.\nFinally, we keep the smallest set of ducks and output its size.\n</p><p>\nThis solution requires $$$\\mathbf{N}$$$ iterations of the outer loop, to try every possible \"first duck\".\nChecking a pair of statements or a statement and a meeting for consistency\ntakes constant time, as it is only checking whether birds that are mentioned in both can get\nfrom one point in space-time to another, which is a simple bit of math.\nThus, checking every statement against every other statement and every meeting takes\n$$$O(\\mathbf{S} \\times (\\mathbf{S} + \\mathbf{M}))$$$. On every iteration through statements except for one (the\nlast one) we find at least one additional duck, so there are at most $$$\\mathbf{N} - 1$$$ iterations\n(remember we start with an identified duck). Therefore, the overall running time is\n$$$O(\\mathbf{N}^2 \\times \\mathbf{S} \\times (\\mathbf{S} + \\mathbf{M}))$$$. With all those variables being bounded by\n$$$50$$$, that should fit in time.\n</p>\n<h3>Test Set 2</h3>\n<p>\nIn Test Set 2, we need to speed up things significantly. We can start by making use of a more\nrefined version of our consistency observations. As you can see in the proof, we do not need\nto require every pair of statements or a statement and a meeting to be consistent: only those\nthat are \"consecutive\".\n</p><p>\nFormally, let us call two statements $$$s_1$$$ and $$$s_2$$$\nconsecutive in $$$S$$$ if they refer to times $$$t_1$$$ and $$$t_2$$$,\nrespectively, and to bird $$$b$$$, and there is no other statement in $$$S$$$ that\nrefers to a time $$$t_3$$$ such that $$$t_1 \\lt t_3 \\lt t_2$$$ and to bird $$$b$$$.\nSimilarly, let us call a statement $$$s$$$ in $$$S$$$ that refers to time $$$t_1$$$\nand a meeting $$$m$$$ at time $$$t_2$$$ consecutive if there is no other meeting at time $$$t_3$$$\nsuch that $$$t_1 \\lt t_3 \\lt t_2$$$.\nNotice that consecutive is not a total order, because of statements referring to the same time.\nHowever, making it a total order by breaking ties arbitrarily maintains the validity of the\ntheorem.\n</p><p>\nThen, we can say that a set $$$S$$$ of statements and/or meetings with known ducks is\nconsistent if and only if any consecutive pair of them is consistent. The proof is the same\nas the one given above.\n</p><p>\nWith the observation above, if we can maintain a sorted list of meetings and goose-made statements\nabout each bird, we can check the consistency for each statement $$$s$$$ in logarithmic time by\nonly checking its consecutive neighbors (at most $$$2$$$ meetings and $$$2$$$ statements per\nbird in $$$s$$$). This would already reduce the $$$O(\\mathbf{S} \\times (\\mathbf{S} + \\mathbf{M}))$$$ inner-most  \ncheck in the Test Set 1 solution to logarithmic time, a significant improvement.\n</p><p>\nTo maintain that, we can keep a tree structure that allows insertion and lookup\nin logarithmic time for each bird (like <code>set</code> in C++ or <code>TreeSet</code> in Java).\nIn this way, every time we process a statement, we simply add the new information to the \nappropriate birds.\n</p><p>\nWe can further improve by not resetting every time we find a duck. If our structure also allows\nremoval in logarithmic time (like the examples above), we can do the following:\nWhen we discover a duck, delete all information coming from their\nstatements. For that, we keep a list for each bird of all information they contributed. Since\neach piece of information is removed at most once, the overall number of removals is at most\nthe overall number of insertions and does not affect the time complexity.\n</p><p>\nAt this point we have reduced the complexity to $$$O(\\mathbf{N} \\times (\\mathbf{S} + \\mathbf{M}) \\times F)$$$ where\n$$$F$$$ is only logarithmic factors. The $$$\\mathbf{N}$$$ comes from the external \"first duck\" iteration.\nTo improve upon that, we can first notice that, if we start from the empty set of ducks and\nstill find some, those birds must always be ducks, and would be ducks when starting from any set.\nTherefore, in that case, that set of ducks is the answer. If there are no forced ducks, we need to do\nsomething different, but we know there is no inconsistency between statements.\n</p><p>\nAt this point, we only need to check consistency between statements and meetings. A statement\nbeing inconsistent with a meeting is equivalent to a bird $$$b_1$$$ saying that bird $$$b_2$$$\nis not a duck. Therefore, if $$$b_2$$$ were a duck, so would $$$b_1$$$. We can represent the\nsituation with a <a href=\"https://en.wikipedia.org/wiki/Directed_graph\" target=\"_blank\">directed\ngraph</a>\nin which the edges represent these implications. If there is a path in that graph\nfrom $$$b_1$$$ to $$$b_2$$$, then there is an implication (possibly not coming directly from\na single statement) that if $$$b_1$$$ is a duck, then so is $$$b_2$$$. So, if a bird is a duck,\nthen so is every other bird in its\n<a href=\"https://en.wikipedia.org/wiki/Strongly_connected_component\" target=\"_blank\">strongly\nconnected component</a> (SCC). That means we want to choose an SCC that is as small as possible.\nMoreover, we want to choose a final component, that is, one that is not pointed to by other\ncomponents. Non-final components imply other components also being made of ducks, and\nultimately bringing in at least one final component. In summary, in this final case the answer\nis the size of the smallest final SCC, which we can\n<a href=\"https://en.wikipedia.org/wiki/Strongly_connected_component#Algorithms\" target=\"_blank\">\nfind in linear time</a>.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3LkArbHqwSp1sSZjVtL-yytDfcvucfz7ojR8c2MIW0dvSU7mJnX1WLtEex-gw2kupr-RKJU_TE/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000b9ce14","statement":"<h3>Problem</h3>\n\n<p>\nThe first international Geese conference just wrapped up, and even though it should have been a\nhappy occasion, it was bittersweet. The organizers found a paper with detailed plans of a duck\ninfiltration. Now, they are trying to identify the infiltrating group from among the attendees.\n</p><p>\nThe document that they found contained a list of $$$\\mathbf{M}$$$ triples of integers\n$$$(\\mathbf{X_i}, \\mathbf{Y_i}, \\mathbf{C_i})$$$ meaning the ducks would meet exactly $$$\\mathbf{C_i}$$$ seconds after the\nstart of the conference at point $$$(\\mathbf{X_i}, \\mathbf{Y_i})$$$, which is $$$\\mathbf{X_i}$$$ meters east and\n$$$\\mathbf{Y_i}$$$ meters north of the center of the conference floor.\nEach goose may or may not have been at those specific points at\nthose specific times, but every duck certainly was.\n</p><p>\nBoth ducks and geese walk at a maximum speed of one meter per second,\nwhich means an attendee that is at point $$$(x, y)$$$ at time\n$$$t$$$ can reach any point of the form $$$(x + \\Delta_{x}, y + \\Delta_{y})$$$\nby time $$$t + \\Delta_{t}$$$ as long as\n$$${\\Delta_{x}}^2 + {\\Delta_{y}}^2 \\le {\\Delta_{t}}^2$$$.\nEach attendee's position at time $$$0$$$ can be any point, independently of the other attendees.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3UAEiKO049dVNNTmHvu6JDoS03xwc1WfUTVqJCeMspGoALz2JuZjxPqMyUlNIsv0VcFqbLvTd3dL9BLXZ8OeLVFDvI/goose_goose_ducks.png\" alt=\"A picture of two geese and one duck.\" style=\"border: 1px solid black\"/>\n</p><p>\nAfter the discovery, the group held a questioning session to try to identify the ducks.\nDuring that session, attendees issued a series of statements, one at a time.\nThe $$$j$$$-th of those, in the order they were issued, was made by attendee $$$\\mathbf{A_j}$$$,\nclaiming that both they and attendee $$$\\mathbf{B_j}$$$\nwere at point $$$(\\mathbf{U_j}, \\mathbf{V_j})$$$ exactly $$$\\mathbf{D_j}$$$ seconds after the start of the conference.\nPoints in statements may or may not be points where duck meetings happened.\n</p>\n<p>\n  Statements from geese are always true, but ducks may lie.\n  Moreover, ducks know which attendees are ducks and which are geese. To avoid getting caught\n  easily, ducks only make statements that are consistent with all statements previously made\n  by geese. Note that statements made by geese are consistent\n  with all ducks being at all duck meetings.\n</p><p>\n  It may not be possible to determine all the ducks with the information provided.\n  However, knowing the minimum number of ducks\n  will at least provide a lower bound on the level of duck activity. Note that there was at least\n  one duck. Find this minimum number of ducks.\n</p>\n<p>\nFormally, a <i>hypothesis</i> $$$H$$$ is a partition of all attendees into a set of ducks\n(named $$$H$$$-ducks) and geese (named $$$H$$$-geese).\n$$$H$$$ is consistent with a set of statements $$$S$$$\nif there exists a path for each attendee moving at most one meter per second\nsuch that:\n</p>\n<ul>\n  <li>all $$$H$$$-ducks were at all duck meetings and</li>\n  <li>for each statement in $$$S$$$ claiming that $$$A$$$ saw $$$B$$$ at point $$$P$$$ at time $$$T$$$,\n    both $$$A$$$ and $$$B$$$&NoBreak;'s paths went through point $$$P$$$ at time $$$T$$$.</li>\n</ul>\n<p>\nA hypothesis $$$H$$$ is <i>feasible</i> under a set of statements $$$S$$$ if:\n</p>\n<ul>\n  <li>$$$H$$$-ducks is not empty <i>(i.e., there was at least one duck)</i>,</li>\n  <li>the subset of all statements from $$$S$$$ made by members of $$$H$$$-geese is consistent with $$$H$$$ <i>(i.e., statements from geese are always true), and</i></li>\n  <li>for each statement $$$s \\in S$$$ made by a member of $$$H$$$-ducks, if $$$P \\subseteq S$$$ is the subset\n    of statements made by members of $$$H$$$-geese issued before $$$s$$$, there exists a hypothesis $$$H'$$$\n    (which may or may not be equal to $$$H$$$) such that $$$\\{ s \\} \\cup P$$$ is consistent\n    with $$$H'$$$ <i>(i.e., ducks do not contradict previous statements made by geese).</i></li>\n</ul>\n<p>\nNotice that the hypotheses $$$H$$$ such that $$$H$$$-ducks contains all attendees is always feasible.\n</p><p>\nFind the minimum size of $$$H$$$-ducks over all feasible hypotheses $$$H$$$.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case starts with a line containing three integers, $$$\\mathbf{N}$$$, $$$\\mathbf{M}$$$, and $$$\\mathbf{S}$$$, representing\nthe numbers of attendees, duck meetings, and statements, respectively.\nThe next $$$\\mathbf{M}$$$ lines each describe a different duck meeting with\nthree integers $$$\\mathbf{X_i}$$$, $$$\\mathbf{Y_i}$$$, and $$$\\mathbf{C_i}$$$, representing that there was a meeting at point\n$$$(\\mathbf{X_i}, \\mathbf{Y_i})$$$, held exactly $$$\\mathbf{C_i}$$$ seconds after the start of the conference. Then, the last\n$$$\\mathbf{S}$$$ lines of a test case each describe a statement. The $$$j$$$-th of these lines describes\nthe $$$j$$$-th issued statement with five integers $$$\\mathbf{A_j}$$$, $$$\\mathbf{B_j}$$$, $$$\\mathbf{U_j}$$$, $$$\\mathbf{V_j}$$$, and $$$\\mathbf{D_j}$$$,\nrepresenting that attendee $$$\\mathbf{A_j}$$$ stated that they and attendee $$$\\mathbf{B_j}$$$ were both at point\n$$$(\\mathbf{U_j}, \\mathbf{V_j})$$$ exactly $$$\\mathbf{D_j}$$$ seconds after the start of the conference.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is the minimum number of ducks\nthat might have infiltrated the conference.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 50$$$.<br/>\n$$$-10^9 \\le \\mathbf{X_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n$$$-10^9 \\le \\mathbf{Y_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n$$$1 \\le \\mathbf{C_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n$$$\\mathbf{C_i} \\lt \\mathbf{C_{i+1}}$$$, for all $$$i$$$.<br/>\n$$$(\\mathbf{X_i} - \\mathbf{X_{i+1}})^2 + (\\mathbf{Y_i} - \\mathbf{Y_{i+1}})^2 \\le (\\mathbf{C_i} - \\mathbf{C_{i+1}})^2$$$, for all $$$i$$$.<br/>\n$$$1 \\le \\mathbf{A_j} \\le \\mathbf{N}$$$, for all $$$j$$$.<br/>\n$$$1 \\le \\mathbf{B_j} \\le \\mathbf{N}$$$, for all $$$j$$$.<br/>\n$$$\\mathbf{A_j} \\ne \\mathbf{B_j}$$$, for all $$$j$$$.<br/>\n$$$-10^9 \\le \\mathbf{U_j} \\le 10^9$$$, for all $$$j$$$.<br/>\n$$$-10^9 \\le \\mathbf{V_j} \\le 10^9$$$, for all $$$j$$$.<br/>\n$$$1 \\le \\mathbf{D_j} \\le 10^9$$$, for all $$$j$$$.<br/>\n$$$(\\mathbf{A_j}, \\mathbf{B_j}, \\mathbf{U_j}, \\mathbf{V_j}, \\mathbf{D_j}) \\ne (\\mathbf{A_k}, \\mathbf{B_k}, \\mathbf{U_k}, \\mathbf{V_k}, \\mathbf{D_k})$$$, for all $$$j \\ne k$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n\n$$$2 \\le \\mathbf{N} \\le 50$$$.<br/>\n$$$1 \\le \\mathbf{M} \\le 50$$$.<br/>\n$$$1 \\le \\mathbf{S} \\le 50$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n\n  $$$2 \\le \\mathbf{N} \\le 10^5$$$.<br/>\n  $$$1 \\le \\mathbf{M} \\le 10^5$$$.<br/>\n  $$$1 \\le \\mathbf{S} \\le 10^5$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3p3CAH7wVqW0fWl9UOtSdpIS5tcmQmF8zRaoYz68jlDf-AuNEjKWeT83MVROtAYM2ocS_1XWdCpa2C2ZxH6HRitOmdg0ZPkHIclhlR1oxujg/goose_goose_ducks_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n2 1 2\n1 2 3\n1 2 1 1 1\n2 1 2 2 2\n4 2 4\n4 3 10\n-4 -3 20\n1 3 4 3 11\n2 4 0 0 16\n3 1 6 3 9\n4 2 0 0 16\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0CJjxBd0CK3h2daMJw_G_-txN40rQWaXO1tzh62R1-Jq7vFwjBi2Hrmqm2VqoR3yeBybCZxXsKXxZSNEfeGI6zkxOPr1Zub5NP1lsq3w_hUTQ/goose_goose_ducks_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 1\nCase #2: 2\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, attendee 1 being the only duck is a feasible hypothesis.\n</p><p>\n  In Sample Case #2, attendees 2 and 4 being the only ducks is a feasible hypothesis.\n  Note that there is at least one duck, so all attendees being geese is not feasible.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Goose, Goose, Ducks?","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000087762e","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2022","ui_appearance":0,"ui_appearance__str":"APPEARANCE_TYPE_DEFAULT"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
