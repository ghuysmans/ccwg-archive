{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1431257400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433b4d","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nEven though about 2000 contestants had already advanced from Rounds 1A and 1B and weren't in the field for this round, Round 1C was still no picnic.  To advance, contestants needed to solve at least two complete problems, or at least three small inputs and one large input with a fast enough time.\n</p>\n<p>\nThe problems were slightly easier than previous rounds.  <i>Brattleship</i> involved finding a winning strategy in a simple game.  The small input had one-dimensional boards, and the large input had two-dimensional boards, so coders had to take additional care before submitting their large input as the small input was not a comprehensive set of cases against which to test their code.  3434 people solved the small input correctly, and almost all of them attempted the large as well, but only two thirds of those attempts passed.\n</p>\n<p>\n<i>Typewriter Monkey</i> could be solved easily in linear time with some insights about string matching and probability.  However, a slower approach using dynamic programming could solve it as well.  The limits were set small enough that a brute force algorithm could solve the small input too.\n</p>\n<p>\nThe solution to <i>Less Money, More Problems</i> seems simple, but it was still somewhat difficult to figure out the correct approach.\n</p>\n<p>\nThere were 4312 contestants who downloaded at least one input file in Round 1C. 84% of the contestants solved at least one input file, and 132 contestants got a perfect score.\n</p>\n<p>\nCongratulations to everyone who has now advanced to Round 2!\n</p>\n<hr>\n<p>\nCast\n</p>\n<p>\nProblem A. <i>Brattleship</i> written and prepared by Ian Tullis.\n</p>\n<p>\nProblem B. <i>Typewriter Monkey</i> written by Ian Tullis.  Prepared by Carlos Guía Vera.\n</p>\n<p>\nProblem C. <i>Less Money, More Problems</i> written by Ian Tullis.  Prepared by David Gómez Cermeño.\n</p>\n<p>\nSolutions and other problem preparation by\nAhmed Aly,\nDavid Gómez Cermeño,\nDavid Spies,\nFelix Halim,\nIan Tullis,\nIgor Naverniouk,\nIlham Kurnia,\nJackson Gatenby,\nJohn Dethridge,\nJonathan Paulson, and\nKarim Nosir\n</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1431248400000,"tasks":[{"analysis":"<p>\nThis problem naturally has two parts &mdash; computing the maximum number of bananas needed, and computing the expected number of bananas needed.\n</p>\n\n<p>\nTake, for example, the target string X = ABACABA.  To find a string of length S containing the maximum number of copies of X, we start by putting X at the start of the string.  Then to fit as many more copies as possible, we want to overlap each copy of X as much as possible with the previous copy.  For this example, we could overlap with the final \"A\" and add \"BACABA\", but it is even better to overlap with \"ABA\" and add just \"CABA\" to get a second copy.  To find the maximum amount of overlap, we can just try every possible amount and check which ones work, since L is small.  It can also be computed in linear time using the initialization phase of the <a href=\"https://www.google.com/search?q=knuth+morris+pratt\" target=\"_blank\">Knuth-Morris-Pratt algorithm</a>.  If the maximum amount of overlap is O, then we can fit 1+(S-L)/(L-O) copies of the string.\n</p>\n\n<p>\nTo find the expected number of copies, we start by computing the probability P of the word occurring at a fixed place.  This is equal to the product of the probabilities for each letter of the word being correct.  The probability for a single letter being correct is the fraction of keys which are that letter.\n</p>\n\n<p>\nBy <a href=\"https://www.google.com/search?q=linearity+of+expectation\" target=\"_blank\">linearity of expectation</a>, the expected number of copies is then just P multiplied by the number of places the string can occur, which is S-L+1.  This is a convenient fact to use, because we don't need to take into account that the string occurring in one position and the string occurring in an overlapping position are not independent events.\n</p>\n\n<p>Sample implementation in Python:</p>\n<pre>\n# Find the maximum amount of overlap. We can just try\n# every possible amount and check which ones work.\ndef max_overlap(t):\n  for i in range(1, len(t)):\n    if t[i:] == t[0:len(t)-i]:\n      return len(t) - i\n  return 0\n\n# Returns the probability of the target word\n# occurring at a fixed place.\ndef probability(target, keyboard):\n  P = 1.0\n  # Compute the product of the probabilities \n  # for each letter of the word being correct.\n  for i in range(len(target)):\n    # The probability for a single letter being correct\n    # is the fraction of keys which are that letter.\n    C = keyboard.count(target[i])\n    P = P * C / len(keyboard);\n  return P\n\nfor tc in range(input()):\n  K, L, S = map(int, raw_input().split(' '))\n  keyboard = raw_input()\n  target = raw_input()\n  res = 0\n  P = probability(target, keyboard)\n  if P &gt; 0:\n    O = max_overlap(target)\n    max_copies = 1.0 + (S-L) / (L-O)\n    min_copies = P * (S-L+1)\n    res = max_copies - min_copies\n  print(\"Case #%d: %f\" % (tc + 1, res))\n\n</pre>\n\n<p>\nKlockan wrote a solution in C++ that also uses this approach, which you can download from the scoreboard.\n</p>\n\n<p>\nWe could also use a dynamic programming algorithm for both parts of the problem, using O(LS) states, where the state is the number of characters typed and the largest number of characters of the word that are currently matched, and the value at each state is the probability of that state and the maximum number of copies of the word that could have been produced while reaching it.  For each of the states where the entire word has just been matched, we add the probability of reaching that state to the expected number of copies of the word, and update the maximum number of copies that are possible.  linguo wrote a solution of this type in Python.\n</p>\n","id":"0000000000433411","statement":"<h3>Problem</h3>\n<p>\nYour publishing house has decided to use monkeys randomly typing at keyboards to write great works of literature. You are the supervisor for one monkey with a keyboard containing <b>K</b> keys, each of which is labeled with an uppercase English letter. (There may be multiple keys displaying the same letter.) The monkey will start with an empty string and repeat the following <b>S</b> times: choose a key from its keyboard uniformly at random and press it, adding a copy of that key's letter to the right end of the string. The final resulting string will have length <b>S</b>.<br>\n<br>\nYou have a <i>target word</i> of length <b>L</b> that you are hoping the monkey will type. (The target word will not necessarily be a real English word.) This target word may even appear multiple times in what the monkey types. (Overlapping instances count too -- for example, if \"ABA\" is the target word and the monkey types \"ABABA\", that contains two instances of the target.)<br>\n<br>\nYou plan to pay the monkey one banana for each instance of the target word that it types. When you go to inspect the monkey's work, you will bring along the minimum number of bananas that you need to <i>ensure</i> that you will always have enough bananas to pay the monkey, no matter what it has typed. Then, you will pay the monkey one banana for each instance of the target word that it <i>actually</i> typed. You will keep the remaining bananas that you brought with you.<br>\n<br>\nWhat is the expected number of bananas that you will get to keep?<br>\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow. Each consists of three lines. The first contains three space-separated positive integers: <b>K</b>, <b>L</b>, and <b>S</b>. The second contains a string of <b>K</b> uppercase English letters representing the monkey's keyboard. The third contains a string of <b>L</b> uppercase English letters representing the target word.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where y is the expected number of bananas you will get to keep after paying the monkey.\n</p>\ny will be considered correct if it is within an absolute or relative error of 10<sup>-6</sup> of the correct answer.  See the <a href=\"/codejam/faq.html#floating_point\" target=\"_blank\">FAQ</a> for an explanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>K</b> &le; 7.<br/>\n1 &le; <b>L</b> &le; <b>S</b> &le; 7.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>K</b> &le; 100.<br/>\n1 &le; <b>L</b> &le; <b>S</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n7 6 6\nBANANAS\nMONKEY\n2 3 4\nAA\nAAA\n2 1 2\nAB\nB\n6 2 2\nGOOGLE\nGO\n26 11 100\nABCDEFGHIJKLMNOPQRSTUVWXYZ\nROSENCRANTZ\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.0\nCase #2: 0.0\nCase #3: 1.0\nCase #4: 0.8888889\nCase #5: 9.0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nNote that Case #5 is not within the limits for the Small dataset.<br>\n<br>\nIn Case #1, the monkey has no chance of typing the target word \"MONKEY\" even once (because his keyboard lacks most of the letters in \"MONKEY\"), so you do not bring any bananas along when you visit, and of course you do not pay any. Poor monkey!<br>\n<br>\nIn Case #2, the monkey is guaranteed to type \"AAAA\", which has two overlapping instances of the target word \"AAA\". You will bring two bananas and then pay both.<br>\n<br>\nIn Case #3, the monkey will produce the following outputs with equal probability (1/4 each): \"AA\", \"AB\", \"BA\", \"BB\". These have 0, 1, 1, and 2 instances of the target word, respectively. You must bring 2 bananas to be ready for the \"BB\" case, but you will on average pay (0 + 1 + 1 + 2) / 4 = 1.<br>\n<br>\nIn Case #4, the monkey has a 1/3 chance of typing a \"G\" first and a 1/3 chance of typing an \"O\" second, for a 1/9 chance of typing \"GO\". You will bring one banana and give it up 1/9 of the time.<br>\n<br>\nIn Case #5, the monkey could in theory type \"ROSENCRANTZ\" up to nine times, but the chances of this happening even once are so small that they are negligible compared to the acceptable margin of error for answers.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Typewriter Monkey","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nWe will incrementally build a set S of denominations that solves the problem using the minimal number of additional denominations, by restricting ourselves to adding denominations from smallest to largest.\n</p>\n\n<p>\nAs we add denominations to S, we also maintain an integer N, which is the largest value such that we can produce each value up to and including N.  In fact, after all of our choices, S will be able to produce exactly the set of values from 0 to N, and no others.\n</p>\n\n<p>\nWhen we add a new denomination X to S, the new set of values we could produce include each of the values we could produce with the existing set S plus between 0 and C of the new denomination X.  If X is at most N+1, then this new set of values will be the set of all values from 0 to N+X*C, so we can update N to N+X*C.\n</p>\n\n<p>\nSo, we initialize S to the empty set, and N to 0.\n</p>\n\n<p>\nThen while N is less than V, we do the following:\n<ul>\n<li>Identify the smallest value we cannot produce: N+1.</li>\n<li>If there is still a pre-existing denomination which we haven't used, let the minimum such denomination be X.  If X is less than or equal to N+1, we add it to S, and update N to N+X*C.</li>\n<li>Otherwise, we have no way yet to produce N+1 using the denominations we have, so we must add to S a new denomination X between 1 and N+1.  This will increase N to N+X*C.  We use X=N+1.  No other choice for X could lead to a better solution, since for X=N+1, the set of values the new S will be able to produce is a superset of the values S would be able to produce with any other choice.</li>\n</ul>\n</p>\n\n<p>\nFinally, when we have a set S which can produce all values up to V, we output the number of new denominations we had to add.\n</p>\n\n<p>\nIn the above algorithm, the first option &mdash; using a pre-existing denomination &mdash; can only occur D times.  When the second option is chosen, N increases to (C+1)N+C.  Since we stop when N reaches V, this will occur O(log V) times.  So the overall time complexity is O(D+log(V)).\n</p>\n\n<p>\nSample implementation in Java:\n</p>\n\n<pre>\nimport java.util.*;\n\npublic class C {\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    int T = scan.nextInt();\n    for (int TC = 1; TC &lt;= T; TC++) {\n      int C = scan.nextInt();\n      int D = scan.nextInt();\n      int V = scan.nextInt();\n      Queue&lt;Integer&gt; Q = new ArrayDeque&lt;&gt;();\n      for (int i = 0; i &lt; D; i++) {\n        Q.add(scan.nextInt());\n      }\n\n      long N = 0;\n      int add = 0;\n      while (N &lt; V) {\n        // X = The smallest value we cannot produce.\n        long X = N + 1;\n        if (!Q.isEmpty() &amp;&amp; Q.peek() &lt;= X) {\n          // Use pre-existing denomination we haven't used.\n          X = Q.poll();\n        } else {\n          // No way to produce N+1, add a new denomination.\n          add++;\n        }\n        N += X * C;\n      }\n      System.out.printf(\"Case #%d: %d\\n\", TC, add);\n    }\n  }\n}\n</pre>\n\n<p>\nVitaliy's solution in C, which you can download from the scoreboard, is another good example of this approach.\n</p>\n","id":"0000000000433650","statement":"<h3>Problem</h3>\n<p>\nUp until today, the nation you live in has used <b>D</b> different positive integer denominations of coin for all transactions. Today, the queen got angry when a subject tried to pay his taxes with a giant sack of low-valued coins, and she just decreed that no more than <b>C</b> coins of any one denomination may be used in any one purchase. For instance, if <b>C</b> = 2 and the existing denominations are 1 and 5, it is possible to buy something of value 11 by using two 5s and one 1, or something of value 12 by using two 5s and two 1s, but it is impossible to buy something of value 9 or 17.<br>\n<br>\nYou cannot directly challenge the queen's decree, but you happen to be in charge of the mint, and you <i>can</i> issue new denominations of coin. You want to make it possible for <i>any</i> item of positive value at most <b>V</b> to be purchased under the queen's new rules. (Note that this may not necessarily have been possible before the queen's decree.) Moreover, you want to introduce as few new denominations as possible, and your final combined set of pre-existing and new denominations may not have any repeats.<br>\n<br>\nWhat is the smallest number of new denominations required?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each consists of one line with three space-separated values <b>C</b>, <b>D</b>, and <b>V</b>, followed by another line with <b>D</b> distinct space-separated values representing the preexisting denominations, in ascending order.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of new denominations required, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\nEach existing denomination &le; <b>V</b>. \n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n<b>C</b> = 1.<br/>\n1 &le; <b>D</b> &le; 5.<br/>\n1 &le; <b>V</b> &le; 30.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>C</b> &le; 100.<br/>\n1 &le; <b>D</b> &le; 100.<br/>\n1 &le; <b>V</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1 2 3\n1 2\n1 3 6\n1 2 5\n2 1 3\n3\n1 6 100\n1 5 10 25 50 100\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 1\nCase #3: 1\nCase #4: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nNote that Cases #3 and #4 are not within the limits for the Small dataset.<br>\n<br>\nIn Case #1, it is already possible to make all the required values (1, 2, and 3) using at most one copy of each of the existing denominations.<br>\n<br>\nIn Case #2, it suffices to add a denomination of either 3 or 4 -- whichever you choose, only one new denomination is required.<br>\n<br>\nIn Case #3, the optimal solution is to add a denomination of 1.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Less Money, More Problems","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nOnce we first make a hit, it will take at least W-1 more moves to win, since we have to hit the remainder of the ship.\n</p>\n\n<p>\nIf there's still more than one possible position for the ship, then the little brother will get at least one more opportunity to answer \"miss.\"  To limit the number of additional misses to one, we make moves adjacent to the hits we already have.  If we get a \"miss,\" then we will have a row of \"hits\" with a miss at the end, so we will know the exact location of the ship.\n</p>\n\n<p>\nNow, the little brother may as well try to maximize the number of misses we make until we first get a hit.  He can't control what cells we name, so all he can do is answer \"miss\" until we make a guess which must unavoidably be a hit.  So we need to find a pattern of guesses that uses as few cells as possible, and such that each possible ship position is covered by one of them.  To do this, we use a pattern that chooses every W<sup>th</sup> cell of each row.\n</p>\n\n<p>\nThe total number of guesses is then R * floor(C/W) for the pattern, plus W-1 to hit the remainder of the ship, plus 1 more guess if there is more than one possibility for the position of the ship, which occurs if C is not an exact multiple of W. Below is a sample code in C that implements this solution:\n</p>\n<pre>\n#include &lt;stdio.h&gt;\n\nint main() {\n  int T, TC, R, C, W, score;\n\n  scanf(\"%d\", &amp;T);\n  for (TC = 1; TC &lt;= T; TC++) {\n    scanf(\"%d %d %d\", &amp;R, &amp;C, &amp;W);\n\n    // The R * floor(C/W) for the guess pattern.\n    score = R * (C / W);\n\n    // Plus W-1 to hit the remainder of the ship.\n    score += W - 1;\n\n    // Plus 1 more guess if there is more than one\n    // possibility for the position of the ship,\n    // which occurs if C is not an exact multiple of W.\n    if (C % W) score++;\n\n    printf(\"Case #%d: %d\\n\", TC, score);\n  }\n}\n</pre>\n\n<p>\ntos.lunar wrote a solution for this question using Haskell, which you can download from the scoreboard.\n</p>\n\n<p>\nA <a href=\"https://google.com/search?q=minimax+for+alternating+moves\" target=\"_blank\">recursive search of the game tree</a>, simulating all choices for our moves and the little brother's moves, will also work for the small input.\n</p>\n","id":"0000000000433de4","statement":"<h3>Problem</h3>\n\nYou're about to play a simplified \"battleship\" game with your little brother. The board for this game is a rectangular grid with <b>R</b> rows and <b>C</b> columns. At the start of the game, you will close your eyes, and you will keep them closed until the end of the game. Your little brother will take a single rectangular 1 x <b>W</b> ship and place it <b>horizontally</b> somewhere on the board. The ship must always fit entirely on the board, with each cell of the ship occupying exactly one of the grid's cells, and it can never be rotated.<br>\n<br>\nIn each turn of the game, you name a cell on the board, and your little brother tells you whether that is a hit (one of the cells occupied by the ship) or a miss. (Your little brother doesn't say <i>which</i> part of the ship was hit -- just that the cell you named has a part of the ship in it.) You have perfect memory, and can keep track of all the information he has given you. Once you have named all of the cells occupied by the ship, the game is over (the ship is sunk), and your score is the number of turns taken. Your goal is to minimize your score.<br>\n<br>\nAlthough the ship is not supposed to be moved once it is placed, you know that your little brother, who is a brat, plans to cheat by changing the location of the ship whenever he wants, as long as the ship remains horizontal and completely on the board, and the new location is consistent with all the information he has given so far. For example, for a 1x4 board and 1x2 ship, your little brother could initially place the ship such that it overlaps the leftmost two columns. If your first guess was row 1, column 2, he could choose to secretly move the ship to the rightmost two columns, and tell you that (1, 2) was a miss. If your next guess after that was (1, 3), though, then he could not say that was also a miss and move the ship back to its original location, since that would be inconsistent with what he said about (1, 2) earlier.<br>\n<br>\nNot only do you know that your little brother will cheat, he knows that you know. If you both play optimally (you to minimize your score, him to maximize it), what is the lowest score that you can <b>guarantee</b> you will achieve, regardless of what your little brother does?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> lines follow, each with three space-separated integers <b>R</b>, <b>C</b>, and <b>W</b>: the number of rows and columns of the board, followed by the width of the ship.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum score you can guarantee.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>W</b> &le; <b>C</b>.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n<b>T</b> = 55.<br/>\n<b>R</b> = 1.<br/>\n1 &le; <b>C</b> &le; 10.<br/>\n\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>R</b> &le; 20.<br/>\n1 &le; <b>C</b> &le; 20.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1 4 2\n1 7 7\n2 5 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 7\nCase #3: 10\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn Case #1, the board has one row and four columns, and the ship takes up one row and two columns. One optimal strategy is for you to start by naming cell (1, 2):<br>\n<br>\nIf your little brother says it is a hit, then the other cell of the 1x2 ship must be in either (1, 1) or (1, 3), and you just have to name both. If you happen to correctly name the cell where the other part of the ship is, your little brother will just reposition the ship so that (1, 2) is still hit, but your guess is a miss. Notice that your little brother can still move the ship even after it has been hit, as long as the new position is not inconsistent with the information he has already given.<br>\n<br>\nIf your little brother says it is a miss, then the only remaining consistent scenario is that the ship is in (1, 3) and (1, 4), and your little brother will be unable to change this from now on; you just need to name those two cells.<br>\n<br>\nSo no matter what your little brother does after you say (1, 2), you can finish the game in two more moves after that, for a total of three moves.<br>\n<br>\nMoreover, a three-move solution is optimal, because it is impossible to guarantee a finish in only two moves: without loss of generality, pick a first move. No matter what you pick, there is still a 1x2 area open and your little brother can just move the ship there and claim that you missed. It is impossible for you to sink that ship, which has not yet been hit, with only one more move.<br>\n<br>\nIn Case #2, the ship completely fills in the board and so your little brother has only one place to put it. All you have to do is name every cell.<br>\n<br>\nIn Case #3, your little brother can always move the 1x1 ship to a cell you have not tried yet, so you must name all 10 cells, only finally getting a hit (and immediately sinking the ship) on the last one.<br>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Brattleship","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433b4d","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2015"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
