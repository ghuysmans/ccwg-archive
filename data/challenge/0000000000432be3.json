{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1306002600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432be3","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1B was clearly easier than 1A. Only 10 minutes after the start, submissions for A-small started pouring in. Gennady.Korotkevich took an early lead with a lightning fast submission of A-large. Fifteen minutes later, he followed it up with a correct solution to problem B, taking the first place back from rng..58, who had briefly held it by solving problem B first.\n</p>\n\n<p>\nAfter a long silence, three nearly simultaneous submissions for C-small arrived from RAVEman, Gennady.Korotkevich and vepifanov at the 50-minute mark, putting the three contestants into a dead heat for a shot at the first place. Five minutes later, emaxx joined the race with a correct C-small. We spent the next ten minutes in anticipation.\n</p>\n\n<p>\nAt the one hour mark almost exactly, three new contestants took a leap to the top with correct submissions on C-large -- rng..58, pieguy and bsod.\n</p>\n\n<p>\nWhen the round ended, almost half of the submissions to B-large turned out to be incorrect, possibly because of overflow errors. rng..58 retained his top spot with six flawless submissions, followed by Zhukov Dmitry and winger. In order to advance to round 2, it was not enough to have solved only problem A.\n</p>\n\n<p>\nGood luck to the top 1000 in round 2. Everyone else will have one more chance to advance in round 1C.\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>RPI</i> Written and prepared by David Arthur.</p>\n<p>Problem B. <i>Revenge of the Hot Dogs</i> Written by David Arthur and prepared by Onufry Wojtaszczyk.</p>\n<p>Problem C. <i>House of Kittens</i> Written and prepared by David Arthur.</p>\n<p>Contest analysis presented by Jonathan Calhoun and David Arthur.</p>\n<p>Solutions and other problem preparation by Jorge Bernadas Saragoza, Igor Naverniouk, Petr Mitrichev, Tomek Czajka, Sean Henderson, John Dethridge, Steve Thomas and Marcin Michalski.\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1305993600000,"tasks":[{"analysis":"<p>The problem statement explains exactly what to do here. You just need to follow the instructions and not get too confused! We wanted to give you something to warm up with before the next two problems, which are both quite tricky.</p>\n\n<p>First the winning percentage (WP) of each team needs to be calculated. This is fairly straightforward since the WP of team i only depends on team i's record. To do this part, we need to know the total number of wins for each team, as well as the total number of games played. We can then calculate WP[i] = Wins[i] / Total[i].</p>\n\n<p>Next the OWP of each team needs to be calculated, but the OWP requires a modified WP for each opponent. Let's consider WP'[i][j], the winning percentage of team i if you exclude games against team j. To calculate WP'[i][j], we have to examine three possible cases.</p>\n<ol>\n<li>If team i never played versus team j, then WP' has no relevance and can be ignored. \n<li>If team i did play versus team j and won the game, then WP'[i][j] = (Wins[i]-1) / (Total[i]-1).\n<li>If team i did play versus team j and lost the game, then WP'[i][j] = (Wins[i]) / (Total[i]-1).\n</ol>\n\n<p>All that is left to do to calculate WP' is to try all pairs of teams and calculate the value if the two teams played.</p>\n\n<p>Now that we have WP' for every pair of teams, we can calculate the OWP values. Let S[i] be the set of teams that team i played against. Then we can calculate OWP[i] as follows:</p>\n\n<p>OWPSum[i] = 0<br>\nfor team j in S[i]:<br>\n&nbsp;&nbsp; OWPSum[i] += WP'[j][i]<br>\nOWP[i] = OWPSum[i] / size(S[i]).</p>\n\n<p>Lastly, we need to calculate the OOWP for every team i. The OOWP uses the OWP which we already calculated:</p>\n\n<p>OOWPSum[i] = 0<br>\nfor team j in S[i]:<br>\n&nbsp;&nbsp; OOWPSum[i] += OWP[j]<br>\nOOWP[i] = OOWPSum[i] / size(S[i]).</p>\n\n<p>Finally, we can combine everything with the formula:<br>\nRPI[i] = WP[i] * 0.25 + OWP[i] * 0.5 + OOWP[i] * 0.25.</p>\n\n<p>By the way, this formula really is in use. It is not always very good at ranking teams though!</p>","id":"0000000000432a87","statement":"<h3>Problem</h3>\n\n<p>\nIn the United States, 350 schools compete every year for an invitation to the NCAA College Basketball Tournament. With so many schools, how do you decide who should be invited? Most teams never play each other, and some teams have a much more difficult schedule than others.\n</p>\n\n<p>\nHere is an example schedule for 4 teams named A, B, C, D:\n</p>\n<pre>\n   |ABCD\n  -+----\n  A|.11.\n  B|0.00\n  C|01.1\n  D|.10.\n</pre>\n<p>\nEach 1 in a team's row represents a win, and each 0 represents a loss. So team C has wins against B and D, and a loss against A. Team A has wins against B and C, but has not played D.\n</p>\n\n<p>\nThe NCAA tournament committee uses a formula called the RPI (Ratings Percentage Index) to help rank teams. Traditionally, it has been defined as follows:\n</p>\n<pre>\n  RPI = 0.25 * WP + 0.50 * OWP + 0.25 * OOWP\n</pre>\nWP, OWP, and OOWP are defined for each team as follows:\n<ul>\n<li> WP (Winning Percentage) is the fraction of your games that you have won.<br/>\nIn the example schedule, team A has WP = 1, team B has WP = 0, team C has WP = 2/3, and team D has WP = 0.5.</li>\n<li> OWP (Opponents' Winning Percentage) is the average WP of all your opponents, after first throwing out the games they played against you.<br/>\n For example, if you throw out games played against team D, then team B has WP = 0 and team C has WP = 0.5. Therefore team D has OWP = 0.5 * (0 + 0.5) = 0.25. Similarly, team A has OWP = 0.5, team B has OWP = 0.5, and team C has OWP = 2/3.</li>\n<li> OOWP (Opponents' Opponents' Winning Percentage) is the average OWP of all your opponents. OWP is exactly the number computed in the previous step.<br/> For example, team A has OOWP = 0.5 * (0.5 + 2/3) = 7/12.\n</ul>\n<p>\nPutting it all together, we see team A has RPI = (0.25 * 1) + (0.5 * 0.5) + (0.25 * 7 / 12) = 0.6458333...\n</p>\n\n<p>\nThere are some pretty interesting questions you can ask about the RPI. Is it a reasonable measure of team's ability? Is it more important for teams to win games, or to schedule strong opponents? These are all good questions, but for this problem, your task is more straightforward: given a schedule of games, can you calculate every team's RPI?\n<p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case begins with a single line containing the number of teams <b>N</b>.\n</p>\n\n<p>\nThe next <b>N</b> lines each contain exactly <b>N</b> characters (either '0', '1', or '.') representing a schedule in the same format as the example schedule above. A '1' in row i, column j indicates team i beat team j, a '0' in row i, column j indicates team i lost to team j, and a '.' in row i, column j indicates team i never played against team j.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output <b>N</b> + 1 lines. The first line should be \"Case #x:\" where x is the case number (starting from 1). The next <b>N</b> lines should contain the RPI of each team, one per line, in the same order as the schedule.\n</p>\n\n<p>\nAnswers with a relative or absolute error of at most 10<sup>-6</sup> will be considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 20.<br/>\nIf the schedule contains a '1' in row i, column j, then it contains a '0' in row j, column i.<br/>\nIf the schedule contains a '0' in row i, column j, then it contains a '1' in row j, column i.<br/>\nIf the schedule contains a '.' in row i, column j, then it contains a '.' in row j, column i.<br/>\nEvery team plays at least two other teams.<br/>\nNo two teams play each other twice.<br/>\nNo team plays itself.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n3 &le; <b>N</b> &le; 10.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n3 &le; <b>N</b> &le; 100.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\n.10\n0.1\n10.\n4\n.11.\n0.00\n01.1\n.10.\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n0.5\n0.5\n0.5\nCase #2:\n0.645833333333\n0.368055555556\n0.604166666667\n0.395833333333\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":12}],"title":"RPI","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem might look petty tough at first glance. There are lots of hot dog vendors, and each one has a very important choice to make. How can you account for all the possibilities at once?\n</p>\n\n<p>\nIt turns out there are at least two completely different solutions, one of which uses a classical algorithmic technique, and one of which is purely mathematical. We will present both approaches here.\n</p>\n\n<h3>An Algorithmic Solution</h3>\n\n<p>\nThere are two key ideas that motivate the algorithmic solution.\n</p>\n<ul>\n<li>There is no reason to ever have one hot dog vendor walk past another. Instead of doing that, they could walk up to each other and then just go back the way they came. Since everyone moves at the same speed, this is completely equivalent to having the two people cross.</li>\n<li>Rather than trying to directly calculate the minimum time required, it suffices to ask the following slightly easier question: Given a time <b>t</b> and a distance <b>D</b>, is it possible to move all the hot dog vendors distance <b>D</b> apart in some fixed time <b>t</b>? If we can answer that question efficiently, we can use a <a href=\"http://www.google.com/search?sourceid=chrome&ie=UTF-8&q=binary+search\" target=\"_blank\">binary search</a> to find the minimum <b>t</b>:\n<pre>\nlower_bound = 0\nupper_bound = 10<sup>12</sup>\nwhile upper_bound - lower_bound &gt; 10<sup>-8</sup> * upper_bound:\n  t = (lower_bound + upper_bound) / 2\n  if t is high_enough:\n    upper_bound = t\n  else:\n    lower_bound = t\nreturn lower_bound\n</pre>\n</ul>\n\n<p>\nSo we need to decide if <b>t</b> seconds is enough to move all the hot dogs vendors apart. Let's think about the road as going from left (negative values) to right (positive values), and focus on the leftmost person <i>A</i>. By our first observation, he is still going to be leftmost when everyone is done moving. So we might as well just move him as far left as possible. That way, he will interfere as little as possible with the remaining people. Since we have fixed <b>t</b>, this tells us exactly where <i>A</i> will end up.\n</p>\n\n<p>\nNow let's consider the second leftmost person <i>B</i>. He has to end up right of <i>A</i> by at least distance <b>D</b>. Subject to that limit, he should once again go as far left as possible. (Of course once you account for the first guy, \"as far left as possible\" might actually be to the right!) The reason for doing this is the same as before: the further left this person goes, the easier it will be to place all the remaining people. In fact, this same strategy works for everyone. Once the time is fixed, each person should always go as far left as possible without getting less than distance <b>D</b> from the previous person.\n</p>\n\n<p>\nUsing this greedy strategy, we can position every single person one by one. If we come up with a valid set of positions in this way, then we know <b>t</b> is enough time. If we do not, then there is nothing better we could have possibly done.\n</p>\n\n<p>\nWe can now just plug this into the binary search, and the problem is solved!\n</p>\n\n<h3>A Mathematical Solution</h3>\n\n<p>\nOn the Google Code Jam, we would expect our contestants to try algorithmic approaches first. After all, you guys are algorithm experts! However, we would like to also present a mathematical solution to this problem. It avoids the binary search, and so it is more efficient than the previous solution if you implement it right.\n</p>\n\n<p>\nAs above, sort the people from left to right. Let P<sub>i</sub> be the position of the i<sup>th</sup> person, and let x<sub>i,j</sub> = D*(j - i) - (P<sub>j</sub> - P<sub>i</sub>). Finally, define\nX = max<sub>i &lt; j</sub> x<sub>i,j</sub>. We claim max(0, X) / 2 is exactly the amount of time required.\n</p>\n\n<p>\nLet's first show that you need at <i>least</i> this much time. Focus on two arbitrary people: i and j. Since nobody should ever cross (as argued above), there must still be j - i - 1 people between these two when everything is done. Therefore, they must end up separated by a distance of at least D*(j - i). They start off separated by only P<sub>j</sub> - P<sub>i</sub>, and this distance can go up by at most 2 every second, so we do in fact need at least [D*(j - i) - (P<sub>j</sub> - P<sub>i</sub>)] / 2 seconds altogether.\n</p>\n\n<p>\nTo prove this much time suffices, we show how X can always be decreased at a rate of 2 meters per second. Let's focus on some single person j. We will say he is \"left-limited\" if there exists i &lt; j such that x<sub>i,j</sub> = X, and he is \"right-limited\" if there exists k &gt; j such that x<sub>j,k</sub> = X. Suppose we can move every left-limited person to the left at maximum speed, and every right-limited person to the right at maximum speed. Then any term x<sub>i,j</sub> which is equal to X will be decreasing by the full 2 meters per second, and hence X will also be decreasing by 2 meters per second, as required.\n</p>\n\n<p>\nSo this strategy works as long as no single person is both left-limited and right-limited. (If that happened, he would not be able to go both left and right at the same time, and the strategy would be impossible.) So let's suppose x<sub>i,j</sub> = X = x<sub>j,k</sub>. If you just write down the equation, you'll see x<sub>i,k</sub> is exactly equal to x<sub>i,j</sub> + x<sub>j,k</sub>. But this means x<sub>i,k</sub> = 2X &gt; X, and we have a contradiction. Therefore, no single person is ever both left-limited and right-limited, and the proof is complete!\n</p>\n\n<h3>Additional Comments</h3>\n\n<ul>\n<li> It turns out the answer for this problem is always an integer or an integer plus 0.5. Do you see why? In particular, if you multiply all positions by 2 at the beginning, you can work only with integers. This allows you to avoid worrying about floating point rounding issues, which is always nice!\n</li>\n<li>\nAt first, the mathematical solution looks like it is O(n<sup>2</sup>), since you are calculating the maximum of O(n<sup>2</sup>) different numbers. Do you see how to do it linear time?\n</li>\n</ul>\n","id":"0000000000432ad9","statement":"<h3>Problem</h3>\n<p>\nLast year, several hot dog vendors were lined up along a street, and they had a tricky algorithm to spread themselves out. Unfortunately, the algorithm was very slow and they are still going. All is not lost though! The hot dog vendors have a plan: time to try a new algorithm!\n</p>\n\n<p>\nThe problem is that multiple vendors might be selling too close to each other, and then they will take each other's business. The vendors can move along the street at 1 meter/second. To avoid interfering with each other, they want to stand so that every pair of them is separated by a distance of at least <b>D</b> meters.\n</p>\n\n<p>\nRemember that the street is really long, so there is no danger of running out of space to move in either direction. Given the starting positions of all hot dog vendors, you should find the minimum time they need before all the vendors are separated (each two vendors are at least <b>D</b> meters apart from each other).\n</p>\n\n<h3>Input</h3>\n<p>\nEach point of the street is labeled with a number, positive, negative or zero. A point labeled <i>p</i> is <i>|p|</i> meters east of the point labeled <i>0</i> if <i>p</i> is positive, and <i>|p|</i> meters west of the point labeled <i>0</i> if <i>p</i> is negative. We will use this labeling system to describe the positions of the vendors in the input file.\n</p>\n\n<p>\nThe first line of the input file contains the number of cases, <b>T</b>. <b>T</b> test cases follow. Each case begins with a line containing the number of points <b>C</b> that have at least one hot dog vendor in the starting configuration and an integer <b>D</b> -- the minimum distance they want to spread out to. The next <b>C</b> lines each contain a pair of space-separated integers <b>P</b>, <b>V</b>, indicating that there are <b>V</b> vendors at the point labeled <b>P</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the minimum amount of time it will take for the vendors to spread out apart on the street. Answers with relative or absolute error of at most 10<sup>-6</sup> will be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 50.<br/>\nAll the values <b>P</b> are integers in the range [-10<sup>5</sup>, 10<sup>5</sup>].<br/>\nWithin each test case all <b>P</b> values are distinct and given in an increasing order. The limit on the sum of <b>V</b> values is listed below. All the <b>V</b> values are positive integers.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>D</b> &le; 5<br/>\n1 &le; <b>C</b> &le; 20.<br/>\nThe sum of all the <b>V</b> values in one test case does not exceed 100.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>D</b> &le; 10<sup>6</sup><br/>\n1 &le; <b>C</b> &le; 200.<br/>\nThe sum of all <b>V</b> values does not exceed 10<sup>6</sup><br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 2\n0 1\n3 2\n6 1\n2 2\n0 3\n1 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.0\nCase #2: 2.5\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Revenge of the Hot Dogs","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThere are three different tasks you need to work through in order to solve this problem:\n</p>\n<ul>\n<li> How do you transform the input into a more convenient format?</li>\n<li> How do you efficiently calculate <b>C</b>?</li>\n<li> How do you efficiently find a catnip assignment with exactly <b>C</b> flavors?</li>\n</ul>\n<p>\nAn implementation would certainly start with the first task, but when you're just thinking about the problem, it's better to focus on the high-level algorithm first. How could you know what data format is convenient until you know what you want to do with it?\n</p>\n\n<h3>Finding an Optimal Assignment</h3>\n\n<p>\nSo let's start with <b>C</b>. The most important observation is also one of the simplest. Let <b>m</b> be the minimum number of vertices in a single room. Kittens in that room have access to at most <b>m</b> flavors of catnip, so it must be that <b>C</b> &le; <b>m</b>.\n</p>\n\n<p>\nIn fact, it turns out that <b>C</b> is always equal to <b>m</b>. Proving this is pretty much equivalent to the third sub-task: we need to give a method for assigning flavors that always work with <b>C</b> = <b>m</b>. Here it is:\n</p>\n<ul>\n<li> Choose an arbitrary room. Assign flavors to its vertices in such a way that all <b>C</b> flavors are used, and no two adjacent vertices use the same flavor.</li>\n<li> Choose a room adjacent to the starting one. This will have two different flavors fixed for two adjacent vertices. Fill in the remaining vertices as before: all <b>C</b> flavors are used, and no two adjacent vertices use the same flavor.</li>\n<li> Choose another room adjacent to one of the rooms previously considered. Again, it will have two different flavors fixed for two adjacent vertices, and nothing else. Proceed as before.</li>\n<li> Continue in exactly the same way until all rooms are complete.</li>\n</ul>\n\n<p>\nThere are two keys that make this work.\n</p>\n\n<p>\n<i>Key 1:</i> It really is possible to assign valid flavors to the vertices of a single room, even after fixing distinct flavors for two adjacent vertices. Start with those two adjacent vertices, assign the remaining flavors to the next <b>C</b> - 2 vertices, and then just avoid equal neighbors for the remaining vertices. This is always possible since <b>C</b> &ge; 3.\n</p>\n\n<p>\n<i>Key 2:</i> When we get to a new room, only two adjacent vertices will ever be fixed. To see why, let's say you just got to a room R by crossing some wall W. Then, W divides the house into two disjoint parts, so this will be the first time you are touching any room on the same side of W as R. In particular, this means the only vertices that will be fixed are the ones that belong to W.\n</p>\n\n<p>\nThat's it. Just be glad we are asking for an arbitrary assignment of flavors, instead of the lexicographically first one, or something equally evil!\n</p>\n\n<h3>\nHandling the Input\n</h3>\n\n<p>\nThe main technical challenge in implementing this algorithm is figuring out where all the rooms are in the first place, and how they are connected.\n</p>\n\n<p>\nOne approach is to maintain a list of lists, representing the vertices in each room. We start off with just a single room: [[1, 2, ..., <b>N</b>]]. For each wall inside the house, we scan through the rooms until we find the one that has both endpoints of the wall, and then split that room into two. We then have to be a little careful about what order we process the rooms in. One option would be to start with an arbitrary room, and then only process future rooms once they have two vertices set. This runs in O(<b>N</b><sup>2</sup>) time.\n</p>\n\n<p>\nThere are also some fancier (almost) linear-time solutions. For each vertex, record the edges coming out of the vertex, sorted by the opposite endpoint. Now you can start with one face, trace along all of its edges, and then recursively proceed to the faces across each edge.\n</p>\n\n<p>\nEither method works, so you can use whichever you prefer.\n</p>\n","id":"0000000000433088","statement":"<h3>Problem</h3>\n\n<p>\nYou have recently adopted some kittens, and now you want to make a house for them. On the outside, the house will be shaped like a convex polygon with <b>N</b> vertices. On the inside, it will be divided into several rooms by <b>M</b> interior walls connecting vertices along straight lines. No two walls will ever cross, but there might be multiple walls touching a single vertex.\n</p>\n\n<p>\nSo why is your house of kittens going to be so special? At every vertex, you are going to build a pillar entirely out of catnip! Kittens will be able to play with any pillar that touches the room they are in, giving them a true luxury home.\n</p>\n\n<p>\nTo make the house even more exciting, you want to use different flavors of catnip. A single pillar can only use one flavor, but different pillars can use different flavors. There is only one problem. If some room does not have access to <i>all</i> the catnip flavors in the house, then the kittens in that room will feel left out and be sad.\n</p>\n\n<p>\nYour task is to choose what flavor of catnip to use for each vertex in such a way that (a) every flavor is accessible from every room, and (b) as many flavors as possible are used.\n</p>\n\n<p>\nIn the following example, three different flavors (represented by red, green, and blue dots) are distributed across an 8-sided house while keeping the kittens in every room happy:\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2gaEDId3R7A4Hu2RHcbNe5lUvqiv9OwpOOmXNYJq7eEGNioVCXzxEQZF17ZUG5m_6vciCU_hU/Kittens2.png\">\n\n<p>\nIn the image above, starting at the left corner of the top wall and going clockwise, the colors here are: green, blue, red, red, blue, green, blue, red.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\n</p>\n\n<p>\nEach test case consists of three lines. The first line gives <b>N</b> and <b>M</b>, the number of vertices and interior walls in your cat house. The second lines gives space-separated integers <b>U</b><sub>1</sub>, <b>U</b><sub>2</sub>, ..., <b>U<sub>M</sub></b> describing where each interior wall begins. The third lines gives space-separated integers <b>V</b><sub>1</sub>, <b>V</b><sub>2</sub>, ..., <b>V<sub>M</sub></b> describing where each interior wall ends.\n</p>\n\n<p>\nMore precisely, if the vertices of your cat house are labeled 1, 2, ..., <b>N</b> in clockwise order, then the interior walls are between vertices <b>U</b><sub>1</sub> and <b>V</b><sub>1</sub>, <b>U</b><sub>2</sub> and <b>V</b><sub>2</sub>, etc.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output two lines. The first should be \"Case #x: C\", where x is the case number, and C is the maximum number of catnip flavors that can be used. The second line should contain <b>N</b> space-separated integers: \"y<sub>1</sub> y<sub>2</sub> ... y<sub><b>N</b></sub>\", where y<sub>i</sub> is an integer between 1 and C indicating which catnip flavor you assigned to vertex i.</p>\n\n<p>\nIf there are multiple assignments with C flavors, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>M</b> &le; <b>N</b> - 3.<br/>\n1 &le; <b>U</b><sub>i</sub> &lt; <b>V</b><sub>i</sub> &le; <b>N</b> for all i.<br/>\nInterior walls do not touch each other except at the <b>N</b> vertices.<br/>\nInterior walls do not touch the outside of the house except at the <b>N</b> vertices.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n4 &le; <b>N</b> &le; 8.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n4 &le; <b>N</b> &le; 2000.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n4 1\n2\n4\n8 3\n1 1 4\n3 7 7\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\n1 2 1 3\nCase #2: 3\n1 2 3 1 1 3 2 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":20},{"type":2,"type__str":"HIDDEN","value":25}],"title":"House of Kittens","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432be3","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2011"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
