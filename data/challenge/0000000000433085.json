{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1274499000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433085","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThe problems in Round 1A were a collection of simulation, dynamic programming and game theory. After we had selected problem B as the medium, David Arthur came up with a clever solution that was 256 times faster than the original solution, but we decided to keep the input limits as-is. You can see a description of both algorithms in the analysis write-up of problem B.\n</p>\n<p>\nThe winner, rng..58, finished all 3 problems in just under 41 minutes, followed by Pipi and cgy4ever. Last year's winner, ACRush, made mistakes on problems A and B, but still managed to finish in the top 10.\n</p>\n\n<h3>Cast</h3>\n<p>Problem A. <i>Rotate</i> Written and prepared by David Arthur.</p>\n<p>Problem B. <i>Make it Smooth</i> Written by Xiaomin Chen. Prepared by Xiaomin Chen and Bartholomew Furrow.</p>\n<p>Problem C. <i>Number Game</i> Written by David Arthur. Prepared by Petr Mitrichev and David Arthur.</p>\n<p>Contest analysis presented by David Arthur, Xiaomin Chen, and Igor Naverniouk.</p>\n<p>Solutions and other problem preparation provided by Ante Derek, John Dethridge, Igor Naverniouk, and Cosmin Negruseri.</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1274490000000,"tasks":[{"analysis":"<h3>The Basic Solution</h3>\n\n<p>\nJust about any solution to this problem is going to ultimately rely on building up a smoothed array by first solving smaller sub-problems. The challenge is two-fold: (1) What are the sub-problems you want to solve? And (2) How can you efficiently process them all?\n</p>\n\n<p>\nIt is natural to start off by making the first <code>N-1</code> pixels smooth, and then figuring out afterwards what to do with the last pixel. The catch is what we do with the last pixel <code>q</code> depends on <code>p</code>, the final pixel we set before-hand. If <code>p</code> and <code>q</code> differ by at most <code>M</code>, then we are already done! Otherwise, we have two choices:\n<ul>\n<li>Delete <code>q</code> with cost <code>D</code>, leaving the final pixel of our smoothed picture as <code>p</code>.</li>\n<li>Move <code>q</code> to some value <code>q'</code> with cost <code>|q - q'|</code>. If <code>|q' - p| &gt; M</code>, we will then have to add some pixels before-hand to make the transition smooth. In fact, we will need to add exactly <code>(|q' - p| - 1)/ M</code> of these pixels.</li>\n</ul>\nFortunately, both of these cases are easy to analyze, as long as we are willing to loop through every possible value of <code>q'</code>.\n</p>\n\n<p>\nPerhaps the trickiest part of this setup is understanding insertions. After all, when deciding what steps to take to smooth out the transition from one pixel in the starting image to the next pixel, there are a lot of options: we could change either pixel and we could have any number of insertions between them. The insight is that once we have decided where to move both pixels, it is obvious how many insertions we need to do.\n</p>\n \n<p>\nThe pseudo-code shown below recursively finds the minimal cost to make <code>pixels[]</code> smooth, subject to the constraint that the final pixel in the smoothed version must equal <code>final_value</code>:\n<pre>\n  int Solve(pixels[], final_value) {\n    if (pixels is empty) return 0\n\n    // Try deleting\n    best = Solve(pixels[1 to N-1], final_value) + D\n\n    // Try all values for the previous pixel value\n    for (all prev_value) {\n      prev_cost = Solve(pixels[1 to N-1], prev_value)\n      move_cost = |final_value - pixels[N]|\n      num_inserts = (|final_value - prev_value| - 1) / M\n      insert_cost = num_inserts * I\n      best = min(best, prev_cost + move_cost + insert_cost)\n    }\n    return best\n  }\n</pre>\nTo answer the original problem, we just take the minimum value from <code>Solve</code> over all possible choices of <code>final_value</code>.\n</p>\n\n<p>\nUnfortunately, this algorithm will be too slow if implemented exactly like this.   Within each call to <code>Solve</code>, we are making 257 recursive calls, and we might have to go 100 levels deep. That won't finish in any of our life times, let alone within the time limit! Fortunately, the only reason it is this slow is because we are duplicating work. There are only <code>256 * N</code> different sets of parameters that we will ever see for the <code>Solve</code> function, so as long as we store the result in a cache, and re-use it when we see the same set of parameters, everything will be much faster. This trick is called <a href=\"http://www.google.com/search?q=dynamic+programming\" target=\"_blank\">Dynamic Programming</a> or more specifically, <a href=\"http://www.google.com/search?q=memoization\" target=\"_blank\">Memoization</a>.\n</p>\n\n<h3>The Fancy Solution</h3>\n\n<p>\nThe run-time of the previous solution is <code>O(256 * 256 * N)</code>, which is plenty fast in a competitive language. (Some interpreted languages are orders of magnitude slower at this kind of work than compiled languages - beware!) The extra 256 factor comes from the fact that we need to try 256 possibilities within each function call. It is actually possible to solve this problem in just <code>O(256 * N)</code> time. Here are some hints in case you are interested:\n</p>\n\n<ul>\n\n<li> As before, you want to calculate <code>Cost[n][p]</code>, the cost of making the first <code>n</code> pixels smooth while setting the final pixel to value <code>p</code>. Unlike before, you want to do a batch of these updates at the same time. In particular, you want to simultaneously calculate <i>all</i> values for <code>n+1</code> given the values for <code>n</code>.</li>\n\n<li> So how do we do this batch update? First, let's do an intermediate step to calculate <code>Cost'[n][p]</code>, the minimum cost for each value after doing all insertions between pixel <code>n</code> and pixel <code>n+1</code>. To make this more tractable, it helps to notice that there is never any need to insert a pixel with distance less than <code>M</code> from the previous pixel. (Do you see why?)</li>\n\n<li> The real challenge is that when calculating <code>Cost[n][]</code> from <code>Cost'[n][]</code>, you are going to want to take minimums over several elements. For example, <code>Cost[n][q] = min(Cost[n-1][q], {Cost'[n][q-M], Cost'[n][q-M+1], Cost'[n][q-M+2], ..., Cost'[n][q+M]})</code>. In other words, given the array <code>Cost'[n][]</code>, you are going to need to be able to  calculate in linear time the minimum element in each range of length <code>2M+1</code>. This is an interesting and challenging problem in its own right, and we encourage you to think it through! For a more thorough discussion of this sub-problem, see <a href=\"https://people.cs.uct.ac.za/~ksmith/articles/sliding_window_minimum.html\" target=\"_blank\">here</a>.</li>\n</ul>\n","id":"0000000000432df7","statement":"<h3>Problem</h3>\n<p>\nYou have a one-dimensional array of <b>N</b> pixels. Each pixel has a value, represented by a number between 0 and 255, inclusive. The <i>distance</i> between two pixels is the absolute difference of their numbers.<br/>\n</p>\n\n<p>\nYou can perform each of the following operations zero or more times:<br/>\n<ol>\n<li> With cost <b>D</b>, delete any pixel, so its original neighbors become neighboring pixels.<br/>\n<li> With cost <b>I</b>, insert one pixel of any value into any position -- either between two existing pixels, or before the first pixel, or after the last pixel.<br/>\n<li> You can change the value of any pixel. The cost is the absolute difference of the old value of the pixel and the new value of the pixel.\n</ol>\n</p>\n\n<p>\nThe array is <i>smooth</i> if any neighboring pixels have distance at most <b>M</b>. Find the minimum possible cost of a sequence of operations that makes the array smooth.\n</p>\n\n<p>\nNote: The empty array -- the array containing no pixels -- is considered to be smooth.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow, each with two lines. The first line is in the form \"<b>D</b> <b>I</b> <b>M</b> <b>N</b>\", the next line contains <b>N</b> numbers <b>a<sub>i</sub></b>: the values of the pixels from left to the right.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1), and y is the minimum cost to make the input array smooth.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\nAll the numbers in the input are integers.<br/>\n1 &le; <b>T</b> &le; 100<br/>\n0 &le; <b>D</b>, <b>I</b>, <b>M</b>, <b>a<sub>i</sub></b> &le; 255<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 3.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 100</sup>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1oAUUQg6uCQ8PHuG88Sm5J-HMlmGNOXmTi_ip5NrLkGI6S8513qW9SsxCeCty1lzoz2JPtj9NqpI-y8JqMWYGMMbbVBzR8e_-IuLHYDw/make_it_smooth_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n6 6 2 3\n1 7 5\n100 1 5 3\n1 50 7\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0Bod5p_upqH6YvLrU3PkZWG9sw3g3vi89m0NpaVEGG0UFklrKDMH4SUk1Dmh8gTJbq0r9iTi5wN9V08Ki6O2n3TlIINDgqKPl2cxyhW9M/make_it_smooth_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 4\nCase #2: 17\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<h4>Explanation</h4>\n<p>\nIn Case #1, decreasing the 7 to 3 costs 4 and is the cheapest solution.  In Case #2, deleting is extremely expensive; it's cheaper to insert elements so your final array looks like <code>[1, 6, 11, 16, 21, 26, 31, 36, 41, 46, 50, 45, 40, 35, 30, 25, 20, 15, 10, 7]</code>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Make it Smooth","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nLet us begin by focusing on a single game. Given <b>A</b> and <b>B</b>, we can first assume without loss of generality that <code>A &ge; B</code>. Now, how can we decide if it is a winning position or not? (It is impossible to have a tie game since <code>A+B</code> is always decreasing.) Well, a position is winning if and only if, in one step, you can reach a losing position for your opponent. This is an important fact of combinatorial games, so make sure you understand why it's true!\n</p>\n<h3>Observations, easy and not so easy</h3>\n<p>\nOne trivial observation is that <code>(A, A)</code> is a losing position.\n</p>\n<p>\nAnother observation is much trickier unless you have already been exposed to combinatorial games before:\n<blockquote>\nIf <code>A &ge; 2B</code>, then <code>(A, B)</code> is a winning position.\n</blockquote>\nTo justify this: in such a position, suppose <code>k</code> is the largest number of <code>B</code>'s we can subtract from <code>A</code>, i.e., <code>A - kB &ge; 0</code> and <code>A - (k+1)B &lt; 0</code>. We do not know yet whether <code>(A-kB, B)</code> is a winning position or not. But there are just two possibilities. If it is losing, great, we can subtract <code>kB</code> from <code>A</code>, and hand the bad position to our opponent. On the other hand, if it is winning, we can subtract <code>(k-1)B</code> from <code>A</code>, and our opponent has no choice but to subtract another <code>B</code> from the result, giving us the winning position <code>(A-kB, B)</code>. Therefore, <code>(A, B)</code> is a winning position either way!\n</p>\n<h3>Expand further</h3>\n<p>\nThe observation above gives us a fairly quick algorithm to figure out who wins a single game <code>(A, B)</code>. Instead of using dynamic programming to solve the subproblem for all <code>(A', B')</code> with <code>A' &le; A</code> and <code>B' &le; B</code>, which is the most common way of analyzing this kind of game, we can do the following:<br/>\n<ul>\n<li>In round 1: If <code>A &ge; 2B</code>, it's a winning position and we're done. Otherwise, we have only one choice: subtract <code>B</code> from <code>A</code>, and give our opponent <code>(B, A-B)</code>.</li>\n<li>In round 2: If <code>B &ge; 2(A-B)</code>, it is a winning position for our opponent. Otherwise, the only choice he has is to subtract <code>A-B</code> from <code>B</code>, and hand us <code>(A-B, 2B-A)</code>.</li>\n<li>In round 3: If <code>A-B &ge; 2(2B-A)</code>, it is a winning position for us again. Otherwise, we are going to make it <code>(2B-A, 2A-3B)</code>.</li>\n</ul>\nAnd so on. This leads to the following algorithm for efficiently solving a single game <code>(A, B)</code>, assuming <code>A &ge; B</code>:\n<pre>\n  bool winning(int A, int B) {\n    if (B == 0) return true;\n    if (A &gt;= 2*B) return true;\n    return !winning(B, A-B);\n  }\n</pre>\n</p>\n<p>\nDoes this sound familiar? One connection you might see is that the Number Game closely resembles Euclid's algorithm for greatest common divisor. It is not hard to see that this algorithm, like Euclid's, will need to recurse at most <code>O(log A)</code> times.\n</p>\n<p>\nUnfortunately, we still cannot afford to run the algorithm for every possible <code>(A, B)</code>! To solve the problem, we need to work with many positions at once. Let us go through the same rounds, but imagine having a fixed B and consider all possible A's at the same time:\n<ul>\n<li> Round 1: <code>(A, B)</code>. If <code>A &ge; 2B</code>, i.e., <code>A/B &ge; 2</code>, then <code>(A, B)</code> is winning.</li>\n<li> Round 2: <code>(B, A-B)</code>. If <code>B &ge; 2(A-B)</code>, i.e., <code>A/B &le; 3/2</code>, then <code>(A, B)</code> is losing.</li>\n<li> Round 3: <code>(A-B, 2B-A)</codE>. If <code>A-B &ge; 2(2B-A)</code>, i.e., <code>A/B &ge; 5/3</code>, then <code>(A, B)</code> is wining.</li>\n<li> Round 4: <code>(2B-A, 2A-3B)</code>. If <code>2B-A &ge; 2(2A-3B)</code>, i.e., <code>A/B &le; 8/5</code>, then <code>(A, B)</code> is losing.</li>\n<li> And so on.</li>\n</ul>\nThis gives a fast enough solution to our problem. For each <code>B</code>, we consider all <code>A</code>'s in the above manner, and in O(log 10<sup>6</sup>) rounds, we can classify all the <code>A</code>'s.\n</p>\n\n<h3>Simplify</h3>\n\n<p>\nThe above method is perfectly correct, but it can be made simpler. First of all, does anything in the above list look familiar? There are Fibonacci numbers all over the place! Let <code>F(i)</code> be the <code>i</code>-th Fibonacci number. One can show by induction that the previous analysis is actually saying the following:\n<ul>\n<li> Round 2t-1: If <code>A/B &ge; F(2t+1)/F(2t)</code>, then <code>(A,B)</code> is a winning position.</li>\n<li> Round 2t: If <code>A/B &le; F(2t+2)/F(2t+1)</code>, then <code>(A,B)</code> is a losing position.</li>\n</ul>\nIt turns out that both <code>F(2t+1)/F(2t)</code> and <code>F(2t+2)/F(2t+1)</code> approach the golden ratio <code>&phi; = (1 + &radic; 5) / 2</code> as t gets large. This means there is a very simple characterization of all winning positions!\n\n<blockquote>\n<b>Theorem:</b> <code>(A, B)</code> is a winning position if and only if <code>A &ge; &phi; B</code>.\n</blockquote>\n\nUsing this theorem, it is easy to solve the problem. Loop through each value for <code>B</code>, and count how many <code>A</code> values satisfy <code>A &ge; &phi; B</code>.\n\n<h3>Why it is Golden?</h3>\n<p>\nOnce we have stumbled upon the statement of this theorem, it is actually pretty easy to prove. Here is one method: Using mathematical induction, assume we proved the theorem for all smaller A's and B's. If <code>A &ge; 2B</code>, then <code>(A, B)</code> is a winning position as we discussed earlier. Otherwise we will leave our opponent with <code>(B, A-B)</code>. Then <code>(A, B)</code> is winning if and only if <code>(B, A-B)</code> is losing. By our inductive hypothesis, this is equivalent to <code>B &le; &phi; (A - B)</code>, or <code>A &ge; ((1 + &phi;) / &phi;) * B</code>. Since <code>&phi; = (1 + &phi;) / &phi;</code>, this proves <code>(A, B)</code> is winning if and only if <code>A &ge; &phi; B</code>, as required.\n</p>\n<p>\nHere is another, more geometric viewpoint. You start with a piece of paper which is an <code>A</code> by <code>B</code> rectangle (<code>A &ge; B</code>), and cut out a <code>B</code> by <code>B</code> square from it. If the rectangle is <i>golden</i>, where <code>A = &phi;B</code>, then the resulting rectangle will also be golden. In our game, <code>A</code> and <code>B</code> are integers, so the rectangle is never golden. We call it <i>thin</i> if <code>A &gt; &phi;B</code>, otherwise we call it <i>fat</i>. From a thin rectangle you can always cut it to a fat rectangle, and from a fat one you can only cut it to a thin one. They correspond to the winning positions and losing positions, respectively.\n<br/><br/>\n&nbsp;&nbsp;&nbsp;<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1m-tbk6NHOZyfAgFhVPYysMA135EL8FLYZvAVIT6SAjJQx6p816ueIIcrfsbNw4GxZ6hB6/golden.png\"><br/>\n&nbsp;&nbsp;&nbsp;A picture of golden rectangles from Wikipedia.\n<br/><br/>\n</p>\n\n<h3>Other Approaches</h3>\n<p>\nThere are many ways of arriving at the solution to this problem -- our analysis focuses on only one of these ways. Another approach would be to start with a slower method and compute which <code>(A, B)</code> are winning positions for small <code>A</code>, <code>B</code>. From looking at these results, you could easily guess that <code>(A, B)</code> is winning if and only if <code>A &ge; x B</code> for some <code>x</code>, and all that remains would be to figure out what <code>x</code> is!\n</p>\n\n<h3>More Information</h3>\n<a href=\"http://www.google.com/search?q=euclid+algorithm\" target=\"_blank\">Euclid's Algorithm</a> -\n<a href=\"http://www.google.com/search?q=fibonacci+numbers\" target=\"_blank\">Fibonacci Numbers</a> -\n<a href=\"http://www.google.com/search?q=golden+ratio\" target=\"_blank\">Golden Ratio</a>\n","id":"0000000000432fe1","statement":"<h3>Problem</h3>\n<p>\nArya and Bran are playing a game. Initially, two positive integers <b>A</b> and <b>B</b> are written on a blackboard. The players take turns, starting with Arya. On his or her turn, a player can replace <b>A</b> with <b>A</b> - <b>k</b>*<b>B</b> for any positive integer <b>k</b>, or replace <b>B</b> with <b>B</b> - <b>k</b>*<b>A</b> for any positive integer <b>k</b>. The first person to make one of the numbers drop to zero or below loses.</p>\n\n<p>For example, if the numbers are initially (12, 51), the game might progress as follows:\n<ul>\n<li>Arya replaces 51 with 51 - 3*12 = 15, leaving (12, 15) on the blackboard.\n<li>Bran replaces 15 with 15 - 1*12 = 3, leaving (12, 3) on the blackboard.\n<li>Arya replaces 12 with 12 - 3*3 = 3, leaving (3, 3) on the blackboard.\n<li>Bran replaces one 3 with 3 - 1*3 = 0, and loses.\n</ul>\nWe will say (<b>A</b>, <b>B</b>) is a <i>winning</i> position if Arya can always win a game that starts with (<b>A</b>, <b>B</b>) on the blackboard, no matter what Bran does.</p>\n\n<p>\nGiven four integers <b>A<sub>1</sub></b>, <b>A<sub>2</sub></b>, <b>B<sub>1</sub></b>, <b>B<sub>2</sub></b>, count how many winning positions (<b>A</b>, <b>B</b>) there are with <b>A<sub>1</sub></b> &le; <b>A</b> &le; <b>A<sub>2</sub></b> and <b>B<sub>1</sub></b> &le; <b>B</b> &le; <b>B<sub>2</sub></b>.\n</p>\n\n<h3>Input</h3>\n\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, one per line. Each line contains the four integers <b>A<sub>1</sub></b>, <b>A<sub>2</sub></b>, <b>B<sub>1</sub></b>, <b>B<sub>2</sub></b>, separated by spaces.\n</p>\n\n<h3>Output</h3>\n\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1), and y is the number of winning positions (<b>A</b>, <b>B</b>) with <b>A<sub>1</sub></b> &le; <b>A</b> &le; <b>A<sub>2</sub></b> and <b>B<sub>1</sub></b> &le; <b>B</b> &le; <b>B<sub>2</sub></b>.\n</p>\n\n<h3>Limits</h3>\n\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100. <br/>\n1 &le; <b>A<sub>1</sub></b> &le; <b>A<sub>2</sub></b> &le; 1,000,000.<br/>\n1 &le; <b>B<sub>1</sub></b> &le; <b>B<sub>2</sub></b> &le; 1,000,000.\n</p>\n\n<h3>Small dataset (Test set 1 - Visible)</h3>\n\n<p>\nTime limit: 30 seconds.<br/>\n<b>A<sub>2</sub></b> - <b>A<sub>1</sub></b> &le; 30.<br/>\n<b>B<sub>2</sub></b> - <b>B<sub>1</sub></b> &le; 30.\n</p>\n\n<h3>Large dataset (Test set 2 - Hidden)</h3>\n\n<p>\nTime limit: 90 seconds.<br/>\n<b>A<sub>2</sub></b> - <b>A<sub>1</sub></b> &le; 999,999.<br/>\n<b>B<sub>2</sub></b> - <b>B<sub>1</sub></b> &le; 999,999.\n</p>\n\n<p>\nNo additional constraints.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n5 5 8 8\n11 11 2 2\n1 6 1 6\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 1\nCase #3: 20\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":16},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Number Game","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis is a relatively straightforward simulation problem -- the problem statement tells you what to do, and you just need to do it.\n</p>\n<p>\nWell, except for one fun point: The name of the problem is <i>Rotate</i>, and in the statement we talk about the rotation a lot. However, that is the one thing you do <i>not</i> need to implement! Rotating 90 degrees clockwise and pushing everything downwards has the same effect as pushing everything towards the right without rotating. As long as you push the pieces in the correct direction, it doesn't matter whether you actually do the rotation. Any <b>K</b> pieces in a row will be the same in these two pictures, and your output will be the same too.\n</p>\n<p>\nSo, a simple solution to this problem looks like this: <br/>\n(1) In each row, push everything to the right. This can be done with some code like the following:\n<pre>\n    for (int row = 1; row &lt; n; ++row) {\n      int x = n-1;\n      for (int col = n-1; col &gt;= 0; col--) \n        if (piece[row][col] != '.') {\n          piece[row][x] = piece[row][col]; x--;\n        }\n      while(x&gt;=0) {piece[row][x]='.'; x--;}\n    }\n</pre>\n(2) Test if there are <b>K</b> pieces in a row of the same color. There are tricks that can be done to speed this up, but in our problem, <b>N</b> is at most 50, and no special optimizations are needed. For each piece, we can just start from that piece and look in all 8 directions (or we can do just 4 directions because of symmetry). For each direction, we go <b>K</b> steps from the starting piece, and see if all the pieces encountered are of the same color. The code -- how to go step by step in a direction, and how to check if we are off the board -- will look  similar in many different programming languages. We encourage you to check out some of the correct solutions by downloading them from the scoreboard.\n</p>\n","id":"0000000000433196","statement":"<h3>Problem</h3>\n\n<p>\nIn the exciting game of Join-<b>K</b>, red and blue pieces are dropped into an <b>N</b>-by-<b>N</b> table. The table stands up vertically so that pieces drop down to the bottom-most empty slots in their column. For example, consider the following two configurations:\n</p>\n\n<table>\n<tr>\n<td>\n<pre>\n    <b>- Legal Position -</b>\n\n          .......\n          .......\n          .......\n          ....R..\n          ...RB..\n          ..BRB..\n          .RBBR..\n</pre>\n</td>\n<td>\n<pre>\n   <b>- Illegal Position -</b>\n\n          .......\n          .......\n          .......\n          .......\n   Bad -&gt; ..BR...\n          ...R...\n          .RBBR..\n</pre>\n</td>\n</tr>\n</table>\n\n<p>\nIn these pictures, each '.' represents an empty slot, each 'R' represents a slot filled with a red piece, and each 'B' represents a slot filled with a blue piece. The left configuration is legal, but the right one is not. This is because one of the pieces in the third column (marked with the arrow) has not fallen down to the empty slot below it.\n</p>\n\n<p>\nA player wins if they can place at least <b>K</b> pieces of their color in a row, either horizontally, vertically, or diagonally. The four possible orientations are shown below:\n<table>\n<tr><td>\n<pre>\n      <b>- Four in a row -</b>\n\n     R   RRRR    R   R\n     R          R     R\n     R         R       R\n     R        R         R\n</pre>\n</td><td></td>\n</tr>\n</table>\nIn the \"Legal Position\" diagram at the beginning of the problem statement, both players had lined up two pieces in a row, but not three.\n</p>\n\n<p>\nAs it turns out, you are right now playing a very exciting game of Join-<b>K</b>, and you have a tricky plan to ensure victory! When your opponent is not looking, you are going to rotate the board 90 degrees clockwise onto its side. Gravity will then cause the pieces to fall down into a new position as shown below:\n<table>\n<tr>\n<td>\n<pre>\n    <b>- Start -</b>\n\n     .......\n     .......\n     .......\n     ...R...\n     ...RB..\n     ..BRB..\n     .RBBR..\n</pre>\n</td>\n<td>\n<pre>\n   <b>- Rotate -</b>\n\n     .......\n     R......\n     BB.....\n     BRRR...\n     RBB....\n     .......\n     .......\n</pre>\n</td>\n<td>\n<pre>\n   <b>- Gravity -</b>\n\n     .......\n     .......\n     .......\n     R......\n     BB.....\n     BRR....\n     RBBR...\n</pre>\n</td>\n</tr>\n</table>\nUnfortunately, you only have time to rotate once before your opponent will notice.\n</p>\n\n<p>\nAll that remains is picking the right time to make your move. Given a board position, you should determine which player (or players!) will have <b>K</b> pieces in a row after you rotate the board clockwise and gravity takes effect in the new direction.\n</p>\n\n<h3>Notes</h3>\n\n<ul>\n<li>You can rotate the board only once.</li>\n<li>Assume that gravity only takes effect after the board has been rotated completely.</li>\n<li>Only check for winners after gravity has finished taking effect.</li>\n</ul>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, each beginning with a line containing the integers <b>N</b> and <b>K</b>. The next <b>N</b> lines will each be exactly <b>N</b> characters long, showing the initial position of the board, using the same format as the diagrams above.\n</p>\n\n<p>\nThe initial position in each test case will be a legal position that can occur during a game of Join-<b>K</b>. In particular, neither player will have already formed <b>K</b> pieces in a row.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1), and y is one of \"Red\", \"Blue\", \"Neither\", or \"Both\". Here, y indicates which player or players will have <b>K</b> pieces in a row after you rotate the board.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n3 &le; <b>K</b> &le; <b>N</b>.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n3 &le; <b>N</b> &le; 7.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n3 &le; <b>N</b> &le; 50.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n7 3\n.......\n.......\n.......\n...R...\n...BB..\n..BRB..\n.RRBR..\n6 4\n......\n......\n.R...R\n.R..BB\n.R.RBR\nRB.BBB\n4 4\nR...\nBR..\nBR..\nBR..\n3 3\nB..\nRB.\nRB.\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: Neither\nCase #2: Both\nCase #3: Red\nCase #4: Blue\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Rotate","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433085","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2010"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
