{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1307809800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433333","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nAt the start of Round 3, a few contestants glanced at the picture of a polygon in problem A and immediately jumped to problem D instead. The first few submissions were brute force solutions to D-small. Problem A, however, turned out not to be as scary as it looked, and acrush took an early lead by solving it in under 10 minutes.\n</p>\n\n<p>\nA large number of contestants chose to start with problem B instead, and omeometo went for problem C. For quite some time, he remained the only one to have solved C correctly.\n</p>\n\n<p>\nAt the 30 minute mark, nika, andrewzta, vepifanov, KennyHORROR, zyz915 and acrush held the top 6 spots with solutions to both A and B. Forty minutes into the contest, everyone in the top 25 had correctly solved two problems. No one had three yet, although winger had A and C instead of A and B, which held him in first place.\n</p>\n\n<p>\nJust short of one hour into the competition, nika became the first contestant to solve three problems correctly. He had also already had D-small at that point, which gave him a commanding, 22-point lead over Gennady.Korotkevich, who was in second place despite a failed B-large. Of course, he probably did not know that at the time.\n</p>\n\n<p>\nMore and more solutions to problem C continued to come in, but with less than an hour left to go there were still no attempts on D-large. With 45 minutes left to go, the top 25 contestants all had 69 points, which meant having solved everything except for D-large, and there were still no attempts at the fiendishly difficult problem.\n</p>\n\n<p>\nIn the end, only linguo managed to solve D-large, earning him a well-deserved first place. He went with Python this time instead of choosing a more esoteric language.\n</p>\n\n<p>\nCongratulations to the top 25. We hope to see you in Tokyo!\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Irregular Cakes</i> Written and prepared by Jorge Bernadas Saragoza.</p>\n<p>Problem B. <i>Dire Straights</i> Written by Patrick Nguyen and David Arthur. Prepared by Tomek Czajka.</p>\n<p>Problem C. <i>Perpetual Motion</i> Written by David Arthur. Prepared by Luka Kalinovcic.</p>\n<p>Problem D. <i>Mystery Square</i> Written by David Arthur. Prepared by David Arthur and Petr Mitrichev.</p>\n<p>Contest analysis by Jonathan Calhoun, Luka Kalinovcic and David Arthur.</p>\n<p>Solutions and other problem preparation by Yiming Li, David Arthur, Igor Naverniouk, Luka Kalinovcic, Tomek Czajka, John Dethridge, Patrick Nguyuen, Petr Mitrichev, Md. Arifuzzaman Arif, Jorge Bernadas Saragoza and Onufry Wojtaszczyk.\n\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1307800800000,"tasks":[{"analysis":"<b>Overview</b>\n\n<p>\nThis problem may have a simple statement, but make no mistake: it is really hard. Unless you have a small army of computers working in parallel, there is no way to try all 2<sup>40</sup> possible values. You need a way to limit your search.</p>\n\n<p>The key observation is that for the most part, a perfect square is uniquely determined by <i>both</i> the first half of its digits, <i>and</i> by the second half. Either one suffices. So the high-level idea is to pick the half that has fewer question marks in it, try all possible ways of filling the question marks, deduce what the rest of the number has to be, and then see if it works. Before we get into the details though, let's talk about one nasty little implementation detail that you can't help but notice.\n</p>\n\n<b>Dealing with big integers</b>\n\n<p>\nIf a binary number has 120 digits, there is obviously no way to fit it into a standard 64-bit integer! And that means arithmetic can be a nuisance. Here are a few ways you can deal with this extra complication:\n</p>\n<ul>\n<li> Use Java and take advantage of the BigInteger class.</li>\n<li> In g++, you can use the little known __uint128_t type.</li>\n<li> Roll your own BigInteger functions for 128 bits. In practice you only need Square and SquareRoot. The first is doable with grade-school long multiplication formulas and some care. The second can be done with a binary search.</li>\n<li> Use an external library such as GMP.</li>\n</ul>\n<p>\nHopefully you remembered your Fair Warning from last year, and were prepared! Even so, we would have loved to let you work on only 64-bit integers if we could, but it turns out computers are so fast today that you can simply loop over ALL 64-bit perfect squares in a few seconds. The problem becomes pretty boring in that case.\n</p>\n\n<b>Filling in a perfect square top-down</b>\n\n<p>\nAll right, so with that detail of the way, let's get down to the solution. If you know the first half of the digits in a perfect square, how can you easily figure out the rest? For example, let's look at 10110????? (in binary).\n</p>\n\n<p>\nNotice the square root has to be at least sqrt(1011000000) and at most sqrt(1011011111). In fact, there is only one integer that is between these two, and it is 11011! So we can just see if 11011<sup>2</sup> matches 10110?????, and then we're done. And this always works. If a number X has 2t digits, then its square root Y has t digits, and (Y+1)<sup>2</sup> = Y<sup>2</sup> + 2Y + 1, which already differs from Y<sup>2</sup> in more than the last t digits.\n</p>\n\n<p>\nSo in summary: once we know the first half of the digits in <b>N</b>, we can just replace the ? characters with 1, take the square root, round down, and that is the only possible option.\n</p>\n\n<b>Filling in a perfect square bottom-up</b>\n\n<p>\nThe other half of the solution is not much harder conceptually, but the devil is in the details. If you know the second half of the digits in a perfect square, how can you easily figure out the rest? For example, let's look at ????011001.\n</p>\n\n<p>\nGetting started is actually tricky, but let's suppose we have figured out the last two binary digits of the square root are 01.\n</p>\n<ul>\n<li> The square root must then be 4A + 1 for some integer A. Its square is 16A<sup>2</sup> + 8A + 1 = 8A + 1 mod 16. However, we know that the square is 9 mod 16, and hence A must be odd. Therefore, the square root must end in 101.</li>\n<li> We now know the square root must be 8B + 5 for some integer B. Its square is then 64B<sup>2</sup> + 80B + 25 = 16B + 25 mod 32. However, we know that the square is 25 mod 32, and hence B must be even. Therefore, the square root must end in 0101.\n</li>\n<li> Continuing in this way, we can use the last k+1 digits of <b>N</b> to calculate the last k digits of its square root. If you know just over half of the digits in <b>N</b>, this is enough to completely determine the square root. As above, we can now just check if it works, and then we're done.\n</li>\n</ul>\n\n<p>\nThis technique always works, subject to two condition: (a) <b>N</b> must be odd, and (b) you must already know the last two digits of the square root. You might enjoy writing down the formula in both failure cases, and seeing what goes wrong.\n</p>\n\n<p>\nLet's think about (b) first. If <b>N</b> is odd, then the square root must also be odd, and so the last digit must be 1. There is no easy way to determine what the second last digit has to be in advance, but who cares? Just try both of them, and see which one works!\n</p>\n\n<p>\nNext let's suppose <b>N</b> is even. Since it is a perfect square, it must actually be a multiple of 4, and <b>N</b>/4 is also a perfect square. So we can just cut the last two digits off of <b>N</b>, repeat until <b>N</b> becomes odd, and then solve as above. In fact, this trick is pretty much required. If <b>N</b> is odd, then the last k digits are enough to find k-1 digits in the square root. If <b>N</b> is even though, then the last k digits may only be enough to find k/2 digits in the square root.\n</p>\n\n<p>\nOf course, we might not know whether <b>N</b> is even or odd in advance. If the last digit is a '?' character, then we just try both possibilities and see what happens.\n</p>\n\n<p>\n<i>Remark:</i> This whole approach works only because 2 is prime. If we were working base-10, then an even number that is not a multiple of 10 would be pretty nasty to deal with!\n</p>\n\n\n<b>Putting it all together</b>\n\n<p>\nHere is the full solution:\n</p>\n\n<ul>\n<li> Assume that <b>N</b> is odd, if possible.</li>\n<li> If <b>N</b> has more question marks in its bottom half than in its top half, then iterate over all possible ways of filling in the top half question marks, deduce the whole number, and see if it works.</li>\n<li> If <b>N</b> has more question marks in its top half than in its bottom half, then iterate over all possible ways of filling in the bottom half question marks, deduce the whole number, and see if it works.</li>\n<li> Now assume that <b>N</b> is even, if possible. Fill in the last two digits as zero, and repeat from the very beginning (potentially solving either top-down or bottom-up) for <b>N</b>/4.\n</li>\n</ul>\n\n<p>\nThe parenthetical comment in the  last part is actually quite important! Consider the following input for example: \"10010000010000011100000110110010001???????????????????????????????????000000000??000000000000000?0000000000000000000000??00\". Most of the '?' characters are in the first half, so it is tempting to just start from the back and never re-evaluate your decision. However, there are only '0' characters back there, and they will not give you much information. To run fast enough in this case, you need to start from the front after eliminating some of the 0's.\n</p>\n","id":"00000000004329fd","statement":"<h3>Problem</h3>\n<p>\nI have written down a large perfect square in binary, and then replaced some of the digits with question marks. Can you figure out what my original number was?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, one per line. Each line contains <b>S</b>: a perfect square written in binary, but with some of the digits replaced by question marks. \n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: <b>N</b>\", where x is the case number (starting from 1) and <b>N</b> is a perfect square written in binary, obtained by replacing each '?' character in <b>S</b> with either a '0' character or a '1' character.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 25.<br/>\n<b>S</b> begins with '1'.<br/>\n<b>S</b> contains only the characters '0', '1', and '?'.<br/>\nIn every test case, there is exactly one possible choice for <b>N</b>.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n<b>S</b> is at most 60 characters long.<br/>\n<b>S</b> contains at most 20 '?' characters.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n<b>S</b> is at most 125 characters long.<br/>\n<b>S</b> contains at most 40 '?' characters.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1???\n1\n10??110??00??1000??\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1001\nCase #2: 1\nCase #3: 1011110110000100001\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":31}],"title":"Mystery Square","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nDire Straights had one of the easiest small datasets for round 3. Several brute force or backtracking solutions that followed the rules could come up with a valid answer in the allotted time, so rather than look at the small dataset, we will instead examine the large. The large dataset requires some insight into a greedy approach.\n</p>\n\n<p>\nFor a problem like this, a good strategy is to think of how you might try to solve this problem by hand. A very intuitive strategy is to first put all the cards in order, then start setting the cards down on the table, creating a new straight whenever necessary. Since our goal is to make the length of the shortest straight as long as possible, then one idea that seems like it might work is to always increase the length of the shortest straight when we have a choice. Now we need only to prove that this choice is optimal.\n</p>\n\n<p>\nSuppose we have two straights, one from <b>a</b> to <b>b</b>, another from <b>c</b> to <b>d</b>, such that <b>a</b> &lt; <b>c</b> &lt;= <b>d</b> &lt; <b>b</b>. \n</p>\n\n<pre>\n   a-------b\n    c-----d\n</pre>\n\n<p>\nNotice that we can replace these two straights with straights from <b>a</b> to <b>d</b> and <b>c</b> to <b>b</b> (this change is illustrated below), and this does not decrease the score. In fact, this change has the potential to increase the score. \n\n<pre>\n   a------d\n    c------b\n</pre>\n\n<p>\nThis shows that we can always make sure that a straight that started later never ends before one that started earlier. Hence, attaching the next card to the shortest straight is optimal.\n</p>\n\n<p>\nFinally, the size of every straight is examined and the length of the shortest straight is the total score achieved in Dire Straights.\n</p>","id":"0000000000432f3c","statement":"<h3>Problem</h3>\n<p>\nYou are playing a card game, where each card has an integer number written on it.\n</p>\n<p>\nTo play the game, you are given some cards &#8212; your <i>hand</i>.  Then you arrange the cards in your hand into <i>straights</i>.  A straight is a set of cards with consecutive values; e.g. the three cards {3, 4, 5}, or the single card {7}.  You then receive a number of dollars equal to the length of the shortest straight.  If you have no cards, you can form no straights, so you get zero dollars.\n</p>\n<p>\nYou will be given a series of test cases, each of which describes the cards you will have in your hand.  Find the maximum number of dollars you can receive for each test case.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input contains the number of test cases, <b>T</b>.\n\nEach test case consists of one line.  Each line contains <b>N</b>, the number of cards in your hand, followed by <b>N</b> integers giving the numbers on those cards.  These numbers are all space-separated.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the maximum number of dollars you can receive.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100<br/>\nThe numbers on the cards are between 1 and 10000.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n0 &le; <b>N</b> &le; 10<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n0 &le; <b>N</b> &le; 1000<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n10 1 2 3 4 5 10 9 8 7 6\n8 101 102 103 104 105 106 103 104\n0\n5 1 2 3 4 9\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 10\nCase #2: 4\nCase #3: 0\nCase #4: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<p>\nIn case 1, you have ten cards numbered 1 to 10, so you make one straight of length 10, and get 10 dollars.\n<p>\nIn case 2, you could make two straights {101,102,103,104,105,106} and {103,104} and get 2 dollars.  But it would be better to make {101,102,103,104} and {103,104,105,106} and get 4 dollars.\n<p>\nIn case 4, the card with the number 9 must be in a straight containing only that card.  So you get 1 dollar.\n<p>\nIn case 3, you have zero cards, so you get zero dollars.  You don't get money for nothing.\n</p>\n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Dire Straights","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nBefore we can start solving the problem, we first need to know how to calculate the area of the cake, so we know how much cake each party-goer is going to eat. We are guaranteed that this is a non-intersecting polygon in the limits, so we can use the equation: \n</p>\n\n<p>\n2*Area = sum(X<sub>i</sub> * Y<sub>i+1</sub> - X<sub>i+1</sub> * Y<sub>i</sub>) for i = 0 to N-1.\n</p>\n\n<p>\nFor this to work the first and last points in the polygon must be the same point. That is, X<sub>0</sub> = X<sub>N</sub> and Y<sub>0</sub> = Y<sub>N</sub>. The list of points must also be in counterclockwise order. This can be achieved by iterating over all points in L, and then iterating over all points in U in reverse order. \n</p>\n\n<p>\nOnce we know the total area of the cake, we need to determine how much cake to give each guest. Since there are G guests, we can evenly calculate this number as AreaPerGuest = Area / G.\n</p>\n\n<p>\nFinally we are ready to determine where to cut the cake. This can be solved a variety of ways, but here we will discuss using a binary search as this is often the simplest algorithm to code.\n\nTo obtain a piece of cake with an area of AreaPerGuest, we know that the vertical cut will have an X coordinate between 0 and W, so we do a binary search over this range.\n\nFor each cut point we try during the search, we compute the area of the cake to the left of that cut.\n\nIf it produces a piece of cake with area greater than AreaPerGuest, we update the upper bound of our search.\n\nIf we choose a cut that produces a piece of cake with area less than or equal to AreaPerGuest, we update the lower bound of our search.\n\nThis search will eventually converge to the correct cut point with sufficient accuracy.\n</p>\n\n<p>\nIf G=2, then we are done. If G &gt; 2, then the binary search can be repeated to find the other cuts.  The second cut point should be placed such that the area of cake to the left of that cut is AreaPerGuest * 2, the third cut point should be placed so that the area of cake to the left of that cut is AreaPerGuest * 3, and so on.\n</p>\n\n<p>\nAt each iteration of the binary search, we need to calculate the area of a polygon using part of L, U, and a line on an arbitrary X coordinate, which requires more work than computing the area of the whole cake. The first thing to note is that we can use all points in L and U that have X coordinates such that 0 &lt;= X<sub>i</sub> &lt;= X<sub>cut</sub>, where X<sub>i</sub> is the X coordinate of point i, and X<sub>cut</sub> is the X coordinate of the cut. Next we need to determine the Y coordinates of our X<sub>cut</sub> points on L and U. If we find two consecutive points A and B in L such that A<sub>x</sub> &lt;= X<sub>cut</sub> and B<sub>x</sub> &gt;= X<sub>cut</sub>, we can use line intersection to find the intersection of line AB and the vertical line defined by X<sub>cut</sub>. Once we know these two new points the area of the cut piece of cake can be calculated.\n</p>\n\n<p>\nThis problem can also be solved with a linear time solution in O(N+G). The basic premise is to split the cake into trapezoids, and iterate from left to right accumulating the total area. Any time a trapezoid needs to be split for a cut, a quadratic equation is used to determine where to cut the cake. This approach only requires the basic formula for the area of a trapezoid, which is (a+b)/2 * h, where a and b are the lengths of the bases, and h is the height of the trapezoid.\n</p>\n\n<p>\n<b>More information:</b><br>\n<a href=\"http://google.com/search?q=polygon+area\" target=\"_blank\">Polygon area</a><br>\n<a href=\"http://google.com/search?q=binary+search\" target=\"_blank\">Binary search</a><br>\n</p>\n\n","id":"00000000004330ff","statement":"<h3>Problem</h3>\n\n<p>\nMary the Mathematician has a bakery that she founded some years ago, but after all this time she has become bored with always baking the same rectangular and circular cakes. For her next birthday, she wants to bake an <i>irregular</i> cake, which is defined as the area between two \"polylines\" between x=0 and x=<b>W</b>. These polylines will be called the lower boundary and the upper boundary.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1vy87GlE7RfiLar-UQ4oJ83rd3RjWyS2GC-mQZc32agEqKljVG4UqP1V68OKXShKmU8Kpafw/example.png\">\n</p>\n\n<p>\nFormally, a polyline is defined by a sequence of points (P<sub>0</sub>, P<sub>1</sub>, ..., P<sub>n</sub>) going from left to right. Consecutive points are connected to form a sequence of line segments, which together make up the polyline.\n</p>\n\n<p>\nToday is Mary's birthday and she has baked an irregular cake bounded by two polylines with <b>L</b> points and <b>U</b> points respectively. After singing \"Happy Birthday,\" she wants to make <b>G</b>-1 vertical cuts to split the cake into <b>G</b> slices with equal area. She can then share these cake slices with all her guests. However, the irregular cake shape makes this task pretty tricky. Can you help her decide where to make the cuts?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case begins with a line containing four integers: <b>W</b> (the cake's width), <b>L</b> (the number of points on the lower boundary), <b>U</b> (the number of points on the upper boundary) and <b>G</b> (the number of guests at the party).\n</p>\n\n<p>\nThis is followed by <b>L</b> lines specifying the lower boundary. The i-th line contains two integers x<sub>i</sub> and y<sub>i</sub>, representing the coordinates of the i-th point on the lower boundary. This is followed by <b>U</b> more lines specifying the upper boundary. The j-th line here contains two integers x<sub>j</sub> and y<sub>j</sub>, representing the coordinates of the j-th point on the upper boundary.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output <b>G</b> lines. The first line should be \"Case #x:\" where x is the case number (starting from 1). The next <b>G</b>-1 lines should contain the x-coordinates at which cuts must be made, ordered from the leftmost cut to the rightmost cut.\n</p>\n\n<p>\nAnswers with a relative or absolute error of at most 10<sup>-6</sup> will be considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>W</b> &le; 1000.<br/>\n2 &le; <b>L</b> &le; 100.<br/>\n2 &le; <b>U</b> &le; 100.<br/>\nAll coordinates will be integers between -1000 and 1000, inclusive.<br/>\nThe x-coordinate of the leftmost point of both boundaries will be 0.<br/>\nThe x-coordinate of the rightmost point of both boundaries will be <b>W</b>.<br/>\nPoints in the same boundary will be sorted increasingly by x-coordinate.<br/>\nPoints in the same boundary will have different x-coordinates.<br/>\nThe lower boundary will always be strictly below the upper boundary for all x between 0 and <b>W</b>, inclusive. (In other words, the lower boundary will have a smaller y-coordinate than the upper boundary at every x position.)<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n2 &le; <b>G</b> &le; 3.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n2 &le; <b>G</b> &le; 101.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n15 3 3 3\n0 6\n10 8\n15 9\n0 10\n5 11\n15 13\n8 3 4 2\n0 2\n5 4\n8 3\n0 5\n3 4\n4 7\n8 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n5.000000\n10.000000\nCase #2:\n4.290588\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":7}],"title":"Irregular Cakes","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  The first thing we need to notice is that if two lemmings do not end up in the same square after one second, they will never end up in the same square. That is because after one second there will be exactly one lemming in each square, and the state is exactly the same as the second before.\n</p>\n<p>\n  The number of combinations for the conveyor belt directions is 2<sup>R&middot;C</sup>, so we can afford to try all of them to solve the easy input and count how many combinations lead to all lemmings being in different squares after one second. \n</p>\n\n<p>\n  To solve the hard input, we'll have to take a look at the problem from a graph theory perspective.\n  Suppose we created a bipartite graph like this:\n</p>\n<ul>\n  <li>\n    For each cell (r, c), create two nodes start<sub>r, c</sub> and end<sub>r, c</sub>.\n  </li>\n  <li>\n    Create an edge between start<sub>r<sub>1</sub>, c<sub>1</sub></sub> to end<sub>r<sub>2</sub>, c<sub>2</sub></sub> if there is a way to choose the direction of the conveyor belt in cell (r<sub>1</sub>, c<sub>1</sub>) such that the lemming ends up in (r<sub>2</sub>, c<sub>2</sub>) after one second.\n  </li>\n</ul>\n\n\n<p>\nAll start nodes will end up being incident to exactly two edges because there are exactly two different cells where a lemming can end up in one second starting from any given cell.\nEnd nodes, on the other hand, can be incident to 0-8 edges, depending on the conveyor belt orientations of the neighbouring cells.\n</p>\n<p>\n  Let's observe the graph some more. There are two rules that apply:\n</p>\n<ol>\n  <li>\n    If there are no edges incident to a node end<sub>r, c</sub> then no lemming can end up in cell (r, c) in one second, so there will be two lemmings in some other cell no matter how we direct the conveyor belts. In that case the answer is simply 0, so we can proceed to the next test case.\n  </li>\n  <li>\n    If there is a node end<sub>r<sub>2</sub>, c<sub>2</sub></sub> incident to only one edge leading to start<sub>r<sub>1</sub>, c<sub>1</sub></sub> then we have no other choice but to direct the conveyor belt on the cell (r<sub>1</sub>, c<sub>1</sub>) to lead to the cell (r<sub>2</sub>, c<sub>2</sub>).\n    Then we can simply remove both end<sub>r<sub>2</sub>, c<sub>2</sub></sub> and start<sub>r<sub>1</sub>, c<sub>1</sub></sub> from the graph along with all the incident edges.\n  </li>\n</ol>\n\n\n<p>\n  We can apply these rules iteratively until they can not be applied anymore.\n</p>\n<p>\n  Let N be the number of start nodes left after the above process is done. The number of end nodes is also equal to N, because we removed them in pairs.\n</p>\n<p>\n  The number of edges incident to each start node is still equal to two, so total the number of edges is equal to 2&middot;N because the graph is bipartite. We also know that each end node is now incident to at least two edges, because the above rules do not apply anymore.\n</p>\n<p>\n  But, if any of the end nodes had more than two incident edges then the number of edges incident to all the end nodes combined would be greater than 2&middot;N. This would contradict the fact that the number of edges is equal to 2&middot;N. Therefore, the number of edges incident to each end node is also equal to two. \n</p>\n<p>\n  Any graph having all node degrees equal to two is in fact a set of cycles. For bipartite graphs, the length of each cycle is even. So, we are left with K cycles of even length which we can solve independently and multiply the individual numbers to get the final number.\n</p>\n<p>\n  To solve the circle, select any cell (r<sub>1</sub>, c<sub>1</sub>) and pick a conveyor belt direction. The lemming ends up in (r<sub>2</sub>, c<sub>2</sub>). Now remove start<sub>r<sub>1</sub>, c<sub>1</sub></sub> and end<sub>r<sub>2</sub>, c<sub>2</sub></sub> from the graph along with incident edges.\n  This will break up the cycle, and we can proceed to apply rule #2 until we decide the conveyor belt for all the remaining cells. Because the cycle has even length and we always remove nodes in pairs, the rule #1 will never apply.\n</p>\n<p>\n  We can pick the direction of the cell (r<sub>1</sub>, c<sub>1</sub>) in two ways. So the answer for any cycle is always 2. So the final answer is equal to 2<sup>K</sup> (modulo 1000003).\n</p>\n","id":"000000000043324e","statement":"<h3>Problem</h3>\n<p>\nHave you ever been to the Google Lemming Factory? It is a very unusual place. The floor is arranged into an <b>R</b> x <b>C</b> grid. Within each grid square, there is a conveyor belt oriented up-down, left-right, or along one of the two diagonals. The conveyor belts move either forwards or backwards along their orientations, and you can independently choose which of the two possible directions each conveyor belt should move in.</p>\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U23Ybxnf7yqnjsBnxgDLG5sRIc48T91HnPrHcRJSDxNrBaHwYx_Ix034-qT9To_g0wIN1g/input.png\"></p>\n\n<p>\nCurrently, there is a single lemming standing at the center of each square. When you start the conveyor belts, each lemming will move in the direction of the conveyor belt he is on until he reaches the center of a new square. All these movements happen simultaneously and take exactly one second to complete. Afterwards, the lemmings will all be on new squares, and the process will repeat from their new positions. This continues forever, or at least until you turn off the conveyor belts.\n</p>\n<ul>\n<li> When a lemming enters a new square, he continues going in the direction he was already going until he reaches the center of that square. He will not be affected by the new conveyor belt until the next second starts.</li>\n<li> If a lemming moves off the edge of the grid, he comes back at the same position on the opposite side. For example, if he were to move diagonally up and left from the top-left square, he would arrive at the bottom-right square. By the miracle of science, this whole process still only takes 1 second.</li>\n<li> Lemmings never collide and can always move past each other without difficulty.</li>\n</ul>\nThe trick is to choose directions for each conveyor belt so that the lemmings will keep moving forever without ever having two of them end up in the center of the same square at the same time. If that happened, they would be stuck together from then on, and that is not as fun for them.</p>\n\n<p>\nHere are two ways of assigning directions to each conveyor belt from the earlier example:\n</p>\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0DnRvfO8y1IAvO2yiCIjO0sqb_rJv01DLBUpsd945Bbb34H1H3VcTyI-bUCQOxfxn5jcep/output.png\"></p>\n\n<p>\nIn both cases, we avoid ever sending two lemmings to the center of the same square at the same time.\n</p>\n\n<p>\nGiven an arbitrary floor layout, calculate <b>N</b>, the number of ways to choose directions for each conveyor belt so that no two lemmings will ever end up in the center of the same square at the same time. The answer might be quite large, so please output it modulo 1000003.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each begins with a line containing positive integers <b>R</b> and <b>C</b>.\n</p>\n\n<p>\nThis is followed by <b>R</b> lines, each containing a string of <b>C</b> characters chosen from <code>\"|-/\\\"</code>. Each character represents the orientation of the conveyor belt in a single square:\n</p>\n<ul>\n<li> '<code>|</code>' represents a conveyor belt that can move up or down.</li>\n<li> '<code>-</code>' represents a conveyor belt that can move left or right.</li>\n<li> '<code>/</code>' represents a conveyor belt that can move up-right or down-left.</li>\n<li> '<code>\\</code>' represents a conveyor belt that can move up-left or down-right.</li>\n</ul>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: <b>M</b>\", where x is the case number (starting from 1), and <b>M</b> is the remainder when dividing <b>N</b> by 1000003.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 25.<br/>\nMemory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n3 &le; <b>R</b> &le; 4.<br/>\n3 &le; <b>C</b> &le; 4.<br/>\nTime limit: 30 seconds.\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n3 &le; <b>R</b> &le; 100.<br/>\n3 &le; <b>C</b> &le; 100.<br/>\nTime limit: 60 seconds.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3 3\n|-/\n|||\n--|\n3 4\n----\n||||\n\\\\//\n4 4\n|---\n\\-\\|\n\\|||\n|--\\\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 0\nCase #3: 16\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Perpetual Motion","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433333","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2011"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
