{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1222061700000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000436b54","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\r\n  This is the first local onsite final of the 2008 Code Jam. We had four\r\n  problems with different styles, two of them unconventional for different\r\n  reasons.\r\n</p><p>\r\n  Problem C, the Millionaire, is one of the rare gems in the programming\r\n  contests that, at first glance, is continuous and offers an infinite search\r\n  space. The beautiful solution makes the problem discrete, and reminds us of\r\n  some classical puzzles of recursive reasoning. Players from Japan did really\r\n  well on this problem. 8 Japanese players qualified for the world finals; all\r\n  of them solved the small dataset of this problem, which is almost as hard as\r\n  the large dataset.\r\n</p><p>\r\n  Problem B, Apocalypse Soon, is another type of big puzzle. The solution is\r\n  really simple, but you need to see through the properties of the game with\r\n  very good intuition to believe that the code is really just a trivial\r\n  simulation. Under such pressure, with the other nice and hard problems, it is\r\n  not a big surprise that this one had the least number of correct submissions.\r\n  The top two scorers both solved left this problem to the end.\r\n</p><p>\r\n  Problem A, What Are Birds, was meant to be the easy problem here. The best way\r\n  to solve it is to visualize it as a cute geometry problem. The problem is far\r\n  from trivial. Several players solved a more difficult problem yet still missed\r\n  the qualification just because they did not succeed on this one.\r\n</p><p>\r\n  Problem D, Modern Art Plagiarism, had the biggest point value. It is a\r\n  standard graph problem, with a nice solution using matchings. It turns out we\r\n  have more contestants who solved D than B or C. This implies that many of our\r\n  players are well trained in classical algorithms.\r\n</p><p>\r\n  Again, we had scores of 100 in this match. They are two of the favorites,\r\n  <b>ACRush</b> and <b>Ahyangyi</b>, both from China. Around 30 minutes before\r\n  the end of the contest we saw a duel for the top spot. They both had the last\r\n  program -- for problem C -- almost ready, but soon submitted 6 wrong\r\n  submissions to C-small. Finally, they fixed their bugs. <b>Ahyangyi</b> was\r\n  the first to finish all the problems, but had 3 more wrong submissions.\r\n  <b>ACRush</b> was the winner of the APAC final, with a lower penalty score.\r\n</p><p>\r\n  Congratulations to all the participants. It was a wonderful match.\r\n</p>\r\n\r\n<hr>\r\n<p>\r\n  <b>Credits</b>\r\n</p><p>\r\n  Problem A. <i>What are Birds?</i>\r\n  Written by John Dethridge. Prepared by John Dethridge and Marius Andrei.\r\n</p><p>\r\n  Problem B. <i>Apocalypse Soon</i>\r\n  Written by Derek Kisman. Prepared by Igor Naverniouk and Kelly Poon.\r\n</p><p>\r\n  Problem C. <i>Millionaire</i>\r\n  Written by Geir Engdahl. Prepared by Xiaomin Chen.\r\n</p><p>\r\n  Problem D. <i>Modern Art Plagiarism</i>\r\n  Written by John Dethridge. Prepared by Frank Chu and Marius Andrei.\r\n</p><p>\r\n  Contest analysis presented by Xiaomin Chen, Derek Kisman, and Geir Engdahl.\r\n</p>\r\n","registration_gives_participant":false,"result_status":20,"result_status__str":"FULLY_VISIBLE","start_ms":1222054500000,"tasks":[{"analysis":"<p>\n  This problem is a sheep in wolf's clothing. However, it must have been very\n  convincing wolf's clothing! Fewer competitors solved it than any other\n  problem, despite the simplicity of the actual solution. Since this was an\n  onsite round, they were all experienced competitors; in some sense, that\n  worked against them.\n</p><p>\n  Why does the problem seem so hard? To a practiced eye, it has all the\n  trappings of a horrible exponential search. You have 5 actions to choose from\n  on each day, and the results of those actions don't tend to overlap, leading\n  to an exponential number of possible states. Furthermore, even the subtlest\n  change in a nation's strength can drastically affect the final outcome, so at\n  each step the entire state of the world matters. This makes a Dynamic\n  Programming-based solution look unlikely. And due to the chaotic nature of the\n  rules, there's unlikely to be a greedy strategy that works in all cases.\n</p><p>\n  So a horrible exponential search seems essential. On a 50x50 grid of numbers\n  between 0 and 1000, this is clearly intractable! Give up and go home. No,\n  wait... it's supposed to be solvable somehow, right? How could that be?\n</p><p>\n  Well, if you try a few cases by hand, you'll soon realize why: everyone ends\n  up killing their neighbors really, really quickly. A random map tends to\n  stabilize (no living neighbors) in only 4-6 days. It's actually very difficult\n  to come up with a case that takes longer. The more you try, the more you'll\n  realize just how difficult it is; the army sizes required grow exponentially,\n  and the tighter you pack them the sooner they all die. The map size doesn't\n  turn out to matter much - it's the army size bound of 1000 that really sets\n  the cap on how long you'll need to search.\n</p><p>\n  What exactly is this cap? That's a really tough question. For instance, if\n  army sizes are unbounded, there <i>is</i> no small limit. Here's a simple\n  (2<i>n</i>-2)x2 case that takes <i>n</i> days to stabilize:<br>\n  1 2 4 8 ... 2<sup>2<i>n</i>-3</sup><br>\n  1 2 4 8 ... 2<sup>2<i>n</i>-3</sup>\n</p><p>\n  However, the army sizes <i>must</i> grow exponentially relative to the number\n  of days. Here's a simple proof: on day <i>n</i>, let <i>S<sub>n</sub></i> be\n  the strength of the strongest nation that still has living neighbors. Let\n  <i>N</i> be any nation with strength &ge; <i>S<sub>n</sub></i>/2.\n  Suppose that after 8 days <i>N</i> still has strength &ge;\n  <i>S<sub>n</sub></i>/2. Then it must have killed all its neighbors, since\n  none had strength &ge; <i>S<sub>n</sub></i> (that is, any neighbor would die\n  after at most 2 attacks). So every such <i>N</i> either ends up isolated or\n  weaker than <i>S<sub>n</sub></i>/2 after 8 days. Thus,\n  <i>S<sub>n+8</sub></i> &le; <i>S<sub>n</sub></i>/2. This puts a strict bound\n  of 8(log<sub>2</sub><i>S<sub>n</sub></i>+1) more days before all nations are\n  dead or isolated.\n</p><p>\n  Unfortunately, for army sizes of 1000 this bound of 80 days still isn't very\n  helpful. The bound can be improved with tighter reasoning, but due to the\n  compact, constrained nature of the grid, the \"true\" bound is probably much\n  smaller - around 9-10 days! However, we don't know how to prove a bound\n  anywhere near this. If you can think of a way, let us know! :)\n</p><p>\n  The worst test case in our data had an answer of \"9 day(s)\". So as it turns\n  out, even a straight brute force solution (on the worst-case order of\n  50x50x5<sup>9</sup>) would suffice to solve it. Adding simple pruning\n  heuristics and memoization can potentially also help, but isn't necessary.\n</p><p>\n  Incidentally, one potential coding error you could make is to assume that\n  effects can only propagate at one grid square per day. The \"speed of light\"\n  (as it's known in cellular automata) is actually <i>two</i> grid squares per\n  day, because if an army's neighbor changes, it may choose to attack its\n  opposite neighbor instead. In the \"9 day(s)\" test case, there are nations 13\n  squares away from yours that end up affecting the answer. So if you tried to\n  speed up your solution by considering only the local region around your\n  nation, you'd have to be careful not to make it <i>too</i> local.\n</p><p>\n  In the end, all it took to get this problem was bravery (or foolishness). If\n  you code it properly and try it, it works! It's just a question of how well\n  you can convince yourself that the simple solution has a hope of working. You\n  certainly wouldn't want to download the Large dataset and <i>then</i> realize\n  your solution was too slow...\n</p>\n","id":"0000000000436280","statement":"<h3>Problem</h3>\n<p>\n  Oh no! The delicate political balance of the world has finally collapsed, and\n  everybody has declared war on everybody else. You warned whoever would listen\n  that this would happen, but did they pay attention? Ha! Now the only thing you\n  can hope for is to survive as long as possible.\n</p><p>\n  Fortunately (sort of), everyone's industrial centers have already been nuked,\n  so the only method of attack available to each nation is to hurl wave after\n  wave of conscripted soldiers at each other. This limits each nation to\n  attacking only its immediate neighbors. The world is a R-by-C grid with R\n  rows, numbered from 1 in the far North to R in the far South, and C columns,\n  numbered from 1 in the far West to C in the far East. Each nation occupies one\n  square of the grid, which means that each nation can reach at most 4 other\n  adjacent nations.\n</p><p>\n  Every nation starts with a specific strength value, known to everyone. They\n  have no concept of advanced strategy, so at the beginning of each day, they\n  will simply choose their strongest neighbor (breaking ties first by\n  Northernmost nation, then by Westernmost) and attack them with an army. The\n  army will have a power equal to the current strength S of the nation; by the\n  end of the day, it will have depleted that neighbor's strength by S. A nation\n  whose strength reaches 0 is destroyed. Note that all nations attack at the\n  same time; an army's power is the same regardless of whether its nation is\n  attacked that day.\n</p><p>\n  Your nation is located at (c, r), in row r and column c. Fortunately, your\n  nation is listening to your advice, so you don't have to follow this crazy\n  strategy. You may choose to attack any of your neighbors on a given day (or do\n  nothing at all). You can't attack multiple neighbors, however, or attack with\n  an army of less than full power.\n</p><p>\n  Determine the maximum number days you can survive.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>T</b>. <b>T</b> test\n  cases follow. The first line of each test case contains four integers,\n  <b>C</b>, <b>R</b>, <b>c</b>, and <b>r</b>. The next <b>R</b> lines each\n  contain <b>C</b> integers, giving the starting strength\n  <b>S<sub>ci,ri</sub></b> of the nation in column <b>ci</b> and row <b>ri</b>.\n  It may be 0, indicating that the nation has already been destroyed. Your\n  nation's starting strength will not be 0.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>A</b>: \" followed by:\n</p>\n<ul>\n  <li>\n    \"<b>B</b> day(s)\", where <b>B</b> is the most days you can hope to survive.\n  </li>\n  <li>\"forever\", if you can outlast all your neighbors.</li>\n</ul>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; T &le; 100<br>\n  1 &le; c &le; C<br>\n  1 &le; r &le; R\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; C &le; 5<br>\n  1 &le; R &le; 5<br>\n  0 &le; S<sub>ci,ri</sub> &le; 10\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; C &le; 50<br>\n  1 &le; R &le; 50<br>\n  0 &le; S<sub>ci,ri</sub> &le; 1000\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3 3 2 2\n2 3 2\n1 7 1\n2 1 2\n4 3 2 1\n1 2 2 0\n10 8 5 10\n10 2 9 10\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: forever\nCase #2: 3 day(s)\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Apocalypse Soon","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>The Simple Solution</h3><p>\nLet us visualize this problem. Each animal is characterized as a pair (H, W), which can be viewed as a point in the two dimensional Cartesian coordinate system. For each animal that is known to be a bird, we color it red. For each animal known to be a non-bird, we color it blue. The problem states that there exists a rectangle such that a point is red if and only if it is in the rectangle. The problem is trivial if there are no red points. From now on we assume there are red points.\n</p><p>\nFor any two distinct points U and V, there is naturally a rectangle determined by U and V. It is the smallest rectangle containing both U and V, with the four corners U, V, (H<sub>U</sub>, W<sub>V</sub>), and (H<sub>V</sub>, W<sub>U</sub>). When U and V are on the same horizontal or vertical line, the rectangle degenerates to a segment. Formally, the rectangle contains all the points (H, W) such that\n<blockquote>\n(|H - H<sub>U</sub>| + |W - W<sub>U</sub>|) + (|H - H<sub>V</sub>| + |W - W<sub>V</sub>|) = |H<sub>U</sub> - H<sub>V</sub>| + |W<sub>U</sub> - W<sub>V</sub>|.\n</blockquote>\n</p><p>\nWe have the following proposition.\n<blockquote>\nIf U and V are two red points, and R be the rectangle determined by U and V; then any point in R must also be red, since any rectangle containing both U and V must contain R.\n</blockquote>\n</p><p>\nFor the set of all red points in the input, there is also naturally a <i>smallest</i> rectangle, R<sub>0</sub>, that contains all of them. There are different ways to define this rectangle:\n<ul>\n<li>(a) The intersection of all the rectangles that contain all the red points.</li>\n<li>(b) The union of all the rectangles determined by U and V, where (U, V) range over all the red point pairs.</li>\n<li>(c) The rectangle with four corners A=(H<sub>min</sub>, W<sub>min</sub>), B=(H<sub>min</sub>, W<sub>max</sub>), C=(H<sub>max</sub>, W<sub>min</sub>), and D=(H<sub>max</sub>, W<sub>max</sub>), where the min and max are taken over all the red points.</li>\n</ul>\nThe interested reader may check the equivalence of the above definitions.\n</p><p>\nNow, given a point X, we want to know if it is a bird or not. Clearly, if X is inside R<sub>0</sub>, then it must be bird. Otherwise, we may pretend it is red, and compute the new rectangle R' based on (c). This can be done in a constant number of comparisons. If there is a blue point from the input that lies in R', then X must not be a bird. Otherwise, X might (taking R' as the red rectangle) or might not (taking R<sub>0</sub> as the red rectangle) be a bird.\n</p><p>\nBy the limits of this problem, a &Theta;(NM) algorithm is fast enough. That is, we simply take any blue input point, and check if that is inside R'.\n</p>\n\n<h3>Further Discussion</h3><p>\nAnother way to view the last step of the solution, when the query point X is given, is to see whether there is a known red point Y such that the rectangle determined by X and Y contains any blue point. It is enough to check Y = A, B, C, or D as in (c). To check this, we do not need to go over all the blue input points. There are standard pre-processing techniques that can reduce the query time from N to log N.\n</p><p>\nFor example, for A, we can define two sets based on the blue inputs: those points that are higher (along the W-axis) than A (call them A<sub>1</sub>) and the rest of the A points (<nobr>A<sub>2</sub> = A - A<sub>1</sub></nobr>). The task of determining whether there is a blue point between X and A becomes the query of lowest or highest point in the range between H<sub>X</sub> and H<sub>A</sub>.\n</p>\n","id":"00000000004369b7","statement":"<h3>Problem</h3>\n<p>\n  You are studying animals in a forest, and are trying to determine which\n  animals are birds and which are not.\n</p><p>\n  You do this by taking two measurements of each animal &ndash; their height and\n  their weight. For an animal to be a bird, its height needs to be within some\n  range, and its weight needs to be within another range, but you're not sure\n  what the height and weight ranges are. You also know that <i>every</i> animal\n  that satisfies these ranges is a bird.\n</p><p>\n  You have taken some of the animals you have measured and shown them to\n  biologists, and they have told you which are birds and which are not. This has\n  given you some information on what the height and weight ranges for a bird\n  must be. For the remaining animals, your program should determine if they are\n  definitely birds, definitely not birds, or if you don't know from the\n  information you have.\n</p>\n\n<h3>Input</h3>\n<p>\n  One line containing an integer <b>C</b>, the number of test cases in the\n  input.\n</p><p>\n  Then for each of the <b>C</b> test cases:\n</p>\n<ul>\n  <li>\n    One line containing an integer <b>N</b>, the number of animals you have\n    shown to the biologists.\n  </li>\n  <li>\n    <b>N</b> lines, one for each of these animals, each of the format \"<b\n      >H W X</b\n    >\", where <b>H</b> is the height of the animal, <b>W</b> is the weight of\n    the animal, and <b>X</b> is either the string \"BIRD\" or \"NOT BIRD\". All\n    numbers are positive integers.\n  </li>\n  <li>\n    One line containing an integer <b>M</b>, the number of animals you have not\n    shown to the biologists.\n  </li>\n  <li>\n    <b>M</b> lines, one for each of these animals, each of the format \"<b>H W</b\n    >\", where <b>H</b> is the height of the animal and <b>W</b> is the weight of\n    the animal. All numbers are positive integers.\n  </li>\n</ul>\n\n<h3>Output</h3>\n<p>\n  For each of the <b>C</b> test cases:\n</p>\n<ul>\n  <li>\n    One line containing the string \"Case #<b>X</b>:\" where <b>X</b> is the\n    number of the test case, starting from 1.\n  </li>\n  <li>\n    M lines, each containing one of \"BIRD\", \"NOT BIRD\", or \"UNKNOWN\" (quotes are\n    just for clarity and should not be part of the output).\n  </li>\n</ul>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>C</b> &le; 10<br>\n  1 &le; all heights and weights &le; 1000000\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10<br>\n  1 &le; <b>M</b> &le; 10<br>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 1000<br>\n  1 &le; <b>M</b> &le; 1000<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n5\n1000 1000 BIRD\n2000 1000 BIRD\n2000 2000 BIRD\n1000 2000 BIRD\n1500 2010 NOT BIRD\n3\n1500 1500\n900 900\n1400 2020\n3\n500 700 NOT BIRD\n501 700 BIRD\n502 700 NOT BIRD\n2\n501 600\n502 501\n1\n100 100 NOT BIRD\n3\n107 93\n86 70\n110 115\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\nBIRD\nUNKNOWN\nNOT BIRD\nCase #2:\nUNKNOWN\nNOT BIRD\nCase #3:\nUNKNOWN\nUNKNOWN\nUNKNOWN\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Case 1:\n</p><p>\n  The animal \"1500 1500\" must be within the ranges for birds, since we know\n  that the ranges for height and weight each include 1000 and 2000.\n</p><p>\n  The animal \"900 900\" may or may not be a bird; we don't know if the ranges\n  for height and weight include 900.\n</p><p>\n  The animal \"1400 2020\" is within the height range for birds, but if 2020 was\n  in the weight range, then the animal \"1500 2010\", which we know is not a\n  bird, would also have to be within the weight range.\n</p><p>\n  Case 2:\n</p><p>\n  In this case we know that birds must have a height of 501. But we don't know\n  what the weight range for a bird is, other than that it includes weight 700.\n</p><p>\n  Case 3:\n</p><p>\n  In this case, we know that anything with height 100 and weight 100 is not a\n  bird, but we just don't know what birds are.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":12}],"title":"What are Birds?","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  The problem explicitly states that the contestant has an infinite number of\n  degrees of freedom. She can bet ANY fraction of her current amount. This makes\n  it impossible to brute force over all of the possible bets. The trick is to\n  discretize the problem.\n</p><p>\n  Following one of the principles in problem solving, we look at the easier\n  cases. The problem is easy if there is one round. We suggest you do it for the\n  case when there are two rounds. It is not hard, but it reveals the interesting\n  nature of the problem. The figure below illustrates the situation in the\n  second-to-last round, the last round and after the last round.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0cOx6gst1T8ohtxwsd-pwdvfHK3UjteeHwd5JZFGoBF0NDmkFQ5lwHDTx-W1uxZXnyL01d7w/milli01.png\" />\n<p>\n  The colors represent different probability zones. All sums in a probability\n  zone share the same probability of winning. The <i>important</i> sums are\n  marked and labeled.\n</p><p>\n  If we know the probability of winning for all sums in the next round\n  P<sub>next</sub>(sum), then the probability of winning in this round is:\n</p>\n<blockquote>\n  p * P<sub>next</sub>(sum + stake) + (1 - p) P<sub>next</sub>(sum - stake),\n</blockquote>\n<p>where <code>stake</code> is the amount we are betting.</p><p>\n  Now, given the existence and location of the important sums in the next round,\n  we can find the locations of the important sums in this round. The figure\n  below illustrates how we find these sums. The midpoints between the important\n  sums of the next round become important in this round. I.e in the case of the\n  green point in figure 2, we can move up by lowering the stake, and we can move\n  down by increasing the stake, without changing the end probability. The\n  probability of the blue, green and red points is the same. This also\n  illustrates that the probability in a 'probability zone' which is limited by\n  two important sums is equal to the probability at the lower important sum.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U01bErKnQnTz5oPw9BdebnlY2wh4Ge_gFpK7uvCGqqv1uNsxfaeWVyIN4HojnJ5rcKHJObdVQ/milli02.png\" />\n\n<p>\n  Conclusion: The important sums of round i are the union of the important sums\n  of round <nobr>(i+1)</nobr> and their midpoints. We need to consider $0 an\n  important sum in the last round because we can't bet more than we have.\n</p><p>\n  Now, we only need to compute probabilities at the important sums,\n  bootstrapping at 1.0 for $1000000, and 0.0 for $0 in the last round. Then,\n  going backwards, we fill the probabilities at the important sums in the\n  previous rounds.\n</p><p>\n  By the limits of the input, we may try all the stakes that lead to important\n  points in the next round. It is an interesting question whether there are\n  mathematical properties that could reduce the complexity of this computation,\n  but that is beyond the scope of this analysis.\n</p>\n","id":"0000000000436a99","statement":"<h3>Problem</h3>\n<p>\n  You have been invited to the popular TV show \"Would you like to be a\n  millionaire?\". Of course you would!\n</p><p>\n  The rules of the show are simple:\n</p>\n<ul>\n  <li>\n    Before the game starts, the host spins a wheel of fortune to determine\n    <b>P</b>, the probability of winning each bet.\n  </li>\n  <li>You start out with some money: <b>X</b> dollars.</li>\n  <li>\n    There are <b>M</b> rounds of betting. In each round, you can bet any part of\n    your current money, including none of it or all of it. The amount is not\n    limited to whole dollars or whole cents.<br>\n    If you win the bet, your total amount of money increases by the amount you\n    bet. Otherwise, your amount of money decreases by the amount you bet.\n  </li>\n  <li>\n    After all the rounds of betting are done, you get to keep your winnings\n    (this time the amount is rounded down to whole dollars) only if you have\n    accumulated $1000000 or more. Otherwise you get nothing.\n  </li>\n</ul>\n<p>\n  Given <b>M</b>, <b>P</b> and <b>X</b>, determine your probability of winning\n  at least $1000000 if you play optimally (i.e. you play so that you maximize\n  your chances of becoming a millionaire).\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of input gives the number of cases, <b>N</b>.\n</p><p>\n  Each of the following <b>N</b> lines has the format \"<b>M</b> <b>P</b>\n  <b>X</b>\", where:\n</p>\n<ul>\n  <li><b>M</b> is an integer, the number of rounds of betting.</li>\n  <li><b>P</b> is a real number, the probability of winning each round.</li>\n  <li><b>X</b> is an integer, the starting number of dollars.</li>\n</ul>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing \"Case #<b>X</b>: <b>Y</b>\",\n  where:\n</p>\n<ul>\n  <li><b>X</b> is the test case number, beginning at 1.</li>\n  <li>\n    <b>Y</b> is the probability of becoming a millionaire, between 0 and 1.\n  </li>\n</ul>\n<p>\n  Answers with a relative or absolute error of at most 10<sup>-6</sup> will be\n  considered correct.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.<br>\n  1 &le; <b>N</b> &le; 100<br>\n  0 &le; <b>P</b> &le; 1.0, there will be at most 6 digits after the decimal\n  point.<br>\n  1 &le; <b>X</b> &le; 1000000\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>M</b> &le; 5\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>M</b> &le; 15\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n1 0.5 500000\n3 0.75 600000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.500000\nCase #2: 0.843750\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  In the first case, the only way to reach $1000000 is to bet everything in\n  the single round.\n</p><p>\n  In the second case, you can play so that you can still reach $1000000 even\n  if you lose a bet. Here's one way to do it:\n</p>\n<ul>\n  <li>You have $600000 on the first round. Bet $150000.</li>\n  <li>If you lose the first round, you have $450000 left. Bet $100000.</li>\n  <li>\n    If you lose the first round and win the second round, you have $550000\n    left. Bet $450000.\n  </li>\n  <li>If you win the first round, you have $750000 left. Bet $250000.</li>\n  <li>\n    If you win the first round and lose the second round, you have $500000\n    left. Bet $500000.\n  </li>\n</ul>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":2,"type__str":"HIDDEN","value":16}],"title":"Millionaire","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This problem is a classical graph problem called <i>subtree isomorphism</i>.\n  As an interesting note, the modern era in art history actually starts far\n  earlier than the so called classical period in computer science.\n</p><p>\n  In this problem, we are given two trees <b>T<sub>1</sub></b> and\n  <b>T<sub>2</sub></b>. We are going to decide if T<sub>2</sub> is isomorphic\n  to any subtree of T<sub>1</sub>. The general sub-graph isomorphism problem is\n  notoriously hard.  But as you perhaps have seen many times, when the things\n  come to trees, it is very solvable. The problem is actually well studied, and\n  is a standard exercise in algorithm design.\n</p><p>\n  <i>First, a bit of terminology.</i> Just for convenience, in our discussion,\n  for two rooted trees, we say one <i>fits into</i> the other if there us an\n  isomorphism that maps the former to a subtree of the latter such that the root\n  is mapped to the other's root.\n</p><p>\n  We may fix T<sub>2</sub> and consider it as a tree rooted at vertex 0. We do\n  not know which vertex of T<sub>1</sub> corresponds to 0 of T<sub>2</sub> in\n  the isomorphism. But we may try each vertex in T<sub>1</sub>, and see if\n  T<sub>2</sub> fits into T<sub>1</sub>.<br>\n  For a concrete example, let's say we root T<sub>1</sub> at vertex <b>x</b>.\n  Assume that there are 3 children of 0 in T<sub>2</sub> -- y<sub>1</sub>,\n  y<sub>2</sub>, and y<sub>3</sub>. Assume that there are 5 children of x in\n  T<sub>1</sub> -- x<sub>1</sub>. x<sub>2</sub>, x<sub>3</sub>. T<sub>2</sub>\n  fits into T<sub>1</sub> if and only if we can find that the subtree at\n  y<sub>1</sub> fits into the subtree at x<sub>i</sub> for some i, the subtree\n  at y<sub>2</sub> fits into the subtree at x<sub>j</sub> for some other j &ne;\n  i, and the subtree at y<sub>3</sub> fits into the subtree at x<sub>k</sub>\n  for some k &ne; i, k &ne; j.\n</p><p>\n  The solution for this problem as follows. Once we have fixed the root x, each\n  vertex has a level in its tree. For each vertex <b>u</b> in T<sub>1</sub> and\n  <b>v</b> in T<sub>2</sub>, if they have the same level (just a bit of\n  reasonable optimization, not necessary for this problem), we want to decide if\n  the subtree at v fits into the subtree at u. We do this from bottom up, the\n  deeper levels first.<br>\n  For any such pair (u, v) with children { u<sub>i</sub> | i = 1,2,... } and {\n  v<sub>j</sub> | j = 1,2,... }, we know which v<sub>j</sub> fits into which\n  u<sub>i</sub> since we are doing the computations bottom up. We find a fit if\n  and only if we can find, for each v<sub>j</sub>, a distinct u<sub>i</sub> such\n  that v<sub>j</sub> fits into u<sub>i</sub>. This is clearly a bipartite graph\n  matching problem.\n</p><p>\n  We leave it an exercise to prove that the algorithm, runs in\n  O(N<sup>2</sup>M<sup>2</sup>) time. There are algorithms with better\n  complexities. For interested readers, we refer to the following paper<br>\n  R. Shamir, D. Tsur, \"<i>Faster Subtree Isomorphism</i>\", Journal of Algorithm,\n  33, 267-280 (1999).<br>\n  which contains a recent result as well as references to earlier works.\n</p>\n\n<h3>More information</h3>\n<p>\n  <a href=\"http://www.google.com/search?q=subtree+isomorphism\" target=\"_blank\">Subtree Isomorphism</a> -\n  <a href=\"http://www.google.com/search?q=graph+isomorphism\" target=\"_blank\">Graph Isomorphism</a> -\n  <a href=\"http://www.google.com/search?q=bipartite+matching\" target=\"_blank\">Bipartite Matching</a>\n</p>\n","id":"0000000000436f68","statement":"<h3>Problem</h3>\n<p>\n  You have pictures of two sculptures. The sculptures consist of several solid\n  metal spheres, and some rubber pipes connecting pairs of spheres. The pipes in\n  each sculpture are connected in such a way that for any pair of spheres, there\n  is exactly one path following a series of pipes (without repeating any)\n  between those two spheres. All the spheres have the same radius, and all the\n  pipes have the same length.\n</p><p>\n  You suspect that the smaller of the two sculptures was actually created by\n  simply removing some spheres and pipes from the larger one. You want to write\n  a program to test if this is possible.\n</p><p>\n  The input will contain several test cases. One sculpture is described by\n  numbering the spheres consecutively from 1, and listing the pairs of spheres\n  which are connected by pipes. The numbering is chosen independently for each\n  sculpture.\n</p>\n\n<h3>Input</h3>\n<ul>\n  <li>\n    One line containing an integer <b>C</b>, the number of test cases in the\n    input file.\n  </li>\n</ul>\n\nFor each test case, there will be:\n<ul>\n  <li>\n    One line containing the integer <b>N</b>, the number of spheres in the large\n    sculpture.\n  </li>\n  <li>\n    <b>N</b>&minus;1 lines, each containing a pair of space-separated integers,\n    indicating that the two spheres with those numbers in the large sculpture\n    are connected by a pipe.\n  </li>\n  <li>\n    One line containing the integer <b>M</b>, the number of spheres in the small\n    sculpture.\n  </li>\n  <li>\n    <b>M</b>&minus;1 lines, each containing a pair of space-separated integers,\n    indicating that the two spheres with those numbers in the small sculpture\n    are connected by a pipe.\n  </li>\n</ul>\n\n<h3>Output</h3>\n<ul>\n  <li>\n    <b>C</b> lines, one for each test case in the order they occur in the input\n    file, containing \"Case #<b>X</b>: YES\" if the small sculpture in case\n    <b>X</b> could have been created from the large sculpture in case <b>X</b>,\n    or \"Case #<b>X</b>: NO\" if it could not. (<b>X</b> is the number of the test\n    case, between 1 and <b>C</b>.)\n  </li>\n</ul>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br>\n  Memory limit: 1GB.\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n  1 &le; <b>C</b> &le; 100<br>\n  2 &le; <b>N</b> &le; 8<br>\n  1 &le; <b>M</b> &lt; N<br>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>C</b> &le; 50<br>\n  2 &le; <b>N</b> &le; 100<br>\n  1 &le; <b>M</b> &lt; N<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n5\n1 2\n2 3\n3 4\n4 5\n4\n1 2\n1 3\n1 4\n5\n1 2\n1 3\n1 4\n4 5\n4\n1 2\n2 3\n3 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: NO\nCase #2: YES\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  In the first case, the large sculpture has five spheres connected in a\n  line, and the small sculpture has one sphere that has three other spheres\n  connected to it. There's no way the smaller sculpture could have been made\n  by removing things from the larger one.\n</p><p>\n  In the second case, the small sculpture is four spheres connected in a\n  line. These can match the larger sculpture's spheres in the order 2-1-4-5.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Modern Art Plagiarism","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000436b54","type":1,"type__str":"SPECTATOR"},"title":"APAC Semifinal 2008"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
