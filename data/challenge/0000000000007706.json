{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1526747400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000007706","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  This year, rank 1000 in Round 2 became an especially important cutoff point\n  &mdash; contestants had to place at least 1000th to earn advancement to Round\n  3 and the Distributed Code Jam Online Round, as well as the 2018 Code Jam\n  T-shirt. With 4500 eligible contestants, though, it wasn't going to be easy,\n  and there were also four problems to contend with!\n</p><p>\n  We hope you warmed up with <i>Falling Balls</i>, which allowed for\n  complicated constructions but was solvable with a straightforward greedy one.\n  <i>Graceful Chainsaw Jugglers</i> and <i>Costume Change</i> required some\n  original insights and some familiarity with typical techniques in the\n  algorithmic toolbox like dynamic programming and matching. The graph problem\n  <i>Gridception</i> was the toughest of the set; even once you saw the\n  solution, there was plenty of implementation work left!\n</p><p>\n  Unlike many of our previous Round 2s, this set lacked a killer problem, and\n  our awesome contestants racked up almost 250 perfect scores! Our four-time\n  defending world champion <b>Gennady.Korotkevich</b> secured first place,\n  solving all four problems in just over 40 minutes. <b>Um_nik</b> and\n  <b>cki86201</b> were close behind, coming in with penalty times around the 43\n  and 46 minute marks. The cutoff for advancement appears to be 44 points\n  (Falling Balls plus Costume Change) plus sufficient solving speed; as usual,\n  official results will be mailed out soon.\n</p><p>\n  Our top 1000 contestants have a weekend with two rounds (Code Jam and\n  Distributed Code Jam) coming up in three weeks.\n  After that, we will know who will be heading to Toronto!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Falling Balls: Written by Pablo Heiber.\n</p><p>\n  Graceful Chainsaw Jugglers: Written by Pablo Heiber and Ian Tullis.\n</p><p>\n  Costume Change: Written by Jonathan Irvin Gunawan.\n</p><p>\n  Gridception: Written by Pablo Heiber and Ian Tullis.\n</p><p>\n  All four problems prepared by Jonathan Irvin Gunawan.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Jackson\n  Gatenby, Md Mahbubul Hasan, Brian Hirashiki, Trung Thanh Nguyen, Ray\n  Robinson, Kevin Tran, and Erick Wong.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Falling Balls: Ian Tullis</li>\n  <li>Graceful Chainsaw Jugglers: Pablo Heiber</li>\n  <li>Costume Change: Jonathan Irvin Gunawan</li>\n  <li>Gridception: Jonathan Irvin Gunawan</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1526738400000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  Trying every possible costume on every dancer will be too slow, even for this\n  test set. Therefore, we need another solution.\n</p>\n<p>\n  To solve this test set, we can first observe that this problem is equivalent\n  to the following: Find the largest subset of dancers such that no two dancers\n  in the subset have the same costume type and share the same row or column.\n</p>\n<p>\n  If we find such a subset, we can change the costume types of the dancers not\n  in the subset so that they follow the rules. We can iterate through the\n  dancers in any order (e.g. row-major). If the current dancer is in the subset,\n  we leave the costume as it is. Otherwise, we pick a new costume type for that\n  dancer. Since a dancer can be in the same row or column as at most\n  2<b>N</b> - 2 other dancers, and since there are 2<b>N</b> costume types, it\n  will always be possible to find a valid type to change to.\n</p>\n<p>\n  So, we can iterate through every subset of of dancers and check whether there\n  are two dancers in the subset having the same costume type and sharing the\n  same row or column. This solution runs in\n  O(2<sup><b>N</b><sup>2</sup></sup> &times; <b>N</b><sup>2</sup>) time.\n</p>\n<h3>Test set 2</h3>\n<p>\n  To solve this test set, we need a much more efficient way of finding the\n  subset mentioned above. We can solve the problem independently for each\n  costume type. Let f(x) be the largest subset of dancers who are wearing a\n  costume with type x, such that no two dancers in the subset share a row or\n  column. Then the size of our desired subset will be &Sigma; f(i) for\n  -<b>N</b> &leq; i &leq; <b>N</b>, i &ne; 0.\n</p>\n<p>\n  How can we find f(x)? Let us create a bipartite graph as follows:\n  <ul>\n    <li>\n      {A<sub>i</sub>} is a set of vertices, where each vertex corresponds to a\n      row.\n    </li>\n    <li>\n      {B<sub>i</sub>} is another set of vertices, where each vertex corresponds\n      to a column.\n    </li>\n    <li>\n      If and only if the dancer in the i-th row and the j-th column wears a\n      costume of type x, we add an edge connecting A<sub>i</sub> and\n      B<sub>j</sub>.\n    </li>\n  </ul>\n  To find the largest valid subset of dancers, we need to find the maximum\n  independent set of this graph, since we can only pick one dancer for each row\n  and column. We can use a\n  <a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)#Bipartite_matching\">\n  maximum cardinality bipartite matching algorithm</a> to solve this problem.\n</p>\n<p>\n  A simple maximum cardinality bipartite matching algorithm runs in O(VE), where\n  V is the number of vertices and E is the number of edges. Since\n  V = O(<b>N</b>) and the sum of E among all costume types is\n  <b>N</b><sup>2</sup>, this solution runs in O(<b>N</b><sup>3</sup>), which is\n  fast enough to solve test set 2.\n</p>\n","id":"0000000000045875","statement":"<h3>Problem</h3>\n<p>\n  Supervin is a well-known choreographer. Today is the <b>N</b>-th anniversary\n  of his choreography career. To celebrate it, he is planning a dance on a stage\n  that is a square grid of size <b>N</b> by <b>N</b>. Exactly one dancer will\n  stand in each grid cell.\n</p><p>\n  Each dancer will wear a costume; each costume has a single color, and is made\n  out of either wool or cotton as its material. Supervin has <b>N</b> colors to\n  choose from when designing the costumes for his dancers, indexed from 1 to\n  <b>N</b>.\n</p><p>\n  Each dancer wants to feel special. If two or more dancers share a row or\n  column and also have costumes of the same color and material, they will no\n  longer feel special.\n</p><p>\n  Supervin wants all of his dancers to feel special. Therefore, Supervin is\n  prepared to change the color and/or material of dancers' costumes so that no\n  dancer shares a row or column with another dancer with the same costume (same\n  color and same material). What is the minimum number of dancers whose costumes\n  must be changed in order to make this happen? (Note that a change to both the\n  color and material of a costume still counts as only one change.)\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line containing an integer\n  <b>N</b>: the side length (in unit cells) of the square grid of dancers.\n  Then, <b>N</b> lines follow; each contains <b>N</b> non-zero integers\n  <b>A</b><sub>i, j</sub>. The j-th value on the i-th line represents the\n  costume of the dancer in the i-th row and j-th column of the grid. The\n  magnitude of the value gives the color and the sign of the value gives the\n  material (- for wool, + for cotton).\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the minimum number of dancers whose costumes must be changed, as described\n  above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  -<b>N</b> &le; <b>A</b><sub>i, j</sub> &le; <b>N</b>, for all i, j.<br/>\n  <b>A</b><sub>i, j</sub> &ne; 0, for all i, j.<br/>\n  Time limit: 15 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  2 &le; <b>N</b> &le; 4.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  2 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">4\n2\n1 2\n2 1\n2\n1 1\n2 1\n2\n1 2\n1 2\n2\n2 2\n-2 2\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: 0\nCase #2: 1\nCase #3: 2\nCase #4: 1\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  In Sample Case #1, no costumes need to be changed, since no dancer shares a\n  row or column with another dancer with the same costume.\n</p><p>\n  In Sample Case #2, one optimal solution is to change the value of <b>A</b>\n  into the following (bold indicates changed values):\n</p><pre>\n  1 <b>-2</b>\n  2 1\n</pre><p>\n  Other optimal solutions are possible. Note that changing both the color and\n  the material of a dancer's costume only counts as one change.\n</p><p>\n  In Sample Case #3, one optimal solution is to change the value of <b>A</b>\n  into the following (bold indicates changed values):\n</p><pre>\n  1 2\n  <b>2</b> <b>1</b>\n</pre><p>\n  Other optimal solutions are possible.\n</p><p>\n  In Sample Case #4, one optimal solution is to change the value of <b>A</b>\n  into the following (bold indicates changed values):\n</p><pre>\n  2 <b>-2</b>\n  -2 2\n</pre><p>\n  Other optimal solutions are possible.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Costume Change","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  We can narrow down the scope of Test set 1 with only a couple of insights:\n</p>\n<ul>\n  <li>We cannot put any ramps in the leftmost and rightmost columns, so the\n    balls dropped into those columns must fall straight down to the bottom. So,\n    if either of those columns has no balls, the case is\n    <code>IMPOSSIBLE</code>. (Later on in this analysis, it will become clear\n    that this is the only way for a case to be impossible!)</li>\n  <li>Suppose <b>C</b> has its maximum value of 5. Since we know the leftmost\n    and rightmost columns must have at least one ball each, the only variation\n    among cases comes from where the other 3 balls end up. It turns out that\n    there are only 35 ways to partition 3 balls among 5 columns, and some of\n    these cases are mirror reflections of each other, so there are really only\n    19 distinct cases to consider. When <b>C</b> is smaller than 5, there are\n    even fewer cases.</li>\n</ul>\n<p>\n  So, we can experiment offline, generating potential ramp arrangements via\n  simulation or by hand, until we are confident in our solutions for all cases,\n  and then submit; since Test set 1 is Visible, we have little to lose.\n  However, we can avoid this extra work, as follows...\n</p>\n<h3>Test set 2</h3>\n<p>\n  Consider the paths that each ball might take through the toy, and notice\n  that whenever two balls' paths intersect, those balls must end up in the\n  same final column. (Because we can never have a <code>\\</code> ramp\n  immediately to the left of a <code>/</code> ramp, paths cannot cross over\n  each other.)\n</p><p>\n  So, for example, if your friend says there are exactly K balls in the\n  leftmost column, they must have been the balls that were originally dropped\n  into the K leftmost columns. Suppose that one of those balls had instead come\n  from, e.g., the (K+1)-th column; then the path taken by that ball would have\n  crossed all of the paths taken by the balls in the K leftmost columns, so all\n  K+1 of the balls would have ended up in the leftmost column, which is a\n  contradiction.\n</p><p>\n  With those observations in mind, let us think of the i-th column as both a\n  <i>source</i> of one ball and a potential <i>target</i> of\n  <b>B<sub>i</sub></b> balls (if <b>B<sub>i</sub></b> &gt; 0). We can scan our\n  friend's list from left to right, and when we encounter a positive\n  <b>B<sub>i</sub></b> value, we allocate the <b>B<sub>i</sub></b> leftmost\n  source columns that we have not used so far to target column i. So, for\n  example, if we have the data <code>3 2 0 0 0 0 2 1</code>, we map the source\n  column range [1, 3] to target column 1, the source column range [4, 5] to\n  target column 2, the source column range [6, 7] to target column 7, and the\n  source column range [8, 8] to target column 8.\n</p><p>\n  Once we have this mapping, we can move on to designing the toy to ensure\n  that every source column's ball will end up at the bottom of the appropriate\n  target column. We will start with an empty top row, and add ramps and more\n  rows as needed.\n</p><p>\n  For each source column range, we check whether the left endpoint is to the\n  left of the target. If it is not, we do nothing. Suppose, on the other hand,\n  that it is L columns to the left of the target. Then we add L <code>\\</code>\n  ramps, starting in the top row and the left endpoint's column, and proceeding\n  diagonally, moving one cell to the right and one cell down each time. Notice\n  that this line of ramps will catch all balls in that source column range that\n  need to move to the right, so we do not need to explicitly worry about those\n  balls. Then, we draw similar diagonal lines of <code>/</code> ramps running\n  down and to the left from our right endpoints. Finally, if our bottom row is\n  not empty, we add an empty bottom row, as the rules require.\n</p><p>\n  Can we convince ourselves that this construction is optimal? We have already\n  shown that the mapping of source columns to target columns is forced.\n  Consider the largest absolute difference, in columns, between a target column\n  and one of the endpoints of the range of source columns mapped to it. (In our\n  example above, this value is |5 - 2| = 3.) The toy must have at least this\n  many rows (in addition to the empty bottom row), because a ball can only\n  interact with one ramp per row, and each ramp only moves a ball one cell in\n  the desired direction. Observe that our construction uses exactly this many\n  rows, plus the required empty bottom row. For our example, our method\n  produces:\n</p>\n<p><code>\n    .././\\..<br/>\n    ././....<br/>\n    ../.....<br/>\n    ........<br/>\n</code></p>\n<p>\n  Notice that there is no danger of creating a <code>\\/</code> pattern within a\n  range, since no target position could cause that.\n</p>\n","id":"00000000000459f2","statement":"<h3>Problem</h3>\n\n<p>\n  A certain toy consists of a grid of 2 or more columns and 1 or more rows,\n  where each cell of the grid contains either a <code>\\</code> ramp or a\n  <code>/</code> ramp, or is empty. The leftmost and rightmost columns are\n  empty and the bottom row is also empty. Balls are dropped into the top row\n  and fall vertically, sliding on ramps. To prevent balls from getting stuck,\n  a cell with a <code>\\</code> ramp is never immediately to the left of a cell\n  with a <code>/</code> ramp.\n</p><p>\n  When a ball is dropped into the top row, it moves deterministically as\n  follows:\n</p>\n<ul>\n  <li>A ball in an empty cell moves to the cell immediately below its current\n    cell, unless it is in the bottom row, in which case it does not move any\n    more.</li>\n  <li>A ball in a cell containing a <code>\\</code> ramp moves to the cell\n    immediately below and to the right of its current cell.</li>\n  <li>A ball in a cell containing a <code>/</code> ramp moves to the cell\n    immediately below and to the left of its current cell.</li>\n</ul>\n<p>\n  To see the mechanism to its full extent, the user drops exactly one ball into\n  each column. Balls do not interfere with each other, and it is possible for a\n  cell to contain multiple balls.\n</p><p>\n  Your friend has a toy with <b>C</b> columns and an unknown number of rows.\n  They just dropped one ball into the top row of each column, and waited for\n  all balls to stop moving. Then, they counted how many balls ended up in each\n  of the cells of the bottom row, and gave you those results... but you think\n  it is possible that they made a mistake. Can you create a layout that is\n  consistent with the results and uses as few rows as possible, or determine\n  that no such layout exists?\n</p><p>\n  For example, if your friend reported the values <code>3 0 0 2 0 1</code>,\n  one possible solution would be the following. (Note that it is not necessary\n  to use a minimal number of ramps, or for every ramp to affect the balls.)\n</p>\n<p><code>\n    .//\\..<br/>\n    ./\\./.<br/>\n    ......<br/>\n</code></p>\n<p>\n  Here are the paths that the balls would take when falling through that grid:\n</p>\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" height=\"500px\" width=\"500px\"\n\t viewBox=\"0 0 144 144\" enable-background=\"new 0 0 144 144\" xml:space=\"preserve\">\n<g>\n\t<rect x=\"8\" y=\"45.3\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M29.4,66.7H7.9V45.2h21.5V66.7z M8.1,66.5h21.2V45.3H8.1V66.5z\"/>\n</g>\n<g>\n\t<rect x=\"29.3\" y=\"45.3\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M50.7,66.7H29.3V45.2h21.5V66.7z M29.4,66.5h21.2V45.3H29.4V66.5z\"/>\n</g>\n<g>\n\t<rect x=\"50.7\" y=\"45.3\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M72.1,66.7H50.6V45.2h21.5V66.7z M50.7,66.5h21.2V45.3H50.7V66.5z\"/>\n</g>\n<g>\n\t<rect x=\"72\" y=\"45.3\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M93.4,66.7H71.9V45.2h21.5V66.7z M72.1,66.5h21.2V45.3H72.1V66.5z\"/>\n</g>\n<g>\n\t<rect x=\"93.3\" y=\"45.3\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M114.7,66.7H93.3V45.2h21.5V66.7z M93.4,66.5h21.2V45.3H93.4V66.5z\"/>\n</g>\n<g>\n\t<rect x=\"114.7\" y=\"45.3\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M136.1,66.7h-21.5V45.2h21.5V66.7z M114.7,66.5h21.2V45.3h-21.2V66.5z\"/>\n</g>\n<g>\n\t<rect x=\"8\" y=\"66.6\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M29.4,88H7.9V66.5h21.5V88z M8.1,87.9h21.2V66.7H8.1V87.9z\"/>\n</g>\n<g>\n\t<rect x=\"29.3\" y=\"66.6\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M50.7,88H29.3V66.5h21.5V88z M29.4,87.9h21.2V66.7H29.4V87.9z\"/>\n</g>\n<g>\n\t<rect x=\"50.7\" y=\"66.6\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M72.1,88H50.6V66.5h21.5V88z M50.7,87.9h21.2V66.7H50.7V87.9z\"/>\n</g>\n<g>\n\t<rect x=\"72\" y=\"66.6\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M93.4,88H71.9V66.5h21.5V88z M72.1,87.9h21.2V66.7H72.1V87.9z\"/>\n</g>\n<g>\n\t<rect x=\"93.3\" y=\"66.6\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M114.7,88H93.3V66.5h21.5V88z M93.4,87.9h21.2V66.7H93.4V87.9z\"/>\n</g>\n<g>\n\t<rect x=\"114.7\" y=\"66.6\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M136.1,88h-21.5V66.5h21.5V88z M114.7,87.9h21.2V66.7h-21.2V87.9z\"/>\n</g>\n<g>\n\t<rect x=\"8\" y=\"87.9\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M29.4,109.3H7.9V87.9h21.5V109.3z M8.1,109.2h21.2V88H8.1V109.2z\"/>\n</g>\n<g>\n\t<rect x=\"29.3\" y=\"87.9\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M50.7,109.3H29.3V87.9h21.5V109.3z M29.4,109.2h21.2V88H29.4V109.2z\"/>\n</g>\n<g>\n\t<rect x=\"50.7\" y=\"87.9\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M72.1,109.3H50.6V87.9h21.5V109.3z M50.7,109.2h21.2V88H50.7V109.2z\"/>\n</g>\n<g>\n\t<rect x=\"72\" y=\"87.9\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M93.4,109.3H71.9V87.9h21.5V109.3z M72.1,109.2h21.2V88H72.1V109.2z\"/>\n</g>\n<g>\n\t<rect x=\"93.3\" y=\"87.9\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M114.7,109.3H93.3V87.9h21.5V109.3z M93.4,109.2h21.2V88H93.4V109.2z\"/>\n</g>\n<g>\n\t<rect x=\"114.7\" y=\"87.9\" fill=\"#FFFFFF\" width=\"21.3\" height=\"21.3\"/>\n\t<path fill=\"#D1D3D4\" d=\"M136.1,109.3h-21.5V87.9h21.5V109.3z M114.7,109.2h21.2V88h-21.2V109.2z\"/>\n</g>\n<g>\n\t<rect x=\"18.1\" y=\"36.2\" fill=\"#2196F3\" width=\"1.2\" height=\"1.2\"/>\n\t<path fill=\"#2196F3\" d=\"M19.2,105.8h-1.2v-2.3h1.2V105.8z M19.2,101.3h-1.2V99h1.2V101.3z M19.2,96.7h-1.2v-2.3h1.2V96.7z\n\t\t M19.2,92.1h-1.2v-2.3h1.2V92.1z M19.2,87.6h-1.2v-2.3h1.2V87.6z M19.2,83h-1.2v-2.3h1.2V83z M19.2,78.5h-1.2v-2.3h1.2V78.5z\n\t\t M19.2,73.9h-1.2v-2.3h1.2V73.9z M19.2,69.3h-1.2V67h1.2V69.3z M19.2,64.8h-1.2v-2.3h1.2V64.8z M19.2,60.2h-1.2v-2.3h1.2V60.2z\n\t\t M19.2,55.6h-1.2v-2.3h1.2V55.6z M19.2,51.1h-1.2v-2.3h1.2V51.1z M19.2,46.5h-1.2v-2.3h1.2V46.5z M19.2,41.9h-1.2v-2.3h1.2V41.9z\"\n\t\t/>\n\t<rect x=\"18.1\" y=\"108.1\" fill=\"#2196F3\" width=\"1.2\" height=\"1.2\"/>\n</g>\n<g>\n\t<rect x=\"124.8\" y=\"40.9\" fill=\"#4CAF50\" width=\"1.2\" height=\"1.2\"/>\n\t<path fill=\"#4CAF50\" d=\"M125.9,105.8h-1.2v-2.3h1.2V105.8z M125.9,101.3h-1.2V99h1.2V101.3z M125.9,96.7h-1.2v-2.3h1.2V96.7z\n\t\t M125.9,92.2h-1.2v-2.3h1.2V92.2z M125.9,87.6h-1.2v-2.3h1.2V87.6z M125.9,83h-1.2v-2.3h1.2V83z M125.9,78.5h-1.2v-2.3h1.2V78.5z\n\t\t M125.9,73.9h-1.2v-2.3h1.2V73.9z M125.9,69.4h-1.2v-2.3h1.2V69.4z M125.9,64.8h-1.2v-2.3h1.2V64.8z M125.9,60.2h-1.2V58h1.2V60.2z\n\t\t M125.9,55.7h-1.2v-2.3h1.2V55.7z M125.9,51.1h-1.2v-2.3h1.2V51.1z M125.9,46.6h-1.2v-2.3h1.2V46.6z\"/>\n\t<rect x=\"124.8\" y=\"108.1\" fill=\"#4CAF50\" width=\"1.2\" height=\"1.2\"/>\n</g>\n<g>\n\t<rect x=\"39.5\" y=\"36.2\" fill=\"#F44336\" width=\"1.2\" height=\"1.2\"/>\n\t<path fill=\"#F44336\" d=\"M23.2,105.8h-1.2v-2.4h1.2V105.8z M23.2,101h-1.2v-2.4h1.2V101z M23.2,96.3h-1.2V94h1.2V96.3z M23.2,91.6\n\t\th-1.2v-2.4h1.2V91.6z M23.2,86.9h-1.2v-2.4h1.2V86.9z M23.2,82.2h-1.2v-2.4h1.2V82.2z M23.2,77.4h-1.2v-2.4h1.2V77.4z M23.2,72.7\n\t\th-1.2v-2.4h1.2V72.7z M23.2,68h-1.2v-1.7c0-0.2,0.1-0.3,0.2-0.4l0.5-0.5l0.8,0.8l-0.3,0.3V68z M25.2,64.6l-0.8-0.8l1.7-1.7l0.8,0.8\n\t\tL25.2,64.6z M28.5,61.2l-0.8-0.8l1.7-1.7l0.8,0.8L28.5,61.2z M31.8,57.8L31,57l1.7-1.7l0.8,0.8L31.8,57.8z M35.1,54.4l-0.8-0.8\n\t\tl1.7-1.7l0.8,0.8L35.1,54.4z M38.4,51.1l-0.8-0.8l1.7-1.7l0.8,0.8L38.4,51.1z M40.6,46.8h-1.2v-2.4h1.2V46.8z M40.6,42.1h-1.2v-2.4\n\t\th1.2V42.1z\"/>\n\t<rect x=\"22.1\" y=\"108.1\" fill=\"#F44336\" width=\"1.2\" height=\"1.2\"/>\n</g>\n<g>\n\t<rect x=\"60.8\" y=\"36.2\" width=\"1.2\" height=\"1.2\"/>\n\t<path d=\"M26.7,105.8h-1.2v-2.3h1.2V105.8z M26.7,101.2h-1.2v-2.3h1.2V101.2z M26.7,96.6h-1.2v-2.3h1.2V96.6z M26.7,92h-1.2v-2.3\n\t\th1.2V92z M26.7,87.4h-1.2v-2.3h1.2V87.4z M27.7,83.6l-0.8-0.8l1.6-1.6l0.8,0.8L27.7,83.6z M30.9,80.4l-0.8-0.8l1.6-1.6l0.8,0.8\n\t\tL30.9,80.4z M34.2,77.1l-0.8-0.8l1.6-1.6l0.8,0.8L34.2,77.1z M37.5,73.8L36.6,73l1.6-1.6l0.8,0.8L37.5,73.8z M40.7,70.6l-0.8-0.8\n\t\tl1.6-1.6l0.8,0.8L40.7,70.6z M44,67.3l-0.8-0.8l1.6-1.6l0.8,0.8L44,67.3z M47.2,64.1l-0.8-0.8l1.6-1.6l0.8,0.8L47.2,64.1z\n\t\t M50.5,60.8L49.7,60l1.6-1.6l0.8,0.8L50.5,60.8z M53.8,57.5l-0.8-0.8l1.6-1.6l0.8,0.8L53.8,57.5z M57,54.3l-0.8-0.8l1.6-1.6\n\t\tl0.8,0.8L57,54.3z M60.3,51l-0.8-0.8l1.5-1.5l0.2,0.2h0.8v0.2c0,0.2-0.1,0.3-0.2,0.4L60.3,51z M61.9,46.6h-1.2v-2.3h1.2V46.6z\n\t\t M61.9,42h-1.2v-2.3h1.2V42z\"/>\n\t<rect x=\"25.6\" y=\"108.1\" width=\"1.2\" height=\"1.2\"/>\n</g>\n<circle fill=\"#1976D2\" cx=\"18.7\" cy=\"38\" r=\"4.6\"/>\n<path fill=\"#2196F3\" d=\"M18.7,33.3v9.2c-2.6,0-4.6-2.1-4.6-4.6C14,35.4,16.1,33.3,18.7,33.3z\"/>\n<circle fill=\"#D32F2F\" cx=\"40\" cy=\"37.9\" r=\"4.6\"/>\n<circle cx=\"61.3\" cy=\"38\" r=\"4.6\"/>\n<circle fill=\"#388E3C\" cx=\"125.3\" cy=\"38\" r=\"4.6\"/>\n<g>\n\t<rect x=\"82.1\" y=\"36.2\" fill=\"#FFC107\" width=\"1.2\" height=\"1.2\"/>\n\t<path fill=\"#FFC107\" d=\"M83.2,46h-1.2v-2.1h1.2V46z M83.2,41.7h-1.2v-2.1h1.2V41.7z\"/>\n\t<path fill=\"#FFC107\" d=\"M83.1,50.5l-0.8-0.8c-0.1-0.1-0.2-0.3-0.2-0.4v-1.2h1.2V49l0.6,0.6L83.1,50.5z\"/>\n\t<path fill=\"#FFC107\" d=\"M96.7,64.2L95,62.5l0.8-0.8l1.7,1.7L96.7,64.2z M93.3,60.8l-1.7-1.7l0.8-0.8l1.7,1.7L93.3,60.8z M89.9,57.3\n\t\tl-1.7-1.7l0.8-0.8l1.7,1.7L89.9,57.3z M86.5,53.9l-1.7-1.7l0.8-0.8l1.7,1.7L86.5,53.9z\"/>\n\t<path fill=\"#FFC107\" d=\"M99.3,67.5l-0.8-0.8l0.4-0.4l-0.4-0.4l0.8-0.8l0.8,0.8c0.2,0.2,0.2,0.6,0,0.8L99.3,67.5z\"/>\n\t<path fill=\"#FFC107\" d=\"M79.9,105.8h-1.2v-2.3h1.2V105.8z M79.9,101.1h-1.2v-2.3h1.2V101.1z M79.9,96.5h-1.2v-2.3h1.2V96.5z\n\t\t M79.9,91.8h-1.2v-2.3h1.2V91.8z M80.1,87.7l-0.8-0.8l1.6-1.7l0.8,0.8L80.1,87.7z M83.3,84.4l-0.8-0.8l1.6-1.7l0.8,0.8L83.3,84.4z\n\t\t M86.5,81l-0.8-0.8l1.6-1.7l0.8,0.8L86.5,81z M89.7,77.6l-0.8-0.8l1.6-1.7l0.8,0.8L89.7,77.6z M92.9,74.3l-0.8-0.8l1.6-1.7l0.8,0.8\n\t\tL92.9,74.3z M96.1,70.9l-0.8-0.8l1.6-1.7l0.8,0.8L96.1,70.9z\"/>\n\t<rect x=\"78.7\" y=\"108.1\" fill=\"#FFC107\" width=\"1.2\" height=\"1.2\"/>\n</g>\n<g>\n\t<rect x=\"103.4\" y=\"36.2\" fill=\"#673AB7\" width=\"1.2\" height=\"1.2\"/>\n\t<path fill=\"#673AB7\" d=\"M87.3,105.8h-1.2v-2.4h1.2V105.8z M87.3,101h-1.2v-2.4h1.2V101z M87.3,96.3h-1.2V94h1.2V96.3z M87.3,91.6\n\t\th-1.2v-2.4h1.2V91.6z M88,87.6l-0.8-0.8l1.7-1.7l0.8,0.8L88,87.6z M91.3,84.3l-0.8-0.8l1.7-1.7l0.8,0.8L91.3,84.3z M94.7,81\n\t\tl-0.8-0.8l1.7-1.7l0.8,0.8L94.7,81z M98,77.6l-0.8-0.8l1.7-1.7l0.8,0.8L98,77.6z M101.4,74.3l-0.8-0.8l1.7-1.7l0.8,0.8L101.4,74.3z\n\t\t M104.6,70.4h-1.2v-2.4h1.2V70.4z M104.6,65.7h-1.2v-2.4h1.2V65.7z M104.6,61h-1.2v-2.4h1.2V61z M104.6,56.3h-1.2v-2.4h1.2V56.3z\n\t\t M104.6,51.5h-1.2v-2.4h1.2V51.5z M104.6,46.8h-1.2v-2.4h1.2V46.8z M104.6,42.1h-1.2v-2.4h1.2V42.1z\"/>\n\t<rect x=\"86.2\" y=\"108.1\" fill=\"#673AB7\" width=\"1.2\" height=\"1.2\"/>\n</g>\n<path fill=\"#58595B\" d=\"M136,110.7H8c-0.8,0-1.4-0.6-1.4-1.4v-64c0-0.8,0.6-1.4,1.4-1.4c0.8,0,1.4,0.6,1.4,1.4v62.6h125.1V45.3\n\tc0-0.8,0.6-1.4,1.4-1.4c0.8,0,1.4,0.6,1.4,1.4v64C137.5,110.1,136.8,110.7,136,110.7z\"/>\n<polygon fill=\"#2196F3\" points=\"20.7,105.8 18.7,107.8 16.7,105.8 \"/>\n<polygon fill=\"#FFC107\" points=\"81.3,105.8 79.3,107.8 77.3,105.8 \"/>\n<polygon fill=\"#673AB7\" points=\"88.8,105.8 86.8,107.8 84.8,105.8 \"/>\n<polygon fill=\"#4CAF50\" points=\"127.3,105.8 125.3,107.8 123.3,105.8 \"/>\n<polygon fill=\"#F44336\" points=\"24.6,105.8 22.6,107.8 20.6,105.8 \"/>\n<polygon points=\"28.2,105.8 26.2,107.8 24.2,105.8 \"/>\n<path fill=\"#939598\" d=\"M93.3,89.4c-0.4,0-0.7-0.1-1-0.4c-0.6-0.6-0.6-1.5,0-2l21.3-21.3c0.6-0.6,1.5-0.6,2,0c0.6,0.6,0.6,1.5,0,2\n\tL94.4,89C94.1,89.2,93.7,89.4,93.3,89.4z\"/>\n<path fill=\"#939598\" d=\"M72,89.4c-0.4,0-0.7-0.1-1-0.4L49.6,67.6c-0.6-0.6-0.6-1.5,0-2c0.6-0.6,1.5-0.6,2,0L73,86.9\n\tc0.6,0.6,0.6,1.5,0,2C72.7,89.2,72.4,89.4,72,89.4z\"/>\n<path fill=\"#939598\" d=\"M29.3,89.4c-0.4,0-0.7-0.1-1-0.4c-0.6-0.6-0.6-1.5,0-2L71,44.2c0.5-0.5,1.5-0.5,2,0l21.3,21.3\n\tc0.6,0.6,0.6,1.5,0,2c-0.6,0.6-1.5,0.6-2,0L72,47.3L30.3,89C30.1,89.2,29.7,89.4,29.3,89.4z\"/>\n<path fill=\"#939598\" d=\"M29.3,68c-0.4,0-0.7-0.1-1-0.4c-0.6-0.6-0.6-1.5,0-2l21.3-21.3c0.6-0.6,1.5-0.6,2,0c0.6,0.6,0.6,1.5,0,2\n\tL30.3,67.6C30.1,67.9,29.7,68,29.3,68z\"/>\n<path fill=\"#F44336\" d=\"M40.1,33.3v9.2c-2.6,0-4.6-2.1-4.6-4.6C35.4,35.4,37.5,33.3,40.1,33.3z\"/>\n<path fill=\"#616161\" d=\"M61.3,33.3v9.2c-2.6,0-4.6-2.1-4.6-4.6C56.7,35.4,58.8,33.3,61.3,33.3z\"/>\n<circle fill=\"#FFA000\" cx=\"82.7\" cy=\"38\" r=\"4.6\"/>\n<path fill=\"#FFC107\" d=\"M82.7,33.3v9.2c-2.6,0-4.6-2.1-4.6-4.6C78,35.4,80.1,33.3,82.7,33.3z\"/>\n<circle fill=\"#512DA8\" cx=\"104\" cy=\"38\" r=\"4.6\"/>\n<path fill=\"#673AB7\" d=\"M104,33.3v9.2c-2.6,0-4.6-2.1-4.6-4.6C99.4,35.4,101.4,33.3,104,33.3z\"/>\n<path fill=\"#4CAF50\" d=\"M125.3,33.3v9.2c-2.6,0-4.6-2.1-4.6-4.6C120.7,35.4,122.8,33.3,125.3,33.3z\"/>\n</svg>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line containing an integer\n  <b>C</b>: the number of columns in your friend's falling ball toy. Then,\n  there is one more line containing <b>C</b> integers <b>B<sub>i</sub></b>. The\n  i-th of these integers represents the number of balls that ended up in the\n  i-th cell from the left of the bottom row of your friend's falling ball toy,\n  according to the data they gave you.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1) and\n  <code>y</code> is either <code>IMPOSSIBLE</code>, or the number of rows in\n  your layout, as described above. If <code>y</code> is not\n  <code>IMPOSSIBLE</code>, output <code>y</code> more rows, representing the\n  rows of your proposed falling ball toy layout, in order from top to bottom.\n  Use <code>.</code> to represent a cell with no ramp, and <code>\\</code> or\n  <code>/</code> to represent the ramps. The layout must obey all of the rules\n  in the problem statement.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  0 &le; <b>B<sub>i</sub></b> &le; <b>C</b>, for all i.<br/>\n  The sum (over all i from 1 to <b>C</b>, inclusive) of all\n  <b>B<sub>i</sub></b> values = <b>C</b>.<br/>\n  Time limit: 10 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  2 &le; <b>C</b> &le; 5.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  2 &le; <b>C</b> &le; 100.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">3\n4\n1 1 1 1\n3\n0 2 1\n6\n3 0 0 2 0 1\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: 1\n....\nCase #2: IMPOSSIBLE\nCase #3: 3\n.//\\..\n./\\./.\n......\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  Note that the last sample case would not appear in Test set 1.\n</p>\n<p>\n  The following layout is the only valid solution for Sample Case #1. (There\n  must be at least one row, and including any more rows would make the solution\n  use more rows than needed. It is not legal to include any ramps in the\n  bottom row.)\n</p>\n<p><code>\n    ....<br/>\n</code></p>\n<p>\n  In Sample Case #2, there is no way to prevent the leftmost ball from falling\n  to the bottom of its column without adding a ramp, but ramps cannot be added\n  to that column.\n</p>\n<p>\n  Sample Case #3 is the one described at the end of the problem statement. Note\n  that the following <u>invalid</u> layout for Sample Case #3 breaks several\n  rules: it has more rows than needed, it has ramps in the three illegal zones\n  (left column, right column, bottom row), and it contains a <code>\\</code>\n  ramp immediately to the left of a <code>/</code> ramp.\n</p>\n<p><code>\n    \\\\..\\/<br/>\n    ../.\\/<br/>\n    ./../.<br/>\n    ..../.<br/>\n</code></p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Falling Balls","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nWe can identify each juggler by a pair of integers (b, r) where 0 &le; b &le; <b>B</b>\nand 0 &le; r &le; <b>R</b>. The pair (0, 0) does not identify a valid juggler, although we\ncould assume that it does and, since we can always add (0, 0) to any valid configuration\nthat does not contain it, just solve the modified problem and subtract 1 to obtain the\nfinal answer. We can then focus on finding the size of the largest subset of\nV = [0; <b>B</b>] &times; [0; <b>R</b>] such that the sum of the first component of each element\nis <b>B</b>, and the sum of the second component of each element is\n<b>R</b>. Let us call b,r-valid to a set of distinct pairs that fulfills the sum conditions for\nspecific b and r.\n</p>\n<h3>Test set 1</h3>\n<p>\nFor Test set 1, we can first notice that the size of V is small. Therefore, we can do a dynamic\nprogramming iterating through V and deciding, for each pair, whether to include it or not.\nAs part of the state we have to also include how many blue and red jugglers we can still include.\nTherefore, we enumerate V in any order\nv<sub>1</sub>, v<sub>2</sub>, ..., v<sub>(<b>B</b>+1) &times; <b>R</b>+1</sub>,\nand then we compute a function f(i, b, r) defined as the size of the largest b,r-valid subset of\n{v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>i</sub>}.\n</p><p>\nWe can see that f has also a recursive definition as follows:\n</p><ul>\n  <li>f(0, 0, 0) = 0.</li>\n  <li>f(i + 1, b, r) = max(f(i, b, r), 1 + f(i, b - left(v<sub>i</sub>), r - right(v<sub>i</sub>)))\n    for all b, r, i.</li>\n</ul><p>\nThe definition above is incomplete because it's not checking for indefinitions. A simple\nsolution is to just define every undefined case as -infinity, or for this particular\nproblem, - <b>B</b> - <b>R</b>.\n</p><p>\nMemoizing this recursive definition leads to an implementation that takes time proportional\nto the size of the domain of f, which is (<b>B</b>+1)<sup>2</sup> &times; (<b>R</b>+1)<sup>2</sup>,\nwhich is likely fast enough to solve Test set 1. If your implementation and language of choice\nare both on the slow side, it's possible that you need some additional insight to make it through\nthe time limit. One simple trick is that the function f actually solves all possible test cases,\nsince the set V is fixed. So, you can reuse the memoization table for all test cases and save\n99% of the work compared to solving each test case from scratch. You can even\ncompute the entire table before submitting, and include it in your source code,\nalthough you should be wary of this strategy in general since it might cause\nyour source file to exceed the 1 MB limit specified in our rules.\n</p>\n<h3>Test set 2</h3>\n<p>\nFor Test set 2, we will definitely need the additional insight of not resetting the memoization\ntable for each test case. However, the important additional insight is more specific to\nthe problem.\n</p><p>\nFirst, let us define weak-b,r-valid sets as sets of distinct pairs of non-negative integers\nsuch that the sum of the values of the left sides of each pair is less than or equal\nto b, the sum of the values of the right sides of each pair is less than or equal to r.\nOf course, every b,r-valid set is also a weak-b,r-valid set, but the converse is not true.\n</p><p>\nOne important property of weak-b,r-valid sets is that for fixed b and r, the size X of the\nlargest weak-b,r-valid set is equal to the size Y of the largest b,r-valid set. We can prove\nthat by noticing: (1) Y &le; X because every b,r-valid set is a weak-b,r-valid set;\nand (2) X &le; Y\nbecause if we let S be a weak-b,r-valid set of size X and then take an element (i,j) of S such\nthat i is maximum, and j is maximum among those with maximum i, we can construct\nS' = S - {(i,j)} &cup; {(i + db, j + dr)} where db and dr are the difference between\nthe sums of the left/right values of the pairs and b/r, respectively. By construction,\nS' is b,r-valid, and by the maximality of the choice of (i,j), (i + db, j + dr) is not\nin S - {(i,j)}, and thus, the sizes of S and S' are equal.\n</p><p>\nLet us now define minimal-weak-b,r-valid sets as weak-b,r-valid sets S such that\nfor any (i,j) in S with i &gt; 0, (i-1, j) is also in S, and analogously,\nfor any (i,j) in S with j &gt; 0, (i, j-1) is also in S. Similarly to the above,\nwe can prove that the size of the largest minimal-weak-b,r-valid set for fixed b and r\nis the same as the size of the largest weak-b,r-valid sets by constructing a\nminimal-weak-b,r-valid sets of size X from a given weak-b,r-valid set S of size X.\nLet (i,j) in S be such that the minimality of the definition is violated (if such exists).\nThen, replace (i,j) in S for either (i-1,j) or (j-1,i) as appropriate to obtain another\nweak-b,r-valid set of the same size. This step strictly decreases the sum of the values\nof all pairs in S, thus, at some point, there are no such (i,j) to choose for and we\nsuccessfully obtained a minimal-weak-b,r-valid set of size X.\n</p><p>\nThe problem that remains is to find the size of the largest minimal-weak-b,r-valid set for\ngiven b and r. By the minimality condition, if (i,j) is in such largest set, so are\n(i-1, j), (i-2,j) (i,j-1), (i,j-2), (i-1, j-1), .... To formalize, (i,j) being present\nin a minimal-weak-b,r-valid set prescribes the presence of (i+1) &times; (j+1) pairs including\nitself. We can bound the sum of the left side values of all those pairs by\n(j+1) &times; (1 + 2 + ... + i) = (j+1) &times; i &times; (i+1) / 2, and analogously\nthe sum of the right sides by (i+1) &times; j &times; (j+1) / 2. This means that instead\nof the set V from the solution above, we can use V', composed of the pairs in V that are\nunder these bounds. This makes the size of V' be approximately\nO(<b>B</b><sup>1/3</sup> &times; <b>R</b><sup>1/3</sup>) when <b>B</b> and <b>R</b> are\nclose, which is a big reduction from the size of V which is O(<b>B</b> &times; <b>R</b>).\nThe overall complexity of the resulting algorithm for all test cases is then\nO(<b>B</b><sup>4/3</sup> &times;  <b>R</b><sup>4/3</sup>), which is fast enough to pass\nTest set 2.\n</p>\n","id":"00000000000459f3","statement":"<h3>Problem</h3>\n<p>\n  You are the manager of the Graceful Chainsaw Jugglers performance group, and\n  you are trying to succeed in the very competitive chainsaw juggling business.\n  You have an unlimited number of identical talented jugglers, and each of them\n  knows how to juggle any number of chainsaws. To run a show, you will choose\n  some number of jugglers, and then distribute your red chainsaws and blue\n  chainsaws among them, so that each juggler gets at least one chainsaw. For\n  example, one juggler might juggle two red chainsaws and three blue chainsaws,\n  and another juggler might juggle just one red chainsaw. During the show, each\n  chainsaw is used by only one juggler; the jugglers do not pass chainsaws\n  around, because it is already hard enough just to juggle them!\n</p><p>\n  According to your market research, your audience is happiest when the show\n  uses as many jugglers and chainsaws as possible, but the audience also\n  demands variety: no two jugglers in the show can use both the same number\n  of red chainsaws <i>and</i> the same number of blue chainsaws.\n</p><p>\n  You have <b>R</b> red chainsaws and <b>B</b> blue chainsaws, and you must\n  use all of them in the show. What is the largest number of jugglers that you\n  can use in the show while satisfying the audience's demands?\n<p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>;\n  <b>T</b> test cases follow. Each test case consists of one line with two\n  integers <b>R</b> and <b>B</b>: the numbers of red and blue chainsaws that\n  you must use in the show.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the largest number of jugglers that you can use in the show while\n  satisfying the audience's demands, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  <b>R</b> + <b>B</b> &gt; 0.<br/>\n  Time limit: 25 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  0 &le; <b>R</b> &le; 50.<br/>\n  0 &le; <b>B</b> &le; 50.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  0 &le; <b>R</b> &le; 500.<br/>\n  0 &le; <b>B</b> &le; 500.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">2\n2 0\n4 5\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: 1\nCase #2: 5\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  In Sample Case #1, the only possible strategy is to give both red chainsaws\n  to one juggler.\n</p><p>\n  In Sample Case #2, one optimal strategy is to have:\n</p>\n<ul>\n  <li>one juggler with one red chainsaw</li>\n  <li>one juggler with two red chainsaws</li>\n  <li>one juggler with one blue chainsaw</li>\n  <li>one juggler with three blue chainsaws</li>\n  <li>one juggler with one red chainsaw and one blue chainsaw</li>\n</ul>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Graceful Chainsaw Jugglers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  This test set can be solved using complete search. We can try enumerating\n  every possible connected pattern. For each possible connected pattern, we\n  check whether that pattern exists in the grid which has been deepened twice.\n  Among all connected patterns which exist in the grid which has been deepened\n  twice, we take the one with the largest number of cells. The correctness of\n  this algorithm will be proved later in this section.\n</p>\n<p>\n  Note that it is not sufficient to check the pattern in the grid which has been\n  deepened only once. The first sample case in the problem description shows\n  that there is a pattern which does not exist in the grid which has been\n  deepened once, but the pattern exists in the grid which has been deepened\n  more than once.\n</p>\n<p>\n  Why is it sufficient to check the pattern in the grid which has been deepened\n  twice? We can first observe that a grid which has been deepened X times\n  consists of blocks of cells. Each block is a square of cells of the same color\n  with side length 2<sup>X</sup>. This does mean any pattern of size at most 3\n  &times; 4 can fit in the same block in the grid which has been deepened\n  twice, whereas this might not be the case in the grid which has been deepened\n  once.\n</p>\n<p>\n  Moreover, any pattern of size at most 3 &times; 4 overlaps with at least one\n  and at most four blocks in the grid which has been deepened twice. This is\n  also the case in the grid which has been deepened more than twice. Therefore,\n  the set of patterns of size at most 3 &times; 4 which exists in the grid which\n  has been deepened twice is equivalent to the set of patterns of size at most 3\n  &times; 4 which exists in the grid which has been deepened X times for any\n  X &gt; 2. Therefore, it is sufficient to check the pattern in the grid which\n  has been deepened twice.\n</p>\n<p>\n  There are at most O(2<sup><b>R</b> &times; <b>C</b></sup>) patterns.\n  Therefore, there are not more than O(2<sup><b>R</b> &times; <b>C</b></sup>)\n  possible connected patterns. For each pattern, we can first check whether it\n  is connected, and if it is, we can then check whether that pattern exists in\n  the grid which has been deepened twice in O(<b>R</b> &times; <b>C</b>) time.\n  Therefore, the total complexity of this solution is\n  O(2<sup><b>R</b> &times; <b>C</b></sup> &times; <b>R</b> &times; <b>C</b>)\n  which is fast enough to solve test set 1.\n</p>\n<h3>Test set 2</h3>\n<p>\n  Since <b>R</b> and <b>C</b> can be up to 20, the exponential solution will not\n  run in time. Therefore, we must not enumerate every possible connected\n  pattern. To solve this test set, we can first observe that a block of cells in\n  the grid which has been deepened at least a googol times will have a side\n  length larger than the size of any possible pattern.\n</p>\n<p>\n  The observation in the previous paragraph ensures that every possible pattern\n  can overlap with at most four blocks of cells in the deepened grid.\n  This means that Codd's pattern needs to be divisible into four quadrants by a\n  horizontal and a vertical line where each cell of the pattern in the same\n  quadrant has the same color. Moreover, that particular combination of four\n  colors has to exist in the original grid.\n</p>\n<p>\n  Therefore, we can consider every possible quadrant center and combination of\n  colors (there are up to O(2<sup>4</sup> &times; <b>R</b> &times; <b>C</b>)).\n  For each quadrant center and combination of colors, we want to get the largest\n  connected component where each cell in this connected component has the same\n  color as the color assigned to the quadrant it belongs to.\n</p>\n<p>\n  For each possible quadrant center and combination of colors, we need\n  O(<b>R</b> &times; <b>C</b>) time to find the largest connected component.\n  Therefore, this solution will run in\n  O(2<sup>4</sup> &times; <b>R</b><sup>2</sup> &times; <b>C</b><sup>2</sup>)\n  time.\n</p>\n","id":"00000000000459f4","statement":"<h3>Problem</h3>\n<p>\n  The master thief Jom Codd is able to infiltrate the dreams of others. Since\n  dream-viewing technology is not very good yet, Codd sees a dream as a\n  <i>dream grid</i> of unit cells, each of which is white or black.\n</p><p>\n  Given a starting dream grid, Codd can <i>go deeper</i> by replacing each\n  white cell with a 2x2 grid of white cells, and each black cell with a 2x2\n  grid of black cells; this creates a new dream grid that is four times\n  larger. He can go deeper again from that grid, and so on. For example, given\n  this starting dream grid:\n</p>\n<p><code>\n    BBB<br>\n    BWB<br>\n    BBB<br>\n</code></p>\n<p>\n  then going deeper once produces this new dream grid:\n</p>\n<p><code>\n    BBBBBB<br>\n    BBBBBB<br>\n    BBWWBB<br>\n    BBWWBB<br>\n    BBBBBB<br>\n    BBBBBB<br>\n</code></p>\n<p>\n  and going deeper again produces this new dream grid:\n</p>\n<p><code>\n    BBBBBBBBBBBB<br>\n    BBBBBBBBBBBB<br>\n    BBBBBBBBBBBB<br>\n    BBBBBBBBBBBB<br>\n    BBBBWWWWBBBB<br>\n    BBBBWWWWBBBB<br>\n    BBBBWWWWBBBB<br>\n    BBBBWWWWBBBB<br>\n    BBBBBBBBBBBB<br>\n    BBBBBBBBBBBB<br>\n    BBBBBBBBBBBB<br>\n    BBBBBBBBBBBB<br>\n</code></p>\n<p>\n  and so on.\n</p><p>\n  Codd has just infiltrated a dream and viewed its starting dream grid. He is\n  on a very difficult mission, and he knows that he will need to go deeper many\n  times. To help him navigate, he is looking at various <i>patterns</i> in the\n  starting dream grid. A pattern consists of a single group of cells connected\n  by shared edges (shared corners do not count as connections), plus their\n  colors. A pattern might contain internal gaps (as long as the pattern's cells\n  are a single connected group); such gaps are not considered part of the\n  pattern. Two patterns are the same if and only if they have the same number\n  and arrangement of cells (not reflected or rotated), with the same colors.\n<p>\n  For example, in the grids above, the following 8-cell pattern is present in\n  the starting grid:\n</p>\n<p><code>\n  BBB<br>\n  B B<br>\n  BBB<br>\n</code></p>\n<p>\n  It is not present after going deeper once, but it is present after going\n  deeper twice, and three times, and so on for every deeper dream grid.\n</p><p>\n  Codd wants to find the largest pattern from the starting dream grid that will\n  be present in at least a googol (10<sup>100</sup>) of deeper dream grids.\n  For the given example, the pattern above is the largest such pattern. Even\n  though it is not present after going deeper once, it is present in at least\n  a googol of deeper levels. Other such patterns of smaller sizes also meet\n  this condition, but there is no 9-cell pattern that does; the only such\n  pattern would have to be identical to the entire starting dream grid, and\n  that pattern will never show up in any deeper dream grid, let alone in a\n  googol of them.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with two integers\n  <b>R</b> and <b>C</b>: the numbers of rows and columns, respectively, in the\n  dream grid. Each case continues with <b>R</b> more lines of <b>C</b>\n  characters each; every such character is either <code>B</code> or\n  <code>W</code>. These lines directly represent the dream grid.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the largest possible size of at least one pattern that meets Codd's\n  requirements, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>R</b> &le; 3.<br/>\n  1 &le; <b>C</b> &le; 4.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>R</b> &le; 20.<br/>\n  1 &le; <b>C</b> &le; 20.<br/>\n</p>\n\n\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"io-table-header\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"io-table-header\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<pre class=\"io-content\">5\n3 3\nBBB\nBWB\nBBB\n2 3\nBBB\nWBW\n1 1\nW\n3 3\nWBW\nBWB\nWBW\n2 4\nBBWW\nBBWW\n\n</pre>\n</td>\n<td>\n<pre class=\"io-content\">Case #1: 8\nCase #2: 5\nCase #3: 1\nCase #4: 4\nCase #5: 8\n\n</pre>\n</td></tr></table>\n</div>\n\n\n<p>\n  Sample Case #1 is the one described in the problem statement.\n</p><p>\n  In Sample Case #2, one possible largest pattern is:\n</p>\n<p><code>\n  BBB<br>\n  WB<br>\n</code></p>\n<p>Another equally large one is:</p>\n<p><code>\n  BBB<br>\n  W W<br>\n</code></p>\n<p>\n  In Sample Case #3, the entire starting dream grid is a largest pattern.\n</p><p>\n  In Sample Case #4, note that the five <code>W</code>s would not form a valid\n  pattern, because they are not connected. However, this is a largest pattern:\n</p>\n<p><code>\n  WB<br>\n  BW<br>\n</code></p>\n<p>\n  In Sample Case #5, the entire starting dream grid is a largest pattern.\n  Note that even though this grid happens to be what Codd would get by going\n  deeper starting from <code>BW</code>, that is irrelevant; Codd will never \"go\n  shallower\".\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Gridception","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000007706","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2018"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
