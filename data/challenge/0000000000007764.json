{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1525026600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000007764","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Round 1B started off with <i>Rounding Error</i>, which explored a phenomenon\n  that often arises when interpreting poll results. A greedy insight was\n  required to solve the third test set. <i>Mysterious Road Signs</i> challenged\n  contestants to understand a strange situation involving signpost numbering.\n  Finally, <i>Transmutation</i> was a tough graph problem about producing as\n  much lead as possible; contestants had to narrow down the set of possible\n  choices in an efficient way.\n</p><p>\n  This round proved to be really tough for a Round 1. None of the problems\n  was really easy in the way some Round 1 problem usually is. To add to that,\n  2 out of 3 problems had an extra test set, making a perfect score even harder to\n  attain. We had rounds in the past with few perfect scores, but they were usually\n  due to a single particularly hard problem. This round featured a good number of\n  solutions for each problem individually, but a relatively low number of 37 perfect\n  scores. overtroll was the first to get there in just under an hour with no penalty\n  attempts, to claim first place.\n</p><p>\n  In the end, 25 points and some speed and accuracy was needed to get into the top 1500.\n  In most cases, that means solving Rounding Error, but you would also advance with\n  a full solution of any of the other two problems. It was even possible to advance with\n  just visible points, if you managed to get some points from every problem.\n</p><p>\n  1500 more contestants have advanced to Round 2, and there are 1500 more\n  spots available in Round 1C, coming up in a week.\n  Good luck!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Rounding Error: Written by Ian Tullis. Prepared by Micah Stairs.\n</p><p>\n  Mysterious Road Signs: Written by Md Mahbubul Hasan. Prepared by Shane Carr\n  and Jonathan Irvin Gunawan.\n</p><p>\n  Transmutation: Written by Pablo Heiber. Prepared by Pablo Heiber and Ian\n  Tullis.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Shane Carr,\n  John Dethridge, Jonathan Irvin Gunawan, Md Mahbubul Hasan, Jason Shao, Micah\n  Stairs, and Erick Wong.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Rounding Error: Jonathan Irvin Gunawan</li>\n  <li>Mysterious Road Signs: Shane Carr</li>\n  <li>Transmutation: Md Mahbubul Hasan and Pablo Heiber</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1525017600000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  This test set can be solved using a complete search. We can try every possible\n  partition of <b>N</b> voters among <b>N</b> languages. If two partitions\n  differ only in the order of their languages, then we consider those partitions\n  equivalent.\n</p>\n<p>\n  Therefore, we can consider a partition as an <b>N</b>-tuple\n  (x<sub>1</sub>, x<sub>2</sub>, ..., x<sub><b>N</b></sub>), where\n  x<sub>i</sub> &ge; x<sub>i + 1</sub> and &Sigma; x<sub>i</sub> = <b>N</b>.\n</p>\n<p>\n  Even with <b>N</b> = 25, there are <a href=\"https://oeis.org/A000041\">no more\n  than 2,000</a> different partitions. For each partition, we can use the\n  following greedy algorithm to check whether the partition can be achieved by\n  only adding voters: let us sort the <b>C</b><sub>i</sub> values in\n  non-increasing order &mdash; that is, such that\n  <b>C</b><sub>i</sub> &ge; <b>C</b><sub>i + 1</sub>. Then the partition can be\n  achieved by only adding voters if and only if\n  <b>x</b><sub>i</sub> &ge; <b>C</b><sub>i</sub> for all 1 &le; i &le; <b>L</b>.\n  Among all such partitions, we can find the largest percentage sum, which is\n  our answer.\n</p>\n<h3>Test set 2</h3>\n<p>\n  For this test set, we can remove our assumption that a partition and <b>C</b>\n  must be sorted non-increasingly. Therefore, we consider a partition of\n  <b>N</b> voters to <b>N</b> languages as\n  (x<sub>1</sub>, x<sub>2</sub>, ..., x<sub><b>N</b></sub>), where\n  &Sigma; x<sub>i</sub> = <b>N</b>.\n</p>\n<p>\n  To solve this test set, we can use\n  <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">\n  dynamic programming</a> (DP). We define a function f(a, b) as the following:\n</p>\n<p>\n  Among all partitions\n  (x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>a</sub>) such that\n  &Sigma; (1 &le; i &le; a) x<sub>i</sub> = b and\n  x<sub>i</sub> &ge; <b>C</b><sub>i</sub> for all 1 &le; i &le; a, what is the\n  maximum &Sigma; (1 &le; i &le; a) round(x<sub>i</sub> / <b>N</b> &times; 100)\n  possible? If there is no satisfying partition, then f(a, b) = -&infin;. We\n  can assume <b>C</b><sub>i</sub> = 0 for i &gt; <b>L</b>.\n</p>\n<p>\n  We can first handle the base case of the function. We can easily compute\n  f(1, b) since there is only at most one satisfying partition. Therefore,\n  f(1, b) = round(b / <b>N</b> &times; 100) if b &geq; <b>C</b><sub>1</sub>, or\n  -&infin; otherwise.\n</p>\n<p>\n  The recurrence f(a, b) of this function can be computed by considering all\n  possible values of x<sub>a</sub>. Let i be the value of x<sub>a</sub>.\n  Therefore, x<sub>a</sub> contributed round(i / <b>N</b> &times; 100) to the\n  total percentage, and there are (b - i) votes left to be distributed among\n  x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>a - 1</sub>. Therefore,\n  for a > 1, f(a, b) = max (<b>C</b><sub>a</sub> &le; i &le; b)\n  (round(i / <b>N</b> &times; 100) + f(a - 1, b - i)).\n</p>\n<p>\n  Since we want to distribute <b>N</b> voters to\n  x<sub>1</sub>, x<sub>2</sub>, ..., x<sub><b>N</b></sub>, the answer for the\n  problem is f(<b>N</b>, <b>N</b>).\n</p>\n<p>\n  Function f has O(<b>N</b><sup>2</sup>) possible states and each state takes\n  O(<b>N</b>) time to compute. Therefore, this solution runs in\n  O(<b>N</b><sup>3</sup>) time.\n</p>\n<h3>Test set 3</h3>\n<p>\n  We can solve this test set with a greedy strategy. For each language, we will\n  either be rounding the percentage up or down. We get the maximum answer when\n  as many of these as possible are rounded up.\n</p>\n<p>\n  Therefore, we can ignore any languages that are already being rounded up.\n  Since there can be arbitrarily many languages, nothing ever forces us to\n  disturb these languages by adding another vote&mdash;it's no worse to add that\n  vote to some new language instead. We figure out how many more votes each\n  language (including languages nobody has even mentioned yet) would need in\n  order for it to be rounded up.\n</p>\n<p>\n  We greedily satisfy as many of these as possible, starting with the ones that\n  take the fewest additional votes. This solution runs in\n  O(<b>N</b> &times; log(<b>N</b>)) time.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0BsakhqvFne3zR8T_DHTandV96_BjLw2vT3Pn4vKh14FuEV3woMGDRwl9NzlbPcnbe0XGcpg/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"0000000000036601","statement":"<h3>Problem</h3>\n<p>\n  To finally settle the age-old question of which programming language is the\n  best, you are asking a total of <b>N</b> people to tell you their favorite\n  language. This is an open-ended question: each person is free to name any\n  language, and there are infinitely many languages in the world.\n</p><p>\n  Some people have already responded, and you have gathered this information as\n  a list of counts. For example, <code>1 2</code> means that you have asked 3\n  people so far, and one picked a particular language, and the other two picked\n  some other language.\n</p><p>\n  You plan to publish the results in a table listing each language and the\n  percentage of people who picked it. You will round each percentage to the\n  nearest integer, rounding up any percentage with a decimal part equal to or\n  greater than 0.5. So, for example, 12.5% would round up to 13%, 99.5% would\n  round up to 100%, and 12.4999% would round down to 12%.\n</p><p>\n  In surveys like this, sometimes the rounded percentages do not add up to\n  exactly 100. After you are done surveying the remaining people, what is the\n  largest value that the rounded percentages could possibly add up to?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each consists of two lines. The first line\n  consists of two integers <b>N</b> and <b>L</b>: the total number of people\n  in the survey, and the total number of different languages represented\n  among the people who have already responded. The second line consists of\n  <b>L</b> integers <b>C<sub>i</sub></b>; the i-th of these is the number of\n  people who said that the i-th of the represented languages was their\n  favorite.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the largest value that the percentages could possibly add up to, as\n  described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>L</b> &lt; <b>N</b>.<br/>\n  1 &le; <b>C<sub>i</sub></b>, for all i.<br/>\n  The sum of all <b>C<sub>i</sub></b> values &lt; <b>N</b>.<br/>\n  Time limit: 10 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  2 &le; <b>N</b> &le; 25.<br/>\n</p>\n\n<h4>Test set 2 (Visible)</h4>\n<p>\n  2 &le; <b>N</b> &le; 250.<br/>\n</p>\n\n<h4>Test set 3 (Hidden)</h4>\n<p>\n  2 &le; <b>N</b> &le; 10<sup>5</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1NZ33SpDNJwbYRqc5xf4c7ZVB0ymxYb6Br74Dy07ocdYLSaurCFIkOlfo01AZUB7Lc_BTToAsMYdFELou8tvDNVurk1FhinDjJc_U/rounding_error_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n3 2\n1 1\n10 3\n1 3 2\n6 2\n3 1\n9 8\n1 1 1 1 1 1 1 1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3z8UO6vLpA-T6lwF5wWER7pciJz9DnPSa-Z1Frqa_uLl7Vst6TOScFLtO4_JFlmQxPq7YOjEBkqCQ5W3RhNyjxOTz2HqucjQhQX7NE/rounding_error_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 100\nCase #2: 100\nCase #3: 101\nCase #4: 99\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, two people have already responded, and they have chosen\n  different languages. One person has not yet responded. If that person chooses\n  a third language, then the rounded percentages will add up to 33 + 33 + 33 =\n  99. However, if that person chooses one of the already-chosen languages, then\n  the rounded percentages will add up to 67 + 33 = 100. So 100 is the maximum\n  possible sum.\n</p><p>\n  In Sample Case #2, regardless of what the other four people choose, the\n  percentages for the various languages will always be exact multiples of 10\n  that do not need to be rounded, and they will add up to exactly 100.\n</p><p>\n  In Sample Case #3, one optimal scenario is as follows: each of the remaining\n  two people chooses an unchosen language, so the rounded percentages add up to\n  50 + 17 + 17 + 17 = 101.\n</p><p>\n  In Sample Case #4, whether or not the remaining person chooses an\n  already-chosen language, the rounded percentages will add up to 99.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":11}],"title":"Rounding Error","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1 (Visible)</h3>\n<p>\n  First, let's break down what the problem is asking us to find. We are asked to identify sets of\n  contiguous signs, where each set is defined by four variables:\n</p>\n<ol>\n  <li>The index of the first sign in the set, <i>i</i> (inclusive)</li>\n  <li>The index of the last sign in the set, <i>j</i> (exclusive)</li>\n  <li>The destination for eastbound travelers, <i>M</i></li>\n  <li>The destination for westbound travelers, <i>N</i></li>\n</ol>\n<p>\n  In order for a set to be valid, each sign in the set must be truthful to eastbound travelers,\n  westbound travelers, or both. Given the four variables above, we can evaluate a set of signs for\n  validity in O(<em>j</em>&ndash;<em>i</em>) time. We can bound the number of possible values for\n  <i>M</i> and <i>N</i> by <b>S</b> by taking the set of all westbound or eastbound destinations\n  displayed by at least one sign. Since <em>i</em> and <em>j</em> are also bounded by <b>S</b>, we\n  would need O(<b>S</b><sup>5</sup>) time for this solution, which is not sufficient for Test Set 1.\n</p>\n<p>\n  To improve our brute-force solution, we can be more clever with how we pick <i>M</i> and <i>N</i>.\n  The first sign in a set tells us a lot of information: namely, it defines what either <i>M</i> or\n  <i>N</i> must be (one of the two destinations on the sign, or else the sign wouldn't be able to be\n  in the set). Suppose we fix <i>M</i> based on the first sign. Now, we can walk through the rest of\n  the signs in the set until we find a sign whose eastbound destination is not <i>M</i>; use that\n  sign's westbound destination as <i>N</i>. Continue walking until we reach a sign that does not\n  share either <i>M</i> or <i>N</i>, in which case the set is invalid, or until we reach the end of\n  the set, in which case the set is valid. We can perform the analogous process by fixing <i>N</i>\n  based on the first sign. This &ldquo;two-pass&rdquo; set evaluation algorithm runs in O(<b>S</b>)\n  time, since sets have size O(<b>S</b>).\n</p>\n<p>\n  Since there are O(<b>S</b><sup>2</sup>) sets of signs and we can evaluate each set for validity in\n  O(<b>S</b>) time, we have a O(<b>S</b><sup>3</sup>) algorithm, which is fast enough for Test Set\n  1.\n</p>\n<h3>Test Set 2 (Hidden)</h3>\n<p>\n  Clearly the cubic solution won't work on Test Set 2. It turns out that a quadratic solution coded\n  in a fast language with a sufficient amount of pruning can pass Test Set 2. However, in this\n  analysis, we will describe a O(<b>S</b> log <b>S</b>) solution followed by a linear-time\n  O(<b>S</b>) solution, both of which comfortably finish in time when evaluating Test Set 2.\n</p>\n<p>\n  The O(<b>S</b> log <b>S</b>) solution is a classic application of\n  <a href=\"https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm\">divide and conquer</a>.\n  Cut the list of signs in half, except for a single sign at the center, which we will call the\n  &ldquo;midpoint&rdquo; sign. Recursively apply the algorithm to the western half and the eastern\n  half of signs. Then, use a modified version of the previously described two-pass algorithm to find\n  the best set containing the midpoint: first, fix <i>M</i> to the midpoint's eastbound destination.\n  Since we are looking for long segments, we can greedily add as many signs to the set as possible.\n  Walk the list of signs both westward and eastward until reaching a sign on each end that does not\n  share the same eastbound destination (<i>M</i> value) with the midpoint. Let <i>N</i><sub>1</sub>\n  equal the westbound destination of the western boundary (the first sign to the west that did not\n  match <i>M</i>) and let <i>N</i><sub>2</sub> equal the westbound destination of the eastern\n  boundary (the firsts sign to the east that did not match <i>M</i>). Find <i>M</i><sub>1</sub> and\n  <i>M</i><sub>2</sub> using an analogous procedure: return to the midpoint, walk westward and\n  eastward until reaching signs that do not share a westbound destination (<i>N</i> value) with the\n  midpoint, and let <i>M</i><sub>1</sub> and <i>M</i><sub>2</sub> be the eastbound destination of\n  the signs at the western boundary and eastern boundary, respectively. We now have four possible\n  M/N pairs: (<i>M</i>, <i>N</i><sub>1</sub>), (<i>M</i>, <i>N</i><sub>2</sub>),\n  (<i>M</i><sub>1</sub>, <i>N</i>), and (<i>M</i><sub>2</sub>, <i>N</i>). We can greedily walk east\n  and west from the midpoint with each of the four pairs to find the longest set containing the\n  midpoint. This &ldquo;four-pass&rdquo; step for D&amp;C runs in linear time. Now that we have\n  found the longest set(s) containing the midpoint as well as (recursively) the longest sets from\n  the western and eastern halves of signs, we can combine these results to get the longest sets for\n  the whole dataset. This yields an algorithm requiring T(<b>S</b>) operations to compute an input\n  of size <b>S</b>, for a function T that satisfies T(<b>S</b>) = 2T(<b>S</b>/2) + O(<b>S</b>).\n  Using the\n  <a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\">Master Theorem</a>\n  we get that T(<b>S</b>) = O(<b>S</b> log <b>S</b>).\n</p>\n<p>\n  The linear-time solution does a single pass, identifying all possible long segments. Start by\n  walking forward from the first sign. Maintain two &ldquo;candidates&rdquo;, called the\n  &ldquo;M-candidate&rdquo; and the &ldquo;N-candidate&rdquo;, with the following properties:\n</p>\n<ul>\n  <li>Two destinations <i>M</i> and <i>N</i>.</li>\n  <li>An index <i>start</i> corresponding to the westernmost sign in the contiguous segment of signs\n    that includes the current sign and that satisfies <i>M</i> or <i>N</i>.</li>\n  <li>An index <i>xstart</i> corresponding to the westernmost sign in the contiguous segment of\n    signs that includes the current sign and whose eastbound destinations are all <i>M</i> (for the\n    M-candidate) or whose westbound destinations are all <i>N</i> (for the N-candidate).</li>\n</ul>\n<p>\n  With these invariants, the set of signs starting at <i>start</i> and ending after the current\n  index is guaranteed to be a valid set.\n</p>\n<p>\n  To maintain the invariants when reading a new sign, we can use the following procedure to create\n  the new the M-candidate (the procedure for creating the new N-candidate is analogous):\n</p>\n<ul>\n  <li>If new sign's eastbound destination equals previous sign's eastbound destination, copy the\n    previous M-candidate to become the new M-candidate.</li>\n  <li>If the new sign's eastbound destination equals the previous N-candidate's <i>M</i> value, copy\n    the previous N-candidate to become the new M-candidate, and set <i>xstart</i> to the new sign's\n    index.</li>\n  <li>Otherwise, copy the previous N-candidate to become the new M-candidate, set <i>M</i> to the\n    new sign's eastbound destination, set <i>start</i> to <i>xstart</i>, and set <i>xstart</i> to\n    the new sign's index.</li>\n</ul>\n<p>\n  Consider the following illustration:\n</p>\n<svg xmlns=\"http://www.w3.org/2000/svg\" style=\"max-width: 450px\" viewBox=\"0 0 450 200\"><defs><style>.a{font-size:15px;font-family:DejaVuSans, DejaVu Sans;}.b{fill:#29abe2;}.b,.d{stroke:#000;stroke-miterlimit:10;stroke-width:2px;}.c{font-size:20px;font-family:DejaVuSansCondensed-Bold, DejaVu Sans;font-weight:700;}.d{fill:none;}.e{font-size:14px;font-family:DejaVuSansCondensed, DejaVu Sans;}</style></defs><title>mysterious_road_signs</title><text class=\"a\" transform=\"translate(10.86 34.01)\">eastbound destinations (Dᵢ+Aᵢ)</text><text class=\"a\" transform=\"translate(10.86 172.4)\">westbound destinations (Dᵢ–Bᵢ)</text><rect class=\"b\" x=\"10.86\" y=\"48.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(24.6 75.56)\">6</text><rect class=\"b\" x=\"10.86\" y=\"108.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(20.86 135.56)\">-1</text><rect class=\"b\" x=\"70.86\" y=\"48.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(84.6 75.56)\">8</text><rect class=\"b\" x=\"70.86\" y=\"108.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(80.86 135.56)\">-1</text><rect class=\"b\" x=\"130.86\" y=\"48.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(144.6 75.56)\">7</text><rect class=\"b\" x=\"130.86\" y=\"108.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(144.6 135.56)\">0</text><rect class=\"b\" x=\"190.86\" y=\"48.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(204.6 75.56)\">8</text><rect class=\"b\" x=\"190.86\" y=\"108.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(204.6 135.56)\">2</text><rect class=\"b\" x=\"250.86\" y=\"48.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(264.6 75.56)\">8</text><rect class=\"b\" x=\"250.86\" y=\"108.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(264.6 135.56)\">2</text><rect class=\"b\" x=\"310.86\" y=\"48.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(324.6 75.56)\">9</text><rect class=\"b\" x=\"310.86\" y=\"108.11\" width=\"40\" height=\"40\"/><text class=\"c\" transform=\"translate(324.6 135.56)\">0</text><line class=\"d\" x1=\"310.86\" y1=\"108.11\" x2=\"290.86\" y2=\"88.11\"/><line class=\"d\" x1=\"310.86\" y1=\"88.11\" x2=\"290.86\" y2=\"108.11\"/><line class=\"d\" x1=\"250.86\" y1=\"128.11\" x2=\"230.86\" y2=\"128.11\"/><line class=\"d\" x1=\"250.86\" y1=\"68.11\" x2=\"230.86\" y2=\"68.11\"/><line class=\"d\" x1=\"190.86\" y1=\"108.11\" x2=\"170.86\" y2=\"88.11\"/><line class=\"d\" x1=\"130.86\" y1=\"88.11\" x2=\"110.86\" y2=\"108.11\"/><line class=\"d\" x1=\"70.86\" y1=\"128.11\" x2=\"50.86\" y2=\"128.11\"/><line class=\"d\" x1=\"190.86\" y1=\"88.11\" x2=\"170.86\" y2=\"108.11\"/><line class=\"d\" x1=\"130.86\" y1=\"108.11\" x2=\"110.86\" y2=\"88.11\"/><line class=\"d\" x1=\"70.86\" y1=\"88.11\" x2=\"50.86\" y2=\"108.11\"/><text class=\"e\" transform=\"translate(360.36 34.61)\">M-candidate:<tspan x=\"0\" y=\"16.8\">M=9, N=2</tspan><tspan x=\"0\" y=\"33.6\">start=3</tspan><tspan x=\"0\" y=\"50.4\">xstart=5</tspan></text><text class=\"e\" transform=\"translate(360.36 120.61)\">N-candidate:<tspan x=\"0\" y=\"16.8\">M=8, N=0</tspan><tspan x=\"0\" y=\"33.6\">start=1</tspan><tspan x=\"0\" y=\"50.4\">xstart=5</tspan></text></svg>\n<p>\n  The illustration shows six zero-indexed signs and the destinations for those six signs. The signs\n  are connected by lines that show which candidates are used when calculating the candidates for the\n  next step. The candidates after reading the sixth sign (index 5) are shown at the end. On top we\n  have the M-candidate with <i>M</i>=9 and <i>N</i>=2. The candidate starts at index 3, because the\n  sign at index 2 does not have a compatible westbound or eastbound destination for that candidate.\n  The illustration also demonstrates how <i>xstart</i>=5 is the start of the most recent string of\n  westbound destination <i>M</i> matches, which in this case is only the current sign. The\n  N-candidate goes all the way back to start index 1 with <i>M</i>=8 and <i>N</i>=0.\n</p>\n<p>\n  Since calculating the new candidates takes constant time, and we have to read each sign in\n  sequence, this is an O(<b>S</b>) solution.\n</p>\n<p>\n  There are two more tips that can aid in solutions to this problem. First is that we don't ever\n  need to remember <b>A<sub>i</sub></b>, <b>B<sub>i</sub></b>, and <b>D<sub>i</sub></b> directly; we\n  only care about the westbound and eastbound destinations. You could therefore compute those\n  destinations upon reading in the data and store them in a list of pairs. The second tip is that\n  there is a lot of opportunity for pruning: if you maintain a global list of the best known sets of\n  signs, you never need to look at any candidate sets that are smaller than the current best,\n  allowing you to prune away a lot of segments that you no longer need to evaluate. All of the\n  solutions described here except for the O(<b>S</b>) solution can take advantage of pruning.\n</p>\n\n\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2mT0kiapynBHwSsopxOJ56-KIPAiGdqLsjDZvrxMTKkcz9UnpfUuf8uC-LdAhRn33hipOd7A/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"000000000003675b","statement":"<h3>Problem</h3>\n<p>\n  The town of Signfield is on a perfectly straight and infinitely long road\n  running from west to east. Along that road, there is a sequence of <b>S</b>\n  mysterious road signs with numbers on both sides. The i-th sign (numbered in\n  order from west to east) is at a point <b>D<sub>i</sub></b> kilometers east\n  of Signfield, and has a number <b>A<sub>i</sub></b> on the west-facing side\n  and a number <b>B<sub>i</sub></b> on the east-facing side.\n</p><p>\n  Nobody in Signfield knows what these signs are trying to say. You think\n  that the numbers on the west sides of the signs are intended for drivers\n  traveling east, and that they represent distances to some particular\n  destination. Similarly, you think that the numbers on the east sides of the\n  signs are for drivers traveling west, and that they represent distances to\n  some particular destination. You suspect that not all of the signs may be\n  consistent with this theory, though.\n</p><p>\n  To start testing your theory, you are interested in finding valid sets of\n  signs that obey the following rules:\n</p>\n<ul>\n  <li>The set is a contiguous subsequence of the sequence of all road\n    signs. (The entire sequence also counts as a contiguous subsequence.)</li>\n  <li>There exist locations M and N kilometers east of Signfield, where M and N\n    are (not necessarily positive and not necessarily distinct) numbers, such\n    that for every sign in that set, at least one of the following is true:\n    <ul>\n      <li><b>D<sub>i</sub></b> + <b>A<sub>i</sub></b> = M.</li>\n      <li><b>D<sub>i</sub></b> - <b>B<sub>i</sub></b> = N.</li>\n    </ul>\n  </li>\n</ul>\n<p>\n  What is the largest possible number of signs in a valid set as described\n  above, and how many different valid sets of that size are there?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line containing one integer\n  <b>S</b>: the number of road signs. Then, <b>S</b> more lines follow. The\n  i-th of these lines represents the i-th sign (in west-to-east order), and\n  contains three integers <b>D<sub>i</sub></b>, <b>A<sub>i</sub></b>, and\n  <b>B<sub>i</sub></b>: the sign's distance (in kilometers) east of Signfield,\n  the number on its west side, and the number on its east side.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y z</code>,\n  where <code>x</code> is the test case number (starting from 1), and\n  <code>y</code> and <code>z</code> are the largest possible number of signs\n  in a valid set and the number of valid sets of that size, as described in\n  the problem statement.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 60.<br/>\n  1 &le; <b>D<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  <b>D<sub>i</sub></b> &lt; <b>D<sub>j</sub></b>, for all i &lt; j.<br/>\n  1 &le; <b>A<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  1 &le; <b>B<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  Time limit (for each test set): 10 seconds.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  1 &le; <b>S</b> &le; 100 for all test cases.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>S</b> &le; 100 for all but 3 test cases.<br/>\n  <b>S</b> = 10<sup>5</sup> for 3 test cases.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0S8EJK_A_KcQpB8lIe1ds1AbG8JkxxuPFa0CSjEsC4LzN3ZkEVweRs2OoVjWtS2YepGSbBJP0OJxbbD0kp3k7gWHHiIwfVw0YN_AfsiQywaAos/mysterious_road_signs_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n1\n1 1 1\n5\n2 7 12\n6 3 11\n8 10 1\n11 11 12\n13 9 14\n5\n1 3 3\n2 2 2\n3 1 1\n4 2 2\n5 3 3\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2KMMrHpudGduHssvBqwRzLaEW82TvXcDnBDFKKbmOTomqoAK6YOGSsYThUDTvm3o5oZC4b-w_704Ii1zlbL90ETDaJn7rcWVCOCDCUaxw7fICYJQ/mysterious_road_signs_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 1 1\nCase #2: 3 2\nCase #3: 5 1\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, there is only one sign. If we choose just that sign as our\n  set, there are many possible values of M and N that work &mdash; for example:\n</p>\n<ul>\n  <li>M = 2 and N = 0</li>\n  <li>M = 1 and N = 0 (remember that each sign only needs to be correct for\n    one of its values; also, M and N might be in the same place as one or more\n    signs, or Signfield itself)</li>\n  <li>M = 2 and N = -12345 (N might be west of Signfield)</li>\n  <li>M = 0 and N = 0 (M and N are not necessarily distinct)</li>\n  <li>M = 2 and N = 3 (N might be east of M)</li>\n</ul>\n<p>\n  So, the set consisting of just that one sign is valid. That is the only set\n  of that length, so the answer is <code>1 1</code>.\n</p><p>\n  In Sample Case #2, note that the first, second, fourth, and fifth signs would\n  be consistent with M = 9 and N = -1, but they do not form a contiguous\n  subsequence. (The 1 on the back of the third sign cannot be used as if it\n  were on the front.) As it turns out, there is no valid set of four signs.\n  There are two different valid sets of three signs. Note that although there\n  are two different M/N pairs that make the second set of three signs valid,\n  that set counts only once:\n</p>\n<ul>\n  <li>the first, second, and third signs, with M = 9 and N = 7</li>\n  <li>the third, fourth, and fifth signs, with M = 18 and N = -1 or with M = 22 and N = 7</li>\n</ul>\n<p>\n  In Sample Case #3, the entire sequence is a valid set, with M = 4 and N = 2.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Mysterious Road Signs","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  This is a very tricky problem with lots of pitfalls to consider.\n</p>\n<h3>Test set 1 (Visible)</h3>\n<p>\n  Plain brute force is sufficient to pass this data set. There are many ways\n  to approach it that would work, though. One intuitive approach would be to\n  create one gram of lead (metal 1) as often as possible.\n  Suppose <code>Create(i)</code> is a function that takes\n  a metal i as parameter and returns true if it can create one gram of the\n  i-th metal and false otherwise. Then, we can call <code>Create(1)</code>\n  repeatedly until it returns false, and output the number of calls that returned\n  true. An implementation of <code>Create(i)</code> works as follows:\n</p>\n<ul>\n  <li>First, check if the remaining amount of the i-th metal is positive. If it is,\n    we consume 1 gram of this metal and return true.\n  <li>Otherwise, let P and Q be the two metals that can be combined to create\n    the i-th metal.\n  <li>We recursively call <code>Create(P)</code> and <code>Create(Q)</code>.\n  <li>If both of the function calls return true, we return true. Otherwise we return\n    false.\n</ul>\n<p>\n  However, there is slight problem with the above function. When we are not\n  be able to create metal 1, this function will never end, it will keep\n  trying to create the metals. Consider a simple example: there are 3 metals\n  and for each of them the other two are the ingredients. Suppose, the\n  amount of the metals are now 0 but we are trying to create lead.\n  In such case, it will try to create the other two metals recursively, which will\n  eventually try to create the lead again and so on. One way to fix it would be\n  to check if we tried to create this i-th metal in the current call stack.\n  If we already tried to create the i-th metal and while doing so we looked\n  into its ingredient elements and again arrived at the i-th metal, that means it is not\n  possible to create the i-th metal (and eventually the lead) anymore. Another\n  way that is simpler to code is to limit the depth of the recursive call to\n  <b>M</b>, because after <b>M</b> recursive calls we are guaranteed to repeat at least\n  one metal.\n</p>\n<p>\n  The runtime of the above solution is not very large. The recursive call stack\n  is up to <b>M</b> calls deep and at each level we call <code>Create</code> twice recursively.\n  We may imagine it as a binary tree. The number of leaf nodes is at most\n  2<sup><b>M</b></sup> which makes the total less than 2<sup><b>M</b>+1</sup>. So, a\n  <code>Create(1)</code> call\n  takes O(2<sup><b>M</b></sup>) time. There may be at most 8 grams of each of these metals.\n  So we will call <code>Create(1)</code> function about 8<b>M</b> times. For <b>M</b> = 8,\n  this means the body of the function executes 8 &times; 8 &times; 2<sup>8</sup>, which is\n  not too large.\n</p>\n\n<h3>Test set 2 (Hidden)</h3>\n<p>\n  The approach above is of course too slow for the second test set. We can do a top-down approach\n  as follows: we maintain a current \"recipe\" to create lead. The initial recipe is just use 1\n  gram of lead to create 1 gram of lead. The invariant is that the current recipe is always optimal,\n  that is, any other way to create lead that can be done with the current supply is an expansion\n  of the recipe. An expansion of a recipe is the result of zero or more applications of replacing 1\n  gram of a metal in the recipe by 1 gram of each of the two metals required to make it. This\n  invariant is clearly true for the initial recipe.\n</p><p>\n  As a first step, we make as much lead as we can with the current recipe, which we already\n  mentioned is optimal.\n  After doing that, the supply of one or more of the metals in the recipe is less than\n  the recipe requirements of each. That means that any recipe that works is an expansion\n  of replacing 1 gram of each of those metals for its ingredients. We perform one of those\n  replacements to get a new optimal recipe and repeat.\n</p><p>\n  Notice that the total amount of grams of metal in the recipe only increases and the same number\n  in the supply only decreases or stays the same (if we make no lead in a step).\n  So, when the amount in the recipe surpasses the amount\n  in the supply we can stop, since we won't be able to make another gram of lead.\n</p><p>\n  Let S be the sum of all <b>G<sub>i</sub></b>, that is, the amount of grams of metal\n  in the initial supply.\n  Each step above takes O(<b>M</b>) if we represent the recipe as a vector of size <b>M</b>\n  with the required grams of each metal in the recipe. Checking how much lead we can do requires\n  a single pass to find the limiting ingredient, and finding an ingredient that we need to replace\n  requires another pass. Making the replacement of a single ingredient takes constant time.\n  Since after each step the total amount of grams of metal in the recipe increases by at least\n  1, and the supply does not increase, the number of steps until the stopping condition is at most\n  <b>S</b>. This makes the running time of this algorithm O(<b>M</b>S) which is enough\n  to pass for <b>M</b> &le; 100 and S &le; 10000.\n</p>\n<h3>Test set 3 (Hidden)</h3>\n<p>\n  Since S can be up to 10<sup>11</sup> for test set 3, we can't really use the\n  approach above. Adding a lot of prunning to it to prevent really long cycles of\n  replacements to happen can work, but it's hard to know exactly how much prunning\n  is required unless we take a systematic approach. Fortunately, using binary search can\n  simplify this a lot.\n  First, we consider the simplified problem of deciding if it is possible to make L grams\n  of lead, for an arbitrary L. If we can solve that efficiently, a simple binary search\n  within the range [0, S] finished the problem, and multiplies the time complexity\n  by a (relatively) small log S.\n</p><p>\n  For a fixed L, we start by adjusting our supply by making the amount of lead\n  <b>G<sub>1</sub></b> - L. That may leave us with lead debt instead of lead supply.\n  We now iterate paying off debt until either we cannot or we have no debt left. If\n  we cannot pay off some debt, then we cannot make L grams of lead. If we find ourselves\n  with no debt left, we can make L grams of lead. While we iterate, we will adjust the supply\n  <b>G</b> and the recipes <b>R</b>, that start as given in the input.\n</p><p>\n  For each step of pay off, find an ingredient i such that <b>G<sub>i</sub></b> &lt; 0.\n  If there are none, we paid off all debt and we are done. If there is, we go through\n  the recipe to make metal i. If the recipe contains metal i itself, we can't pay off\n  the debt and we are done. Otherwise, for each k grams required of metal j in the\n  recipe, we do <b>G<sub>j</sub></b> := <b>G<sub>j</sub></b> + k &times; <b>G<sub>i</sub></b>\n  (remember <b>G<sub>i</sub></b> is negative). That is, we push the debt of metal i to requiring\n  amounts of metals from its recipe. Finally we can set <b>G<sub>i</sub></b> := 0.\n  If we ever need i in the future, we know we\n  will again need to go through its recipe, so we replace any k grams of i in the recipe\n  of any ingredient by i's recipe multiplied by k. In this way, metal i will never be required\n  in the future.\n</p><p>\n  A step of payoff takes O(<b>M</b><sup>2</sup>) time: finding a metal in debt takes time\n  linear on <b>M</b>, and so do adjusting all ingredients (remember we represent recipes by\n  a vector of size <b>M</b> with the grams required for each metal). Replacing metal i in\n  a single recipe takes time linear on <b>M</b> too, and we have to do it for each other\n  of up to <b>M</b> metals, yielding O(<b>M</b><sup>2</sup>) time for the step.\n</p><p>\n  During each step of payoff one metal disappears from the recipes. Since at most <b>M</b> - 1\n  metals can disappear (when there is only one metal i left, its recipe is guaranteed to contain\n  metal i itself and we'll stop, since recipes only grow and thus are never empty) the total\n  number of payoff steps is O(<b>M</b>). This makes the overall time to check an arbitrary\n  L O(<b>M</b><sup>3</sup>), and the overall time for the entire algorithm\n  O(<b>M</b><sup>3</sup> log S), which is fast enough to solve the hardest test set.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U11ZFUQquRccyGwYetL5tzx8lRUW07n4WYYyYAJ2XC338liMF3tNJCNBTtld6dA2knvHQRELw/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"000000000003675c","statement":"<h3>Problem</h3>\n<p>\n  You are the most skilled alchemist of a country that considers metals such as\n  gold, platinum, and silver to be uninteresting, but highly values lead. There\n  are <b>M</b> metals known in the world; lead is metal number 1 on your\n  periodic table. Your country's leader has asked you to use the metal in the\n  treasury to make as much lead as possible.\n</p><p>\n  For each metal (including lead), you know exactly one formula that lets you\n  create one gram of that metal by destroying one gram each of two ingredient\n  metals. (If you are wondering about the principle of mass conservation, the\n  other gram is lost in useless waste products.) The formulas do not work with\n  partial grams. However, you can use each formula as often as you would like\n  (or not at all), as long as you have the required ingredients each time.\n</p><p>\n  If you make optimal choices, what is the largest total amount of lead you can\n  end up with? Note that it is possible that you may have some metals other\n  than lead left over after you are done.\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with an integer\n  <b>M</b>: the number of metals known in the world. Then there are <b>M</b>\n  more lines with two integers <b>R<sub>i1</sub></b> and <b>R<sub>i2</sub></b>\n  each; the i-th of these lines indicates that you can create one gram of metal\n  i by destroying one gram of metal <b>R<sub>i1</sub></b> and one gram of metal\n  <b>R<sub>i2</sub></b>. Finally, there is one line with <b>M</b> integers\n  <b>G<sub>1</sub></b>, <b>G<sub>2</sub></b>, ..., <b>G<sub><b>M</b></sub></b>;\n  <b>G<sub>i</sub></b> is the number of grams of metal i in the treasury. Lead\n  is metal 1.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the largest amount of lead, in grams, that you can end up with.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>R<sub>i1</sub></b> &lt; <b>R<sub>i2</sub></b> &le; <b>M</b>,\n    for all i.<br/>\n  Time limit: 5 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  2 &le; <b>M</b> &le; 8.<br/>\n  0 &le; <b>G<sub>i</sub></b> &le; 8, for all i.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  2 &le; <b>M</b> &le; 100.<br/>\n  0 &le; <b>G<sub>i</sub></b> &le; 100, for all i.<br/>\n</p>\n\n<h4>Test set 3 (Hidden)</h4>\n<p>\n  2 &le; <b>M</b> &le; 100.<br/>\n  0 &le; <b>G<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1gf2Vu82HyAuQapN9cZVyaYsS2p0s6jLZnypEa7NYROeECFdi0GqMCXeuBLu2YgbVMre_5jMfyQjkVB_GwdFQh7XpM8V6k9NGR5w/transmutation_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n3\n2 3\n1 3\n1 2\n5 2 3\n5\n3 4\n3 4\n4 5\n3 5\n1 3\n0 8 6 2 4\n4\n3 4\n2 3\n2 3\n2 3\n0 1 1 0\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0rtFlIkx98iWZEGER-_sziXu9VtOPTViJCUwHIB6Kh8OafGtF2BHFRn1CIkr1MO8xOxrto0mn4EuZVv3_qKYxh_3Qxqt3iYRHP0R8/transmutation_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 7\nCase #2: 4\nCase #3: 0\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, the optimal strategy is to use 2 grams of metals 2\n  and 3 to produce 2 more grams of lead, for a total of 7 grams of lead.\n</p><p>\n  In Sample Case #2, the optimal strategy is to first use 2 grams of metal 3\n  and 2 grams of metal 5 to produce 2 grams of metal 4, and then use 4 grams\n  of metal 3 and 4 grams of metal 4 to produce 4 grams of lead. Note that it is\n  possible for two formulas to have the same two ingredients (you just use\n  different alchemical techniques). Also note that not every metal is\n  necessarily an ingredient in some other formula; in this case, metal 2 is\n  never an ingredient.\n</p><p>\n  In Sample Case #3, note that it is possible for a metal to be used to produce\n  itself. (Sometimes the laws of alchemy may be silly!) Unfortunately, it is\n  not possible to produce any lead in this case. Note that since formulas only\n  work on single-gram quantities, you <i>cannot</i>, for example, use 0.5 grams\n  of each of metals 2 and 3 to create 0.5 grams of metal 4, and then use 0.5\n  grams of each of metals 3 and 4 to create 0.5 grams of lead.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":18},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Transmutation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000007764","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2018"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
