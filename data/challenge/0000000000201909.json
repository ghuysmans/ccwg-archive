{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1502465400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201909","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  This year, we served up another set of six tough problems for our strongest\n  contestants to chew on. <i>Dice Straight</i> was the most approachable of the\n  six, and could be solved via max flow. <i>Operation</i> required several\n  observations in order to make the underlying dynamic programming problem\n  tractable. The unusual <i>Spanning Planning</i> asked contestants to construct\n  a graph with a certain exact number of spanning trees; it turned out to be\n  possible to solve the problem with a randomized algorithm!\n  <i>Omnicircumnavigation</i> involved a perennially tough programming contest\n  problem topic: geometry on a sphere. <i>Stack Management</i> presented a\n  simple-sounding solitaire-style card game; there was a relatively simple way to\n  determine whether each game was winnable, but it was very hard to see! Finally,\n  <i>Teleporters</i> was another 3D geometry problem that required careful\n  thought and implementation.\n</p><p>\n  As usual, most contestants chose to work on earlier problems first; A, B, and\n  even the unusual C got many submissions. Our defending champion\n  <b>Gennady.Korotkevich</b> did not appear on the scoreboard at all until the\n  2:30 mark, but he had clearly used the preceding time well; in the last hour,\n  he submitted six more datasets, and reached 120 points with 10 minutes to go!\n  <b>SnapDragon</b> overtook him in the last minute with a submission for D-large,\n  jumping to 130 points, but alas, it was incorrect. That left Gennady as our\n  <i>four-time</i> Code Jam champion! <b>zemen</b> took second with 110;\n  <b>vepifanov</b> was third thanks to a successful last-minute D-large\n  submission; <b>SnapDragon</b> was fourth. There were no successful\n  submissions for E-large and F-large; this was one of our toughest final rounds\n  yet!\n</p><p>\n  As always, we congratulate all 26 of our finalists, and we thank everyone who\n  competed this year! We hope that you will all join us again in 2018 for another\n  Code Jam tournament.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Problem A (Dice Straight): Written and prepared by Pablo Heiber.\n</p><p>\n  Problem B (Operation): Written by Pablo Heiber. Prepared by Ahmed Aly.\n</p><p>\n  Problem C (Spanning Planning): Written and prepared by Petr Mitrichev.\n</p><p>\n  Problem D (Omnicircumnavigation): Written by Chieu Nguyen. Prepared by Igor\n    Naverniouk.\n</p><p>\n  Problem E (Stack Management): Written by Onufry Wojtaszczyk. Prepared by John\n    Dethridge.\n</p><p>\n  Problem F (Teleporters): Written by Pablo Heiber. Prepared by Trung Thanh\n    Nguyen.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Mohammed\n  Hossein Bateni, John Dethridge, Md Mahbubul Hasan, Petr Mitrichev, Gareth\n  Pearce, Ray Robinson, Steve Thomas, Ian Tullis, and Josef Ziegler.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Dice Straight: Pablo Heiber</li>\n  <li>Operation: Pablo Heiber</li>\n  <li>Spanning Planning: Liang Bai, Petr Mitrichev, and Ian Tullis</li>\n  <li>Omnicircumnavigation: Pablo Heiber</li>\n  <li>Stack Management: Onufry Wojtaszczyk</li>\n  <li>Teleporters: Pablo Heiber</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1502451000000,"tasks":[{"analysis":"<h2>Dice Straight: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  One brute force approach to the problem is to examine all possible subsets of\n  dice in all possible orders, and look for the longest straights. Since there\n  may be as many as 100 dice in the Small dataset, we need a better strategy.\n</p><p>\n  First, let's create the set of all integers that are present on at least one\n  die, and sort that set in increasing order. Then we will create an interval\n  that initially contains only the first number in that sorted list. We will\n  expand and contract that interval according to the following strategy. As an\n  invariant, the entire interval will always be a straight (a sequence of one\n  or more consecutive numbers).\n</p>\n<p>\n  Check whether it is possible to build the straight using the available\n  dice (we'll get to how to do that in a moment).\n</p>\n<ul>\n  <li>If it is possible: Expand the interval to include the next value to\n    the right.\n    <ul>\n      <li>If that value is not one greater than the previous rightmost\n        value, then we no longer have a straight; contract the interval to\n        remove all but that new rightmost value. Then we have a straight\n        again.</li>\n    </ul>\n  </li>\n  <li>If it is not possible: Contract the interval by removing its leftmost\n    value.</li>\n</ul>\n<p>\n  To check whether a possible straight can be built, we can find a\n  <a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)#Bipartite_matching\">bipartite matching</a>\n  from the required integers to the dice by using a flow algorithm such as\n  <a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\">Ford-Fulkerson</a>. Since each die has exactly 6 faces, the number of edges in the\n  graph is 6<b>N</b>, and the running time of one iteration of Ford-Fulkerson\n  is O(<b>N<sup>2</sup></b>). We run it up to O(<b>N</b>) times as we adjust\n  our interval, so this solution is O(<b>N<sup>3</sup></b>). Other polynomial\n  solutions are possible.\n</p>\n<h3>Large dataset</h3>\n<p>\n  To make the flow algorithm fast enough to solve the Large dataset, we need\n  the additional insight that we do not need to start the algorithm from\n  scratch every time. When expanding by adding a new number, we need to add\n  all O(<b>N</b>) edges into that number (either by adding them outright or\n  changing their flow capacity from 0 to 1), and then find and add a single\n  augmenting path to the existing flow, which also takes O(<b>N</b>) time\n  (since the total number of edges in the graph is at most 6<b>N</b>). So an\n  expansion takes O(<b>N</b>) time overall. When contracting, we need to remove\n  edges and flow from the path associated with that number; this takes\n  O(<b>N</b>) time. Since we have O(<b>N</b>) expansions and contractions, they\n  take O(<b>N<sup>2</sup></b>) time in total. Adding this to the\n  O(<b>N<sup>2</sup></b>) from completely solving the flow problem\n  the first time, the overall complexity is still O(<b>N<sup>2</sup></b>).\n  This is fast enough for the Large dataset.\n</p>\n","id":"00000000002017fc","statement":"<h3>Problem</h3>\n<p>\n  You have a special set of <b>N</b> six-sided dice, each of which has six\n  different positive integers on its faces. Different dice may have different\n  numberings.\n</p><p>\n  You want to arrange some or all of the dice in a row such that the faces\n  on top form a <i>straight</i> (that is, they show consecutive integers). For\n  each die, you can choose which face is on top.\n</p><p>\n  How long is the longest straight that can be formed in this way?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case begins with one line with <b>N</b>,\n  the number of dice. Then, <b>N</b> more lines follow; each of them has six\n  positive integers <b>D<sub>ij</sub></b>. The j-th number on the i-th of these\n  lines gives the number on the j-th face of the i-th die.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the length of the longest straight that can be formed.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>D<sub>ij</sub></b> &le; 10<sup>6</sup> for all i, j.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n  1 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n  1 &le; <b>N</b> &le; 50000.<br/>\n  The sum of <b>N</b> across all test cases &le; 200000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n4 8 15 16 23 42\n8 6 7 5 30 9\n1 2 3 4 55 6\n2 10 18 36 54 86\n2\n1 2 3 4 5 6\n60 50 40 30 20 10\n3\n1 2 3 4 5 6\n1 2 3 4 5 6\n1 4 2 6 5 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 1\nCase #3: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In sample case #1, a straight of length 4 can be formed by taking the 2 from\n  the fourth die, the 3 from the third die, the 4 from the first die, and the\n  5 from the second die.\n</p><p>\n  In sample case #2, there is no way to form a straight larger than the\n  trivial straight of length 1.\n</p><p>\n  In sample case #3, you can take a 1 from one die, a 2 from another, and\n  a 3 from the remaining unused die. Notice that this case demonstrates that\n  there can be multiple dice with the same set of values on their faces.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Dice Straight","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Stack Management: Analysis</h2>\n<p>\n  This problem requires quite a lot of thinking, but relatively little code in\n  the end!\n</p><p>\n  Let S be the number of suits that appear on at least one card used in\n  the problem. For each of these suits, we will call the card with the highest\n  value the <i>ace</i> of that suit, and the second-highest card (if it exists)\n  the <i>king</i>. We'll say that a card is <i>visible</i> if it is at the top\n  of one of the stacks, and that a suit is <i>visible</i> if a card of that\n  suit is visible.\n</p><p>\n  Notice that once a suit becomes visible, it will stay visible throughout the\n  rest of the game. At any point in the game, if there are <b>N</b> visible\n  suits (recall that <b>N</b> is the number of stacks), then either we have\n  won, or we cannot make any more moves and so we have lost. On the other hand,\n  if there are fewer than <b>N</b> visible suits, then either we have won, or\n  we are able to make a move (because either a suit has two visible cards, or\n  there is an empty stack). In particular, this implies that if S &lt;\n  <b>N</b>, then we are guaranteed to win however we play. However, if\n  S &gt; <b>N</b>, we cannot win, because we can never remove the last\n  card of any suit from the game. This means that S = <b>N</b> is the\n  only interesting case, so we will assume from now on that S = <b>N</b>.\n  In this case, a winning position is a position in which we have exactly one\n  card in each stack, with each one representing a different suit.\n</p><p>\n  Let us assume there is some way to win the game, and we will consider the\n  very last move of that game. Before that move, we had not won, and yet we\n  were able to make a move; this means there must have been fewer than <b>N</b>\n  suits visible. So, the last move must have exposed a card of some suit that\n  had never been visible. This means that this suit contained only one card\n  (the card that now remains as the only card in its stack), and this card\n  started the game at the bottom of its stack.\n</p><p>\n  Also note that it is never disadvantageous to remove a card; the only real\n  decisions made in the game are choosing which cards to move into an empty\n  stack. Thus, as a pre-processing step, we can remove all the cards that can\n  be removed from the initial position. If doing that is enough to win the game,\n  we are done. If doing that leaves us with no empty stacks, we are also \"done\",\n  because we have lost the game! So, let's assume that when we begin, there is\n  at least one empty stack.\n</p><p>\n  We will now aim to prove that the following condition is necessary and\n  sufficient for a game to be winnable. Let us construct a graph in which\n  vertices are the suits for which the ace begins the game at the bottom of some\n  stack. We say that a vertex (suit) <i>s</i> is a <i>source</i> if the ace is\n  the only card in this suit, and that <i>s</i> is a <i>target</i> if there is\n  another ace (of a different suit) in the stack in which the ace of <i>s</i>\n  is at the bottom. We add an edge from vertex <i>s<sub>1</sub></i> to a\n  different vertex <i>s<sub>2</sub></i> if the king of <i>s<sub>2</sub></i> is\n  in the stack that has the ace of <i>s<sub>1</sub></i> at the bottom.\n</p><p>\n  Now, we claim the game is winnable if and only if there exists any path from\n  some source vertex to some target vertex.\n</p><p>\n  To understand this condition, consider a simple case in which there is a\n  single edge from a source suit <i>s<sub>1</sub></i> to a target suit\n  <i>s<sub>2</sub></i>; i.e., suit <i>s<sub>1</sub></i> has exactly one card\n  (an ace), which is at the bottom of a stack <i>A</i>, and suit\n  <i>s<sub>2</sub></i>'s king is in <i>A</i>. To ensure that\n  <i>s<sub>1</sub></i> is a source but not a target, assume that there are no\n  other aces in <i>A</i>, and to ensure that <i>s<sub>2</sub></i> is a target,\n  assume that its ace is at the bottom of a different stack <i>B</i>, and\n  there is a third suit <i>s<sub>3</sub></i> that has an ace higher up in\n  <i>B</i>, which we will assume is the ace nearest the bottom except for the\n  bottmmost card in <i>B</i>.\n</p><p>\n  The winning strategy in this case is as follows. First, make all legal moves\n  until the only remaining legal move is moving the ace of <i>s<sub>3</sub></i>\n  to an empty pile. Since we won't uncover the ace of <i>s<sub>1</sub></i>,\n  there will be fewer than <b>N</b> suits visible, so this state is always\n  achievable. When we reach this state, all of the following are true:\n  <ul>\n    <li>There is an empty stack (since <i>s<sub>1</sub></i> isn't visible, we'd\n      otherwise have two cards visible in one suit, and could remove the one\n      with the lower value).</li>\n    <li>Stacks <i>A</i> and <i>B</i> are the only stacks with more than one\n      card. (Otherwise, we could move a card from from one of the other stacks\n      into the empty space.)</li>\n    <li>The other <b>N</b>-3 stacks (aside from <i>A</i>, <i>B</i> and the\n      aforementioned empty stack) each contain an ace of one of the remaining\n      <b>N</b>-3 colors. (We couldn't have removed the aces, and they are not\n      in stack <i>A</i> or stack <i>B</i>).</li>\n  </ul>\n</p><p>\n  At this point, we will move the ace of <i>s<sub>3</sub></i> to the empty\n  stack, and then try to remove cards from <i>B</i>, until we get down to the\n  ace of <i>s<sub>2</sub></i>. If the top card of <i>B</i> isn't yet the ace of\n  <i>s<sub>2</sub></i>, then it's either in suit <i>s<sub>2</sub></i> (and\n  lower than the king, so we can remove it, because the king is visible), or in\n  some other suit (in which case the ace of that suit is visible, and we can\n  remove it). Therefore, we can remove cards down to the ace of\n  <i>s<sub>2</sub></i>, then remove the king of <i>s<sub>2</sub></i>, and then\n  again dig down to the ace of <i>s<sub>1</sub></i>. We can do this because\n  any card in <i>A</i> other than the ace of <i>s<sub>1</sub></i> will be\n  removable, since we now see all the aces other than <i>s<sub>1</sub></i>, and\n  there are no cards but the ace in suit <i>s<sub>1</sub></i>.\n</p><p>\n  The description above can be extended relatively easily to show how to win\n  the game when a longer path exists. First, we clean up everything but the\n  aces mentioned in the path, and then move the ace from the end of the path\n  into the empty space, and remove all the remaining cards one by one. So, what\n  remains is to prove that if the game is winnable, a path from a source to a\n  target always exists in the graph we constructed.\n</p><p>\n  At the end of a successful game, each of the <b>N</b> stacks will contain one\n  of the <b>N</b> aces. Whenever we move an ace to the bottom of a stack, it\n  will never again be covered. So, before the last move action, <b>N</b>-1 aces\n  will be on the bottom of a stack, and the last move is necesarilly moving an\n  ace to the empty spot. Some of the aces are visible before the last move.\n  Nothing interesting will happen to cards in those suits - we might uncover a\n  card in one of those suits, and then we will be able to immediately remove\n  it, because the ace is visible. The more interesting suits are the ones in\n  which the aces are not visible and are at the bottoms of stacks. Note that\n  once uncovered, an ace cannot be covered again, so these aces had to be at\n  the bottoms of their stacks from the beginning of the game, and the cards on\n  top of them had to be there from the beginning of the game. So, it's enough\n  to prove that we will see a source-target path in the position before the\n  last move. This will mean that the path was there from the beginning of the\n  game.\n</p><p>\n  The cards on top of the other stacks with more than one card have to be in\n  the same set of colors as the covered aces (or else they would have already\n  been removed). We want to prove they are all kings. We will proceed by\n  contradiction: assume that one of them is a lower card (say, a \"queen of\n  spades\"). Since it is visible and not removed, the king of spades must be\n  somewhere in one of the stacks, and not visible; it cannot have been removed\n  yet, because in this case the ace would have to be visible, and the queen\n  would have been removed as well.\n</p><p>\n  Consider what happens if we move this queen into the empty space. We\n  experience a sequence of removals, which cannot end with removing the queen\n  (that would contradict the assumption that no more moves can be made before\n  the winning one). Thus, it has to end in uncovering the ace of the suit that\n  was not previously visible (causing us to lose the game) - let's call this\n  suit \"diamonds\".\n</p><p>\n  Now, consider the winning move instead. We also end up with a sequence of\n  removals. After each removal except the last one, we see <b>N</b>-1 suits,\n  and so we have exactly one choice what to remove. So, we deterministically\n  remove cards until we, at some point, uncover the king or the ace of spades,\n  whichever comes first, and that causes us to remove the queen of spades...\n  and then execute the exact same deterministic sequence of removals that, in\n  the end, caused us to uncover the ace of diamonds. Note that the other high\n  spade card (whichever among the king and ace that we did not see) is not\n  uncovered in this sequence. If it were, it would have removed the queen of\n  spades in the previous scenario - so, we end up with at least one card that\n  is not visible, which is a contradiction.\n</p><p>\n  So, we have proven that kings are on top of our stacks with (non-visible)\n  aces on the bottom. At this point, following the graph from the ace that was\n  the source will eventually lead us to the target: the stack with two aces.\n</p><p>\n  After establishing all this, the algorithm to check for the desired condition\n  is fairly simple. After constructing our graph, we can start at sources and\n  perform a depth-first search to see if there is a path from any of them to a\n  target. This is considerably faster than running a backtracking algorithm on\n  the set of moves itself, which works for the Small but not for the Large.\n</p>\n","id":"00000000002017fd","statement":"<h3>Problem</h3>\n<p>\n  You are playing a solitaire game in which there are <b>N</b> stacks of\n  face-up cards, each of which initially has <b>C</b> cards. Each card has a\n  <i>value</i> and a <i>suit</i>, and no two cards in the game have the same\n  value/suit combination.\n</p><p>\n  In one move, you can do one of the following things:\n</p>\n<ol>\n  <li>If there are two or more cards with the same suit that are on top of\n    different stacks, you may remove the one of those cards with the smallest\n    value from the game. (Whenever you remove the last card from a stack, the\n    stack is still there &mdash; it just becomes empty.)\n  </li>\n  <li>If there is an empty stack, you may take a card from the top of any one\n    of the non-empty stacks and place it on top of (i.e., as the only card in)\n    that empty stack.\n  </li>\n</ol>\n<p>\n  You win the game if you can make a sequence of moves such that eventually,\n  each stack contains at most one card. Given a starting arrangement, determine\n  whether it is possible to win the game.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number <b>P</b> of premade stacks that will\n  be used in the test cases. Then, <b>P</b> lines follow. The i-th of those lines\n  begins with an integer <b>C<sub>i</sub></b>, the number of cards in the i-th\n  of those premade stacks, and continues with <b>C<sub>i</sub></b> ordered pairs\n  of integers. The j-th of these ordered pairs has two integers\n  <b>V<sub>ij</sub></b> and <b>S<sub>ij</sub></b>, representing the value and suit\n  of the j-th card from the top in the i-th premade stack.\n</p><p>\n  Then, there is another line with one integer <b>T</b>, the number of test cases.\n  <b>T</b> test cases follow. Each case begins with one line with two integers\n  <b>N</b> and <b>C</b>: the number of stacks, and the number of cards in each of\n  those stacks. Then, there is one line with <b>N</b> integers\n  <b>P<sub>i</sub></b>, representing the indexes (starting from 0) of the test\n  case's set of premade stacks.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is <code>POSSIBLE</code> if it is possible to win the game, or\n  <code>IMPOSSIBLE</code> otherwise.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>P</b> &le; 60000.<br/>\n  0 &le; <b>P<sub>i</sub></b> &lt; <b>P</b>, for all i.<br/>\n  The <b>P<sub>i</sub></b>-th premade stack has exactly <b>C</b> cards.<br/>\n  No two cards in a test case have the same value/suit combination.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  2 &le; <b>N</b> &le; 4.<br/>\n  2 &le; <b>C<sub>i</sub></b> &le; 13, for all i.<br/>\n  2 &le; <b>C</b> &le; 13.<br/>\n  1 &le; <b>V<sub>ij</sub></b> &le; 13, for all i and j.<br/>\n  1 &le; <b>S<sub>ij</sub></b> &le; 4, for all i and j.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n  2 &le; <b>N</b> &le; 50000.<br/>\n  2 &le; <b>C<sub>i</sub></b> &le; 50000, for all i.<br/>\n  2 &le; <b>C</b> &le; 50000.<br/>\n  4 &le; <b>N</b> &times; <b>C</b> &le; 10<sup>5</sup>.<br/>\n  1 &le; <b>V<sub>ij</sub></b> &le; 50000, for all i and j.<br/>\n  1 &le; <b>S<sub>ij</sub></b> &le; 50000, for all i and j.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2 7 2 7 1\n2 6 4 7 4\n2 3 2 6 2\n2 4 2 10 2\n2 5 4 7 3\n2\n2 2\n0 2\n3 2\n4 1 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: POSSIBLE\nCase #2: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In sample case #1, there are two stacks, each of which has two cards. The\n  first stack has a 7 of suit 2 on top and a 7 of suit 1 below that. The second\n  stack has a 3 of suit 2 on top and a 6 of suit 2 below that.\n</p><p>\n  It is possible to win the game as follows:\n</p>\n<ul>\n  <li>Remove the 3 of suit 2 from the second stack.</li>\n  <li>Remove the 6 of suit 2 from the second stack. This makes the second\n    stack empty.</li>\n  <li>Move the 7 of suit 2 to the second stack. Then the win condition is\n    satisfied: all stacks have at most one card.</li>\n</ul>\n<p>\n  In sample case #2, there are three stacks, each of which has two cards. It\n  is not possible to win the game in this case; the only possible move is\n  to remove the 5 of suit 4 on top of the third stack, and this does not open\n  up any new moves.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Stack Management","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Operation: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nLet us consider the Small dataset first. The number of operations is large\nenough that trying all possible orderings would time out, but a typical trick\nmight work: turn that <b>N</b>! into a 2<sup><b>N</b></sup> with dynamic programming\nover subsets of cards. That is, try to reduce all possible orderings of a subset\nof the cards to only few possible results that are worth exploring further.\nThe first option to try is to define a function f(C), for a subset C of the\ncards, as the best possible result of applying cards in C to the starting\nvalue <b>S</b>. It seems that defining f(C) as the maximum over all c in C of\napplying c to f(C - c) could be reasonable (with f(&empty;) being <b>S</b>).\nHowever, it doesn't quite work in general. For instance,\nsuppose c is <code>* -1</code>. We are getting the maximum possible result out\nof f(C - c), only to flip the sign right after. It\nwould have been better to get the minimum possible result for f(C - c) instead.\nOf course, if c is <code>* 2</code> instead, getting the maximum for f(C - c)\nseems like a good idea. It turns out that the best option is always either\nthe minimum or the maximum for f(C - c), which we prove below. Therefore,\nlet g(C, maximum) be the maximum possible result of applying cards in C to\n<b>S</b>, and g(C, minimum) be the minimum among those results. We can define\ng(C, m) recursively as the \"m\" (i.e., the maximum or the minimum depending on m)\nover each c and each m' in {minimum, maximum} of applying c to g(C - c, m'),\nwith g(&empty;) = <b>S</b>.\nThis definition of g formalizes our intuition that only the minimum and maximum\npossible values are needed from each subset. We prove its correctness below.\nThe result is then g(C, maximum) for C = the entire input set.\nThe function has a domain of size 2<sup><b>N</b></sup> &times; 2, and calculating\neach value involves an iteration over at most 2 &times; <b>N</b>\npossibilities, yielding O(2<sup><b>N</b></sup> &times; <b>N</b>)\noperations in total after memoizing the recursion.\nOf course, those operations are over large-ish integers. The number of digits\nof those integers is bounded by O(<b>N</b>D) where D is the number of digits\nof the input operands. That means the time complexity of each operation,\nwhich operates on a large integer and an input integer with up to D digits,\nis bounded by O(<b>N</b>D<sup>2</sup>), which makes the overall\nrunning time of this algorithm\nO(2<sup><b>N</b></sup> &times; <b>N</b><sup>2</sup> &times; D<sup>2</sup>).\n</p><p>\nWe can prove the definition of g is correct by complete induction. If C is the empty\nset, then g is correct immediately by definition. Otherwise, assume g is correct\nfor all m' and all sets C' smaller than C, and let us prove that g(C, m)\nis correct. Let c be the last card used in an ordering of C that gives the \"m\"\nresult when applied to <b>S</b>. If c is +v or -v, we can commute\nthe operator \"m\" with the application of c. That is: let T be the result of applying all of\nthe other operations in the optimal order. Then we know that T + v or T - v is\n\"m\" over the operations, so if the value of T is not the\noptimal g(C - c, m), then there is some other ordering that yields\ng(C - c, m) + v or g(C - c, m) - v, which is better. The same is true for c\nbeing a multiplication or division by a non-negative, since those also commute\nwith maximum and minimum. If c is a multiplication or division by a negative,\nthen it can commute with a maximum or minimum operator, but the operator is\nreversed, that is, max turns into min, and vice versa. Since we try both\nmaximum and minimum in the definition of g, that poses no problem.\nNotice that this proof also shows that we do not even need to try both options for m';\nwe only need to check the one that actually works. Trying both is simpler, though,\nand it doesn't impact the running time in a significant way.\n</p>\n<h3>Large dataset</h3>\n<p>\nOf course, an exponential running time would not work for the Large dataset,\nso we need to reason further.\nAs a first simplification, assume all additions and subtractions have positive\noperands by removing those with a zero operand, and flipping both the sign\nand the operand of those with a negative operand. This leaves an input with\nthe same answer as the original one.\n</p><p>\nSuppose all cards are already ordered forming an expression E. We can\n<a href=\"https://www.google.com/url?sa=D&q=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDistributive_property\">distribute</a>\nto \"move\" all additions and subtractions to the right end creating a new expression E'\nthat contains multiplications and divisions first, and additions and subtractions later.\nIn order to make the value of E the same as the value of E', we change the\nadded or subtracted value on each term.\nThe value of a given addition or subtraction card is going to be multiplied/divided by all\nmultiplications/divisions that are to its right in E.\nFor instance, if E = (((0 + 1) &times; 4) - 6) / 2, then\nE' = ((0 &times; 4) / 2) + 2 - 3. Notice \"+ 1\" turned into \"+ 2\" because it is multiplied\nby 4 and divided by 2. \"- 6\" turned into \"- 3\" because it is only divided by 2 (the\nmultiplication in E does not affect it).\n</p><p>\nIf we consider an initial fixed card \"+<b>S</b>\", we can even move that one to the end and\nalways start with a 0, making multiplications and divisions in E effectively not needed\nin E'. The final result is then the sum over all additions minus the sum over\nall subtractions of the adjusted values (in the example above 4 is the adjusted\nvalue of the only addition and 3 is the adjusted value of the only subtraction). Notice\nthat this shows the value of <b>S</b> always impacts the final result in the\nsame way regardless of the order: it adds <b>S</b> times the product of all\nmultiplications and divided by all divisions to the result.\n</p><p>\nConsider a fixed order for multiplications and divisions, and insert the\nadditions and subtractions. As explained in the previous paragraph, inserting\noperation Z at a given position implies that Z will get multiplied by all multiplications\nthat are to its right, and divided by all divisions that are to its right. Effectively,\neach position has a fraction F such that operations inserted there get multiplied by F.\nGiven the view of the final result above, it follows\nthat it's always best to insert additions at a position where F is maximal,\nand subtractions at a position where F is minimal. Even though there could be\nmultiple places with the same value of F, this shows that it is never suboptimal\nto insert all additions in the same place A, and all subtractions in the same\nplace B. Since additions and subtractions commute, this further shows that it\nis equivalent to have an input with a single addition and a single subtraction\nwhose operand is the sum of the operands of the corresponding operation (after\nadjusting the signs to make them all positive).\n</p><p>\nGiven the simplification, we can reverse the point of view. Consider the\naddition and subtraction fixed and insert multiplications and divisions.\nSince multiplication and division commute, we just need to decide between 3\nplaces: a) before both addition and subtraction, b) in between, c) after both.\nWhat we insert in a) will multiply/divide only <b>S</b> in the final result,\nwhat we insert in b) will multiply/divide <b>S</b> and only additions or only subtractions\ndepending on which is earlier, and what we insert in c) will multiply/divide\neverything. If we fix the positions of multiplications\nand divisions with negative operands, we can greedily place multiplications\nand divisions with a positive operand: we place multiplications to apply\nto the greatest of the 3 values mentioned above (after applying the fixed\nmultiplications and divisions by a negative) and divisions to apply to the\nlesser of the 3 (after doing the same). This shows that it is never suboptimal to place\nall multiplications by a positive together in one place, and all divisions\nby a positive in one place.\n</p><p>\nTo further simplify, divisions can't have a zero operand, but multiplications can.\nNotice that a \"* 0\" will nullify the entire thing, so only the placement of the\nrightmost \"* 0\" matters, so we can simplify them all into a single card (or no card\nif there is no \"* 0\" in the input). This leaves only multiplications and divisions\nby a negative. If a pair of multiplications by a negative are in the same place\na), b) or c) as above, they multiply as a positive, so it is always better to move the\npair to the optimal place to put multiplications, as long as we have pairs. If there is\nan even number of multiplications by a negative in a suboptimal place, then all of them\nget moved by this. If their number is odd, all but one are moved. Leaving behind the one with\nthe smallest absolute value is optimal. A similar argument applies\nto divisions by a negative, although the optimal place to move to may of course be different than\nthe optimal place to move multiplications.\nThis shows that we can group multiplications and divisions by a negative similarly\nto what we did with all other operations, but leaving out the two smallest absolute\nvalues of each type, as they may be needed in suboptimal places to perform a sign change\n(there are 3 places out of which 1 is optimal, leaving 2 suboptimal places).\n</p><p>\nAfter all the groupings, we are left with at most 11 cards: 1 addition, 1 subtraction, 1\nmultiplication by 0, 1 multiplication by a positive, 1 division by a positive, 3 multiplications\nby negatives and 3 divisions by negatives. This can be refined further, but there's no\nneed for it. With just 11 cards, we can apply the Small solution and finish the problem. There are\nalso other ways of reasoning among similar lines to get the number of cards low enough.\nAnother possibility that doesn't require any dynamic programming is to notice that we can\nbrute-force the order of the addition and subtraction (two options), and then brute-force which\nplace a), b) or c) each multiplication and division (up to 8 cards after all simplifications)\nshould go into. This requires exploring only 2 &times; 3<sup>8</sup> combinations in total,\nand exploring each one is a relatively fast process requiring only O(<b>N</b><sup>2</sup>) time\n(11 operations of quadratic time each, since the operands in the simplified cards can have linear\nsize).\n</p><p>\nIt is possible to reduce the set of cards further with more thought, and it's also possible\nto follow other lines of reasoning that will lead you to slightly higher card totals that\nare small enough to make the dynamic programming solution work.\n</p>\n","id":"000000000020184a","statement":"<h3>Problem</h3>\n<p>\n  Here at Code Jam, we love to play a game called \"Operation\". (No, it has\n  nothing to do with surgery; why would you think that?) The game is played\n  with cards, each card is labeled with a basic arithmetic operation\n  (addition, subtraction, multiplication or division) <b>O<sub>i</sub></b>\n  and an integer right operand <b>V<sub>i</sub></b> for that operation. For\n  example, a card might say <code>+ 0</code>, or <code>- -2</code>, or\n  <code>/ -4</code> &mdash; note that operands can be negative or zero,\n  although a card with a division operation will never have 0 as an operand.\n</p><p>\n  In each round of the game, a starting integer value <b>S</b> is chosen, and\n  a set of <b>C</b> cards is laid out. The player must\n  choose an order for the cards, using each card exactly once. After that, the\n  operations are applied, in order, to the starting value <b>S</b>, and a final\n  result is obtained.\n</p><p>\n  Although all of the operands on the cards are integers, the operations are\n  executed on rational numbers. For instance, suppose that the initial value\n  is 5, and the cards are <code>+ 1</code>, <code>- 2</code>, <code>* 3</code>,\n  and <code>/ -2</code>. If we put them in the order given above, the final\n  result is (5 + 1 - 2) * 3 / (-2) = -6. Notice that the operations are\n  performed in the order given by the cards, disregarding any operator\n  precedence. On the other hand, if we choose the order <code>- 2</code>,\n  <code>/ -2</code>, <code>+ 1</code>, <code>* 3</code>, the result is\n  ((5 - 2) / (-2) + 1) * 3 = -3 / 2. That example turns out to be the maximum\n  possible value for this set of cards.\n</p><p>\n  Given a set of cards, can you figure out the maximum possible final value\n  that can be obtained? Please give the result as an irreducible fraction with\n  a positive denominator.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case begins with one line with two\n  integers <b>S</b> and <b>C</b>: the starting value for the game, and the\n  number of cards. Then, <b>C</b> lines follow. The i-th of these lines\n  represents one card, and contains one character <b>O<sub>i</sub></b>\n  representing the operation (which is either <code>+</code>, <code>-</code>,\n  <code>*</code>, or <code>/</code>) and one integer <b>V<sub>i</sub></b>\n  representing the operand.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y z</code>,\n  where <code>x</code> is the test case number (starting from 1), and\n  <code>y</code> and <code>z</code> are integers such that\n  <code>y</code>/<code>z</code> is the maximum possible final value of the\n  game, <code>y</code> and <code>z</code> do not have common\n  divisors other than 1 and -1, and <code>z</code> is strictly greater than 0.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  -1,000 &le; <b>S</b> &le; 1,000.<br/>\n  <b>O<sub>i</sub></b> is one of <code>+</code>, <code>-</code>,\n  <code>*</code>, or <code>/</code>, for all i.<br/>\n  -1,000 &le; <b>V<sub>i</sub></b> &le; 1,000, for all\n  i.<br/>\n  If <b>O<sub>i</sub></b> = <code>/</code>, then <b>V<sub>i</sub></b> &ne;\n    0, for all i.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n  1 &le; <b>C</b> &le; 15.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n  1 &le; <b>C</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n1 2\n- 3\n* 2\n5 4\n+ 1\n- 2\n* 3\n/ -2\n1000 7\n* -1000\n* -1000\n* 1000\n* 1000\n* 1000\n* 1000\n* 1000\n-1 3\n- -1\n* 0\n/ -1\n0 1\n+ 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: -1 1\nCase #2: -3 2\nCase #3: 1000000000000000000000000 1\nCase #4: 1 1\nCase #5: 0 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the optimal strategy is to play the <code>* 2</code> card\n  before the <code>- 3</code> card, which yields a result of -1. The unique\n  rational expression of this as specified in the problem is -1 1.\n</p><p>\n  Sample Case #2 is the one described in the third paragraph of the problem\n  statement.\n</p><p>\n  In Sample Case #3, we get the same answer regardless of the order in which\n  we use the cards. Notice that the numerator of the answer is too large to\n  fit in 64-bit integer.\n</p><p>\n  In Sample Case #4, the largest result we can achieve is 1. One way is:\n  <code>/ -1</code>, <code>* 0</code>, <code>- -1</code>.\n</p><p>\n  In Sample Case #5, note that the only valid representation of the answer is\n  <code>0 1</code>. <code>0 2</code> is invalid because it can be reduced.\n  <code>0 -1</code> is invalid because the denominator must be positive.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Operation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Teleporters: Analysis</h2>\n<p>\nThis problem starts off with a strange twist, because instead of the regular\n<a href=\"https://en.wikipedia.org/wiki/Euclidean_geometry\">Euclidean geometry</a>\n(also known as L2 geometry),\nit uses <a href=\"https://en.wikipedia.org/wiki/Taxicab_geometry\">L1 geometry</a>. The reason, if\nyou are curious, is that the distance between two points with integer coordinates is also an\ninteger. A Euclidean geometry version of this had serious precision issues, and L1 geometry has\nall the properties that are needed. A concept that will come up later is the set of points\nthat are at a particular distance from a center. In Euclidean geometry, that's just a sphere.\nIn L1 geometry, though, is an <a href=\"https://en.wikipedia.org/wiki/Octahedron\">octahedron</a>\nwith diagonals (segments that connect opposite vertices, passing through the center) parallel\nto the axis. Luckily, most intuitive properties of spheres in Euclidean geometry also work for\nspheres in L1 geometry, with the important exception of rotations, that are not used in this\nproblem. If it helps you to visualize, for remainder of the text, you can think of the problem as\nworking in L2 geometry. However, throughout the rest of this analysis, every time we say\n\"distance\", we are referring to L1 distance; we will write dist(x, y) for the L1 distance\nbetween points x and y. Every time we say \"sphere\", we are referring to L1 spheres\n(i.e., regular octahedra).\n</p>\n\n\n<h3>Small dataset</h3>\n<p>\nLet us start slowly: after 0 teleportations starting from a point P, the only\nreachable place is point P.\nAfter 1 teleportation, reachable places depend on which teleporter we used. If we use\nteleporter t, reachable points are the surface of the sphere with center t\nand radius dist(P, t). Let R<sub>i</sub> be the set of points that are reachable\nin i teleportations using any set of teleporters. As we mentioned above,\nR<sub>0</sub> = {P} and R<sub>1</sub> is\na union of <b>N</b> sphere surfaces, one centered on each teleporter.\nWhat about R<sub>2</sub>? If we use teleporter u for the second teleportation,\nwe can land at any point that is at distance d from u, where d can take the\nvalue of any distance betwen u and a point in R<sub>1</sub>. This implies R<sub>2</sub>,\nand all other R<sub>i</sub>, are also a union of sphere surfaces, possibly\ninfinitely many.\n</p><p>\nNotice that R<sub>1</sub> is a connected continuous set because all the spheres' surfaces\nintersect at point P. Thus, the values for the distance d in the definition above\nform an interval, since the distance function is continuous. This implies that\nR<sub>2</sub> is actually a union of sphere differences: for each teleporter t,\nall points x such that L<sub>t,2</sub> &le; dist(x, t) &le; U<sub>t,2</sub> are reachable.\n(Throughout these explanations, we use L to refer to a lower bound on a reachable range, and\nU for a corresponding upper bound.)\nOnce again, all the sphere differences contain P, thus, they intersect\nand R<sub>2</sub> is a connected continuous set, which means the distances we use to calculate\nR<sub>3</sub> are intervals. This argument generalizes to prove by induction that each\nR<sub>i</sub> is exactly the union over all teleporters t of all points x such that\nL<sub>t,i</sub> &le; dist(x, t) &le; U<sub>t,i</sub>.\n</p><p>\nThis yields a dynamic programming algorithm that solves the Small dataset. Keep two\narrays L and U representing the values L<sub>t,i</sub> and U<sub>t,i</sub> for a\nparticular i and use them to calculate the next values L<sub>t,i+1</sub> and U<sub>t,i+1</sub>.\nAfter each iteration, check whether L<sub>t,i</sub> &le; dist(Q, t) &le; U<sub>t,i</sub> for\nsome t, and if so, i is the answer.\n</p><p>\nBy definition, L<sub>t,i+1</sub> and U<sub>t,i+1</sub> are the distances from t to its closest\nand farthest points in R<sub>i</sub>, respectively.\nThe farthest point in R<sub>i</sub> from t is at a distance which is the maximum over all\nteleporters u of dist(t, u) + U<sub>u,i</sub> (this is the distance to the point on the\nsurface of the sphere centered at u with radius U<sub>u,i</sub> that is the opposite direction\nfrom t).\nThe closest point is slightly more complicated. For each teleporter u we need to consider:\n</p><ul>\n<li>dist(t, u) - U<sub>u,i</sub> if dist(t, u) &gt; U<sub>u,i</sub> (t is outside the outer\n  sphere centered at u),</li>\n<li>L<sub>u,i</sub> - dist(t, u) if dist(t, u) &lt; L<sub>u,i</sub>\n  (t is inside the inner sphere), or</li>\n<li>0, in all other cases (t is in between, that is, it is itself a\n  reachable point).</li>\n</ul>\nThis means we can calculate each L<sub>t,i</sub> and U<sub>t,i</sub> in O(<b>N</b>) by comparing\nthe values above for each teleporter u.\n<p>\nNotice that a point reachable in i teleportations is also reachable in i+1, i+2, ... etc\nteleportations, because\nyou can use a teleporter to move from a point to itself. Thus, U<sub>t,i</sub> is non-decreasing\nwith i, and L<sub>t,i</sub> is non-increasing with i.\nAdditionally, since the distances dist(t, u) are positive, when <b>N</b> &ge; 2, the maximum\nover all t of U<sub>t,i</sub> is strictly increasing with i, and the minimum over all t of\nL<sub>t,i</sub> is strictly decreasing with i up to the first j where L<sub>t,j</sub> = 0.\nThat means, for <b>N</b> &ge; 2, the intervals grow until one of them represents a\nsphere covering the entire cube of values for Q within the limits.\nMoreover, since the values are integers, the increase\nand decrease is at least 1 per iteration, so the number of iterations needed to cover the\nentire region of valid Qs is bounded by 3M (M on each direction), where M is the number of valid\ncoordinates, which is only 2001 in the Small dataset.\nThis in particular means that for <b>N</b> &ge; 2 the answer is never impossible.\nFor <b>N</b>=1, we can note that using the same\nteleporter twice in a row is never useful, so after 1 iteration, if Q is not reached, the answer\nis impossible.\n</p>\nThe time complexity of the presented algorithm is O(M <b>N</b><sup>2</sup>): up to 3M steps,\neach of which requires calculating O(<b>N</b>) values, and calculating each one requires an\niteration over <b>N</b> other teleporters and constant-time math.\n<p>\n\n<h3>Large dataset</h3>\n<p>\nOf course, when M is bounded by 2 &times; 10<sup>12</sup> + 1, a time complexity linear on M won't\nfinish fast enough, so we have to do something else.\n</p><p>\nLet us focus first on deciding if it's possible to go from P to Q with a single\nteleportation. That means using a single teleporter t, and due to conservation of distance,\nit must be dist(P, t) = dist(Q, t). Moreover, this condition is sufficient and\nnecessary for the answer to be 1. We can check for this condition initially\nwith a loop over all teleporters in O(<b>N</b>) time.\n</p><p>\nAs we saw on the Small, checking whether the answer is 1 is sufficient to fully solve\ncases with <b>N</b> = 1. We assume further that <b>N</b> &ge; 2.\n</p><p>\nLet us now consider the case where there exists two teleporters t and u such that\ndist(P, t) &ge; dist(Q, t) and dist(P, u) &le; dist(Q, u).\nConsider the sphere A centered at t that passes through P, and the sphere B\ncentered at u that passes through Q. By the assumed inequalities, A contains\nQ and B contains P, which means A and B intersect. Let x be any point at the\nintersection, for which dist(P, t) = dist(x, t) and dist(Q, u) = dist(x, u)\nhold. Then, x is a possible intermediate stop to go from P to Q in exactly\n2 teleportations, so, if the inequalities hold, 2 is the answer. Notice there\nare other cases in which 2 is also the answer, which are covered below.\n</p><p>\nAt this point, we can assume that either P is closer to any teleporter than\nQ, or vice versa (otherwise, we can choose two teleporters to fullfill the\ninequalities at the beginning of the previous paragraph). Since the problem\nis symmetric, swap P and Q if needed to make P the closest of P and Q to all\nteleporters.\n</p><p>\nNow recall the definitions of R, L and U from the Small solution.\nSince P is closest to all teleporters, dist(Q, t) &gt; U<sub>t,1</sub> = dist(P, t)\nfor all t. This means Q is outside the spheres centered in all teleporters. Since\nL<sub>t,i</sub> is non-increasing with i, the inner sphere contracts with each\nstep, which means Q is never inside the inner sphere, so as soon as Q is inside\nthe outer sphere, we are guaranteed that Q is reachable. So, we only need to calculate\nthe Us. By reading its definition above, we note that U<sub>t,i</sub> is equal to the\nlongest path from P to t using teleporters as intermediate steps, where the length of\neach step is simply the distance between the two points.\n</p><p>\nWe can calculate the length of the required longest paths\nfor all t and a fixed i in O(<b>N</b><sup>3</sup> log i) time by using\nsomething similar to <a href=\"https://en.wikipedia.org/wiki/Exponentiation_by_squaring\">iterated\nsquaring</a> to calculate the matrix of largest distances from any teleporter to any other in\ni - 1 steps, and then combining that with the vector of distances from P to each teleporter.\nThe \"multiplication\" here is not an actual matrix times matrix multiplication, but\nrather the use of the property that the longest path from t to u in i steps is the longest\npath from t to v in j steps plus the longest path from v to u in k - j steps, for some v.\nTaking j = k / 2 for even k shows how to do log k steps overall.\nThis, combined with a binary search on the number of steps, gives an algorithm with overall\ntime complexity O(<b>N</b><sup>3</sup> log<sup>2</sup> M). If you have a good implementation in\na fast language, this runs in minutes, but it's enough to pass the Large.\n</p><p>\nIt's possible to get rid\nof one the log factors for an overall time complexity of O(<b>N</b><sup>3</sup> log M), and a program\nthat finishes the Large in a few seconds. This is achieved by starting the binary search on a\nrange [min, max) whose size, that is, max - min, is a power of 2. Each step calculates\nmid as the averge of min and max, so mid - min and max - mid are also powers of 2, which\nproves by induction that the range size is a power of 2 in every step of the binary search.\nThen, since mid - min is also a power of 2 in every step, every distance matrix you need is of a\nnumber of steps that is itself a power of 2 (the range keeps being cut in half, so it remains of\nsize a power of 2, so the delta between the min and the midpoint that we need to test is always a\npower of 2). That means we can precalculate all needed matrices in O(<b>N</b><sup>3</sup> log M)\ntime, since the matrix for 2<sup>k+1</sup> steps is the \"square\" of the matrix for 2<sup>k</sup>\nsteps. With the memoized matrices, each step of the binary search only takes\nO(<b>N</b><sup>2</sup>) time to \"multiply\" the matrix and the initial vector.\n</p>\n","id":"000000000020184b","statement":"<h3>Problem</h3>\n<p>\n  A short, short time into the future, in a nearby galaxy, you find yourself\n  wanting to take a little trip and get away from the responsibilities of being\n  Planet Thundera's only manufacturer of yarn. You decide to travel to Planet\n  Care-a-Lot, the most relaxing planet there is. To travel, you are going to\n  use the network of interstellar teleporters.\n</p><p>\n  A teleporter is a small machine floating around somewhere in space. You can\n  use it remotely from any point in space, but, due to the conservation of\n  teleportation distance principle, it can teleport you to any other point in\n  space at exactly the same L1 distance from the teleporter as your\n  L1 distance to it before the teleportation. The L1 distance between two points\n  at coordinates (x<sub>0</sub>, y<sub>0</sub>, z<sub>0</sub>) and\n  (x<sub>1</sub>, y<sub>1</sub>, z<sub>1</sub>) is given by\n  |x<sub>0</sub> -  x<sub>1</sub>| + |y<sub>0</sub> - y<sub>1</sub>|\n  + |z<sub>0</sub> - z<sub>1</sub>|. Unfortunately, your space jetpack is broken,\n  so you cannot move around on your own; to travel, you can only use the\n  teleporters.\n  You start at Planet Thundera. You can use a teleporter to travel from Planet\n  Thundera to a point p<sub>1</sub>, then use another to get from p<sub>1</sub>\n  to p<sub>2</sub>, and so on. The last teleportation must take you exactly to\n  Planet Care-a-Lot.\n</p><p>\n  Given the locations in 3-dimensional space of both planets and all the\n  available teleporters, find out if it is possible for you to make the trip\n  using only teleporters. If the trip can be made, what is the minimum number\n  of teleportations needed to get to your destination? (Even if two\n  teleportations use the same teleporter, they still count as separate\n  teleportations.)\n</p><p>\n  The input is given as points with coordinates that are all integers that fall\n  within a certain range. However, you are allowed to teleport to intermediate\n  points with integer or non-integer coordinates, and there are no range\n  restrictions on the points you can visit.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case starts with a single line with a\n  single integer <b>N</b>, the number of teleporters available. Then,\n  <b>N</b>+2 lines follow, each containing three integers <b>X<sub>i</sub></b>,\n  <b>Y<sub>i</sub></b>, and <b>Z<sub>i</sub></b>. The first of these lines\n  represents the coordinates of your home planet, Thundera. The second of these\n  lines represents the coordinates of your destination planet, Care-A-Lot. Each\n  of the remaining <b>N</b> lines represents the coordinates of one of the\n  teleporters.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is <code>IMPOSSIBLE</code> if it is not possible to get from Thundera to\n  Care-A-Lot using only the available teleporters, or, if it is possible, an\n  integer representing the minimum number of teleportations needed.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  (<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>, <b>Z<sub>i</sub></b>) &ne;\n  (<b>X<sub>j</sub></b>, <b>Y<sub>j</sub></b>, <b>Z<sub>j</sub></b>) for all i\n    &ne; j. (No two described objects have the same coordinates.)\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 180 seconds.<br/>\n  1 &le; <b>N</b> &le; 100.<br/>\n  -10<sup>3</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>3</sup>, for all i.<br/>\n  -10<sup>3</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>3</sup>, for all i.<br/>\n  -10<sup>3</sup> &le; <b>Z<sub>i</sub></b> &le; 10<sup>3</sup>, for all i.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 360 seconds.<br/>\n  1 &le; <b>N</b> &le; 150.<br/>\n  -10<sup>12</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>12</sup>, for all i.<br/>\n  -10<sup>12</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>12</sup>, for all i.<br/>\n  -10<sup>12</sup> &le; <b>Z<sub>i</sub></b> &le; 10<sup>12</sup>, for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1\n0 0 0\n0 4 0\n0 3 0\n2\n0 0 1\n0 0 11\n0 0 3\n0 0 0\n3\n0 0 0\n6 2 0\n6 0 0\n3 0 0\n6 1 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: IMPOSSIBLE\nCase #2: 3\nCase #3: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the only teleporter is exactly 3 units away from Thundera,\n  and we can only use it to go to another position that is <i>exactly</i> 3\n  units away from the teleporter. From that position, we can still only reach\n  other positions that are exactly 3 units away from the teleporter. Since\n  Care-a-Lot is 1 unit away from the teleporter, we can never reach it.\n</p><p>\n  In Sample Case #2, the optimal strategy is to first use the teleporter at\n  (0, 0, 3) to travel to (0, 0, 5). Then, from there, use the teleporter at\n  (0, 0, 0) to travel to (0, 0, -5). Finally, from there, use the teleporter\n  at (0, 0, 3) again to travel to (0, 0, 11). Note that the two uses of the\n  teleporter at (0, 0, 3) cause us to travel different distances, because we\n  are at different distances from the teleporter each time. Also note that the\n  two uses of that teleporter count as two separate teleportations.\n</p><p>\n  In Sample Case #3, the optimal strategy is to first use the teleporter at\n  (3, 0, 0) to travel to (6, 0, 0). Then, from there, use the teleporter at\n  (6, 1, 0) to travel to (6, 2, 0). Note that even though there was a\n  teleporter at (6, 0, 0), merely occupying the same point as a teleporter\n  does not count as using it.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Teleporters","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Spanning Planning: Analysis</h2>\n<p>\n  In general, for any value of X greater than 2, it is possible to construct a\n  graph that has X spanning trees: connect X vertices to form a single cycle.\n  Then there are X ways to delete a single edge, and each of these deletions\n  leaves behind a different spanning tree. However, in this problem, we are\n  only allowed up to 22 vertices, so we can only use that strategy for values\n  of <b>K</b> up to 22.\n</p><p>\n  The statement guarantees that an answer exists for every <b>K</b> in the\n  range [3, 10000], so we just need to find those answers. Since there are so\n  few possible testcases, we can prepare ourselves by finding one answer for\n  each possible <b>K</b> before ever downloading a dataset.\n</p><p>\n  A good way to start exploring the problem is to create random graphs and\n  count their spanning trees. We can use the beautiful\n  <a href=\"https://en.wikipedia.org/wiki/Kirchhoff's_theorem\">Kirchhoff matrix tree theorem</a>\n  to reduce the problem of counting spanning trees in a graph to the problem of\n  finding the determinant of a matrix based on the graph. We can either\n  carefully implement our own function for finding determinants, or use a\n  library function, e.g., from SciPy. We must take care to avoid overflow; a\n  complete 22-node graph has\n  <a href=\"https://en.wikipedia.org/wiki/Cayley%27s_formula\">22<sup>20</sup> trees!</a>\n  Precision loss is also a potential concern if working outside of rational\n  numbers, but one of our internal solutions successfully used Gaussian\n  elimination and doubles.\n</p><p>\n  It turns out that we cannot find all the answers we need via a purely random\n  search, but we can find most of them, which provides some hope that we can\n  reach the others with some tweaking. For example, we can change the graph\n  size and the probability that each edge exists; empirically, 13 nodes and an\n  existence probability of 1/4 work well.\n</p><p>\n  Another strategy is to apply small modifications to a graph, hoping to\n  converge on one of the desired numbers of trees. Specifically, we can\n  remember what numbers of trees we still need to get, pick one of them as a\n  \"target\", and then repeatedly add edges if we have fewer trees than the\n  target or remove them (taking care not to disconnect the graph) if we have\n  more trees than that target. Once we reach our goal, we pick another\n  still-unreached number as the new goal, and so on. To make this finish\n  quickly, we can mark all visited numbers as reached even if we reach them\n  while in pursuit of a different goal.\n</p><p>\n  In both of the above approaches, generating solutions for <b>K</b> = 13 and\n  <b>K</b> = 22 can take a very long time, since those numbers apparently\n  require very specific graph structures. However, since we're allowed 22\n  vertices, we can get the answers from those numbers by building a cycle with\n  13 or 22 vertices, as described earlier.\n</p><p>\n  This problem is inherently experimental, and requires research on a computer;\n  you cannot just write down a solution on paper. (If you do know of a\n  tractable construction-based solution, we'd love to hear about it!) However,\n  this sort of exploratory research skill is valuable in real-world\n  programming, and we like to reward it in Code Jam, particularly in problems\n  in which it is surprising that a randomized strategy works at all.\n</p>\n","id":"000000000020187a","statement":"<h3>Problem</h3>\n<p>\n  A <i>spanning tree</i> of an undirected graph with N nodes is a tree with\n  N-1 edges that uses only edges from N and includes all nodes in N.\n</p><p>\n  Please construct a graph with at least 2 nodes, and no more than 22 nodes,\n  such that the graph has <i>exactly</i> <b>K</b> different spanning trees.\n  (Two spanning trees are considered different if and only if the sets of edges\n  that they use are different.) The graph must have at most one edge per pair\n  of nodes, and must not contain a loop (an edge from a node to itself).\n</p><p>\n  It is guaranteed that at least one such graph exists for every <b>K</b>\n  within the limits below.\n</p>\n\n<h3>Solving this problem</h3>\n<p>\n  This problem has only 1 Small dataset and no Large dataset. You will be able\n  to retry the dataset (with a time penalty).\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of one line with an integer\n  <b>K</b>: the desired number of spanning trees.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, first output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1), and\n  <code>y</code> is the number of nodes in your graph. (<code>y</code> must be\n  between 2 and 22, inclusive.) Then, output <code>y</code> more lines. The\n  i-th of these lines represents the i-th node in the graph, and must contain\n  exactly y characters. The j-th character on the i-th line should be\n  <code>1</code> if the i-th node and the j-th node are connected with an edge,\n  and <code>0</code> otherwise. Note that this matrix will be symmetric and it\n  will have all <code>0</code>s along its main diagonal.\n</p><p>\n  If multiple answers are possible, you may output any of them. Note that we\n  guarantee that at least one valid answer exists for every <b>K</b> within\n  the limits below.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 240 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 300.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  3 &le; <b>K</b> &le; 10000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\n8\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\n011\n101\n110\nCase #2: 4\n0111\n1001\n1001\n1110\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Case #1, the graph is a triangle, and removing any one edge creates a\n  different spanning tree.\n</p><p>\n  In Case #2, the available edges in our solution tree are 1-2, 1-3, 1-4,\n  2-4, and 3-4. The eight different spanning trees are defined by these\n  sets of edges:\n</p>\n<ul>\n  <li>1-2, 1-3, 1-4</li>\n  <li>1-2, 1-3, 2-4</li>\n  <li>1-2, 1-3, 3-4</li>\n  <li>1-2, 1-4, 3-4</li>\n  <li>1-2, 2-4, 3-4</li>\n  <li>1-3, 1-4, 2-4</li>\n  <li>1-3, 2-4, 3-4</li>\n  <li>1-4, 2-4, 3-4</li>\n</ul>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":30}],"title":"Spanning Planning","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Omnicircumnavigation: Analysis</h2>\n<p>\nThe concept of omnicircumnavigation requires a given itinerary to touch every\npossible hemisphere. Pick any plane P that contains the origin. The plane splits the surface of\nthe sphere into 3 parts &mdash; two open hemispheres and a circle between them. If the travel\npath lies entirely within one of the hemispheres, then it is not an omnicircumnavigation.\nThe problem is to find such a <i>dividing plane</i> P or prove that one does not exist.\n</p><p>\nContinuing with that reasoning, the travel path touches\na plane P if and only if one of the stops is on P, or there are stops on both\nhemispheres so that the connection between them passes through P.\nTherefore, another equivalent definition of dividing plane of a travel path\nis a plane that has all stops strictly on one of the hemispheres.\nThis means the order of the input points is not important: the\nanswer is the same for any valid permutation of a given set of points!\n</p><p>\nNotice that each actual stop S is given in the input by giving another point\nS' such that S is the\n<a href=\"https://en.wikipedia.org/wiki/Unit_vector\">normalized vector</a> of S'.\nThat means the origin, S and S'\nare collinear, which in turn implies that any plane P that contains the origin\nleaves both S and S' on the same hemisphere. Then, checking for the actual stops to be\non a side of a plane is equivalent to checking the points S' given as input.\nAnd since points S' have the lovely property of having all integer coordinates,\nit is much better (and precise) to use them directly.\n</p><p>\nTo summarize, the problem we are presented is equivalent to a simplified\nformulation: given a set X of points with integer coordinates, decide whether\nthere exists a plane P that contains the origin such that all points in X lie\nstrictly on the same side of P. Let us call a plane that goes through the origin\nand leaves all points strictly on one side a <i>dividing plane</i>.\n</p>\n<h3>Convex-hull based solutions</h3>\n<p>\nNotice that if there exists a dividing plane P, then P\nalso has the <a href=\"https://en.wikipedia.org/wiki/Convex_hull\">convex hull</a>\nof all points on one side.\nMoreover, by convexity, a dividing plane exists if and only if the convex hull\ndoes not contain the origin. So, one possible solution, that can even work for the\nLarge, is to calculate the convex hull and check whether it contains the\norigin. If you do this using a library, it might be easier to calculate the\nconvex hull of X plus the origin and check whether the origin is indeed a\nvertex of it. This solution, however, has two major drawbacks: 1. the algorithm\nto do convex hull in 3d is pretty hard, and 2. many implementations will have\neither precision issues, overflow problems, or get slowed down by handling\nincreasingly big integers. This is because the needed plane can be really\nskewed, with angles within the 10<sup>-6</sup> order of magnitude. Moreover,\nif the entire input is <a href=\"https://en.wikipedia.org/wiki/Coplanarity\">coplanar</a>,\nthen the convex hull might\nfail. One way to take care of both problems is to calculate the convex hull\nof X plus the origin plus F where F is a point really far away. F is not going\nto be coplanar, and it will also make the convex hull not have extremely narrow\nparts. Of course, the addition of F may make the convex hull contain the\norigin when the original did not. We can solve that with a second pass using the\nantipode of F, -F.\nIf the original convex hull contained the origin, then both of the\npasses will. If the original convex hull didn't, then at least one of them won't (the one where\nF or -F is on the appropriate side of the dividing plane, since they are necessarily on\ndifferent sides).\n</p><p>\nA simplified way to check for this is to notice that, in the same way there is\na triangulation for any convex polygon, there is a tetrahedralization of any\npolyhedron. That means, we can avoid explicitly calculating the convex hull if\nwe check all possible tetrahedra. This can't give false positives because all\nof them are included in the convex hull, and since some subset of those\ntetrahedra will actually be a partition of the convex hull, their union is the\nentire convex hull, and one of them contains the origin. We can conclude\nthat the convex hull of X contains the origin if and only if some tetrahedron\nwith vertices in X does. The coplanar case can be simplified in this case:\nif the entire input is coplanar, we can check for any triangle to contain\nthe origin. This solution, however, takes time O(<b>N</b><sup>4</sup>), which\nis definitely too slow for the Large dataset, and might even be slow for the\nSmall, given that checking for each tetrahedron to contain the origin requires\nquite a few multiplications, which takes significant, though constant,\ntime. The coplanar edge case of this solution can also be avoided by adding\nphantom points F and -F as above.\n</p><p>\nA speedup of the solution above that is certainly fast enough to pass the Small\nis to notice we can fix one of the vertices and try every possible combination\nof the other 3. This is because, for any vertex V, there\nis a tetrahedralization of the convex hull such that all tetrahedra in it have\nV as a vertex. This takes the running time down to O(<b>N</b><sup>3</sup>),\nwhich is definitely fast enough for the Small dataset,\neven with a large constant.\n</p>\n<h3>Solutions based on restricting the dividing planes</h3>\n<p>\nAs usual in geometry problems, we can restrict the search space from the\ninfinitely many possibilities to just a few. Suppose there is a dividing plane\nP. If we rotate P while touching the origin, we will eventually touch at least\none point S from the input. If we rotate while around the line between S and\nthe origin, we will eventually touch another point from the input. That means\nwe can restrict planes P to those who touch two points from the input. Of\ncourse, the plane P is not the dividing plane (since it touches points from the\ninput), but P represents planes epsilon away from those touching points. This\nmeans we need to take special care of inequalities to make sure that small\nrotation doesn't ruin the solution. In short, if there is another point\ntouching P, we can't necessarily rotate P to make all 3 points on P to lie\non one side. We need to take care of this coplanar case separately, with either\nsolving the 2-dimensional version of the problem, or using phantom poins.\nSince 3 points (two points from the input\nand the origin) completely determine a plane, this restricts the number of\nplanes to try to O(<b>N</b><sup>2</sup>) possibilities. For each one, we need\nanother pass through the input to check on which side of the plane each point\nlies. This yields a solution that runs in time O(<b>N</b><sup>3</sup>), which\nis enough to pass the Small. Even in fast languages, this can be too slow\nfor the Large, as the constant is, once again, very significant.\n</p><p>\nThe solution above can be made run much faster,\nby randomizing the input, and thus, the order in which we check the points.\nFor most planes, there will be several points on either side, and then when\nchecking in a random order, the expected time to find one on each side (after\nwhich, we can stop) can be greatly reduced. Notice, however, that a case in\nwhich all the points are coplanar will not have its running time improved by\nthis randomization, as no point will fall strictly on one side. For this to\nwork well, we need to check for the all-coplanar case and special-case that\none before launching the general case algorithm. This randomized version is\nindeed enough to pass the Large.\n</p>\n<h3>A bazooka-to-kill-a-fly solution</h3>\n<p>\nAnd finally, we can use\n<a href=\"https://en.wikipedia.org/wiki/Linear_programming\">linear programming</a>.\nA plane that contains the origin is defined by an equation Ax + By + Cz = 0, for some A, B and C.\nA plane that has all points on one side has to satisfy either AX + BY + CZ &gt; 0 for each point\n(X, Y, Z) or AX + BY + CZ &lt; 0 for (X, Y, Z). Notice that if a triple (A, B, C) satisfies\none of the conditions, then (-A, -B, -C) satisfies the other. So, we can restrict ourselves to\none of the two cases, and then define a polytope with the set of inequalities AX + BY + CZ &gt; 0\nfor each (X, Y, Z) in the input.\nThe answer to the problem is whether that polytope is empty. Most LP algorithms figure that as\nan intermediate result towards optimization, and some libraries may provide functionality to check\nthat directly. For others, you can just optimize the constant function 0 and see whether the answer\nis indeed 0 or \"no solution\".\n</p><p>\nAs simple as the description of this solution is, it has a lot of issues to resolve.\nIf using a library, it is highly likely that you run into similar precision /\nlarge number problems as the convex hull (and for the same reasons) that may\nmake it either wrong or slow or both. If you\nwant to implement your own algorithm, well, it's long and cumbersome to do it\nand avoid precision problems. There are\ntricks here, too. We can catch the possible problems and try to rotate the\ninput to see if the library performs better. We can add additional restrictions\nlike bound A, B and C to absolute values up to 10<sup>6</sup> to have a bounded\npolytope to begin with. That being said, judges tried 4 different LP libraries,\nand only one of them worked, after adding both additional restrictions (the\nlibrary wouldn't handle unbounded spaces) and rotating the input a few times.\nAdding far-away phantom points can also help the LP, because it avoids the same problems\nas in the convex hull case. Of course, if you had a really robust prewritten\nalgorithm or library, this option was best, even enabling a possible 3-line\nsolution that passes the Small and the Large.\n</p>\n","id":"000000000020190a","statement":"<h3>Problem</h3>\n<p>\n  Intrepid globetrotter K, who may or may not be the author of this problem,\n  has been traveling a lot lately. On one of her recent trips, she traveled\n  from San Francisco to Frankfurt to Johannesburg to Abu Dhabi to Singapore to\n  Tokyo and back to San Francisco. On this trip, she circumnavigated the Earth\n  by traveling along a closed path that touches every meridian. In other words,\n  for every possible longitude, there is at least one point along this path at\n  that longitude.\n</p><p>\n  K is not sure that this trip qualifies as being <i>super awesome</i>, however,\n  since it would also be possible to circumnavigate the Earth by flying to the\n  North Pole and then walking around it, which does not seem to be particularly\n  difficult (other than the part about flying to the North Pole). So she has\n  decided to come up with a more generalized definition of circumnavigation.\n  The new concept is called <i>omnicircumnavigation</i> &mdash; a closed path\n  around the Earth (which we assume to be a sphere) that is a circumnavigation\n  regardless of where one places the poles. In other words, an\n  omnicircumnavigation is a closed path on the surface of a sphere that touches\n  every possible hemisphere. (Touching the edge of a hemisphere is sufficient.)\n  Equivalently, an omnicircumnavigation intersects every possible great circle\n  &mdash; a circle of greatest possible diameter on the surface of a sphere.\n</p><p>\n  You are given a sequence of <b>N</b> points on a sphere of radius 1. You need\n  to check whether a path connecting those points in order is an\n  omnicircumnavigation. The path is formed by connecting each pair of\n  successive points along the shortest possible surface route, and connecting\n  the last point to the first one in the same way. No two successive points\n  (including the pair of the last point and the first point) are collinear with\n  the origin. (That is, they are not antipodes &mdash; polar opposites &mdash;\n  and they do not represent the same point on the surface of the sphere.)\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line containing <b>N</b>,\n  the number of cities visited by K. The next <b>N</b> lines contain three\n  integers <b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b> and <b>Z<sub>i</sub></b>\n  each. The i-th point in the list is given by the coordinates\n  (<b>X<sub>i</sub></b> /\n  sqrt(<b>X<sub>i</sub></b><sup>2</sup> + <b>Y<sub>i</sub></b><sup>2</sup> +\n       <b>Z<sub>i</sub></b><sup>2</sup>),\n  <b>Y<sub>i</sub></b> /\n  sqrt(<b>X<sub>i</sub></b><sup>2</sup> + <b>Y<sub>i</sub></b><sup>2</sup> +\n       <b>Z<sub>i</sub></b><sup>2</sup>),\n  <b>Z<sub>i</sub></b> /\n  sqrt(<b>X<sub>i</sub></b><sup>2</sup> + <b>Y<sub>i</sub></b><sup>2</sup> +\n       <b>Z<sub>i</sub></b><sup>2</sup>)).\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the case number and <code>y</code> is either\n  <code>YES</code> or <code>NO</code> depending on whether the route is an\n  omnicircumnavigation or not.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 200.<br/>\n  -10<sup>6</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  -10<sup>6</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  -10<sup>6</sup> &le; <b>Z<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  At least one of the values in (<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>,\n  <b>Z<sub>i</sub></b>) &ne; 0, for all i.\n  For all i, j such that (i + 1 = j) or (i = <b>N</b> - 1 and j = 0),\n    neither of (<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>,\n    <b>Z<sub>i</sub></b>) and (<b>X<sub>j</sub></b>, <b>Y<sub>j</sub></b>,\n    <b>Z<sub>j</sub></b>) is an integer multiple of the other.\n    (No two successive points, including the last and first, are antipodes or\n     represent the same point on the sphere.)<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n  3 &le; <b>N</b> &le; 50.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 300 seconds.<br/>\n  3 &le; <b>N</b> &le; 5000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3\n1 0 0\n0 1 0\n0 0 1\n8\n5 5 5\n5 -5 5\n-5 -5 5\n-5 5 5\n-5 5 -5\n-5 -5 -5\n5 -5 -5\n5 5 -5\n3\n1 0 0\n-1 1 0\n-1 -1 0\n5\n1 0 0\n-1 1 0\n2 0 0\n-2 2 0\n-1 -1 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: NO\nCase #2: YES\nCase #3: YES\nCase #4: YES\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the three points are the surface points of one octant of\n  the sphere, and the path traces out that octant. There are many hemispheres\n  that do not overlap that path at all.\n</p><p>\n  In Sample Case #2, the eight points are the corners of a cube inscribed in\n  the sphere; any hemisphere will contain at least some parts of that path.\n  Note that dividing all values by 5 would produce an equivalent case (with the\n  same set of points).\n</p><p>\n  In Sample Case #3, the path is itself a great circle, and so every other\n  great circle must intersect it somewhere.\n</p><p>\n  Sample Case #4 uses the same three points as in Sample Case #3, except that\n  the first two points are visited twice each. Note that a case may include\n  multiple representations of the same point, and that a path may include the\n  same points or connections more than once.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Omnicircumnavigation","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201909","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2017"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
