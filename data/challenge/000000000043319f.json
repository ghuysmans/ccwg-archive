{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1343410800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043319f","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThe final round of Google Code Jam 2012 was hard-fought throughout, and suspenseful at its end.  In a round where contestants were faced with two medium-difficulty problems and three very tough ones, the careful choice of which problems to attack was vital.\n</p>\n\n<p>\nThe contest for the highest ranks would come down to the very end.  Six of the top eight contestants would make submissions in the last ten minutes of the four-hour contest, and three of them would earn points off of those submissions.  At the end of the round, the scoreboard was as clear as mud: most of the points would come from Large submissions, and over ten of those would prove to be wrong.\n</p>\n\n<p>\nThe dust settled on a close scoreboard, whose final ordering came down to the problems contestants chose to solve and to the time it took them.  In third place was Slovakia's <b>misof</b>, who solved C and earned partial points for D and E.  In second, with his final submission to D coming seven minutes before the end of the contest, was the USA's <b>neal.wu</b>.  The winner, with the same problems and a time nearly an hour and a half faster, was Poland's <b>meret</b>.  He claims the title of Code Jam Champion, as well as a cool $10,000.\n</p>\n\n<p>\nThat's it for Google Code Jam 2012!  With that exciting sendoff, we're really looking forward to seeing you all again in 2013.\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>\nProblem A. <i>Zombie Smash</i> Written by Andrei Missine.  Prepared by Greg Tener and Andrei Missine.\n</p>\n<p>\nProblem B. <i>Upstairs/Downstairs</i> Written by Bartholomew Furrow, with Petr Mitrichev and David Arthur.  Prepared by John Dethridge and Bartholomew Furrow.\n</p>\n<p>\nProblem C. <i>Xeno-archaeology</i> Written by David Arthur.  Prepared by Onufry Wojtaszczyk and Igor Naverniouk.\n</p>\n<p>\nProblem D. <i>Twirling Towards Freedom</i> Written by David Arthur.  Prepared by Luka Kalinovcic and Igor Naverniouk.\n</p>\n<p>\nProblem E. <i>Shifting Paths</i> Written and prepared by David Arthur.\n</p>\n\n<p>\nContest analysis presented by Bartholomew Furrow, Andrei Missine, Bartholomew Furrow, Onufry Wojtaszczyk, John Dethridge and David Arthur.\n</p>\n\n<p>\nSolutions and other problem preparation provided by Adam Polak, Anton Georgiev, Irvan Jahja, Khaled Hafez, Mark Gordon, Nikolay Kurtov, Steve Thomas and Raymond Ho.  Fun fact: David Arthur writes hard problems.\n</i>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1343396400000,"tasks":[{"analysis":"<p> To begin with, let's try to formalize the rules of forming the pattern of tiles. If the center is at some position <b>x</b>, <b>y</b>, then the red tiles are those in positions <b>x'</b>, <b>y'</b> for which the number max(|<b>x</b> - <b>x'</b>|, |<b>y</b> - <b>y'</b>|) is odd, while the blue tiles are those for which this number is even. This is because the formula max(|<b>x</b> - <b>x'</b>|, |<b>y</b> - <b>y'</b>|) = <b>C</b> for any <b>C</b> describes a square ring around <b>x</b>, <b>y</b>, and the rings alternate color with the parity of <b>C</b></p>\n\n<p> For the small problem, we can prove that if there exists a solution, there exists one with |<b>X</b>| + |<b>Y</b>| &lt; 202. Thus, we can check all candidates for the center, for each one check whether all the tiles have the right colors, and output the best candidate. This will not run in time for the large data, of course, as we will have over 10<sup>30</sup> candidate centers to check.</p>\n\n<br/>\n<p><b>Single tile analysis</b></p>\n\n<p> We may now assume we know the parity of <b>x</b> and <b>y</b>. We will simply check all four possibilities, finding the best possible choice of the center for each of the four assumptions, and then pick the one specified by the tie-breaking rules (or output \"Too damaged\" if none of the four assumptions led to finding a viable center for the pattern). This makes it easier to analyse the information gained by knowing the color of a single tile. Suppose the tile at some position <b>x'</b>, <b>y'</b> is, say, red. This means max(|<b>x</b> - <b>x'</b>|, |<b>y</b> - <b>y'</b>|) has to be odd. Now, we know the parities of <b>x</b>, <b>y</b>, <b>x'</b> and <b>y'</b>, and so:\n<ul>\n<li> if both <b>x</b> - <b>x'</b> and <b>y</b> - <b>y'</b> are odd, then any choice of a center (satisfying the parity requirements for <b>x</b> and <b>y</b>) is going to fit our knowledge; </li>\n<li> if both <b>x</b> - <b>x'</b> and <b>y</b> - <b>y'</b> are even, then there is no solution satifying the parity requirements; </li>\n<li> if, say, <b>x</b> - <b>x'</b> is odd, while <b>y</b> - <b>y'</b> is even, we have to have |<b>x</b> - <b>x'</b>| &ge; |<b>y</b> - <b>y'</b>|</li>\n</li>\n</ul>\nIf there is any tile of the second type, we can immediately return \"Too damaged\" for these parity assumptions. We can ignore of tiles of the first type, and now we are left only with tiles of the second type.</p>\n\n<p>Note that in the third case, since the parities of <b>x - x'</b> and <b>y - y'</b> differ, it doesn't matter whether we use a strict inequality, as the equality case is eliminated from consideration by the parity assumptions. Thus, when considering regions defined by these inequalities, we can ignore problems related to \"what happens on the edges of these regions\", as - by the reasoning above - the edges will necessarily be eliminated from consideration by the parity assumptions.\n</p>\n\n<p> The first and second cases are easy to analyse; the trick is to find out whether a solution exists (and if yes, find the best one) satisfying the set of conditions of the type |<b>x</b> - <b>x'</b>| &ge;/&le; |<b>y</b> - <b>y'</b>| for various <b>x'</b> and <b>y'</b>. Transforming the condition |<b>x</b> - <b>x'</b>| &ge; |<b>y</b> - <b>y'</b>| we see it is equivalent to saying that one of the following has to hold:\n<ul>\n<li><b>x + y</b> &ge; <b>x' + y'</b> and <b>x - y</b> &ge; <b>x' - y'</b>, or</li>\n<li><b>x + y</b> &le; <b>x' + y'</b> and <b>x - y</b> &le; <b>x' - y'</b>.</li>\n</ul>\n</p>\n\n<br/>\n<p><b>Dividing the plane</b></p>\n\n<p>\nThe lines <b>x + y</b> = <b>x<sub>i</sub> + y<sub>i</sub></b> and <b>x - y</b> = <b>x<sub>i</sub> - y<sub>i</sub></b> (which are the boundaries of the constraint-satisfaction region for the input tiles) divide the plane into at most (<b>N</b> + 1)<sup>2</sup> rectangles. The idea of our algorithm will be as follows:\n<ul>\n<li>Iterate over the four sets of parity assumptions about the center</li>\n<li>Iterate over all rectangles formed by the boundary lines, and for each of them check whether it satisfies the constraints posed by all input tiles</li>\n<li> for each rectangle satisfying the constraints, find the best (according to the tie-resolution conditions) center candidate within it (if any) </li>\n<li> output the best of all center candidates found. </li>\n</ul>\nA fun fact is that there will be at most <b>N</b>+1 rectangles that satisfy the constraints; so we need not worry overly about the performance of the \"find the optimal within the rectangle\" phase (as long as it is independent of the size of the rectangle). The naive approach to the second phase is O(<b>N</b><sup>3</sup>) (for each rectangle check all tiles), which with <b>N</b> up to a thousand and 50 testcases risks being too slow, so we'll need to speed it up a bit.</p>\n\n<p> There are many ways to trim down the runtime of the constraint-checking phase for rectangles. One sample way is to process the rectangles \"row-by-row\", as follows: Take the set of rectangles with <b>A</b> &le; <b>x+y</b> &le; <b>B</b>, with <b>A</b> and <b>B</b> being some two adjacent boundary values. For each input tile (out of those that set any constraints on the center position), we have two areas of constraint satisfaction; but only one of them is compatible with <b>A</b> &le; <b>x+y</b> &le; <b>B</b>, because one of the areas satisfies the constraint <b>x+y</b> &ge; <b>C</b>, while the other has <b>x+y</b> &le; <b>C</b>. This means that we know which area is the interesting one for this row; so we obtain a constraint on <b>x - y</b> that has to be satisfied by all the rectangles in this row. This will be either of the form <b>x - y</b> &le; <b>D</b>, or <b>x - y</b> &ge; <b>D</b>. We take the largest of the lower bounds, the largest of the upper bounds, and obtain a rectangle that we have to check. This algorithm runs in O(<b>N</b><sup>2</sup>) time, which will be easily fast enough.</p>\n\n<p> A more advanced algorithm (using the sweep line technique) can be used to obtain a runtime of O(<b>N</b> log<b>N</b>) runtime. We will not describe it (as it is not necessary to obtain a fast enough program with the constraints given), but we encourage the reader to figure it out.</p>\n\n<br/>\n<p><b>Finding the best point within a rectangle</b></p>\n\n<p>\nThis was the part of the problem that seemed to cause most difficulties for our contestants. There are two cases to consider here. Let's assume our rectangle is defined by <b>A</b> &le; <b>x+y</b> &le; <b>B</b> and <b>C</b> &le; <b>x-y</b> &le; <b>D</b>. \n</p>\n\n<p>\nLet us define <br/>\ng(k, l) = min(|k|, |l|) if k and l are of the same sign, 0 otherwise.<br/>\nIf g(<b>A</b>, <b>B</b>) = 0 and g(<b>C</b>, <b>D</b>) = 0, then the point (0, 0) is within our rectangle. In this case it suffices to check the near vicinity of the origin. Specifically:\n<ul>\n<li> If both <b>x</b> and <b>y</b> are supposed to be even, (0, 0) is obviously the optimal solution. </li>\n<li> If both <b>x</b> and <b>y</b> are supposed to be odd, then the best four points, in order, are (1, 1), (1, -1), (-1, 1) and (-1, -1). If <b>B</b> &ge; 2 we can take (1, 1) and we're done. Otherwise, if <b>D</b> &ge; 2, we take (1, -1); and so on. If all the four points are infeasible, the rectangle contains no points satisfying the parity constraints. </li>\n<li> If , say, <b>x</b> is supposed to be odd, while <b>y</b> is even, the first eight candidates are (1, 0), (-1, 0), (3, 0), (1, 2), (1, -2), (-1, 2), (-1, -2), (-3, 0). Again, one can check that if none of them is feasible, the rectangle contains no points satisfying the parity constraints. The same happens when <b>x</b> is even and <b>y</b> is odd.</li>\n</ul>\nThus, if (0, 0) is within the rectangle, we can check a constant number of points and take the best feasible one of them.\n</p>\n\n<p>\nWhen (0, 0) is not within the rectangle, we first look for the smallest Manhattan distance of any point within the rectangle. It is equal to <b>M</b> := max(g(<b>A</b>, <b>B</b>), g(<b>C</b>, <b>D</b>)). As all the boundaries have parities disagreeing with the parity assumptions, the smallest Manhattan distance we can hope for is <b>M</b> + 1.\nWe now have an interval of points with Manhattan distance <b>M</b> + 1 in our rectangle, the best one of them is the one with the highest <b>X</b> coordinate (out of the ones fulfilling the parity conditions). The one last special case to deal with here is when the interval contains only one point, and it has the wrong parities - in this case we need to look at distance <b>M</b> + 3 (the fact that one never needs to look at <b>M</b> + 5 is left as an exercise).\n</p>\n\n<p>\nIt was also possible to solve this problem in a number of other ways. A pretty standard one was to identify a number of \"suspicious points\" within a rectangle (the vicinity of (0, 0), the vicinity of the corners, and the vicinity of places where the coordinate axes intersect the edges of the rectangle) and check them all, taking the best solution.\n</p>","id":"0000000000432b8a","statement":"<h3>Problem</h3>\n<p>\nLong ago, an alien civilization built a giant monument. The floor of the monument looked like this:\n\n<pre>\n###############\n#.............#\n#.###########.#\n#.#.........#.#\n#.#.#######.#.#\n#.#.#.....#.#.#\n#.#.#.###.#.#.#\n#.#.#.#.#.#.#.#\n#.#.#.###.#.#.#\n#.#.#.....#.#.#\n#.#.#######.#.#\n#.#.........#.#\n#.###########.#\n#.............#\n###############\n</pre>\n\nEach '#' represents a red tile, and each '.' represents a blue tile. The pattern went on for miles and miles (you may, for the purposes of the problem, assume it was infinite). Today, only a few of the tiles remain. The rest have been damaged by methane rain and dust storms. Given the locations and colours of the remaining tiles, can you find the center of the pattern?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each one starts with a line containing <b>N</b>, the number of remaining tiles. The next <b>N</b> lines each contain <b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>, and the tile colour (either '#' or '.').\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <nobr>\"Case #c: <b>X</b> <b>Y</b>\"</nobr>, where c is the case number (starting from 1) and (<b>X</b>, <b>Y</b>) is the location of the center of the pattern. If there is more than one possible answer, output the <nobr>(<b>X</b>, <b>Y</b>)</nobr> closest to <nobr>(0, 0)</nobr> <i>in Manhattan distance</i> (the distance in x, plus the distance in y). If there are still ties, output the one with the largest <b>X</b>. If there are still ties after that, output the one with the largest <b>Y</b>. If there is no possible answer, output <nobr>\"Case #c: Too damaged\"</nobr>.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 30 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\nThe list of coordinates in each test case will not contain duplicates.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 100.<br/>\n-100 &le; <b>X<sub>i</sub></b> &le; 100.<br/>\n-100 &le; <b>Y<sub>i</sub></b> &le; 100.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.<br/>\n-10<sup>15</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>15</sup>.<br/>\n-10<sup>15</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>15</sup>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">6\n1\n0 0 .\n1\n0 0 #\n3\n0 0 #\n0 1 #\n1 0 #\n5\n50 30 #\n49 30 #\n49 31 #\n49 32 #\n50 32 #\n2\n-98 0 #\n99 50 .\n4\n88 88 .\n88 89 .\n89 88 .\n89 89 .\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 0\nCase #2: 1 0\nCase #3: 1 1\nCase #4: 50 31\nCase #5: 1 0\nCase #6: Too damaged\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":33}],"title":"Xeno-archaeology","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nFirstly, it is worth noting that the small dataset with only 8 zombies can be solved simply by evaluating each possible permutation for the order in which to smash zombies and keeping the best one. For each permutation, simply attempt to smash the zombies in the order given, skipping any zombies that cannot be reached on time. This simple approach has exponential time complexity and clearly will not scale for the large data set.\n</p>\n<p>\nFor the more efficient approach, let us start by considering the game state represented in an inefficient way and see how it can be made more efficient. We can represent the game state at any point in time with the following tuple:\n<ul>\n<li> (Time, Location, Set of zombies already smashed)\n</ul>\nThis certainly works - given this state, we essentially have the snapshot of the game at any point in time, but this is very verbose. Since we want to smash as many zombies as possible, we want to smash zombies as soon as possible, i.e. we want to arrive at the grave they pop out of as soon as possible. With that in mind, we can make the following assumption: we will arrive at the grave of the next zombie as soon as possible, and potentially stand around waiting until that zombie can be smashed. Once smashed, we will move to the next grave as quickly as we can and repeat the process. That way, it becomes unnecessary to keep track of any states where we are transiting between two graves because those states can be derived from the states at the origin and destination graves. We can change the state to be:\n<ul>\n<li> (Time last zombie was smashed, Last zombie smashed, Set of zombies already smashed)\n</ul>\nThis is an improvement, but now the problem is that we keep track of all possible sets of zombies already smashed. Let’s see what we can do about that.\n</p>\n<p>\nConsider the state (<b>T<sub>1</sub></b>, <b>Z<sub>1</sub></b>, {<b>Z<sub>1</sub></b> …}) where we have just smashed zombie <b>Z<sub>1</sub></b> at time <b>T<sub>1</sub></b>. The set of zombies already smashed contains <b>Z<sub>1</sub></b>, and possibly a bunch of other zombies. Suppose that <b>Z<sub>0</sub></b> is a zombie that we have smashed earlier. There are two cases: either <b>Z<sub>0</sub></b> appears at an interval overlapping with <b>Z<sub>1</sub></b>, or it has already appeared before <b>Z<sub>1</sub></b>. \n<ol>\n<li> If <b>Z<sub>0</sub></b> has already appeared before <b>Z<sub>1</sub></b> then by <b>T<sub>1</sub></b> it can no longer be at its grave (even if we haven’t smashed it) and explicitly tracking that it has already been smashed is unnecessary.\n<li> Otherwise, if <b>Z<sub>0</sub></b> appears in an interval overlapping with <b>Z<sub>1</sub></b>, is it possible that we will attempt to smash <b>Z<sub>0</sub></b> again, if we don’t keep track of it? Suppose that <b>Z<sub>0</sub></b> was smashed at <b>T<sub>0</sub></b>, since the Zombie Smasher needs to recharge twice, <b>Z<sub>0</sub></b> will be already gone because it stands around for 1000ms and it takes 1500ms for the Zombie Smasher to recharge twice. Again, it is not necessary to explicitly track the set of zombies smashed to avoid smashing the same zombie twice.\n</ol>\n</p>\n<p>\nIn light of the above observations we can simplify the state to be:\n<ul>\n<li>(Time last zombie was smashed, Last zombie smashed, Number of zombies already smashed)\n</ul>\nIt is easy to see that we prefer earlier times over later times for smashing a zombie - the sooner we smash a zombie, the sooner we can move on to the next one, so we are only interested in states with minimal time possible. Let us model the state transitions as a graph and minimize on time.\n</p>\n<p>\nThe game starts at time 0 and location (0, 0). Based on this information, we can generate the initial frontier of zombies that can be reached and smashed on time. Given this frontier, the times and the locations at which zombies will appear, we can apply a modified Dijkstra’s Algorithm to find the set of game states that are reachable. Once we know those, we can simply return the maximum number of zombies smashed in a reachable state. Here is the pseudo-code:\n\n<p>\n<pre>\nsolve():\n  all_states = Q = generateStates()\n  while Q is not empty:\n    s = Q.popMin()\n    if s.time = infinity:\n      break;\n\n    for each zombie z such that z &#x2260; s.zombie:\n      earliest_arrival_time = s.time + max(750,\n                                           dist(s.zombie, z))\n      if earliest_arrival_time &le; z.appearance + 1000:\n        earliest_smash_time = max(z.appearance,\n                                  earliest_arrival_time)\n        Q.update(earliest_smash_time, z, s.smashed + 1)\n\n  // Scan for states with time &lt; infinity, keeping the maximum\n  // number of zombies smashed to get the final answer.\n  return best_reachable_state(all_states)\n\n\ngenerateStates():\n  states = {}\n  states.Add(0, nil, 0) // Include the initial state.\n  for each zombie z:\n    for zombies_killed from 1 to Z:\n      // For other reachable states this will be revised later.\n      earliest_smash_time = infinity\n      if zombiles_killed = 1:\n        earliest_arrival_time = dist((0, 0), z)\n        if earliest_arrival_time &le; z.appearance + 1000:\n          earliest_smash_time = max(z.appearance,\n                                    earliest_arrival_time)\n      states.Add(earliest_smash_time, z, zombies_killed)\n  return states\n</pre>\n</p>\n\nCrude worst-case complexity analysis of the above: <code>generateStates()</code> will produce O(<b>Z</b><sup>2</sup>) states as each element of the pair (Last zombie smashed, Number of zombies already smashed) can vary from 0 to <b>Z</b> independently. Each state will be iterated over at most once by the outer while loop of <code>solve()</code>, and the inner for loop of <code>solve()</code> will run over all zombies, costing another O(<b>Z</b>), assuming an efficient heap is used, giving O(<b>Z</b><sup>3</sup>), which is fast enough for the large dataset where <b>Z</b> = 100. Lastly, a few contestants solved this problem with dynamic programming, keeping a 2D table with zombie index in one dimension and time since that zombie has popped up in the other dimension, maximizing on the total number of zombies smashed.","id":"0000000000432e00","statement":"<h3>Problem</h3>\n<p>\nYou are playing Zombie Smash: a game where the objective is to smash zombies with your trusty Zombie Smasher as they pop out of graves at the graveyard. The graveyard is represented by a flat 2D grid. Each zombie will pop out of a grave at some (X, Y) cell on the grid, stand in place for 1000 milliseconds (ms), and then disappear back into the grave. At most one zombie can stand around a grave at a time.\n</p>\n<p>\nYou can move to any one of the 8 cells adjacent to your location in 100ms; i.e., you can move North, East, South, West, NW, NE, SW, and SE of your current location. You may move through or stand on a cell even if it is currently occupied by a zombie. You can smash a zombie instantly once you reach the cell that the zombie is standing on, but once you smash a zombie it takes 750ms for your Zombie Smasher to recharge before you can smash another zombie. You may move around while Zombie Smasher is recharging. For example, immediately after smashing a zombie at (0, 0):\n<ul>\n<li> It will take 750ms to reach and smash a zombie at (1, 1) <b>or</b>\n<li> 2000ms to reach and smash a zombie at (20, 20).\n</ul>\n</p>\n<p>\nYou start at cell (0, 0) at the beginning of the game (time=0). After you play a level you would like to know how many zombies you could have smashed, if you had played optimally.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line will contain a single integer <b>T</b>, the number of test cases.  It is followed by <b>T</b> test cases, each starting with a line containing a single integer <b>Z</b>, the number of zombies in the level.\n</p>\n<p>\nThe next <b>Z</b> lines contain 3 space-separated integers each, representing the location and time at which a given zombie will appear and disappear.  The <code>i</code><sup>th</sup> line will contain the integers <b>X</b><sub>i</sub>, <b>Y</b><sub>i</sub> and <b>M</b><sub>i</sub>, where:\n<ul>\n<li> <b>X</b><sub>i</sub> is the X coordinate of the cell at which zombie <code>i</code> appears, </li>\n<li> <b>Y</b><sub>i</sub> is the Y coordinate of the cell at which zombie <code>i</code> appears, </li>\n<li> <b>M</b><sub>i</sub> is the time at which zombie <code>i</code> appears, in milliseconds after the beginning of the game.  The time interval during which the zombie can smashed is inclusive: if you reach the cell at any time in the range [<b>M</b><sub>i</sub>, <b>M</b><sub>i</sub> + 1000] with a charged Zombie Smasher, you can smash the zombie in that cell. </li>\n</ul>\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #c: d\", where c is the case number (starting from 1), and d is the maximum number of zombies you could have smashed in this level.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 30 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n-1000 &le; <b>X</b><sub>i</sub>, <b>Y</b><sub>i</sub> &le; 1000.<br/>\n0 &le; <b>M</b><sub>i</sub> &le; 100000000 = 10<sup>8</sup>.<br/>\nTwo zombies will never be in the same location at the same time.  In other words, if one zombie appears at (x, y) at time t, then any other zombie that appears at (x, y) must appear at or before (t - 1001), or at or after (t + 1001).<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>Z</b> &le; 8.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>Z</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n1 0 0\n-1 0 0\n10 10 1000\n10 -10 1000\n3\n1 1 0\n2 2 0\n3 3 0\n5\n10 10 1000\n-10 10 1000\n10 -10 1000\n-10 -10 1000\n20 20 2000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 2\nCase #3: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Zombie Smash","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nUpstairs/Downstairs was a last-minute addition to the Finals, replacing a year-old problem proposal that had appeared on a separate contest two months before.  This problem loosely mirrors an experience the author had once while on vacation.  He was downstairs.\n</p>\n\n<p>\nSolving this problem involves two observations and an algorithm.  Before making our observations, let's start by writing out the formula for the quantity we want to minimize.  <code>p<sub>i</sub></code> will represent the probability that the <code>i<sup>th</sup></code> activity Konstantin performs will result in Ilia being awake:<br/>\n<code>\nP(woken up) =<br/>\n  (1-p<sub>0</sub>) * (1 - (1-p<sub>1</sub>)(1-p<sub>2</sub>)*...* (1 - p<sub>K</sub>)) +<br/>\n  p<sub>0</sub>(1-p<sub>1</sub>) * (1 - (1-p<sub>2</sub>)(1-p<sub>3</sub>)*...*(1 - p<sub>K</sub>)) +<br/>\n  p<sub>0</sub>p<sub>1</sub>(1-p<sub>2</sub>) * (1 - (1-p<sub>3</sub>)(1-p<sub>4</sub>)*...*(1 - p<sub>K</sub>)) +<br/>\n  ...\n</code>\n</p>\n<h3>Observation 1: Noisy First</h3>\n<p>\nFor our first observation, we'll look for a reason to prefer that Konstantin perform noisier or quieter activities earlier.  Intuitively, we suspect that noisier activities should come first: a strategy that keeps Ilia awake and then tries to keep him asleep seems pretty reasonable.\n</p>\n<p>\nLooking at the structure of the formula above, we can look for differences between how <code>p<sub>i</sub></code> and <code>p<sub>i+1</sub></code> are used.  Here are the terms in which swapping them would lead to a difference in the final result:<br/>\n<code>\np<sub>0</sub>p<sub>1</sub>...p<sub>i-1</sub>(1-p<sub>i</sub>) * (1 - (1-p<sub>i+1</sub>)(1-p<sub>i+2</sub>)*...*(1 - p<sub>K</sub>)) +<br/>\np<sub>0</sub>p<sub>1</sub>...p<sub>i-1</sub>p<sub>i</sub>(1-p<sub>i+1</sub>) * (1 - (1-p<sub>i+2</sub>)*...*(1 - p<sub>K</sub>))<br/>\n</code>\nSimplifying these two terms, we have:<br/>\n<code>\np<sub>0</sub>p<sub>1</sub>...p<sub>i-1</sub> * [<br/>\n&nbsp;&nbsp;(1-p<sub>i</sub>) + p<sub>i</sub>(1-p<sub>i+1</sub>) -<br/>\n&nbsp;&nbsp;(1-p<sub>i</sub>)(1-p<sub>i+1</sub>)...(1-p<sub>K</sub>) -<br/>\n&nbsp;&nbsp;p<sub>i</sub>(1-p<sub>i+1</sub>)...(1-p<sub>K</sub>)]<br/>\n= p<sub>0</sub>p<sub>1</sub>...p<sub>i-1</sub> * [1 - p<sub>i</sub>p<sub>i+1</sub> - (1 - p<sub>i+1</sub>)(1 - p<sub>i+2</sub>)...(1 - p<sub>K</sub>)]<br/>\n</code>\nThis quantity is minimized by choosing <code>p<sub>i+1</sub> &lt; p<sub>i</sub></code>, which confirms the intuition that noisier activities should happen earlier.  Repeatedly swapping adjacent activities like this shows that in an optimal solution, activities should be performed from noisiest to quietest.\n</p>\n\n<h3>Observation 2: Go Extreme!</h3>\n<p>\nOur original formula for <code>P(woken up)</code> is clearly linear in <code>p<sub>i</sub></code> for all <code>i</code>.  This quantity therefore must be minimized by taking either the largest possible value or the smallest possible value for <code>p<sub>i</sub></code>.\n</p>\n<p>\nPutting this observation together with the previous one, we can conclude that Konstantin should start by performing the <code>K-q</code> noisiest activities in order from noisiest to quietest, and then should perform the <code>q</code> quietest activities, also in order from noisiest to quietest.  We'll call the first set of activities the <i>prefix</i>, and the others the <i>suffix</i>.  Note that here we're considering an activity that can be repeated <code>c</code> times as <code>c</code> different activities.\n</p>\n\n<h3>Possible Algorithms</h3>\n<p>\nFor the Small, it's sufficient to try all values of <code>q</code>.  There are <code>O(K)</code> possible values, and evaluating each one naively takes <code>O(sum(c<sub>i</sub>))</code> time, so the running time is <code>O(sum(c<sub>i</sub>)<sup>2</sup>)</code>.\n</p>\n<p>\nThere are only two numbers we really need to keep track of for each possible suffix: the probability that Ilia will end up being woken up if he starts the suffix awake, and the probability that he will end up being woken up if he starts the suffix asleep.  After precomputing those 2 values for each of the K possible suffixes, which we can do in <code>O(K)</code> time, we can simulate each possible prefix, also in <code>O(K)</code> time, and do a quick lookup for the corresponding suffix for each one.  A little math produces the correct answer, in <code>O(sum(c<sub>i</sub>))</code> time.\n</p>\n<p>\nAnother algorithm that boils down to the same thing involves treating Ilia's three states&mdash;awake, asleep, and woken up&mdash;as a 3x1 vector that can be operated on by matrices.  For any activity, we can build a 3x3 <a href=\"http://en.wikipedia.org/wiki/Transition_matrix\" target=\"_blank\">transition matrix</a>, looking like this:<br/>\n<pre>[[p    0    0]\n [1-p  1-p  0]\n [<b>0</b>    <b>p</b>    1]]</pre>\nIlia's initial state is:<br/>\n<pre>[1\n 0\n 0]</pre>\nTo build the transition matrix for a series of activities, we can multiply the activities' matrices together, with the noisiest activity on the right.  In this way, we can compute a 3x3 matrix corresponding to each prefix of length up to K, and one for each suffix of length up to K, in <code>O(K)</code> time.  Then it's an <code>O(1)</code> operation to check the result for any given prefix/suffix pair: multiplying those two matrices by each other, then by Ilia's initial state.  The algorithm ends up taking <code>O(sum(c<sub>i</sub>))</code> time.\n</p>\n<p>\nNote that the bolded entries of the transition matrix, above, correspond to the two numbers we cared about for each suffix in the previous algorithm.\n</p>\n\n<h4>Ternary Search Passed Test Cases, But...</h4>\n\n<p>\nBecause this problem was prepared at the last minute, it didn't occur to us until during the contest to wonder whether ternary search would work for selecting <code>q</code>, the length of the suffix.  We would have been happy with the answer either way, but we would have wanted test data that would break ternary search if the answer turned out to be \"no\".\n</p>\n\n<p>It turned out that the answer <i>was</i> \"no\", and that none of our existing cases broke any ternary search that we found.  Because of this, some contestants&mdash;most notably <b>misof</b>, who came third partly on the strength of the points he got from this problem&mdash;managed to submit ternary search solutions that passed our test data.\n</p>\n\n<p>\nSometimes it happens in Code Jam that contestants will come up with algorithms that don't work in general given the limits we've provided, but do work on our test data.  We try to avoid situations of that sort, but they do happen.  We think the consequences here weren't significant, for a few reasons: Implementing the ternary search is about as hard as implementing a correct solution, if not a little harder; the \"hard part\" of the problem was already done by that point; and if we'd come up with a breaking case, we'd have put it in the Small data as well as the Large.  Contestants who implemented ternary search would have seen it was wrong in the Small, and taken the time to fix it.  <b>misof</b> had plenty of time separating him from the fourth-place contestant, so the top three likely would not have changed.\n</p>\n\n<h4>Why Ternary Search Fails</h4>\n\n<p>\nTernary search seems like it should work.  Indeed, the function that we're minimizing, P(woken up), is strictly <i>non-increasing</i> and then strictly <i>non-decreasing</i> in <code>q</code>.  Unfortunately, that isn't quite enough: it needs to be strictly <i>decreasing</i> and then strictly <i>increasing</i>; otherwise a large constant patch will leave the ternary search unable to tell which direction it should go in.  \n</p>\n<p>\nHere's an example case that breaks ternary search in principle, and breaks a few contestants' submissions in practice:<br/>\n<code>\n2<br/>\n2 200<br/>\n1/2 40<br/>\n1/100 400<br/>\n2 200<br/>\n1/2 40<br/>\n99/100 400\n</code>\n</p>\n<p>\nThe correct answer is:<br/>\n<code>\nCase #1: 0.863976521<br/>\nCase #2: 0.863976521\n</code>\n</p>\n<p>\nIn the first case, the \"1/2\" activities are best not performed; but because they are at the very start of the list of activities, outnumbered severely by the \"1/100\" activities, a standard ternary search will find no difference between the two suffix lengths it tries.  It will merely consider a different number of \"1/100\" activities to be part of the suffix as opposed to the prefix, and leave all the \"1/2\" activities in place.  The second case is identical, but with \"99/100\" activities instead of \"1/100\" activities, which should defeat a ternary search that happens to choose the right direction in the first case.\n</p>\n\n<h4>Paweł i Gaweł</h4>\n\n<p>\nAt dinner after the finals, several Polish contestants were shocked to discover that the problem was not based on a poem called <a href=\"http://pl.wikisource.org/wiki/Pawe%C5%82_i_Gawe%C5%82\" target=\"_blank\">Paweł i Gaweł</a>.  The similarity was entirely coincidental, as the contestants should have known: Gaweł, who (according to Google Translate's translation of that page) \"invented the wildest frolics\", lived <i>downstairs</i>.  Still, in retrospect, we wish we'd named the problem after that poem, and perhaps had Gaweł minimize the probability that Paweł would go fishing.\n</p>","id":"0000000000432fea","statement":"<h3>Problem</h3>\n<p>\nKonstantin and Ilia live in the same house.  Konstantin lives upstairs, and enjoys activities that involve jumping, moving furniture around, and - in general - making noise.  Ilia lives downstairs, and enjoys sleep.\n</p>\n\n<p>\nIn order to have a good evening, Konstantin wants to do at least <b>K</b> activities. Last night, Ilia asked Konstantin to try not to wake him up; and because Konstantin is a very nice neighbor, he agreed.  Unfortunately, he took Ilia's request a bit too literally, and he will choose his activities in such a way as to minimize the probability that Ilia is woken up <i>after falling asleep</i>.\n</p>\n\n<p>\nEach possible activity for Konstantin has an associated probability <b>a<sub>i</sub>/b<sub>i</sub></b>. If Konstantin performs this activity, then at the end of it, Ilia will be awake with probability <b>a<sub>i</sub>/b<sub>i</sub></b>, and asleep otherwise, regardless of whether he was asleep at the start. Moreover, for each possible activity Konstantin can perform it at most <b>c<sub>i</sub></b> times (more than that would be boring, and Konstantin won't have a good evening if he's bored).\n</p>\n\n<p>\nKonstantin wants to choose a number of activities to do, in order, so that:\n<ul>\n<li> The total number of activities done is at least <b>K</b>.\n<li> The <b>i</b>th activity is performed no more than <b>c<sub>i</sub></b> times.\n<li> The probability <b>Q</b> that Ilia is woken up one or more times during the course of the activities is as small as possible.\n</ul>\nIlia starts awake, so in order for him to be woken up, he must be asleep at the end of some activity, and then awake at the end of the next activity.\n</p>\n\n<p>What is the smallest <b>Q</b> Konstantin can achieve while having a good evening?  Note that Konstantin cannot tell whether Ilia is awake or asleep, and so he cannot adapt his activities using that information.</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case starts with a pair of integers, <b>N</b>, <b>K</b>, on a line by themselves.  <b>N</b> lines follow, each of which represents an activity that Konstantin can choose.  Each of those lines is formatted as \"a<sub>i</sub>/b<sub>i</sub> c<sub>i</sub>\", indicating that there is an activity which would leave Ilia awake with probability <b>a<sub>i</sub>/b<sub>i</sub></b> and which Konstantin can perform at most <b>c<sub>i</sub></b> times without being bored.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: Q\", where x is the case number (starting from 1) and <b>Q</b> is the smallest probability of Ilia waking up during the course of the activities that Konstantin performs. Answers with absolute or relative error no larger than 10<sup>-6</sup> will be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &le; <b>a<sub>i</sub></b> &le; <b>b<sub>i</sub></b> &le; 1000000 for all i.<br/>\n1 &le; <b>b<sub>i</sub></b> and 1 &le; <b>c<sub>i</sub></b> for all i.<br/>\n1 &le; <b>K</b> &le; the sum of all <b>c<sub>i</sub></b> in that test case.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\nThe sum of all <b>c<sub>i</sub></b> is no larger than 100 in each test case.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 10000.<br/>\nThe sum of all <b>c<sub>i</sub></b> is no larger than 10<sup>6</sup> in each test case.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 1\n1/2 3\n1/5 2\n2/5 1\n2/2 2\n3 2\n1/2 2\n1/3 2\n3/4 2\n3 3\n99/100 1\n1/2 2\n1/50 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.000000000\nCase #2: 0.083333333\nCase #3: 0.015000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Upstairs/Downstairs","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>For the small dataset, we can directly simulate the process of walking through the forest.  How many steps can this take?  There are 2<sup>10</sup> states the trees in the clearings can be in, and 10 possible states for the clearing we are standing in.  So if we reach the final clearing, it can't take more than 10 &times; 2<sup>10</sup> steps, and if we take that many steps without reaching the final clearing we know the answer is Infinity.\n\n<p>For the large dataset, 40 &times; 2<sup>40</sup> steps is too many to simulate directly, but can an input case approach this many?\n\n<p>A test case can be designed to make the clearings simulate an <b>N</b>-1 bit counter.  The first clearing has both paths leading to the second clearing.  Each clearing after that forms a chain where one path leads to the next clearing, and one path leads back to the first clearing.  Whenever the trail leads back to the first clearing, the states of the clearings give the next <b>N</b>-1 bit number, and after all of those numbers have been produced, it can reach the final clearing.  This will take at least 2<sup>39</sup> steps.\n\n<p>So we need a solution that will not simulate every step individually.  In the previous example, we spend 2<sup>21</sup>-2 steps in the first 20 clearings between each time we visit any of the last 20 clearings.  If our program could detect that this always happens, it could simulate those 2<sup>21</sup>-2 steps without having to do them all individually.  We will only take 2<sup>20</sup>-3 steps from any of the second twenty clearings, so the total runtime would be reasonable.\n\n<p>An implementation of this approach is to split the clearings into two sets A and B of roughly equal size.  We then use dynamic programming to compute, for each location in A and each of the 2<sup>|A|</sup> states of the clearings in A, how many steps it will take to leave A, which clearing in B we will be leaving towards, and what state the clearings in A will be left in.\n\n<p>After this DP is done, our solution will take an amount of time proportional to the number of steps we take from clearings in B -- for each of those, we simulate that step, and if that takes us to a clearing in A, we look up the appropriate result of the DP from a table.  So to make this solution efficient, we need to choose A and B so that only a small number of steps are taken from clearings in B.\n\n<p>Find the distance from each clearing to the final clearing, where distance is defined as the number of paths you need to take, assuming the state of the clearings is optimal.  If the final clearing cannot be reached from some clearings, put those in a separate set.  If we ever reach one of those, the answer is Infinity.\n\n<p>Choose B to be the closest half of the remaining clearings.  There can be at most B &times; 2<sup>|B|</sup> steps taken from clearings in B, because we cannot repeat a state of B without reaching the final clearing.  This can be only at most 20 &times; 2<sup>20</sup>, so this solution is sufficiently fast.\n","id":"0000000000433106","statement":"<h3>Problem</h3>\n<p>\nYou have been walking in the woods for hours, and you want to go home.\n</p>\n\n<p>\nThe woods contain <b>N</b> clearings labeled 1, 2, ..., <b>N</b>.  You are now at clearing 1, and you must reach clearing <b>N</b> in order to leave the woods.  Each clearing from 1 to <b>N</b>-1 has a left path and a right path leading out to other clearings, as well as some number of one-way paths leading in. Unfortunately, the woods are haunted, and any time you enter a clearing, one of the two outgoing paths will be blocked by shifty trees. More precisely, on your k<sup>th</sup> visit to any single clearing:\n<ul>\n<li> You must leave along the left path if k is odd.\n<li> You must leave along the right path if k is even.\n<li> All paths are one-way, so you have no choice at each step: you must go forward through the one unblocked outgoing path.\n</ul>\nSo the first time you are in clearing #1, you will leave along the left path.  If you ever come back to clearing #1 for a second time, you would leave along the right path; the third time, you'd leave along the left path again; and so on.\n</p>\n\n<p>\nYou begin at clearing #1, and when you get to clearing #<b>N</b>, you can leave the woods. How many paths do you need to follow before you get out?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, each beginning with a line containing a single integer <b>N</b>.\n</p>\n\n<p>\n<b>N</b>-1 lines follow, each containing two integers <b>L<sub>i</sub></b> and <b>R<sub>i</sub></b>. Here, <b>L<sub>i</sub></b> represents the clearing you would end up at if you follow the left path out of clearing i, and <b>R<sub>i</sub></b> represents the clearing you would end up at if you follow the right path out of clearing i.\n</p>\n\n<p>\nNo paths are specified for clearing <b>N</b> because once you get there, you are finished.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of paths you need to follow to get to clearing <b>N</b>. If you will never get to clearing <b>N</b>, output \"Infinity\" instead.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 30 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 30.<br/>\n1 &le; <b>L<sub>i</sub></b>, <b>R<sub>i</sub></b> &le; <b>N</b> for all i.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n2 &le; <b>N</b> &le; 10.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n2 &le; <b>N</b> &le; 40.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n4\n2 1\n3 1\n2 4\n3\n2 2\n1 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 8\nCase #2: Infinity\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Sample Explanation</h3>\n\n<p>In the first sample case, your route through the woods will be as shown below:</p>\n\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>Paths followed</td>\n<td>Clearing</td>\n<td>Path direction</td>\n<tr><td><br/>\n<tr><td>0</td> <td>1</td> <td>Left</td>\n<tr><td>1</td> <td>2</td> <td>Left</td>\n<tr><td>2</td> <td>3</td> <td>Left</td>\n<tr><td>3</td> <td>2</td> <td>Right</td>\n<tr><td>4</td> <td>1</td> <td>Right</td>\n<tr><td>5</td> <td>1</td> <td>Left</td>\n<tr><td>6</td> <td>2</td> <td>Left</td>\n<tr><td>7</td> <td>3</td> <td>Right</td>\n<tr><td>8</td> <td>4</td> <td>-</td>\n</table>\n</div>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":46}],"title":"Shifting Paths","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p><b>The Small Input</b></p>\n\n<p>On most Google Code Jam problems, the small input can be solved without worrying about the running time. That was not the case here though. Even if N = 10 and M = 10, there are still 10<sup>10</sup> different rotation patterns you could try. That is a lot!</p>\n\n<p>There are various ways you could try to bring the running time down to a more manageable amount, but here is one fact that makes it easy:\n<ul>\n<li>The 1st star you rotate around, the 5th star you rotate around, and the 9th star you rotate around should all be the same.\n<li>The 2nd star you rotate around, the 6th star you rotate around, and the 10th star you rotate around should all be the same.\n<li>The 3rd star you rotate around and the 7th star you rotate around should be the same.\n<li>The 4th star you rotate around and the 8th star you rotate around should be the same.\n</ul>\nIf you realize this, there are only 10<sup>4</sup> possibilities to try. But why is this fact true? Read on and you'll find out!</p>\n\n<br/>\n<p><b>Understanding Rotations</b></p>\n\n<p>\nOne of the biggest challenges here is just wrapping your head around the problem. How can you intuitively understand what it means to rotate something 100,000 times? The best way to do this is to roll up your sleeves and write down a couple formulas.\n</p>\n\n<p>\nWhen dealing with rotations and translations of points on a plane, <i>complex numbers</i> provide an excellent notation:\n<ul>\n<li> A point (x, y) can be represented as x + iy.\n<li> Complex numbers can be added and subtracted just like vectors.\n<li> Complex numbers can be rotated clockwise 90 degrees about the origin simply by multiplying them by -i.\n</ul>\nIt is this last property that makes them so clean to work with, and it is what we will use for the analysis. If you prefer, you could also imagine replacing everything with matrices.\n</p>\n\n<p>\nWe know that rotating a point P<sub>0</sub> by 90 degrees about the origin will send it to -i * P<sub>0</sub>. However, what happens if we rotate it about a different point Q<sub>0</sub>? There is a standard formula for this situation that you may have already seen. The resulting point P<sub>1</sub> satisfies the following:<p>\n\n<blockquote>P<sub>1</sub> - Q<sub>0</sub> = -i * (P<sub>0</sub> - Q<sub>0</sub>)</blockquote>\n\n<p>This is our previous formula applied to the fact that rotating P<sub>0</sub> - Q<sub>0</sub> by 90 degrees about the origin must give you P<sub>1</sub> - Q<sub>0</sub>. (Do you see why that is true? It's really just a coordinate change.) In our case, it will be helpful to group things a little differently in the formula:\n\n<blockquote>P<sub>1</sub> = -iP<sub>0</sub> + Q<sub>0</sub> * (1 - i)</blockquote>\n\n<p>Now, suppose we rotate P<sub>1</sub> by 90 degrees about another point Q<sub>1</sub>, then by 90 degrees about another point Q<sub>2</sub>, and so on. What would happen to this formula? Let's write out a few examples:\n\n<ul>\n<li> P<sub>2</sub> = -iP<sub>1</sub> + Q<sub>1</sub> * (1 - i) = -P<sub>0</sub> + Q<sub>1</sub> * (1 - i) + Q<sub>0</sub> * (-1 - i).\n<li> P<sub>3</sub> = -iP<sub>2</sub> + Q<sub>2</sub> * (1 - i) = iP<sub>0</sub> + Q<sub>2</sub> * (1 - i) + Q<sub>1</sub> * (-1 - i) + Q<sub>0</sub> * (-1 + i).\n<li> P<sub>4</sub> = -iP<sub>3</sub> + Q<sub>3</sub> * (1 - i) = P<sub>0</sub> + Q<sub>3</sub> * (1 - i) + Q<sub>2</sub> * (-1 - i) + Q<sub>1</sub> * (-1 + i) + Q<sub>0</sub> * (1 + i).\n<li> P<sub>5</sub> = -iP<sub>4</sub> + Q<sub>4</sub> * (1 - i) = -iP<sub>0</sub> + (Q<sub>4</sub> + Q<sub>0</sub>) * (1 - i) + Q<sub>3</sub> * (-1 - i) + Q<sub>2</sub> * (-1 + i) + Q<sub>1</sub> * (1 + i).\n<li> etc.\n</ul>\n\n<p>From here, it's not too hard to guess the general formula. If the origin is rotated by 90 degrees about Q<sub>0</sub>, then Q<sub>1</sub>, and so on, all the way through Q<sub>m-1</sub>, then the final resulting point P<sub>m</sub> is given by:</p>\n\n<blockquote>(1 - i) * (Q<sub>m-1</sub> + Q<sub>m-5</sub> + Q<sub>m-9</sub> + ...) + (-1 - i) * (Q<sub>m-2</sub> + Q<sub>m-6</sub> + Q<sub>m-10</sub> + ...) + (-1 + i) * (Q<sub>m-3</sub> + Q<sub>m-7</sub> + Q<sub>m-11</sub> + ...) + (1 + i) * (Q<sub>m-4</sub> + Q<sub>m-8</sub> + Q<sub>m-12</sub> + ...)</blockquote>\n\n<p>And once the formula is written down, it's not too hard to check that it always works. So anyway, is this simpler than the original problem formulation? It may look pretty complicated, but for the most part, you're now just adding points together here, and addition is easier than rotation!</p>\n\n<br/>\n<p><b>Pick a Direction</b></p>\n\n<p>\nWe want to choose stars Q<sub>0</sub>, Q<sub>1</sub>, ..., Q<sub>m-1</sub> in such a way as to make the following point as far away from the origin as possible:</p>\n\n<blockquote>(1 - i) * (Q<sub>m-1</sub> + Q<sub>m-5</sub> + Q<sub>m-9</sub> + ...) + (-1 - i) * (Q<sub>m-2</sub> + Q<sub>m-6</sub> + Q<sub>m-10</sub> + ...) + (-1 + i) * (Q<sub>m-3</sub> + Q<sub>m-7</sub> + Q<sub>m-11</sub> + ...) + (1 + i) * (Q<sub>m-4</sub> + Q<sub>m-8</sub> + Q<sub>m-12</sub> + ...)</blockquote>\n\n<p>There are different ways of thinking about things from here, but the key is always  <a href=\"https://www.google.com/search?q=convex+hull\" target=\"_blank\">convex hulls</a>.</p>\n\n<p>Let X be the point furthest from the origin that we can attain, and more generally, let X<sub>v</sub> be the point that is furthest in the direction of v that we can attain. Certainly, X = X<sub>v</sub> for some v. (This is because X is surely the point that is furthest in the direction of X.) Therefore, it suffices to calculate X<sub>v</sub> for all v, and we can then measure which of these is furthest from the origin to get our final answer.</p>\n\n<p>So how do we calculate X<sub>v</sub> for some given v? We want (1 - i) * Q<sub>m-1</sub> to be as far as possible in the v direction, or equivalently, we want Q<sub>m-1</sub> to be the star that is furthest in the (1 + i)*v direction. Of course, the same thing is true for Q<sub>m-5</sub>, Q<sub>m-9</sub>, etc. We should choose the same star for all of them. (This is the fact that we used for the small input solution!) Similarly, for Q<sub>m-2</sub>, Q<sub>m-6</sub>, etc., we want to choose the star is furthest in the (-1 + i)*v direction. In general, we want to choose stars from the original set that are as far as possible in the following directions: (1 + i)*v, (-1 + i)*v, (-1 - i)*v, (1 - i)*v.</p>\n\n<p>We are now almost done (at least conceptually). First we find the convex hull of the stars and solve for one particular v. Now what happens when we rotate v? For a while, nothing will change, but eventually, one of the four directions we are trying to optimize will be perpendicular to an edge of the convex hull, and as a result, the optimal star will switch to the next point on the convex hull. This simulation can be done in constant time at each step, and there will be only O(N) steps since each star choice will rotate once around the convex hull.</p>\n\n<p>At this point, we are done! We have found every X<sub>v</sub>, and we can manually check each of them to see which one is best. The implementation here is tricky, but it is an example of a general technique called <a href=\"https://www.google.com/search?q=rotating+calipers\" target=\"_blank\">rotating calipers</a>. You can find plenty more examples of it online. Or you can always download solutions from our finalists!</p>\n\n<br/>\n<p><b>Bonus Question!</b></p>\n\n<p>When we generated test data for this problem, we were surprised to find that we could not come up with a case to break solutions which misread \"clockwise\" as \"counter-clockwise\" in the problem statement. In fact, there is no such case! Can you see why?\n</p>","id":"0000000000433339","statement":"<h3>Problem</h3>\n<blockquote>\n<p>\n\"I say we must move forward, not backward;<br/>\nupward, not forward;<br/>\nand always twirling, twirling, twirling towards freedom!\"<br/>\n&mdash; <i>Former U.S. Presidential nominee Kodos.</i>\n</p>\n</blockquote>\n\n<p>\nAfter hearing this inspirational quote from America's first presidential nominee from the planet Rigel VII, you have decided that you too would like to twirl (rotate) towards freedom. For the purposes of this problem, you can think of \"freedom\" as being as far away from your starting location as possible.\n</p>\n\n<p>\nThe galaxy is a two-dimensional plane. Your space ship starts at the origin, position <nobr>(0, 0)</nobr>. There are <b>N</b> stars in the galaxy. Every minute, you can choose a star and rotate your space ship 90 degrees clockwise around the star. You may also choose to stay where you are.\n</p>\n\n<p>\nHow far away can you move from the origin after <b>M</b> minutes?\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0D5wEurbWTDOuqqmIx1Pm7zweg0Ov84YFXpBxN799MUnT91W10wuJtTSS8cBeocCRGHDE-4q8/rotation.png\">\n\n<p>\nThe image illustrates the first 3 rotations for a possible path in sample case 1. Note that this path is not necessarily a part of any optimal solution.\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, beginning with two lines containing integers <b>N</b> and <b>M</b>. The next <b>N</b> lines each contain two integers, <b>X</b><sub>i</sub> and <b>Y</b><sub>i</sub>, representing the locations of stars.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: <b>D</b>\", where x is the case number (starting from 1) and <b>D</b> is the distance from the origin to the optimal final position. Answers with absolute or relative error no larger than 10<sup>-6</sup> will be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100;<br>\n-1000 &le; <b>X<sub>i</sub></b> &le; 1000;<br/>\n-1000 &le; <b>Y<sub>i</sub></b> &le; 1000.<br/>\nNo two stars will be at the same location.<br/>\nThere may be a star at the origin.\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\n1 &le; <b>M</b> &le; 10.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 5000.<br/>\n1 &le; <b>M</b> &le; 10<sup>8</sup>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n1\n-2 4\n1 -2\n4 1\n0 2\n1\n4\n-5 0\n2\n5\n-1 1\n-2 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 6.3245553203\nCase #2: 10.0000000000\nCase #3: 6.3245553203\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":39}],"title":"Twirling Towards Freedom","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043319f","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2012"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
