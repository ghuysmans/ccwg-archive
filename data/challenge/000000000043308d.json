{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1336303800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043308d","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1C was the last chance to get to round 2, with the top 1000 advancing.\n</p>\n<p>\nProblem A was an easy graph theory problem, and it was first finished in under 8 minutes!  Any algorithm for counting paths between nodes sufficed to solve the problem.\n</p>\n<p>\nProblem C was a dynamic programming problem, similar to the standard Longest Common Subsequence problem.  The input strings each consisted of a small number of runs of equal letters, but each run could be very large.  Since the strings can be so large, standard algorithms for solving the LCS problem had to be modified to take advantage of the special form of the input, making this problem much more challenging.\n</p>\n<p>\nProblem B was a subtle physics problem that turned out to be the hardest in the set.  It appears to require dynamic programming with a state that includes the position, velocity, and time of the car.  But some careful reasoning shows that there's always an optimal strategy that consists of only two phases -- staying still for a period of time, then using the maximum acceleration, with no braking, until reaching the destination.  This simplifies the mathematics considerably, as we only need to figure out how long to wait.\n</p>\n<p>\nmystic won the round by a comfortable margin, finishing the whole set in under an hour.  Congratulations to the 1000 advancers!\n</p>\n\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>\nProblem A. <i>Diamond Inheritance</i> Written and prepared by Khaled Hafez.\n</p>\n\n<p>\nProblem B. <i>Out of Gas</i> Written by Bartholomew Furrow.  Prepared by Bartholomew Furrow and Yiu Yu Ho.\n</p>\n\n<p>\nProblem C. <i>Box Factory</i> Written by David Arthur. Prepared by David Arthur and Luka Kalinovcic.\n</p>\n\n<p>\nContest analysis presented by John Dethridge, Onufry Wojtaszczyk, and John Dethridge again.\n</p>\n\n<p>\nSolutions and other problem preparation by \nIgor Naverniouk,\nAdam Polak,\nLuka Kalinovcic,\nJohn Dethridge,\nAlexander Georgiev,\nSean Henderson,\nAhmed Aly,\nMuntasir Khan and \nNikolay Kurtov.\n</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1336294800000,"tasks":[{"analysis":"<p>This was a hard problem to wrap your head around, as evidenced by the results. The final solution was, however, surprisingly simple (although the argumentation for it is not).</p>\n\n<p>Let us first consider a single case, with a single acceleration value <b>a</b>, and an arbitrarily large <b>N</b>. Suppose some strategy <i>S<sub>1</sub></i> takes you home in time <b>T</b>. Obviously <b>a*T<sup>2</sup></b> / 2 &ge; <b>D</b>, as <b>a*T<sup>2</sup></b> / 2 is the distance we travel if we start accelerating immediately and never brake.</p>\n\n<p>We can propose an alternate strategy <i>S<sub>2</sub></i>: first stop and wait for time <b>T</b> - <i>sqrt</i>(2 <b>D/ A</b>), and then start accelerating full speed and never brake. This will also bring you home in time <b>T</b>.</p>\n\n<p>We have to prove that if <i>S<sub>1</sub></i> did not collide with the other car, neither will <i>S<sub>2</sub></i>. We prove this by checking that <i>S<sub>2</sub></i> arrives at any point between the top of the hill and your home no earlier than <i>S<sub>1</sub></i>.</p>\n\n<p>Assume <i>S<sub>1</sub></i> was at some point <b>X</b> later than <i>S<sub>2</sub></i>. Notice that the speed of <i>S<sub>1</sub></i> coming into <b>X</b> had to be larger than the speed of <i>S<sub>2</sub></i> &mdash; otherwise even accelerating full speed will not let <i>S<sub>1</sub></i> catch up with <i>S<sub>2</sub></i>. But it is impossible to achieve a faster speed at <b>X</b> than <i>S<sub>2</sub></i>: strategy <i>S<sub>2</sub></i> accelerated all the way from the top of the hill to <b>X</b>.</p>\n\n<p>So, now we only need to consider strategies such as <i>S<sub>1</sub></i>. We now just need to determine how long do we need to wait on the top of the hill. </p>\n\n<p>One last thing to notice is that if the other car moves at constant speed between <b>x<sub>i</sub></b> and <b>x<sub>i+1</sub></b>, and our strategy does not put us in front of the other car at <b>x<sub>i</sub></b> or at <b>x<sub>i+1</sub></b>, then it does not intercept the other car in any intermediate point either.  We know that because if we did intercept it in some intermediate point, it would mean that we were moving faster than the other car at the time of interception; and since we're accelerating, and the other car's speed is constant, we would end up in front of it at <b>x<sub>i+1</sub></b>.  Therefore passing the other car between <b>x<sub>i</sub></b> and <b>x<sub>i+1</sub></b> leads to a contradiction, and it must be the case that we don't pass it.</p>\n\n<p> With this reasoning complete, we now have two possible algorithms. One is a binary search: To check if a given waiting time <b>T</b> is long enough, we just need to check all the <b>N</b> points at which the other car can change its speed. To achieve a precision of 10<sup>-6</sup>, we will need around 40 iterations in the binary search. This means we solve each test case in O(<b>N A</b>) time, with the constant 40 hidden in the big-O notation &mdash; fast enough.</p>\n\n<p> If we are worried about the constant factor of 40, we can also iterate over all points <b>x<sub>i</sub></b>, and for each calculate the minimum waiting time needed not to intercept the other car at this point: <code>t<sub>i</sub> - sqrt(2x<sub>i</sub>/a)</code> for all i such that <code>x<sub>i</sub> &lt; D</code> (you also have to include the moment where the other car reaches your house). This will make our solution run in O(<b>N A</b>) time without the pesky constant.</p>","id":"0000000000432dfe","statement":"<h3>Problem</h3>\n\n<p>\nYour car is out of gas, and you want to get home as quickly as possible!  Fortunately, your home is at the bottom of a hill and you (in your car) are at the top of it.  Unfortunately, there is a car in front of you, and you can't move past it.  Fortunately, your brakes are working and they are <i>very</i> powerful.\n</p>\n<p>\nYou <i>start</i> at the top of the hill with speed 0 m/s at time 0 seconds.  Gravity is pulling your car down the hill with a constant acceleration.  At any time, you can use your brakes to reduce your speed, or temporarily reduce your acceleration, by any amount.\n</p>\n<p>\nHow quickly can you reach your home if you use your brakes in the best possible way?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  The first line of each test case contains three space-separated numbers: a real-valued number <b>D</b>, the distance in meters to your home down the hill; and two integers, <b>N</b> and <b>A</b>.  The distance <b>D</b> will be given in <i>exactly 6 decimal places</i>.\n</p>\n<p>\n<b>N</b> lines follow, each of which contains two space-separated, real-valued numbers: a time <b>t</b><sub>i</sub> in seconds, and a position <b>x</b><sub>i</sub> in meters.  The <b>t</b><sub>i</sub> and <b>x</b><sub>i</sub> values will be given in <i>exactly 6 decimal places</i>.\n\n</p>\n<p>\nOne line follows, with <b>A</b> space-separated, real-valued numbers <b>a</b><sub>i</sub>, which are accelerations in <code>m/s<sup>2</sup></code>.  The accelerations will be given in <i>exactly 2 decimal places</i>.\n</p>\n<p>\nThe other car's position is specified by the (<b>t</b><sub>i</sub>, <b>x</b><sub>i</sub>) pairs.  The car's position at time <b>t</b><sub>i</sub> seconds is <b>x</b><sub>i</sub> meters measured from the top of the hill (i.e. your initial position). The car travels at constant speed between time <b>t</b><sub>i</sub> and <b>t</b><sub>i+1</sub>.  The positions and times will both be given in increasing order, with <b>t</b><sub>0</sub>=0.  \n</p>\n<p>\nFor example, if t<sub>5</sub>=10, x<sub>5</sub>=20, t<sub>6</sub>=20, x<sub>6</sub>=40, then 10 seconds after the <i>start</i>, the other car is 20 meters down the hill; 15 seconds after the <i>start</i>, the other car is 30 meters down the hill; and 20 seconds after the <i>start</i>, the other car is 40 meters down the hill.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #c:\", where c is the case number (starting from 1).  Then output <b>A</b> lines, the i<sup>th</sup> of which contains the minimum number of seconds it takes you to reach your home if your acceleration down the hill due to gravity is <b>a</b><sub>i</sub>, and you use your brakes in the best possible way.  Answers within an absolute or relative error of 10<sup>-6</sup> of the correct answer will be accepted.  There should be no blank lines in the output.\n</p>\n\n<h3>Notes</h3>\n<p>\n<p>\n<b>Position and Acceleration:</b> An object with a constant acceleration <code>a m/s<sup>2</sup></code> and starting speed of <code>v<sub>0</sub> m/s</code> will move a distance of v<sub>0</sub>*t + 0.5*a*t<sup>2</sup></code> after <code>t</code> seconds.\n</p>\n<b>Distance on the slope:</b> All the distances and accelerations are given with respect to the straight line down the hill.  They are <b>not</b>, for example, horizontal distances; so if your car is accelerating at <code>2 m/s<sup>2</sup></code> with an initial speed of <code>0 m/s</code>, and the other car is stopped at x=1, it will take exactly 1 second to reach the other car.\n</p>\n<p>\n<b>The other car:</b> You may never pass the other car, which means that at no time shall your distance down the hill be greater than that of the other car.  It may be equal.  The cars should be considered as point masses.\n</p>\n<p>\n<b>Output values:</b> You can print as many decimal places as you like in the output.  We will read and compare your answers with ours, and at that time we will be using 10<sup>-6</sup> as a threshold for inaccuracy.  So 25, 25.0 and 25.000000 are the same from our perspective.  Trailing zeros after the decimal point does not matter.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n1.0 &le; <b>D</b> &le; 10<sup>4</sup>.<br/>\n1.0 &le; <b>a</b><sub>i</sub> &le; 9.81.<br/>\n0.0 &le; <b>t</b><sub>i</sub> &le; 10<sup>5</sup>.<br/>\n0.0 &le; <b>x</b><sub>i</sub> &le; 10<sup>5</sup>.<br/>\n<b>t</b><sub>i</sub> &lt; <b>t</b><sub>i+1</sub>.<br/>\n<b>x</b><sub>i</sub> &lt; <b>x</b><sub>i+1</sub>.<br/>\n<b>t</b><sub>0</sub> = 0<br/>\n<b>x</b><sub>N-1</sub> &ge; <b>D</b>.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 2.<br/>\n1 &le; <b>A</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 2000.<br/>\n1 &le; <b>A</b> &le; 250.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1000.000000 2 3\n0.000000 20.500000\n25.000000 1000.000000\n1.00 5.00 9.81\n50.000000 2 2\n0.000000 0.000000\n100000.000000 100.000000\n1.00 1.01\n10000.000000 3 1\n0.000000 0.000000\n10000.000000 0.100000\n10000.100000 100000.000000\n1.00\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n44.7213595\n25.000000\n25.0\nCase #2:\n50000.0\n50000.0\nCase #3:\n10140.974143\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":27}],"title":"Out of Gas","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem is a variation of the <a href=\"http://www.google.com/search?q=longest+common+subsequence\" target=\"_blank\">Longest Common Subsequence</a> problem, which is to find the longest string of characters which occurs as a subsequence of each of two strings (a string S is a subsequence of a string T if S occurs in T, possibly with more characters inserted between the elements of S.)  In this case, the first \"string\" is the sequence of types of each box produced by the factory, and the second \"string\" is the sequence of types of each toy produced by the factory.\n\n<p>\nA dynamic programming algorithm for this problem is to find the maximum number of toys that could be placed in boxes using the first x boxes and the first y toys.  Let this value be f[x][y].  Then f[x][y] is equal to the maximum of:\n<ul>\n<li>f[x-1][y]\n<li>f[x][y-1]\n<li>f[x-1][y-1]+1\n</ul>\nwith the last case only applying if the x<sup>th</sup> letter of the first string is equal to the y<sup>th</sup> letter of the second string.  These three cases correspond to the last action taken being to drop a box, to drop a toy, and to put a toy in a matching box, respectively.\n\n<p>\nUnfortunately, even though the number of runs of boxes and toys is small, the total number of boxes and toys can be very large, so this algorithm is not practical.  But we can modify it so that f[x][y] will be the maximum number of toys that could be placed in boxes using the first x <b>runs</b> of boxes and the first y <b>runs</b> of toys.  Now f[x][y] is the maximum of:\n<ul>\n<li>f[x-1][y]\n<li>f[x][y-1]\n<li>f[a][b]+g(a,b,x,y), for all a&lt;x, b&lt;y\n</ul>\nSimilarly to before, the last case only applies if the type of box run x matches the type of toy run y.  It corresponds to only using boxes of that type between runs a+1 and x, and toys of that type between runs b+1 and y.  g(a,b,x,y) is the minimum of the number of those toys and the number of those boxes, which is the number of toys that can be placed in boxes in that range.\n\n<p>\nThis algorithm is O(n<sup>4</sup>).  Another improvement can reduce this again to O(n<sup>3</sup>), which we leave as an exercise to the reader!\n","id":"0000000000432fe7","statement":"<h3>Problem</h3>\n<p>\nYou own a factory with two assembly lines. The first assembly line makes boxes, and the second assembly line makes toys to put in those boxes. Each type of box goes with one type of toy and vice-versa.\n</p>\n\n<p>\nAt the beginning, you pick up a box from the first assembly line and a toy from the second assembly line. You then have a few options.\n<ul>\n<li> You can always throw out the box and pick up the next one.\n<li> You can always throw out the toy and pick up the next one.\n<li> If the box and toy are the same type, you can put the toy in the box, and send it out to customers.\n</ul>\nYou always pick boxes up in the order in which they are made, and similarly for toys. You know the order in which boxes and toys are made, and you want to plan out a strategy that will allow you to send as many boxed toys as possible to customers.\n</p>\n\n<p>\nWarning: The two assembly lines make a <i>lot</i> of boxes and toys. However, they tend to make one kind of thing for a long period of time before switching.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.</p>\n\n<p>\nEach test case begins with a line contains two integers <b>N</b> and <b>M</b>. It is followed by a line containing 2 * <b>N</b> integers <b>a<sub>1</sub></b>, <b>A<sub>1</sub></b>, <b>a<sub>2</sub></b>, <b>A<sub>2</sub></b>, ..., <b>a<sub>N</sub></b>, <b>A<sub>N</sub></b>, and another line containing 2 * <b>M</b> integers <b>b<sub>1</sub></b>, <b>B<sub>1</sub></b>, <b>b<sub>2</sub></b>, <b>B<sub>2</sub></b>, ..., <b>b<sub>M</sub></b>, <b>B<sub>M</sub></b>.\n</p>\n\n<p>\nThis means that the first assembly line will make <b>a<sub>1</sub></b> boxes of type <b>A<sub>1</sub></b>, then <b>a<sub>2</sub></b> boxes of type <b>A<sub>2</sub></b>, etc., until it finishes with <b>a<sub>N</sub></b> boxes of type <b>A<sub>N</sub></b>. Similarly, the second assembly will make <b>b<sub>1</sub></b> toys of type <b>B<sub>1</sub></b>, followed by <b>b<sub>2</sub></b> toys of type <b>B<sub>2</sub></b>, etc., until it finishes with <b>b<sub>M</sub></b> toys of type <b>B<sub>M</sub></b>.\n</p>\n\n<p>\nA toy can be matched with a box if and only if they have the same type number.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1), and y is the largest number of boxed toys that you can send out to customers.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 30 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>a<sub>i</sub></b>, <b>b<sub>i</sub></b> &le; 10<sup>16</sup>.<br/>\n1 &le; <b>A<sub>i</sub></b>, <b>B<sub>i</sub></b> &le; 100.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 3.<br/>\n1 &le; <b>M</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N, M</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n3 3\n10 1 20 2 25 3\n10 2 30 3 20 1\n3 5\n10 1 6 2 10 1\n5 1 3 2 10 1 3 2 5 1\n3 5\n10 1 6 2 10 1\n5 1 6 2 10 1 6 2 5 1\n1 1\n5000000 10\n5000000 100\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 35\nCase #2: 20\nCase #3: 21\nCase #4: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Box Factory","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nWe are given a directed graph, and have to determine if there is a pair of nodes (X,Y) such that there are two or more paths from X to Y.\n\n<p>\nFor each node, we do a <a href=\"http://www.google.com/search?q=depth+first+search\" target=\"_blank\">depth-first search</a> with that node as the root.  If during the depth-first search we reach the same node twice, then we must have followed two different paths to get to that node from the root node, so we have found a pair (X,Y).  Conversely, if there are two paths between X and Y, we will reach Y at least twice when doing a DFS from X.  So if this algorithm finds no pair (X,Y), then none exists in the graph.\n\n<p>\nIf there are V nodes and E edges in a graph, then a DFS is O(V+E) in general.  But each DFS will never follow more than V edges, because after following that many edges, some node will have been reached twice, so we can stop at that point.  Therefore this algorithm is O(V<sup>2</sup>).\n\n<p>\nWe can also just use <a href=\"http://www.google.com/search?q=using+floyd's+algorithm+to+count+paths\" target=\"_blank\">a variation of Floyd's algorithm</a>, which is O(V<sup>3</sup>), but very simple to write.  With only 1000 nodes in the graph, a fast implementation will finish within the time limit.\n","id":"000000000043319d","statement":"<h3>Problem</h3>\n<p>\nYou are asked to help diagnose class diagrams to identify instances of diamond inheritance. The following example class diagram illustrates the property of diamond inheritance.  There are four classes: A, B, C and D.  An arrow pointing from X to Y indicates that class X inherits from class Y.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3XK8k_s36uT_1s5z7Ascd9SAWDvVOqB45pb3CpiHUSyptBFDC4cj9i8kotrnTIdz5vDd4CFg/diamond.png\"/>\n<p>\nIn this class diagram, D inherits from both B and C, B inherits from A, and C also inherits from A.  An inheritance path from X to Y is defined as a sequence of classes X, C<sub>1</sub>, C<sub>2</sub>, C<sub>3</sub>, ..., C<sub>n</sub>, Y where X inherits from C<sub>1</sub>, C<sub>i</sub> inherits from C<sub>i + 1</sub> for 1 &le; i &le; n - 1, and C<sub>n</sub> inherits from Y.  There are two inheritance paths from D to A in the example above. The first path is D, B, A and the second path is D, C, A.\n</p>\n\n<p>\nA class diagram is said to contain a diamond inheritance if there exists a pair of classes X and Y such that there are at least two different inheritance paths from X to Y.  The above class diagram is a classic example of diamond inheritance.  Your task is to determine whether or not a given class diagram contains a diamond inheritance.\n</p>\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow, each specifies a class diagram. The first line of each test case gives the number of classes in this diagram, <b>N</b>.  The classes are numbered from 1 to <b>N</b>.  <b>N</b> lines follow.   The i<sup>th</sup> line starts with a non-negative integer <b>M<sub>i</sub></b> indicating the number of classes that class <i>i</i> inherits from. This is followed by <b>M<sub>i</sub></b> distinct positive integers each from 1 to <b>N</b> representing those classes. You may assume that:\n<ul>\n<li>If there is an inheritance path from X to Y then there is no inheritance path from Y to X.</li>\n<li>A class will never inherit from itself.</li>\n</ul>\n</p>\n\n<h3>Output</h3>\n<p>\nFor each diagram, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is \"Yes\" if the class diagram contains a diamond inheritance, \"No\" otherwise.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\nTime limit: 40 seconds per test set.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\n0 &le; <b>M<sub>i</sub></b> &le; 10.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 50.\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n1 &le; <b>N</b> &le; 1,000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2LngCIZeyQHaFUvAYfsxCHwfsE-urkYwU_r4sSZcz5CZXaB-VV9a55DleGY-DQqx6M0u0CI4S7LI1hNX_J0RcNg9utJLSFbJ-nXsxRYk428a23/diamond_inheritance_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n3\n1 2\n1 3\n0\n5\n2 2 3\n1 4\n1 5\n1 5\n0\n3\n2 2 3\n1 3\n0\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3JnQPOgrOt0KRTL8eYI5osH3EdaRh5W9oWzxdsisaOYwU-OvIS1SgUm_nc0qPzB32y_NsWg6hCbbtiffL3RsV3R0dekhLPgvd_cnOH_fUqPoVyYQ/diamond_inheritance_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: No\nCase #2: Yes\nCase #3: Yes\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Diamond Inheritance","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043308d","type":1,"type__str":"SPECTATOR"},"title":"Round 1C 2012"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
