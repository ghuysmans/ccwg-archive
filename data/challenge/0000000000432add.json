{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1397354400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432add","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nGoogle Code Jam 2014 is off and running! We have 20,595 advancers out of 25,462 people who correctly solved at least one input, and 49,066 registrants. People correctly solved problems from 165 different regions of the world, using 88 different programming languages. All those numbers are records for us!\n</p>\n\n<p>\nWe opened with a magic trick, and a game about gathering cookies, both of which had solutions that were straightforward -- at least in principle. Next came Minesweeper Master, which had an astonishingly low success rate: under 50% of people who thought they had solved it eventually did; and of our 25 fastest finishers in the round, 11 of them got it wrong on the first try. Last came Deceitful War, a problem that was harder to understand but easier to solve, which asked you to get inside the heads of both an honest game player and a dishonest one.\n</p>\n\n<p>\nThere are three more rounds to go before the Finals, and we are just getting started. We hope to see all the advancers in the First Rounds!\n</p>\n\n<hr>\n\n<p>Cast</p>\n\n<p>Problem A. <i>Magic Trick</i> Written and prepared by Ahmed Aly.</p>\n\n<p>Problem B. <i>Cookie Clicker Alpha</i> Written by Bartholomew Furrow. Prepared by Sean Henderson and Bartholomew Furrow.</p>\n\n<p>Problem C. <i>Minesweeper Master</i> Written and prepared by Igor Naverniouk.</p>\n\n<p>Problem D. <i>Deceitful War</i> Written by Bartholomew Furrow. Prepared by Jonathan Wills and Bartholomew Furrow.</p>\n\nContest analysis presented by Felix Halim, Topraj Gurung, Zong-Sian Li and Bartholomew Furrow.\n\nSolutions and other problem preparation by Jonathan Paulson, Jonathan Shen, Khaled Hafez, Mahbubul Hasan, Mohammad Kotb, Patrick Nguyen and Steve Thomas.\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1397257200000,"tasks":[{"analysis":"<p>\nThere are many ways to generate a valid mine configuration. In this analysis, we try to enumerate all possible cases and try to generate a valid configuration for each case (if exists). Later, after having some insight, we provide an easier to implement algorithm to generate a valid mine configuration (if exists).\n</p>\n\n<p>\n<h2>Enumerating all possible cases</h2>\n<p>\nWe start by checking the trivial cases:\n<ul>\n<li>\nIf there is only one empty cell, then we can just fill all cells with mines except the cell where you click.\n</li>\n<li>\nIf R = 1 or C = 1, the mines can be placed from left to right or top to bottom respectively and click on the right-most or the bottom-most cell respectively.\n</li>\n</ul>\n</p>\n\n<p>\nIf the board is not in the two trivial cases above, it means the board has at least 2 x 2 size. Then, we can manually check that:\n<ul>\n<li>\nIf  the number of empty cells is 2 or 3, it is Impossible to have a valid configuration.\n</li>\n<li>\nIf R = 2 or C = 2, valid configurations exists only if M is even. For example, if R = 2, C = 7 and M = 5, it is Impossible since M is odd. However, if M = 6, we can place the mines on the left part of the board and click on the bottom right, like this:\n</li>\n</ul>\n<pre>\n            ***....\n            ***...c\n</pre>\n</p>\n\n<p>\nIf the board is not in any of the above case, it means the board is at least 3 x 3 size. In this case, we can always find a valid mine configuration if the number of empty cells is bigger than 9. Here is one way to do it:\n<ul>\n<li>\nIf the number of empty cells is equal or bigger than 3 * C, then the mines can be placed row by row starting from top to bottom. If the number of remaining mines can entirely fill the row or is less than C - 2 then place the mines from left to right in that row. Otherwise, the number of remaining mines is exactly C - 1, place the last mine in the next row. For example:\n</li>\n<pre>\n            ******        ******\n            *****.        ****..\n            ......   -&gt;   *.....\n            ......        ......\n            .....c        .....c\n</pre>\n<li>\nIf the number of empty cells is less than 3 * C but at least 9, we first fill all rows with mines except the last 3 rows. For the last 3 rows, we fill the remaining mines column by column from the left most column. If the remaining mines on the last column is two, then last mine must be put in the next column. For example:\n</li>\n<pre>\n            ******        ******\n            **....   -&gt;   ***...\n            **....        *.....\n            *....c        *....c\n</pre>\n</ul>\n<p>\nNow, we are left with at most 9 empty cells which are located in the 3 x 3 square cells at the bottom right corner. In this case, we can check by hand that if the number of empty cells is 5 or 7, it is Impossible to have a valid mine configuration. Otherwise, we can hard-coded a valid configuration for each number of empty cell in that 3 x 3 square cells.\n</p>\n<p>\nSigh... that was a lot of cases to cover! How do we convince ourselves that when we code the solution, we do not miss any corner case?\n</p>\n\n<p>\n<h2>Brute-force approach</h2>\n<p>\nFor the small input, the board size is at most 5 x 5. We can check all (25 choose M) possible mine configurations and find one that is valid (i.e., clicking an empty cell in the configuration reveal all other empty cells). To check whether a mine configuration is valid, we can run a flood-fill algorithm (or a simple breath-first search) from the clicked empty cell and verify that all other empty cells are reachable (i.e., they are in one connected component). Note that we should also check all possible click positions. This brute-force approach is fast enough for the small input. \n</p>\n\n<p>\nThe brute-force approach can be used to check (for small values of R, C, M) whether there is a false-negative in our enumeration strategy above. A false-negative is found when there exist a valid mine configuration, but the enumeration strategy above yields Impossible. Once we are confident that our enumeration strategy does not produce any false-negative, we can use it to solve the large input.\n</p>\n\n<p>\n<h2>An easier to implement approach</h2>\n<p>\nAfter playing around with several valid mine configurations using the enumeration strategy above, you may notice a pattern: in a valid mine configuration,  the number of mines in a particular row is always equal or larger than the number of mines of the rows below it and all the mines are left-aligned in a row. With this insight, we can implement a simpler backtracking algorithm that places mines row by row from top to bottom with non-increasing number of mines as we proceed to fill in the next row and prune if the configuration for the current row is invalid (it can be checked by clicking at the bottom right cell). This backtracking with pruning can handle up to 50 x 50 sized board in reasonable time and is simpler to implement (i.e., no need to enumerate corner / tricky cases).\n</p>\n<p>\nIf the contest time were shorter, we may not have enough time to enumerate all possible cases. In this case, betting on the backtracking algorithm (or any other algorithm that is easier to implement) may be a good idea. Finding such algorithms is an art :).\n</p>","id":"0000000000432e04","statement":"<h3>Problem</h3>\n<p>\n<i>Minesweeper</i> is a computer game that became popular in the 1980s, and is still included in some versions of the <i>Microsoft Windows</i> operating system. This problem has a similar idea, but it does not assume you have played <i>Minesweeper</i>.\n</p>\n\n<p>\nIn this problem, you are playing a game on a grid of identical cells. The content of each cell is initially hidden. There are <b>M</b> mines hidden in <b>M</b> different cells of the grid. No other cells contain mines. You may click on any cell to reveal it. If the revealed cell contains a mine, then the game is over, and you lose. Otherwise, the revealed cell will contain a digit between 0 and 8, inclusive, which corresponds to the number of neighboring cells that contain mines. Two cells are neighbors if they share a corner or an edge. Additionally, if the revealed cell contains a 0, then all of the neighbors of the revealed cell are automatically revealed as well, recursively. When all the cells that don't contain mines have been revealed, the game ends, and you win.\n</p>\n\n<p>\nFor example, an initial configuration of the board may look like this ('*' denotes a mine, and 'c' is the first clicked cell):\n<pre>\n*..*...**.\n....*.....\n..c..*....\n........*.\n..........\n</pre>\nThere are no mines adjacent to the clicked cell, so when it is revealed, it becomes a 0, and its 8 adjacent cells are revealed as well. This process continues, resulting in the following board:\n<pre>\n*..*...**.\n1112*.....\n00012*....\n00001111*.\n00000001..\n</pre>\nAt this point, there are still un-revealed cells that do not contain mines (denoted by '.' characters), so the player has to click again in order to continue the game.\n</p>\n\n<p>\nYou want to win the game as quickly as possible. There is nothing quicker than winning in one click. Given the size of the board (<b>R</b> x <b>C</b>) and the number of hidden mines <b>M</b>, is it possible (however unlikely) to win in one click? You may choose where you click. If it is possible, then print any valid mine configuration and the coordinates of your click, following the specifications in the <i>Output</i> section. Otherwise, print \"Impossible\".\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each line contains three space-separated integers: <b>R</b>, <b>C</b>, and <b>M</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output a line containing \"Case #x:\", where x is the test case number (starting from 1). On the following <b>R</b> lines, output the board configuration with <b>C</b> characters per line, using '.' to represent an empty cell, '*' to represent a cell that contains a mine, and 'c' to represent the clicked cell.\n</p>\n<p>\nIf there is no possible configuration, then instead of the grid, output a line with <nobr>\"Impossible\"</nobr> instead. If there are multiple possible configurations, output any one of them.\n</p>\n\n<h3>Limits</h3>\n<p>\n0 &le; <b>M</b> &lt; <b>R</b> * <b>C</b>.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\n1 &le; <b>T</b> &le; 230.<br/>\n1 &le; <b>R</b>, <b>C</b> &le; 5.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\n1 &le; <b>T</b> &le; 140.<br/>\n1 &le; <b>R</b>, <b>C</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n5 5 23\n3 1 1\n2 2 1\n4 7 3\n10 10 82\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\nImpossible\nCase #2:\nc\n.\n*\nCase #3:\nImpossible\nCase #4:\n......*\n.c....*\n.......\n..*....\nCase #5:\n**********\n**********\n**********\n****....**\n***.....**\n***.c...**\n***....***\n**********\n**********\n**********\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Minesweeper Master","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Ken's best possible game of War</h2>\n<p>\nFirst, let's think about the best possible outcome for Ken in a game of War. Let's suppose the maximum number of points Ken can get is <b>k</b>; then after a little work convincing yourself, you should see that Ken can achieve that outcome if Ken's <b>k</b> heaviest blocks are played in decreasing order against Naomi's <b>k</b> lightest blocks, also in decreasing order.\n</p>\n<p>\nThat exact pairing likely won't happen, and without knowing Naomi's blocks' weights, Ken doesn't even know what the pairing would be; but Ken can follow a simple strategy to score <b>k</b> points anyway.\n</p>\n\n<h2>Ken's strategy</h2>\n<p>\nKen's strategy is simple: when Naomi plays a block, Ken beats it with the lightest possible block if he can; and if he can't beat it, he plays his lightest block. It is clear that using such strategy will maximize Ken's winning potential for the following rounds because Ken not only wins one point for this round, but also preserves his heavier blocks for the following rounds.\n</p>\n<p>\nThe following block of text proves that this strategy will earn Ken the maximum possible number of points, <b>k</b>, no matter what Naomi does. If that's obvious to you, or you aren't into formal proofs, go ahead and skip it.\n</p>\n\n<h3><b>Proof</b></h3>\n<p>\nIn this strategy, to win <b>k</b> points Ken wants to maintain an invariant: after Ken has scored <b>i</b> points, Ken's <b>k-i</b> heaviest blocks will still beat Naomi's <b>k-i</b> lightest blocks. When <b>k-i</b> is zero, Ken cannot win any more points because his heaviest block is lighter than any of Naomi's blocks. Therefore, if that invariant is maintained Ken must have <b>k</b> points when there are no more blocks left.\n</p>\n<p>\n<b>Proof of invariant:</b>\n<br>\nSuppose Ken has <b>i</b> points. We'll refer to \"pairs\" of blocks later: Ken has <b>k - i</b> heaviest blocks remaining and his <b>j</b>-th heaviest remaining block is \"paired\" with Naomi's <b>(k-i-j)</b>-th lightest remaining block. There are three types of blocks Naomi might play:\n<ol>\n<li>If Naomi plays a block that's heavier than all of Ken's, it isn't from Naomi's lightest <b>k-i</b> blocks. Ken will play his lightest block which isn't from his heaviest <b>k-i</b> blocks, and the invariant is maintained.</li>\n<li>If Naomi plays a block that's lighter than one of Ken's blocks but isn't from Naomi's lightest <b>k-i</b> blocks, Ken will either beat it with his heaviest block—in which case Naomi's lightest <b>k-i-1</b> blocks will lose to Ken's heaviest remaining <b>k-i-1</b> blocks, since nothing has changed about how the remaining blocks are paired—or Ken will beat it with something lighter, in which case his position is obviously no worse. Either way Ken has <b>i+1</b> points and the invariant is maintained.</li>\n<li>If Naomi plays a block from her lightest <b>k-i</b> blocks, Ken will either beat it with the block it's paired with, in which case Ken now has <b>i+1</b> points and the remaining <b>k-i-1</b> pairs are maintained; or Ken will beat it with something lighter, in which case Ken is clearly no worse off. Either way Ken has <b>i+1</b> points and the invariant is maintained.</li>\n</ol>\n</p>\n<h2>Naomi's best possible game of War</h2>\n<p>\nAs we saw in the proof above, Ken can force his maximum possible number of points in War no matter what Naomi does. No wonder Naomi is tired of playing it!\n</p>\n<h2>Naomi's best possible game of Deceitful War</h2>\n<p>\nIn Deceitful War, however, it turns out that the situation is exactly reversed: as we'll show in the following paragraphs. In War, Ken got the best possible pairings for himself but Naomi will get the best possible pairings for herself in Deceitful War.\n</p>\n<h2>Naomi's strategy for Deceitful War</h2>\n<p>\nThere are several strategies for Naomi to play Deceitful War optimally. We present one here.\nNaomi's strategy for that is almost trivial. Assume <b>k</b> is the best possible score Naomi could achieve. Naomi can do score <b>k</b> points by pairing her <b>k</b> heaviest blocks with Ken's <b>k</b> lightest blocks.\n</p>\n<p>\nNaomi will take her <b>i</b>-th heaviest block and tell Ken that it is heavier than all of Ken's blocks. Ken will believe her and play his lightest block, which is what Naomi wanted. Now Naomi simply has to repeat the process of playing her remaining heaviest blocks from lightest to heaviest and inciting Ken to play his  lightest block from lightest to heaviest. After Naomi scores <b>k</b> points, her heaviest block will be lighter than any of Ken's available blocks. Now, since Naomi cannot lie anymore Naomi plays her remaining blocks without lying about their mass.\n</p>\n<h2>Conclusion</h2>\n<p>\nIt's a particularly beautiful piece of symmetry that Ken can achieve his optimal pairing by being reactive, despite being honest and without information; and Naomi can reverse Ken's advantage by beating Ken's reactiveness with dishonesty and perfect information.\n</p>\n","id":"0000000000432fec","statement":"<p>\n<b>\nThis problem is the hardest problem to understand in this round. If you are new to Code Jam, you should probably try to solve the other problems first.\n</b>\n</p>\n\n<h3>Problem</h3>\n<p>\nNaomi and Ken sometimes play games together. Before they play, each of them gets <b>N</b> identical-looking blocks of wood with masses between 0.0kg and 1.0kg (exclusive). All of the blocks have different weights. There are lots of games they could play with those blocks, but they usually play something they call War. Here is how War works:\n</p>\n<p>\n<ol>\n<li>\nEach player weighs each of his or her own blocks, so each player knows the weights of all of his or her own blocks, but not the weights of the other player's blocks.\n</li>\n<li>They repeat the following process <b>N</b> times:\n<ol>\n<li>Naomi chooses one of her own blocks, with mass <code>Chosen<sub>Naomi</sub></code>.</li>\n<li>Naomi tells Ken the mass of the block she chose.</li>\n<li>Ken chooses one of his own blocks, with mass <code>Chosen<sub>Ken</sub></code>.</li>\n<li>They each put their block on one side of a <a href=\"https://www.google.com/search?q=balance+scale&tbm=isch\" target=\"_blank\">balance scale</a>, and the person whose block is heavier gets one point.</li>\n<li>Both blocks are destroyed in a fire.</li>\n</ol>\n</li>\n</ol>\n</p>\n<p>\nNaomi has realized three things about War. First, she has realized that she loses a lot. Second, she has realized that there is a unique strategy that Ken can follow to maximize his points without assuming anything about Naomi's strategy, and that Ken always uses it. Third, she has realized that she hates to lose. Naomi has decided that instead of playing War, she will play a game she calls Deceitful War. The great thing about Deceitful War is that Ken will think they're playing War!\n</p>\n<p>\nHere is how Deceitful War works, with differences between Deceitful War and War in bold:\n</p>\n<p>\n<ol>\n<li>\nEach player weighs each of his or her own blocks.  <b>Naomi also weighs Ken's blocks while he isn't looking, so Naomi knows the weights of all blocks</b> and Ken only knows the weights of his own blocks.\n</li>\n<li>They repeat the following process <b>N</b> times:\n<ol>\n<li>Naomi chooses one of her own blocks, with mass <code>Chosen<sub>Naomi</sub></code>.</li>\n<li>Naomi tells Ken <b>a number, <code>Told<sub>Naomi</sub></code>, between 0.0kg and 1.0kg exclusive.</b> Ken, who thinks they're playing War, thinks the number Naomi just told him is <code>Chosen<sub>Naomi</sub></code>.</li>\n<li>Ken chooses one of his own blocks, with mass <code>Chosen<sub>Ken</sub></code>.</li>\n<li>They each put their block on one side of a <a href=\"https://www.google.com/search?q=balance+scale&tbm=isch\" target=\"_blank\">balance scale</a>, and the person whose block is heavier gets one point.</li>\n<li>Both blocks are destroyed in a fire.</li>\n</ol>\n</li>\n</ol>\n</p>\n<p>\nNaomi doesn't want Ken to know that she isn't playing War; so when she is choosing which block to play, and what mass to tell Ken, she must make sure that the balance scale won't reveal that <code>Chosen<sub>Naomi</sub> &ne; Told<sub>Naomi</sub></code>. In other words, she must make decisions so that:\n<ul>\n<li><code>Chosen<sub>Naomi</sub> &gt; Chosen<sub>Ken</sub></code> if, and only if, <code>Told<sub>Naomi</sub> &gt; Chosen<sub>Ken</sub></code>, and\n<li><code>Told<sub>Naomi</sub></code> is not equal to the mass of any of Ken's blocks, because he knows that isn't possible.</li>\n</ul>\n</p>\n<p>\nIt might seem like Naomi won't win any extra points by being deceitful, because Ken might discover that she wasn't playing War; but Naomi knows Ken thinks both players are playing War, and she knows what he knows, and she knows Ken will always follow his unique optimal strategy for War, so she can always predict what he will play.\n</p>\n<p>\nYou'll be given the masses of the blocks Naomi and Ken started with. Naomi will play Deceitful War optimally to gain the maximum number of points. Ken will play War optimally to gain the maximum number of points <i>assuming that both players are playing War</i>. What will Naomi's score be? What would it have been if she had played War optimally instead?\n</p>\n\n<h3>Examples</h3>\n<p>\nIf each player has a single block left, where Naomi has 0.5kg and Ken has 0.6kg, then Ken is guaranteed to score the point. Naomi can't say her number is &ge; 0.6kg, or Ken will know she isn't playing War when the balance scale shows his block was heavier.\n</p>\n<p>\nIf each player has two blocks left, where Naomi has [0.7kg, 0.2kg] and Ken has [0.8kg, 0.3kg], then Naomi could choose her 0.2kg block, and deceive Ken by telling him that she chose a block that was 0.6kg. Ken assumes Naomi is telling the truth (as in how the War game works) and will play his 0.8kg block to score a point. Ken was just deceived, but he will never realize it because the balance scale shows that his 0.8kg block is, like he expected, heavier than the block Naomi played. Now Naomi can play her 0.7kg block, tell Ken it is 0.7kg, and score a point. If Naomi had played War instead of Deceitful War, then Ken would have scored two points and Naomi would have scored zero.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.  Each test case starts with a line containing a single integer <b>N</b>, the number of blocks each player has. Next follows a line containing <b>N</b> space-separated real numbers: the masses of Naomi's blocks, in kg. Finally there will be a line containing <b>N</b> space-separated real numbers: the masses of Ken's blocks, in kg.\n</p>\n<p>\nEach of the masses given to Ken and Naomi will be represented as a 0, followed by a decimal point, followed by 1-5 digits. Even though all the numbers in the input have 1-5 digits after the decimal point, Ken and Naomi don't know that; so Naomi can still tell Ken that she played a block with mass 0.5000001kg, and Ken has no reason not to believe her.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>x</b>: <b>y</b> <b>z</b>\", where <b>x</b> is the test case number (starting from 1), <b>y</b> is the number of points Naomi will score if she plays Deceitful War optimally, and <b>z</b> is the number of points Naomi will score if she plays War optimally.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 50.<br/>\nAll the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1\n0.5\n0.6\n2\n0.7 0.2\n0.8 0.3\n3\n0.5 0.1 0.9\n0.6 0.4 0.3\n9\n0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899\n0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 0\nCase #2: 1 0\nCase #3: 2 1\nCase #4: 8 4\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":16}],"title":"Deceitful War","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIn the first arrangement, when the volunteer tells the magician the row that contains her card, the magician is able to see a set of four cards in that row. Similarly, in the second arrangement, the magician is able to see another set of four cards in the selected row.\n</p>\n\n<p>\nTherefore, after hearing the two volunteer’s answers, the magician will have two sets of cards:\n<br>\n- the first set of four cards that lie in the selected row in the first arrangement, and\n<br>\n- the second set of four cards that lie in the selected row in the second arrangement.\n</p>\n\n<p>\nTo know which card the volunteer chose, the magician must be able to find exactly one card that is in both sets (i.e., the intersection size of the two sets must be equal to one). If there is more than one card that is in both sets (i.e., the intersection size is bigger than one), then it means the magician can not determine which card the volunteer chose since there are more than one possible card that could have been chosen by the volunteer (the magician did a bad job). If none of the card in the first set is in the second set (i.e., the intersection size is zero), then there is no card consistent with the volunteer's answers (the volunteer cheated).\n</p>\n\n<p>\nThe sample input covers all three possible cases:\n</p>\n\n<p>\nIn Case #1, the two sets are {5, 6, 7, 8} and {9, 10, 7, 12}. There is exactly one card (i.e., card 7) that is in both sets, and thus the volunteer chosen card must be 7.\n</p>\n\n<p>\nIn Case #2, the two sets are {5, 6, 7, 8} and {5, 6, 7, 8}. The card chosen by the volunteer can be any of {5, 6, 7, 8} because all of them contains in both sets. Bad magician!\n</p>\n\n<p>\nLastly, in Case #3, the two sets are {5, 6, 7, 8} and {9, 10, 11, 12}. None of the cards in the first set is in the second set. The volunteer must have cheated!\n</p>","id":"0000000000433092","statement":"<p><b>Note:</b> To advance to the next rounds, you will need to score 25 points. Solving just this problem will not give you enough points.</p>\n\n<h3>Problem</h3>\n<p>\nRecently you went to a magic show. You were very impressed by one of the tricks, so you decided to try to figure out the secret behind it!\n</p>\n<p>\nThe magician starts by arranging 16 cards in a square grid: 4 rows of cards, with 4 cards in each row. Each card has a different number from 1 to 16 written on the side that is showing. Next, the magician asks a volunteer to choose a card, and to tell him which row that card is in.\n</p>\n<p>\nFinally, the magician arranges the 16 cards in a square grid again, possibly in a different order. Once again, he asks the volunteer which row her card is in. With only the answers to these two questions, the magician then correctly determines which card the volunteer chose. Amazing, right?\n</p>\n<p>\nYou decide to write a program to help you understand the magician's technique. The program will be given the two arrangements of the cards, and the volunteer's answers to the two questions: the row number of the selected card in the first arrangement, and the row number of the selected card in the second arrangement. The rows are numbered 1 to 4 from top to bottom.\n</p>\n<p>\nYour program should determine which card the volunteer chose; or if there is more than one card the volunteer might have chosen (the magician did a bad job); or if there's no card consistent with the volunteer's answers (the volunteer cheated).\n</p>\n\n<h3>Solving this problem</h3>\n<p>\nUsually, Google Code Jam problems have 1 Small input and 1 Large input.  This problem has only <b>1 Small input</b>.  Once you have solved the Small input, you have finished solving this problem.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow. Each test case starts with a line containing an integer: the answer to the first question. The next 4 lines represent the first arrangement of the cards: each contains 4 integers, separated by a single space. The next line contains the answer to the second question, and the following four lines contain the second arrangement in the same format.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1). \n</p>\n<p>\nIf there is a single card the volunteer could have chosen, y should be the number on the card. If there are multiple cards the volunteer could have chosen, y should be \"Bad magician!\", without the quotes. If there are no cards consistent with the volunteer's answers, y should be \"Volunteer cheated!\", without the quotes. The text needs to be exactly right, so consider copying/pasting it from here.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 60 seconds.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; both answers &le; 4.<br/>\nEach number from 1 to 16 will appear exactly once in each arrangement.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 5 4\n3 11 6 15\n9 10 7 12\n13 14 8 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n2\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n3\n1 2 3 4\n5 6 7 8\n9 10 11 12\n13 14 15 16\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 7\nCase #2: Bad magician!\nCase #3: Volunteer cheated!\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6}],"title":"Magic Trick","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIn this problem, we need to decide on the number of cookie farms to buy and also need to decide on when to buy the farms.\n</p>\n<p>\nThe strategy is perhaps surprisingly simple: first, collect enough cookies to buy a farm. Then figure out whether it's faster to buy one farm and <i>then</i> collect <b>X</b> cookies, or simply to collect <b>X</b> cookies now. If it's faster to collect <b>X</b> cookies now, you should do that. If it's faster to buy a farm first, buy that farm and then repeat this process (collect enough cookies to buy another farm...).\n</p>\n<p>\nIt's very easy to <i>say</i> that, but it's not as easy to prove it works. How many farms might you end up buying? If it's in the billions, your program might be too slow, and we never proved it wouldn't be. We also didn't prove that it's best to buy a farm <i>right away</i> as soon as you have enough cookies. The rest of this editorial will go into those questions in detail.\n</p>\n<p>\nWe build the intuition for the solution by using geometry. We represent the problem in the 2d plane. Let the x-axis represent time (in seconds) and the y-axis represent the number of cookies. Initially, we gain cookies at the rate of 2 cookies per second which is shown by line L<sub>0</sub> in Figure 1. Let’s say the target number of cookies (X) is 16. We can represent it with line y=16 (L<sub>X</sub>). This means that if we do not buy any cookie farm then the time it takes to get 16 cookies is given by the intersection between L<sub>X</sub> and L<sub>0</sub>. See Figure 1.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3nDEfN7bh_a8BZaB4JPqMNZSQ6Pcoox1-OTvLTv-4RUlla25LF88ycs0G8Npf7rae_tgo9iH9t5gKVMUttsYuxtOY/Figure1CookieClicker.png\">\n<br>\nFigure 1\n</p>\n\n<p>\nNow, let’s delve into what happens (geometrically speaking) when we buy a cookie farm. Let’s say the cost for buying a cookie farm (C) is 6, and the extra cookies per second (F) is 2. In Figure 2, we buy a farm as soon as we have 6 cookies. This means at time = 3, we go from having 6 cookies to 0 cookies (to pay for the cookie farm), and our cookies per second increases to 4. This information is represented by L<sub>1</sub> in Figure 2. Note that the dashed lines represent the drop of current cookies when we buy a cookie farm. Notice that L<sub>0</sub> and L<sub>1</sub> intersect at the 6 second mark (and correspondingly, X=12 cookies). It means that, if our target number of cookies X is anywhere between 0 and 12 then it is not advantageous to buy a cookie farm! Why? Let’s look at an example line L<sub>X</sub>a which is in that range. In Figure 2, we see that L<sub>0</sub> intersects L<sub>X</sub>a earlier (at 4 second mark) than L<sub>1</sub> intersects L<sub>X</sub>a (at 5 second mark). At X = 12 (represented by L<sub>X</sub>b), it does not matter if we buy a cookie farm or not. But if X is higher than 12, for example X = 16 (represented by L<sub>X</sub>), we should buy a cookie farm since L<sub>1</sub> intersect L<sub>X</sub> earlier (at 7 second mark) than L<sub>0</sub> (at 8 second mark). Jumping ahead briefly, we notice a similar behavior for the intersection between L<sub>1</sub>, L<sub>2</sub> and L<sub>X</sub> in Figure 4 (we'll describe how we compute L<sub>2</sub> in subsequent paragraphs). If we choose X = 18, it doesn't matter if we choose L<sub>1</sub> or L<sub>2</sub>, but if X is below 18 then L<sub>1</sub> intersection is better than L<sub>2</sub> intersection, but if X is above 18 then L<sub>2</sub> intersection is better than L<sub>1</sub> intersection.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3mc9ci_f9jwwgv4CkcW2er2WT_kQvBbJ1GluhBSWq6JhT0eckUq9kcRkpS-lOKmYY68Icfwt4RLpspN4agVsKbgmw/Figure2CookieClicker.png\">\n<br>\nFigure 2\n</p>\n\n<p>\nNow we discuss the strategy for how early we should buy a cookie farm i.e. should we buy a cookie farm as soon as we have C cookies, or should we wait a little longer before buying a cookie farm? We claim that we should buy a farm as soon as we have C cookies (and not wait any second longer). \n</p>\n\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3buAL9IpVy8jzxaJD5-k0685ICGCWuQbE8mcRF5JwifZdtxSRsJFLx05hFfVKPEIKMNrVFxmhNGrjZaobdawsnLzM/Figure3CookieClicker.png\">\n<br>\nFigure 3\n</p>\n\n<p>\nIn Figure 3 as before, L<sub>1</sub> represents buying a cookie farm as soon as we have 6 cookies (at 3 second), while L<sub>1</sub>a represents delaying buying a cookie farm by a second (at 4 second). Note that L<sub>1</sub> and L<sub>1</sub>a are going to be parallel to each other (i.e. they have the same rate: 4 cookies for second) but L<sub>1</sub> is located to the left of L<sub>1</sub>a. What does this mean? It means that the intersection between any line L<sub>X</sub> and L<sub>1</sub> will always be at an earlier time than the intersection between L<sub>X</sub> and L<sub>1</sub>a. Therefore we should not wait to buy cookie farms any more than needed. This means that if buying a cookie farm contributes to your winning strategy, then we should buy a cookie farm as soon as possible, i.e. as soon as we have C cookies.\n</p>\n\n<p>\nIn Figure 4, we can observe that the earliest time to buy the first cookie farm is on the intersection of line L<sub>0</sub> with line L<sub>C</sub> (y=C). Then, the earliest time to buy the second cookie farm is on the intersection of line L<sub>1</sub> with L<sub>C</sub>.\n</p>\n\n<p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2YhxkNysOG2hL9bVeK4OrIorFDJX1iIRs3wGiSuGt3f3EmEn2lxBupvXXUp1mqoq-I42Q1J-SLnFoS0sJhxUkd2Vg/Figure4CookieClicker.png\">\n<br>\nFigure 4\n</p>\n\n<p>\nNow, we are ready to describe our solution strategy. We first determine the time t<sub>0</sub> it takes to get X cookies without buying a cookie farm (i.e. intersection between L<sub>0</sub> and L<sub>X</sub>). Then we try to buy 1 cookie farm and figure out the time t<sub>1</sub> it takes to get X cookies (i.e. intersection between L<sub>1</sub> and L<sub>X</sub>). Then compute t<sub>2</sub> for buying another cookie farm (i.e. intersection between L<sub>2</sub> and L<sub>X</sub>), and so on. We stop when t<sub>n+1</sub> is greater than t<sub>n</sub> (i.e. we do worse, in terms of time, by buying an additional cookie farm). For example, in Figure 4, we do worse with L<sub>2</sub> than with L<sub>1</sub> (intersections with L<sub>X</sub>). We finally report  t<sub>n</sub> as our winning time.\n</p>\n\n<p>\nA note on doing the actual line intersection computation follows. We want to compute the line intersections between lines L<sub>0</sub>, L<sub>1</sub>, L<sub>2</sub>, etc and y = C or y = X. Let our current line be L<sub>n</sub> starting at (S<sub>n</sub>, 0) and have a slope of m (i.e. cookies per second after buying n cookie farms). Note that s<sub>0</sub> is 0, and m = 2 + n * F. Then the time required to get A cookies is given as: S<sub>n</sub> + A / m.\n</p>\n\n<p>\nOur solution strategy mentioned above iterates until a winning condition is achieved. But you might be wondering about total iterations needed before we are done. We want to point out that the number of iterations is bounded. In the solution strategy, we noted that the stopping condition for iteration is when we do worse (in terms of time) when buying an additional farm. Let’s formulate that as an equation. Let’s say our current iteration is i with line L<sub>i</sub> with the next line being L<sub>i+1</sub>. The intersection between line y = X and L<sub>i</sub> is given as t<sub>i</sub> = s<sub>i</sub> + X / (2 + i * F), and similarly intersection between line y = X and L<sub>i+1</sub> is given as t<sub>i+1</sub> = s<sub>i+1</sub> + X / (2 + (i + 1) * F). We stop when t<sub>i+1</sub> &gt; t<sub>i</sub>. Note that s<sub>i+1</sub> - s<sub>i</sub> = C / (2 + i * F). After going through some math, we get i &gt; (X / C) - 1 - (2 / F), which is the iteration when t<sub>i+1</sub> becomes bigger than t<sub>i</sub>. Therefore the iteration should terminate around X / C.\n</p>","id":"00000000004331a3","statement":"<h3>Introduction</h3>\n<p>\n<i>Cookie Clicker</i> is a Javascript game by Orteil, where players click on a picture of a giant cookie. Clicking on the giant cookie gives them cookies. They can spend those cookies to buy buildings. Those buildings help them get even more cookies. Like this problem, the game is very cookie-focused. This problem has a similar idea, but it does not assume you have played <i>Cookie Clicker</i>. Please don't go play it now: it might be a long time before you come back.\n</p>\n\n<h3>Problem</h3>\n\n<p>\nIn this problem, you start with 0 cookies. You gain cookies at a rate of 2 cookies per second, by clicking on a giant cookie. Any time you have at least <b>C</b> cookies, you can buy a cookie farm. Every time you buy a cookie farm, it costs you <b>C</b> cookies and gives you an extra <b>F</b> cookies per second.\n</p>\n<p>\nOnce you have <b>X</b> cookies that you haven't spent on farms, you win! Figure out how long it will take you to win if you use the best possible strategy.\n</p>\n\n<h3>Example</h3>\n\n<p>\nSuppose <b>C</b>=500.0, <b>F</b>=4.0 and <b>X</b>=2000.0. Here's how the best possible strategy plays out:\n<ol>\n<li>You start with 0 cookies, but producing 2 cookies per second.</li>\n<li>After <b>250</b> seconds, you will have <b>C</b>=500 cookies and can buy a farm that produces <b>F</b>=4 cookies per second.</li>\n<li>After buying the farm, you have 0 cookies, and your total cookie production is 6 cookies per second.</li>\n<li>The next farm will cost 500 cookies, which you can buy after about <b>83.3333333</b> seconds.</li>\n<li>After buying your second farm, you have 0 cookies, and your total cookie production is 10 cookies per second.</li>\n<li>Another farm will cost 500 cookies, which you can buy after <b>50</b> seconds.</li>\n<li>After buying your third farm, you have 0 cookies, and your total cookie production is 14 cookies per second.</li>\n<li>Another farm would cost 500 cookies, but it actually makes sense not to buy it: instead you can just wait until you have <b>X</b>=2000 cookies, which takes about <b>142.8571429</b> seconds.</li>\n</ol>\nTotal time: 250 + 83.3333333 + 50 + 142.8571429 = 526.1904762 seconds.\n</p>\n<p>\nNotice that you get cookies continuously: so 0.1 seconds after the game starts you'll have 0.2 cookies, and π seconds after the game starts you'll have 2π cookies.\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each line contains three space-separated real-valued numbers: <b>C</b>, <b>F</b> and <b>X</b>, whose meanings are described earlier in the problem statement.\n</p>\n<p>\n<b>C</b>, <b>F</b> and <b>X</b> will each consist of at least 1 digit followed by 1 decimal point followed by from 1 to 5 digits. There will be no leading zeroes.</i>\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of seconds it takes before you can have <b>X</b> delicious cookies.\n</p>\n\n<p>\nWe recommend outputting y to 7 decimal places, but it is not required. y will be considered correct if it is close enough to the correct number: within an absolute or relative error of 10<sup>-6</sup>.  See the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an explanation of what that means, and what formats of real numbers we accept. \n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>C</b> &le; 500.<br/>\n1 &le; <b>F</b> &le; 4.<br/>\n1 &le; <b>X</b> &le; 2000.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>C</b> &le; 10000.<br/>\n1 &le; <b>F</b> &le; 100.<br/>\n1 &le; <b>X</b> &le; 100000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n30.0 1.0 2.0\n30.0 2.0 100.0\n30.50000 3.14159 1999.19990\n500.0 4.0 2000.0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.0000000\nCase #2: 39.1666667\nCase #3: 63.9680013\nCase #4: 526.1904762\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Note</h3>\n<p>\n<i>Cookie Clicker</i> was created by Orteil. Orteil does not endorse and has no involvement with Google Code Jam.\n</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":11}],"title":"Cookie Clicker Alpha","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432add","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2014"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
