{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1497112200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201902","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Round 3 started off with the relatively accessible <i>Googlements</i> problem,\n  in which a bit of combinatorics knowledge saved some time.\n  <i>Good News and Bad News</i> asked contestants to assign weights to directed\n  edges in a graph to achieve a particular goal; it could be solved via a\n  construction or a sufficiently well-designed randomized algorithm.\n  <i>Mountain Tour</i> was a complex-looking graph problem that boiled down to\n  one interesting key insight, and <i>Slate Modern</i> was a challenging\n  implementation exercise to round out the set.\n</p><p>\n  It was an exciting contest! The lead changed many times in the first hour and a half. Gennady.Korotkevich was the first to hit 74 points, with vepifanov following a mere 8 seconds later! kevinsogo was the\n  first of only four contestants to solve the tough Large of Slate Modern, over an hour and a half into the contest, and that plus other solves propelled him to a victory; he was the only contestant to reach 76 points. The Large of Mountain Tour was more widely solved, and the cutoff for the top 25 turned out to be 74 points and a finishing time under 2:30.\n</p><p>\n  We'll see our finalists in August in Dublin, where they will compete for a\n  $15,000 prize and the title of Code Jam World Champion! Will\n  Gennady.Korotkevich successfully defend his title to become a\n  consecutive four-time champion? Or will kevinsogo, who took second place in last year's Finals, repeat the first-place performance that we just saw in Round 3? Or will we see something completely different? Find out next time!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Problem A (Googlements): Written and prepared by Ian Tullis.\n</p><p>\n  Problem B (Good News and Bad News): Written by Petr Mitrichev. Prepared by\n  Ian Tullis.\n</p><p>\n  Problem C (Mountain Tour): Written by David Arthur. Prepared by Shane Carr.\n</p><p>\n  Problem D (Slate Modern): Written by Pablo Heiber. Prepared by Petr\n  Mitrichev.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, John\n  Dethridge, Jackson Gatenby, Md Mahbubul Hasan, Zhusong Li, Petr Mitrichev,\n  Trung Thanh Nguyen, and Josef Ziegler.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Googlements: Ian Tullis</li>\n  <li>Good News and Bad News: Pablo Heiber and Ian Tullis</li>\n  <li>Mountain Tour: Shane Carr</li>\n  <li>Slate Modern: Pablo Heiber</li>\n</ul>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1497103200000,"tasks":[{"analysis":"<h2>Googlements: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  In the Small dataset, the googlements can have a maximum length of 5. We will\n  discuss googlements of that length; the procedure for shorter ones is the\n  same.\n</p><p>\n  Any string of length 5 that uses digits only in the range [0, 5] and is not\n  <code>00000</code> is a googlement; there are 6<sup>5</sup> - 1 = 7775 of\n  these. One workable solution is to iterate through all of these possible\n  googlements and simulate the decay process for each one until it reaches the\n  sole possible looping end state of <code>10000</code>. As we do this, for\n  each googlement, we maintain a count of how many decay chains it appears in.\n  When we are finished, we will know how many possible ancestors each\n  googlement has, and so we will have the answer to every possible Small test\n  case!\n</p><p>\n  Later in this analysis, we will show why <code>10000</code> is the only\n  googlement of length 5 that is its own descendant, and we will look into how\n  long a decay chain can go on. Even if each chain were somehow as long as the\n  number of googlements, though, with only 7775 googlements, this method would\n  still easily run fast enough to solve the Small.\n</p><p>\n  That approach is \"top-down\"; a \"bottom-up\" approach to this tree problem also\n  works. For a given googlement, we can figure out what digits must have been\n  in the googlement that created it (its \"direct ancestor\"). For example, if we\n  are given <code>12000</code>, we know that any direct ancestor must have one\n  <code>1</code>, two <code>2</code>s, and two <code>0</code>s to bring the\n  total number of digits to five. Then we can create all such googlements\n  (e.g., <code>12020</code>) and recursively count <i>their</i> direct\n  ancestors (e.g., <code>42412</code>) in the same way. This process does not\n  go on forever, because (as we noted above) there are at most 7775 googlements\n  in the tree. The worst-case scenario is <code>10000</code>, which is a\n  descendant of every googlement.\n</p><p>\n  After thinking through the bottom-up approach, only implementation details\n  remain. The toughest part is generating direct ancestors with particular\n  counts of particular digits. A permutation library can help, or we can write\n  code to generate permutations in a way that avoids repeatedly considering\n  duplicates. We can save some time across test cases by memoizing results for\n  particular nodes of the tree, since the decay behavior of a given googlement\n  is always exactly the same, and some of the same googlements could (and\n  probably will) show up many times in different cases.\n</p>\n<h3>Large dataset</h3>\n<p>\n  In the bottom-up Small approach outlined above, we spent a lot of time\n  generating new direct ancestors to check. For ancestors such as\n  <code>12020</code> that themselves had direct ancestors, this was necessary.\n  However, it was a waste of time to construct and enumerate ancestors\n  such as <code>42412</code>, which have no ancestors of their own. More\n  generally, a googlement of length L with a digit sum of more than L cannot\n  have any ancestors, since it is impossible to fit more than L digits into a\n  length of L.\n</p><p>\n  It turns out that avoiding enumerating these ancestor-less ancestors saves\n  enough time to turn that bottom-up Small solution into a Large solution. We\n  can do that with some help from combinatorics and the\n  <a href=\"https://en.wikipedia.org/wiki/Multinomial_theorem#Interpretations\">multinomial theorem</a>.\n</p><p>\n  Let's think again about the direct ancestors of <code>12020</code>. Each must\n  have one <code>1</code>, two <code>2</code>s, and two <code>4</code>s. How\n  many ways are there to construct such a string? Starting with a blank set of\n  5 digits, there are (5 choose 2) = 10 ways to place the <code>2</code>s, then\n  (3 choose 2) = 3 ways to place the <code>4</code>s into two of the three\n  remaining slots, then (1 choose 1) = 1 ways to place the leftover\n  <code>1</code>. These terms multiply to give us a total of 30 ways, so\n  <code>12020</code> has 30 direct ancestors. Since each has a digit sum of 13,\n  which is greater than 5, none of them have their own ancestors. So we do not\n  care what they are; we can just add 30 to our total.\n</p><p>\n  At this point, we can either test this improvement on the worst-case\n  googlement <code>100000000</code> before downloading the Large dataset, or\n  we can reassure ourselves via more combinatorics. The googlements of length 9\n  with ancestors are the ones with a digit sum less than or equal to 9; we can\n  use a\n  <a href=\"https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)\">balls-in-boxes argument</a>\n  to find that that number is (10 + 9 - 1)! / (10! * (9-1)!), which is 92377.\n  This is a tiny fraction of the 999999999 possible googlements of length 9; we\n  have avoided enumerating the other 999900000 or so! As long as our method for\n  generating ancestors doesn't impose too much overhead, this is easily fast\n  enough to solve 100 Large test cases in time, even if most or all of them\n  explore most or all of the tree.\n</p>\n<h3>Appendix: Some justifications</h3>\n<p>\n  Let's prove that there is only one looping state for a given googlement\n  length, and that there are no other loops in the graph. We will start with\n  some observations.\n</p>\n<ul>\n  <li>When a googlement decays, the number of non-<code>0</code> digits in\n    the googlement equals the sum of the digits in the googlement it decays\n    into.</li>\n  <li>Because of this, any googlement that has a digit other than\n    <code>0</code>s or <code>1</code>s will decay into a googlement with a\n    smaller digit sum.</li>\n  <li>Any googlement consisting only of <code>0</code>s and <code>1</code>s\n    will decay into a googlement with the same digit sum. If the googlement\n    is <code>1</code> followed by zero or more <code>0</code>s, it will decay\n    into itself. If the googlement has a single <code>1</code> at another position,\n    it will decay into a <code>1</code> followed by <code>0</code>s. Otherwise, it\n    must have at least two <code>1</code>s, so it will decay into a googlement with\n    the same digit sum but with at least one digit other than <code>0</code> or\n    <code>1</code>.</li>\n</ul>\n<p>\n  We can draw some useful conclusions from the above observations:\n</p>\n<ul>\n  <li>The <i>only</i> googlement of length L that can decay into itself is a\n    <code>1</code> followed by L-1 <code>0</code>s. For any other googlement,\n    decay would either reduce its digit sum or create a new googlement with\n    a digit other than <code>0</code> or <code>1</code>, which would itself\n    decay into a googlement with a smaller digit sum.</li>\n  <li>It can take at most two steps for a chain of googlements to lose at least\n    one point of digit sum. This puts a bound on the height of the decay tree;\n    it can be at most 2 times the maximum possible digit sum. (Moreover, it is\n    even less than this; for example, a googlement of <code>999999999</code>\n    will immediately decay into <code>000000009</code>, losing a large amount\n    of its digit sum.</li>\n</ul>\n","id":"00000000002017f6","statement":"<h3>Problem</h3>\n<p>\n  Chemists work with periodic table elements, but here at Code Jam, we have\n  been using our advanced number smasher to study <i>googlements</i>. A\n  googlement is a substance that can be represented by a string of at most\n  nine digits. A googlement of length L must contain only decimal digits in the\n  range 0 through L, inclusive, and it must contain at least one digit greater\n  than 0. Leading zeroes are allowed. For example, <code>103</code> and\n  <code>001</code> are valid googlements of length 3. <code>400</code>\n  (which contains a digit, 4, greater than the length of the googlement, 3) and\n  <code>000</code> (which contains no digit greater than 0) are not.\n</p><p>\n  Any valid googlement can appear in the world at any time, but it will\n  eventually decay into another googlement in a deterministic way, as follows.\n  For a googlement of length L, count the number of <code>1</code>s in the\n  googlement (which could be 0) and write down that value, then count the\n  number of <code>2</code>s in the googlement (which could be 0) and write down\n  that value to the right of the previous value, and so on, until you finally\n  count and write down the number of Ls. The new string generated in this way\n  represents the new googlement, and it will also have length L. It is even\n  possible for a googlement to decay into itself!\n</p><p>\n  For example, suppose that the googlement <code>0414</code> has just appeared.\n  This has one <code>1</code>, zero <code>2</code>s, zero <code>3</code>s, and\n  two <code>4</code>s, so it will decay into the googlement <code>1002</code>.\n  This has one <code>1</code>, one <code>2</code>, zero <code>3</code>s, and\n  zero <code>4</code>s, so it will decay into <code>1100</code>, which will\n  decay into <code>2000</code>, which will decay into <code>0100</code>, which\n  will decay into <code>1000</code>, which will continuously decay into itself.\n</p><p>\n  You have just observed a googlement <b>G</b>. This googlement might have just\n  appeared in the world, or it might be the result of one or more decay steps.\n  What is the total number of possible googlements it could have been when it\n  originally appeared in the world?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of one line with a string\n  <b>G</b>, representing a googlement.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1) and\n  <code>y</code> is the number of different googlements that the observed\n  googlement could have been when it first appeared in the world.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Each digit in <b>G</b> is a decimal digit between 0 and the length of\n  <b>G</b>, inclusive.<br/>\n  <b>G</b> contains at least one non-zero digit.<br/>\n</p>\n\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n  1 &le; the length of <b>G</b> &le; 5.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n  1 &le; the length of <b>G</b> &le; 9.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n20\n1\n123\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4\nCase #2: 1\nCase #3: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In sample case #1, the googlement could have originally been\n  <code>20</code>, or it could have decayed from <code>11</code>, which could\n  have itself decayed from <code>12</code> or <code>21</code>. Neither of the\n  latter two could have been a product of decay. So there are four\n  possibilities in total.\n</p><p>\n  In sample case #2, the googlement must have originally been <code>1</code>,\n  which is the only possible googlement of length 1.\n</p><p>\n  In sample case #3, the googlement must have been <code>123</code>; no other\n  googlement could have decayed into it.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":3},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Googlements","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Good News And Bad News: Analysis</h2>\n\n<p>\n  The ordered pairs of friends form a directed graph in which each friend is a\n  node and each news path is an edge. Notice that we can work on one connected\n  component at a time, because each can be solved independently of the others.\n  In the following, we assume a connected graph.\n</p><p>\n  One additional observation is that if any edge of the undirected graph is a\n  <a href=\"https://en.wikipedia.org/wiki/Bridge_(graph_theory)\">bridge</a>\n  &mdash; that is, an edge not present in any cycle &mdash; then the task is\n  impossible. This is a consequence of the news balance on nodes extending to\n  subsets of nodes: if we group nodes on each side of the bridge, the aggregate\n  balance of each subset must be zero, and values in edges internal to the\n  subset don't affect that balance. Since the bridge is the only external edge,\n  this forces its value to be zero. Formally, the news balance property is\n  preserved by\n  <a href=\"https://en.wikipedia.org/wiki/Edge_contraction#Vertex_identification\">vertex identification</a>,\n  and we can identify all vertices on each side of the bridge to reach a\n  contradiction.\n</p><p>\n  Note that since we can pass positive or negative news on each edge, we can\n  forget about the directions of edges in our graph, and consider it as\n  undirected. If the directed version had opposing edges (v, w) and (w, v), the\n  undirected version can just have two edges between v and w. After solving the\n  problem on the undirected graph, we simply adjust the sign of the value we\n  assign to each edge according to its original direction.\n</p>\n<h3>Small dataset</h3>\n<p>\n  The Small dataset can have up to 4 friends, so there can be as many as 12\n  edges. The bad news is that with up to 2 × 4<sup>2</sup> = 32 possible legal\n  values for each of those edges, there can be 32<sup>12</sup> possible answers\n  to check, which is far too large to handle with brute force. The good news is\n  that there are only on the order of 2<sup>12</sup> graphs to consider; we can\n  rule out the ones that have bridges (since those are impossible), and then\n  run whatever method we come up with on all of the others to see if we get\n  solutions.\n</p><p>\n  What if we don't really need the full extent of the [-16, 16] range? We can\n  try restricting our values to a smaller set and see whether we get solutions.\n  As Sample Case #5 demonstrates, we might need negative values, so we can try\n  a set like {-2, -1, 1, 2, 3}, for instance. It turns out that this set alone\n  is enough to solve all possible Small cases that do not contain a bridge, so\n  we can use brute force to find all possible assignments.\n</p>\n<h3>Large dataset</h3>\n<p>\n  Judging by the Small solution, we may believe that all bridgeless graphs do\n  have a solution, and that's indeed the case (as we will see in Solution 2,\n  below).\n</p><p>\n  <i>Solution 1.</i> Start by using\n  <a href=\"https://en.wikipedia.org/wiki/Depth-first_search\">depth-first search</a>\n  to build a\n  <a href=\"https://en.wikipedia.org/wiki/Spanning_tree\">spanning tree</a> of\n  the underlying undirected graph. Assign all non-tree edges a random nonzero\n  value in [-K, K]. Now, the current balance of each node is some integer. In\n  leaf-to-root order, we can go through all nodes using the single non-assigned\n  edge remaining to make the balance zero. Notice that if we fix all <b>F</b>-1\n  non-root nodes, the root is automatically fixed, because the sum of the\n  balance over all nodes always equals 0 (an edge with value v contributes v to\n  one balance and -v to another). Notice that it is possible that a node's\n  balance is 0 when we need to fix it, leaving us no non-zero choice for the\n  corresponding tree edge. Additionally, if the balance on a node is too high,\n  the value we need for the corresponding edge could be out of range. However,\n  a value for K around <b>F</b> yields a small probability of both, which we\n  can find through experimentation. And, if we happen to run into a problem, we\n  can re-run the algorithm. As long as the probability of success is a\n  not-too-small constant, running it enough times will eventually yield a valid\n  assignment. Since we can implement this in linear time, and the bounds are\n  small, we can afford thousands of runs per test case, or possibly more. So,\n  even with weak experimental data on the probabilities, we can build enough\n  confidence that this method works. Notice that we can avoid explicitly\n  checking for bridges by assuming that failure after 1000 or so retries means\n  the case is impossible.\n</p><p>\n  <i>Solution 2</i>. Again, find a DFS spanning tree of the graph and number\n  the nodes in discovery order. Remember that in a DFS over an undirected\n  graph, every non-tree edge goes from a node to some ancestor in the tree.\n  Direct all edges in root-to-leaf direction (we reverse or split edges after\n  solving, as explained above). We assign edges not in the tree a value of 1,\n  that is, they send positive news from nodes to descendants. On the other\n  hand, we assign negative values to tree edges. We process the nodes in\n  reverse discovery order: as in the previous randomized solution, each node\n  has a single adjacent edge with no assigned value, so we assign it the only\n  value that makes the node balanced.\n</p><p>\n  Let us prove that the values assigned this way are all negative if there is\n  no bridge or contain a zero if there is a bridge: assume a value of 0 for\n  unassigned edges to check the current balance of a node x right before we\n  attempt to balance it. Let A be the set of descendants of x, including x\n  itself. There is exactly one tree edge going into A: the edge that we are\n  trying to assign at this step. Let us call it e. All other edges going into A\n  are non-tree, so they all have a value of 1. The current aggregate balance of\n  A then equals the number of non-tree edges going into A. Since nodes are\n  processed in leaf-to-root order, all nodes in A other than x are balanced,\n  and A's balance equals x's balance. If the number is zero, then there are no\n  edges other than e going into A, which makes e a bridge. If the number is\n  greater than 0 (it is a number of edges, so it can't be negative), the\n  current balance of x is greater than 0 and we can assign its opposite, a\n  negative number, to e. This value is always within the legal\n  [-<b>F</b><sup>2</sup>, <b>F</b><sup>2</sup>] range, because its magnitude is\n  equal to some number of edges in the graph, and the total number of edges in\n  the graph cannot exceed <b>F</b> &times; (<b>F</b> - 1), which is less than\n  <b>F</b><sup>2</sup>.\n</p><p>\n  <i>Solution 3</i>. We keep the nodes balanced at all times. Start with 0 on\n  all edges. For each undirected edge, if it has a 0 in the current valuation,\n  find a cycle that contains it and then add -K to all edges of the cycle,\n  where K is an integer different from the current values of all edges in the\n  cycle. This choice of K guarantees that the procedure doesn't change a\n  non-zero edge into zero, and it always changes at least one zero edge into a\n  non-zero (the current edge), so it always finishes. Adding a value to edges\n  in a cycle maintains the balance of each node. If we choose K with minimum\n  possible absolute value, and cycles as short as possible, this won't exceed\n  the range. The easy to prove maximum absolute value this can produce is\n  <b>F</b> &times; <b>P</b> / 2, because K is always in the range\n  [-<b>F</b>/2, <b>F</b>/2] as there can't be more than <b>F</b> forbidden\n  values for it. There are also at most <b>P</b> steps. However, there are many\n  results showing that graphs with many edges have lots of short cycles, so\n  we believe it's impossible to construct a case in which the range is\n  exceeded. Further, if we randomize the order to fix edges and retry many\n  times, we can work around the worst cases that specifically try to overload a\n  given edge, but possibly produce lots of small cycles that help fix the\n  others cheaply. Notice that the idea of using the DFS tree to fix balances in\n  the previous solutions is actually the same idea from this theoretically\n  simpler solution, but using the\n  <a href=\"https://en.wikipedia.org/wiki/Cycle_basis#Fundamental_cycles\">fundamental cycles</a>\n  of the graph instead of potentially all of them.\n</p>\n","id":"0000000000201846","statement":"<h3>Problem</h3>\n<p>\n  You would like to get your <b>F</b> friends to share some news. You know your\n  friends well, so you know which of your friends can talk to which of your\n  other friends. There are <b>P</b> such one-way relationships, each of which is\n  an ordered pair (<b>A<sub>i</sub></b>, <b>B<sub>i</sub></b>) that means that\n  friend <b>A<sub>i</sub></b> can talk to friend <b>B<sub>i</sub></b>. It does\n  not imply that friend <b>B<sub>i</sub></b> can talk to\n  friend <b>A<sub>i</sub></b>; however, another of the ordered pairs might make\n  that true.\n</p><p>\n  For <i>every</i> such existing ordered pair (<b>A<sub>i</sub></b>,\n  <b>B<sub>i</sub></b>), you want friend <b>A<sub>i</sub></b> to deliver some\n  news to friend <b>B<sub>i</sub></b>. In each case, this news will be\n  represented by an integer value; the magnitude of the news is given by the\n  absolute value, and the type of news (good or bad) is given by the sign. The\n  integer cannot be 0 (or else there would be no news!), and its absolute value\n  cannot be larger than <b>F</b><sup>2</sup> (or else the news would be just\n  <i>too</i> exciting!). These integer values may be different for different\n  ordered pairs.\n</p><p>\n  Because you are considerate of your friends' feelings, for each friend, the\n  sum of the values of all news given <i>by</i> that friend must equal the sum\n  of values of all news given <i>to</i> that friend. If no news is given by\n  a friend, that sum is considered to be 0; if no news is given to a\n  friend, that sum is considered to be 0.\n</p><p>\n  Can you find a set of news values for your friends to communicate such that\n  these rules are obeyed, or determine that it is impossible?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with two integers\n  <b>F</b> and <b>P</b>: the number of friends, and the number of different\n  ordered pairs of friends.\n  Then, <b>P</b> more lines follow; the i-th of these lines has two different\n  integers <b>A<sub>i</sub></b> and <b>B<sub>i</sub></b> representing that\n  friend <b>A<sub>i</sub></b> can talk to friend <b>B<sub>i</sub></b>.\n  Friends are numbered from 1 to <b>F</b>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code> is\n  either <code>IMPOSSIBLE</code> if there is no arrangement satisfying the rules\n  above, or, if there is such an arrangement, <b>P</b> integers, each of which\n  is nonzero and lies inside [-<b>F</b><sup>2</sup>, <b>F</b><sup>2</sup>]. The\n  i-th of those integers corresponds to the i-th ordered pair from the input,\n  and represents the news value that the first friend in the ordered pair will\n  communicate to the second. The full set of values must satisfy the conditions\n  in the problem statement.\n</p><p>\n  If there are multiple possible answers, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>A<sub>i</sub></b> &le; <b>F</b>, for all i.<br/>\n  1 &le; <b>B<sub>i</sub></b> &le; <b>F</b>, for all i.<br/>\n  <b>A<sub>i</sub></b> &ne; <b>B<sub>i</sub></b>, for all i. (A friend does not\n    self-communicate.)<br/>\n  (<b>A<sub>i</sub></b>, <b>B<sub>i</sub></b>) &ne; (<b>A<sub>j</sub></b>,\n    <b>B<sub>j</sub></b>), for all i &ne; j. (No pair of friends is repeated\n    within a test case in the same order.)<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n  2 &le; <b>F</b> &le; 4.<br/>\n  1 &le; <b>P</b> &le; 12.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 40 seconds.<br/>\n  2 &le; <b>F</b> &le; 1000.<br/>\n  1 &le; <b>P</b> &le; 2000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2 2\n1 2\n2 1\n2 1\n1 2\n4 3\n1 2\n2 3\n3 1\n3 4\n1 2\n2 3\n3 1\n2 1\n3 3\n1 3\n2 3\n1 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1 1\nCase #2: IMPOSSIBLE\nCase #3: -1 -1 -1\nCase #4: 4 -4 -4 8\nCase #5: -1 1 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  The sample output shows one possible set of valid answers. Other valid\n  answers are possible.\n</p><p>\n  In Sample Case #1, one acceptable arrangement is to have friend 1 deliver\n  news with value 1 to friend 2, and vice versa.\n</p><p>\n  In Sample Case #2, whatever value of news friend 1 gives to friend 2, it\n  must be nonzero. So, the sum of news values given to friend 2 is not equal\n  to zero. However, friend 2 cannot give any news and so that value is 0.\n  Therefore, the sums of given and received news for friend 2 cannot match, and\n  the case is <code>IMPOSSIBLE</code>.\n</p><p>\n  In Sample Case #3, each of friends 1, 2, and 3 can deliver news with value -1\n  to the one other friend they can talk to &mdash; an unfortunate circle of bad\n  news! Note that there is a friend 4 who does not give or receive any news;\n  this still obeys the rules.\n</p><p>\n  In Sample Case #4, note that <code>-5 5 5 -10</code> would not have been an\n  acceptable answer, because there are 3 friends, and |-10| &gt; 3<sup>2</sup>.\n</p><p>\n  In Sample Case #5, note that the case cannot be solved without using at least\n  one negative value.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Good News and Bad News","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Mountain Tour: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  Since each hiking tour can be taken only once, each of the hiking tours\n  arriving at a camp must be followed by a different departing tour. Since each\n  camp has two arriving and two departing tours, there are exactly two ways to\n  &ldquo;pair&rdquo; the hiking tours at a camp: the first arrival with the\n  first departure (and the second arrival with the second departure), or the\n  first arrival with the second departure (and the second arrival with the\n  first departure). We can think of a candidate solution as specifying this\n  boolean decision for each camp. The total duration is the sum of each hiking\n  trip's duration and the amount of time waiting at each camp.\n</p><p>\n  When evaluating a possible solution, you must check whether or not every\n  hiking tour is present on the path beginning with your start hike. It is\n  possible for a path through the graph to represent a cycle with fewer than\n  2<b>C</b> edges. For example, the left side of the figure farther down on the\n  page shows a setup with three disjoint paths through the graph.\n</p><p>\n  Because the time spent waiting at the base camp is calculated differently\n  than the time spent waiting at all other camps, the base camp needs to be\n  handled as a special case. You could simply run the algorithm four times,\n  once for each &ldquo;start&rdquo; and &ldquo;end&rdquo; hike.\n</p><p>\n  The entire space can be explored in O(2<sup><b>C</b></sup>) time, which is\n  sufficient for the Small dataset with <b>C</b>&nbsp;&le;&nbsp;15.\n</p><p>\n  Another way to look at the small dataset is as a special case of the\n  Travelling Salesman Problem (TSP). Consider the directed graph in which each\n  hiking tour is a node and edges are the possible pairings between hiking\n  tours, four for each camp, with edge weights corresponding to the amount of\n  time you would have to wait at the camp in order to make that transfer. For\n  example, if hiking tour A arrived at node 1 at time 02:00, and hiking tour B\n  left node 1 at time 06:00, there would be an edge from A to B with weight 4.\n  Running TSP on this graph, again with special handling for the base camp, can\n  also yield a correct solution.\n</p>\n\n<h3>Large dataset</h3>\n\n<p>\n  Let's look more closely at the two possible arrival-departure pairings for\n  each camp. Suppose a camp has tours arriving at 13:00 and 21:00 and tours\n  leaving at 22:00 and 07:00, such that there are no departures between the\n  times that the two tours arrive. If the 13:00 arrival were paired with the\n  22:00 departure and the 21:00 arrival were paired with the 07:00 departure,\n  the total wait time at the camp would be (22&nbsp;&ndash;&nbsp;13)&nbsp;+\n  ((7&nbsp;&ndash;&nbsp;21)&nbsp;mod&nbsp;24) =&nbsp;19&nbsp;hours. If we did\n  the other pairing, the total wait time would be\n  (22&nbsp;&ndash;&nbsp;21)&nbsp;+ ((7&nbsp;&ndash;&nbsp;13)&nbsp;mod&nbsp;24)\n  =&nbsp;19&nbsp;hours.  Both pairings result in the same total wait time at\n  the camp.  We will call these camps the &ldquo;free&rdquo; camps.\n</p><p>\n  Now consider a camp having tours arriving at 11:00 and 23:00 and tours\n  leaving at 17:00 and 08:00, such that after each tour arrives, there is a\n  tour that leaves before the other tour arrives. If the 11:00 arrival were\n  paired with the 17:00 departure and the 23:00 arrival were paired with the\n  08:00 departure, the total wait time at the camp would be\n  (17&nbsp;&ndash;&nbsp;11)&nbsp;+ ((8&nbsp;&ndash;&nbsp;23)&nbsp;mod&nbsp;24)\n  =&nbsp;15&nbsp;hours. If we did the other pairing, the total wait time would\n  be ((17&nbsp;&ndash;&nbsp;23)&nbsp;mod&nbsp;24)&nbsp;+\n  ((8&nbsp;&ndash;&nbsp;11)&nbsp;mod&nbsp;24) =&nbsp;39&nbsp;hours, 24 hours\n  longer than the other pairing.\n</p><p>\n  We mentioned that for the small solution, you must ensure that every hiking\n  tour is present on the path starting from the base camp. What does the graph\n  look like if there are hiking tours that are not present on that path? It is\n  a set of disjoint <em>cycles</em>. Each camp has two paths crossing through\n  it.  If those paths are on different cycles, switching the pairing of that\n  camp will in effect merge the two cycles together.\n</p><p>\n  For example, consider the following figure with 5 camps. Camps 2 and 5 are\n  free, and camps 3 and 4 are 24-hour switches. The initial graph has 3\n  disjoint cycles. As it turns out, to merge all of the cycles together, it is\n  necessary to switch the pairing of camp 5 for free and either camp 3 or camp\n  4 for a 24-hour penalty. Note that the red path, the one starting and ending\n  at the base camp, does not pass through camp 5 prior to switching the\n  pairings, but switching the pairing of camp 5 is nonetheless required.\n</p><p>\n  <img alt=\"A graph with three disjoint cycles requires switching two camp pairings. One of the switches is free, and the other costs 24 hours.\" src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1uFjUenEn59ZyErolJMlXfmvrTMLR1I1SJC2UvlaX-xlXuDH6wWvSvTK2pcgAUs0K9THszD-eV/mt3cycle1.png\">\n<p>\n  In this initial state, wait times are minimized, but there are several disjoint cycles.\n</p>\n  <img alt=\"The same example, modified to have only one cycle.\" src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1oQI78wTFgz-C8Saw4MwBStZQqRvHMsjW7LOx7rI9C8pmhXjw228Ij4T--i5xi7Gy-N9u3mKYa/mt3cycle2.png\">\n<p>\n  Now there is only one cycle.\n</p><p>\n  Thus, to solve the problem efficiently, add each hiking tour to a\n  <a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure\" target=\"_blank\">Disjoint Sets data structure</a>.\n  Iterate through each camp. If the camp is free, union all four hiking tours\n  connected to that camp into the same set (this is analogous to letting the\n  free camps take either pairing); otherwise, union each arrival with only its\n  respective departure.  You will end up with one disjoint set per cycle in the\n  graph. If there are <b>Q</b>&nbsp;&gt;&nbsp;1 disjoint sets, since all of the\n  free camps have already been accounted for, you will need to switch the\n  pairing of <b>Q</b>&nbsp;&ndash;&nbsp;1 camps with 24-hour penalties. These\n  <b>Q</b>&nbsp;&ndash;&nbsp;1 camps are guaranteed to exist. The base camp\n  still needs special handling; you can afford to run the algorithm once for\n  each of the four possible start and end hikes. The total duration is the sum\n  of all the hiking tour durations plus the lowest waiting time at each camp\n  plus 24 hours for each of the <b>Q</b>&nbsp;&ndash;&nbsp;1 penalties. This\n  solution takes O(<b>C</b>&nbsp;&alpha;(<b>C</b>)) time, where\n  &alpha;(<b>C</b>), the\n  <a href=\"https://en.wikipedia.org/wiki/Ackermann_function#Inverse\" target=\"_blank\">inverse Ackermann function</a>,\n  is the amortized time per operation on the Disjoint Sets data structure.\n</p>\n","id":"0000000000201877","statement":"<h3>Problem</h3>\n<p>\n  You are on top of Mount Everest, and you want to enjoy all the nice hiking\n  trails that are up there. However, you know from past experience that\n  climbing around on Mount Everest alone is bad &mdash; you might get lost in\n  the dark! So you want to go on hikes at pre-arranged times with tour guides.\n</p><p>\n  There are <b>C</b> camps on the mountain (numbered 1 through <b>C</b>), and\n  there are 2 &times; <b>C</b> one-way hiking tours (numbered 1 through 2\n  &times; <b>C</b>). Each hiking tour starts at one camp and finishes at a\n  different camp, and passes through no other camps in between. Mount Everest\n  is sparsely populated, and business is slow; there are exactly 2 hiking tours\n  departing from each camp, and exactly 2 hiking tours arriving at each camp.\n</p><p>\n  Each hiking tour runs daily. Tours 1 and 2 start at camp 1, tours 3 and 4\n  start at camp 2, and so on: in general, tour 2 &times; i - 1 and tour 2\n  &times; i start at camp i. The i-th hiking tour ends at camp number\n  <b>E<sub>i</sub></b>, leaves at hour <b>L<sub>i</sub></b>, and has a duration\n  of exactly <b>D<sub>i</sub></b> hours.\n</p><p>\n  It is currently hour 0; the hours in a day are numbered 0 through 23. You are\n  at camp number 1, and you want to do each of the hiking tours\n  <i>exactly once</i> and end up back at camp number 1. You cannot travel\n  between camps except via hiking tours. While you are in a camp, you may wait\n  for any number of hours (including zero) before going on a hiking tour, but\n  you can only start a hiking tour at the instant that it departs.\n</p><p>\n  After looking at the tour schedules, you have determined that it is\n  definitely possible to achieve your goal, but you want to do it as fast as\n  possible. If you plan your route optimally, how many hours will it take you\n  to finish all of the tours?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with an integer\n  <b>C</b>: the number of camps. Then, 2 &times; <b>C</b> more lines follow.\n  The i-th of these lines (counting starting from 1) represents one hiking tour\n  starting at camp number floor((i + 1) / 2), and contains three integers\n  <b>E<sub>i</sub></b>, <b>L<sub>i</sub></b>, and <b>D<sub>i</sub></b>, as\n  described above. Note that this format guarantees that exactly two tours\n  start at each camp.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the minimum number of hours that it will take you to achieve your goal,\n  as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>E<sub>i</sub></b> &le; <b>C</b>.<br/>\n  <b>E<sub>i</sub></b> &ne; ceiling(i / 2), for all i. (No hiking tour\n    starts and ends at the same camp.)<br/>\n  size of {j : <b>E<sub>j</sub></b> = i} = 2, for all j. (Exactly two tours\n    end at each camp.)<br/>\n  0 &le; <b>L<sub>i</sub></b> &le; 23.<br/>\n  1 &le; <b>D<sub>i</sub></b> &le; 1000.<br/>\n  There is at least one route that starts and ends at camp 1 and includes each\n    hiking tour exactly once.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  2 &le; <b>C</b> &le; 15.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n  2 &le; <b>C</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2\n2 1 5\n2 0 3\n1 4 4\n1 6 3\n4\n3 0 24\n2 0 24\n4 0 24\n4 0 24\n2 0 24\n1 0 24\n3 0 24\n1 0 24\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 32\nCase #2: 192\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In sample case #1, the optimal plan is as follows:\n</p>\n<ul>\n  <li>Wait at camp 1 for an hour, until it becomes hour 1.\n  <li>Leave camp 1 at hour 1 to take the 5 hour hiking tour; arrive at camp 2\n    at hour 6.\n  </li>\n  <li>Immediately leave camp 2 at hour 6 to take the 3 hour hiking tour;\n    arrive at camp 1 at hour 9.</li>\n  <li>Wait at camp 1 for 15 hours, until it becomes hour 0 of the next day.\n  </li>\n  <li>Leave camp 1 at hour 0 to take the 3 hour hiking tour; arrive at camp 2\n    at hour 3.</li>\n  <li>Wait at camp 2 for 1 hour, until it becomes hour 4.</li>\n  <li>Leave camp 2 at hour 4 to take the 4 hour hiking tour; arrive at camp 1\n    at hour 8.</li>\n</ul>\n<p>\n  This achieves the goal in 1 day and 8 hours, or 32 hours. Any other plan\n  takes longer.\n</p><p>\n  In sample case #2, all of the tours leave at the same time and are the\n  same duration. After finishing any tour, you can immediately take another\n  tour. If we number the tours from 1 to 8 in the order in which they appear in\n  the test case, one optimal plan is: 1, 5, 4, 7, 6, 2, 3, 8.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":24}],"title":"Mountain Tour","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Slate Modern: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\nTo formalize the reasoning about this problem and yield both an\nalgorithm and a proof of its correctness we will resort to some graph theory.\nConsider an undirected graph G where the set of\n<b>R</b> &times; <b>C</b> + 1 nodes is the set of cells in the painting\nplus an additional special node we call root. We add an edge between each\npair of adjacent cells with length <b>D</b> and for each cell that has\na fixed brightness value v we add an edge from the root to the cell node\nwith length v.\n</p><p>\nLet p(c) be the length of the\n<a href=\"https://en.wikipedia.org/wiki/Shortest_path_problem\">shortest path</a> on G from the\nroot to the node that represents cell c.\n</p><p>\nProperty 1. The p(c) is an upper bound on the value that can be assigned to c. Let<br/>\nroot, a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>k</sub>=c<br/>\nbe the path of k edges\nfrom the root to c of total length p(c). By construction of G, a<sub>1</sub> is a fixed cell.\nLet v be a<sub>1</sub>'s value. Also by construction, the edge (root, a<sub>1</sub>) has length v\nand all other edges (a<sub>i</sub>, a<sub>i+1</sub>) have length <b>D</b>.\nThus, p(a<sub>i</sub>) = v + (i - 1) &times; <b>D</b>. Clearly p(a<sub>1</sub>) = v is an\nupper bound on its value v, and by induction, if p(a<sub>i</sub>) is an upper bound on the\nvalues that can be assigned to a<sub>i</sub>, p(a<sub>i+1</sub>) = p(a<sub>i</sub>) + <b>D</b> is\nan upper bound on the values that can be assigned to a<sub>i+1</sub> because it can't differ by more\nthan <b>D</b> with the value assigned to a<sub>i</sub> because the corresponding cells are adjacent\n(any edge from G not involving the root connects nodes representing adjacent cells).\n</p><p>\nProperty 2. Let c be a fixed cell with value v. If p(c) &ne; v, then the case is\nimpossible. Since there is an edge (root, c) with length v, p(c) &le; v. And, if p(c) &lt; v,\nthe case is impossible by Property 1.\n</p><p>\nProperty 3. If p(c) is exactly the value assigned to c for all fixed cells c, then the case is\npossible and assigning p(c) to each non-fixed cell c is a valid assignment of maximum sum.\nBy the precondition we know that p assigns all fixed-cells their original value, so we only need\nto check if neighboring cells are assigned values that differ by no more than <b>D</b>. Let c and\nd be two neighboring cells. Since G contains an edge (c, d) with length <b>D</b> it follows\nby definition of shortest path that p(c) &le; p(d) + <b>D</b> and p(d) &le; p(c) + <b>D</b>.\nSince p is a valid assignment, and by property 1, it assigns all cells a maximum value, it follows\nimmediately that p is a valid assignment of maximum sum.\n</p><p>\nThis yields an algorithm to solve the Small dataset: calculate the shortest path from the root\nto all other cells using\n<a href=\"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\">Dijkstra's algorithm</a> and then\nuse Property 2 to check for impossible cases. If the case is possible, the answer is just the sum\nof p(c) over all cell nodes c. Dijkstra's algorithm takes\nO(<b>R</b> &times; <b>C</b> &times; log (<b>R</b> &times; <b>C</b>)) time while both checking for\nProperty 2 and summing take O(<b>R</b> &times; <b>C</b>) time. Therefore, the overall algorithm\ntakes O(<b>R</b> &times; <b>C</b> &times; log <b>R</b> &times; <b>C</b>) time, that fits\ncomfortably within the Small limits.\n</p><p>\nAnother similar approach that sidesteps the graph theoretical considerations is noticing that by\ntransitivity, a cell at S orthogonal steps of a fixed-cell with value v cannot be assigned a value\ngreater than v + S &times; <b>D</b>. That means that if two fixed cells are at S orthogonal steps\nand their value differs by more than S &times; <b>D</b> the case is impossible. Otherwise, it can\nbe shown that it's possible and a valid assignment of maximum sum results from assigning each\ncell the minimum of v + S &times; <b>D</b> over\nall values for v and S for each fixed cell (which is, of\ncourse, the exact same assignment as p() above). Checking all pairs of fixed-cells takes\nO(<b>N</b><sup>2</sup>) time and finding the assignment takes\nO(<b>R</b> &times; <b>C</b> &times; <b>N</b>) time, which means this yields an algorithm that\ntakes O(<b>R</b> &times; <b>C</b> &times; <b>N</b>) time overall and it also passes the Small.\nThe claims above can be proven directly, but the graph notation makes it easier, and the claims in\nboth cases are essentially the same. Additionally, the graph theoretical approach directly\nyields a more efficient Small-only solution.\n</p>\n<h3>Large dataset</h3>\n<p>\nThe size of the grid in the Large dataset is too big to inspect the cells one by one, so we need\na different approach. The foundations built while solving the Small dataset, however, are still\ntremendously useful. We define the same G and function p as before.\n</p><p>\nProperty 4. For every cell c there is a shortest path in G from the root to c of length k:<br/>\nroot, a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>k</sub>=c<br/>\nwhere a<sub>1</sub> is a fixed cell and there is some i\nsuch that each edge (a<sub>j</sub>, a<sub>j+1</sub>) come from a horiztonal adjacency if and only\nif j &lt; i. In plain English, there is path that goes from the root to a fixed cell a<sub>1</sub>,\nthen moves horizontally zero or more times, and then moves vertically zero or more times.\nWe can prove this easily by noticing that if the last k-1 steps include h horizontal and k-1-h\nvertical steps of any shortest path, a path that does h horiztonal steps first\nand k-1-h vertical steps last will reach the same destination (through different intermediate\ncells), and since the length of the edges of all horizontal and vertical is the same (<b>D</b>),\nthe resulting path is also a shortest path.\n</p><p>\nLet us call our original <b>R</b> &times; <b>C</b> matrix M.\nWe can use a technique called coordinate compression to consider only the <i>interesting</i> part.\nWe call a row or column interesting if it is in the\nborder (top and bottom rows and leftmost and rightmost columns) or if it contains at least one\nfixed cell. The interesting\n<a href=\"https://en.wikipedia.org/wiki/Matrix_(mathematics)#Submatrix\">submatrix</a> M' is the\nsubmatrix of M that results on deleting all non-interesting rows and columns. Notice that M'\ncontains all fixed cells of M, and possibly some non-fixed cells as well. The size of M' is\nhowever bounded by (<b>N</b>+2)<sup>2</sup>, which is much smaller than <b>R</b> &times; <b>C</b>\nin the largest cases within Large limits.\n</p><p>\nDefine the graph G and shortest path function p for M in the same way as for the Small.\nDefine also a smaller graph G'\nwhose nodes are a root and cells that are in M'. G' contains one edge (root, c) with length v\nfor each fixed-cell c with value v. Notice that, since M' contains all fixed cells, the root and\nall its outgoing edges in G' are the same as in G. G' also contains an edge connecting two cells\nthat are orthogonal neighbors in M'. The length of each such edge (c, d) is S &times; <b>D</b>\nwhere S is the distance in orthogonal steps between c and d in the original matrix M.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1YnvhFPr5Q_JXNAlCLDxtp1wxmRoIO4QRRP1ubpfyeRJUlJtBT-PDA5c9qbENjMnQp4jio/matrix.png\">\n<p>\nIn the depicted input matrix there are 3 fixed cells. The 3 interesting rows and 4 interesting\ncolumns are highlighted in light red, and the cells in the intersection of an interesting row and\nan interesting column are highlighted in dark red. Those dark red cells make up M' and the nodes of\nG' (besides the root). The fixed cell containing a 3 has two neighbors in G'. The edge going to\nits vertical neighbor has length 2 &times; <b>D</b>, because it is 2 steps away in the original M.\nSimilary, the edge going to its horizontal neighbor has length 3 &times; <b>D</b>.\n</p><p>\nHaving G', we can define p'(c) as the shortest path in G' from the root to each cell c that exists\nin M'.\n</p><p>\nProperty 5. For each cell c that exists in M', p'(c) = p(c). To prove this, consider a shortest\npath<br/>\nroot, a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>k</sub>=c<br/>\nin G from the root to c with the hypothesis of Property 4 (that is, it does horizontal steps\nfirst, and vertical steps last). First, notice that if the edge going into a<sub>i</sub> is\nhorizontal and the edge going out of it is vertical (that is, a<sub>i</sub> is the only corner),\nthen a<sub>i</sub> is in M', because it shares a row with a<sub>1</sub>, which is a fixed cell and\nthus it is in M', and a column with a<sub>k</sub>=c, which is also in M'. Between a<sub>1</sub> and\na<sub>i</sub> all moves are horizontal, so we can \"skip\" the a<sub>j</sub>s not in M', and the\nlength of the edges in G' will exactly match the sum of the lengths of all intermediate edges.\nThe analogous argument works for all the vertical moves between a<sub>i</sub> and  a<sub>k</sub>.\n</p><p>\nNotice that Property 5 implies that we can use a similar algorithm over G' to distinguish the\nimpossible cases, as we can calculate p' and then know the value of p'(c) = p(c) for all fixed\ncells c, which we can use to check Property 2. We still need, however, a way to know the sum over\nall p(c) for the possible cases, which we can't calculate explicitly.\n</p><p>\nLet a cell c in M be at row i and column j. Let i<sub>0</sub> be the largest interesting row\nthat is no greater than i, and i<sub>1</sub> be the smallest interesting row that is no\nless than i. Notice that i<sub>0</sub> = i = i<sub>1</sub> if i is interesting and\ni<sub>0</sub> &lt; i &lt; i<sub>1</sub> otherwise. Similarly let j<sub>0</sub> and j<sub>1</sub>\nbe the closest interesting columns to j in each direction. We call the up to 4 cells at positions\n(i<sub>0</sub>, j<sub>0</sub>), (i<sub>0</sub>, j<sub>1</sub>), (i<sub>1</sub>, j<sub>0</sub>)\nand (i<sub>1</sub>, j<sub>1</sub>), which are all in M', the <i>sourrounding cells</i> of c.\n</p><p>\nProperty 6. For each non-fixed cell c in row i and column j of M there is a shortest path from the\nroot to c in G that goes through one of its sourrounding cells. This can be proven similarly to\nProperty 4. After the first step of going from the root to the appropriate fixed cell\na<sub>1</sub>, any path that has the minimum number of horizontal and vertical steps yields the\nsame total length. Notice that there is always a sourrounding cell that is closer to a<sub>1</sub>\nthan c (that's why they are \"sourrounding\"). Therefore, we can always take a path that goes through\nthat sourrounding cell.\n</p><p>\nGiven Property 6, we can build G', calculate p', and then solve each contiguous submatrix of M\ndelimited by interesting rows as a separate problem. Each of those problems is an instance of our\noriginal problem in which we have fixed exactly the four corners. There is overlap in the border\namong these subproblems, but we can simply subtract the overlapping from the total. Calculating\nthe sum of the overlapping part requires a few of the simple observations required to calculate\nthe problem with four corners fixed, so we concentrate on solving the following: for a given\nmatrix size and values in its 4 corners, calculate its sum (modulo 10<sup>9</sup>+7).\nIt's important not to do modulo while calculating p or p', as that can ruin the calculation\nbecause we have inequalities in calculating shortest paths, and inequalities are not preserved\nunder modulo operations. Notice that, if U is an upper bound for the given fixed values for cells,\nthe longest path consists of at most 2 &times; U steps, so the highest value in the image of\np is at most U + 2 &times; U &times; <b>D</b>, which is at most U + 2 &times; U<sup>2</sup>.\nWith U up to 10<sup>9</sup>, that value fits in a 64-bit signed integer, which means we don't\nneed large integers to hold on taking the results modulo 10<sup>9</sup>+7 until the summing part.\n</p><p>\nLet us call the matrix A and the 4 corners tl, tr, bl and br for top-left, top-right, bottom-left\nand bottom-right. As we argue in the Small dataset section, each cell's value is determined by\none of the fixed cells, in this case, one of the four corners. Given the existence of the\n<a href=\"https://en.wikipedia.org/wiki/Shortest-path_tree\">shortest path tree</a>, the region\nof cells that are determined by each given corner (breaking ties by giving an arbitrary priority\nto corners) is contiguous.\nFor a given corner x and cell c, let us call the influence of x over c i(x,c) to\nthe fixed value x has plus S &times; <b>D</b> where S is the number of orthogonal steps between x\nand c. We call lower values of influence stronger. The corner that determines the value of a cell\nis therefore any of the ones with the strongest influence.\n</p><p>\nNow, consider the top row: tl has a stronger influence than tr\nover a left-most contiguous set of cells, and tr has a stronger influence over a right-most set of\ncells. There may be a single cell where the influence strength is equal.\nIt is not hard to prove that the column at which the strongest influence switches from being\ntl to tr (if looking from left to right) is the same in this top row as in any other row,\nbecause the influence values from tl and tr for the i-th row (from top to bottom) are exactly the\nsame values as the values in the top row plus i &times; <b>D</b>, so the most influential between\ntl and tr is always the same across cells in any given column. A similar thing happens with each\npair of non-opposite corners. There are 4 such pairs. If we consider the lines that split the\ninfluence region of each of those pairs, we have up to 2 vertical and 2 horizontal lines (some of\nthem may overlap), dividing A into up to 9 pieces. All except the middle\npiece have a single corner that has the most influence, thus they can be solved in the same way.\n</p><p>\nConsider a matrix of r rows and c columns with a single influential corner with value v. The\nsum of a row containing the value v is v + (v + <b>D</b>) + (v + 2 &times; <b>D</b>) + ....\nThis summation can be calculated with a\n<a href=\"https://en.wikipedia.org/wiki/Summation#Some_summations_of_polynomial_expressions\">\nformula</a>. And then, the sum of each other row\nis c &times; <b>D</b> larger than the previous one, as we add <b>D</b> to the sum for each\ncolumn. Again, this yields a summation over a known linear function, which can be reduced by\nthe same known formula.\n</p><p>\nThe middle piece of A has influence from two opposite corners (which pair of opposites depends on\nthe order of the lines). We can again partition A into up to 3 parts: rows with influence from\none corner, rows with influence from the other corner, and rows with influence from both. Two of\nthose can be summed with a similar formula as the single influential corner case. The rest is a\nrectangle partitioned into two stepped shaped pieces where the influence is divided. Those\nladdered pieces can be summed as the summation over a certain range of a quadratic function, which\ncan also be reduced to a\n<a href=\"https://en.wikipedia.org/wiki/Summation#Some_summations_of_polynomial_expressions\">\nformula</a>.\n</p><p>\nThis finishes the problem. There are lots of technical details, specifically math details,\nthat aren't covered in detail, but we hope this conveys the main ideas. We encourage you to fill\nin the gaps yourself and ask the community to help out if you can't, as it will be really good\npractice for your next contest.\n</p>\n","id":"0000000000201903","statement":"<h3>Problem</h3>\n<p>\n  The prestigious Slate Modern gallery specializes in the latest art craze:\n  grayscale paintings that follow very strict rules. Any painting in the\n  gallery must be a grid with <b>R</b> rows and <b>C</b> columns. Each cell in\n  the grid is painted with a color of a certain positive integer\n  <i>brightness value</i>; to make sure the art is not too visually startling,\n  the brightness values of any two cells that share an edge (not just a corner)\n  must differ by no more than <b>D</b> units.\n</p><p>\n  Your artist friend Cody-Jamal is working on a canvas for the gallery. Last\n  night, he became inspired and filled in <b>N</b> different particular cells\n  with certain positive integer brightness values. You just told him about the\n  gallery's rules today, and now he wants to know whether it is possible to\n  fill in all of the remaining cells with positive integer brightness values\n  and complete the painting without breaking the gallery's rules. If this is\n  possible, he wants to make the sum of the brightness values as large as\n  possible, to save his black paint. Can you help him find this sum or\n  determine that the task is impossible? Since the output can be a really big\n  number, we only ask you to output the remainder of dividing the result by the\n  prime 10<sup>9</sup>+7 (1000000007).\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case begins with one line with four\n  integers: <b>R</b>, <b>C</b>, <b>N</b>, and <b>D</b>, as described above.\n  Then, <b>N</b> lines follow; the i-th of these has three integers\n  <b>R<sub>i</sub></b>, <b>C<sub>i</sub></b>, and <b>B<sub>i</sub></b>,\n  indicating that the cell in the <b>R<sub>i</sub></b>th row and\n  <b>C<sub>i</sub></b>th column of the grid has brightness value\n  <b>B<sub>i</sub></b>. The rows and columns of the grid are numbered starting\n  from 1.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is either <code>IMPOSSIBLE</code> if it is impossible to complete the\n  picture, or else the value of the maximum possible sum of all brightness\n  values modulo the prime 10<sup>9</sup>+7 (1000000007).\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>N</b> &le; 200.<br/>\n  1 &le; <b>D</b> &le; 10<sup>9</sup>.<br/>\n  1 &le; <b>R<sub>i</sub></b> &le; <b>R</b>, for all i.\n  1 &le; <b>C<sub>i</sub></b> &le; <b>C</b>, for all i.\n  1 &le; <b>B<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.\n  (Note that the upper bound only applies to cells that Cody-Jamal already\n  painted. You can assign brightness values larger than 10<sup>9</sup> to other\n  cells.)<br/>\n  <b>N</b> &lt; <b>R</b> &times; <b>C</b>. (There is at least one empty\n    cell.)<br/>\n  <b>R<sub>i</sub></b> &ne; <b>R<sub>j</sub></b> and/or\n  <b>C<sub>i</sub></b> &ne; <b>C<sub>j</sub></b> for all i &ne; j.\n  (All of the given cells are different cells in the grid.)<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 40 seconds.<br/>\n  1 &le; <b>R</b> &le; 200.<br/>\n  1 &le; <b>C</b> &le; 200.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 80 seconds.<br/>\n  1 &le; <b>R</b> &le; 10<sup>9</sup>.<br/>\n  1 &le; <b>C</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2 3 2 2\n2 1 4\n1 2 7\n1 2 1 1000000000\n1 2 1000000000\n3 1 2 100\n1 1 1\n3 1 202\n2 2 2 2\n2 1 1\n2 2 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 40\nCase #2: 999999986\nCase #3: IMPOSSIBLE\nCase #4: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the optimal way to finish the painting is:\n</p><p>\n<code>\n  6 7 9<br/>\n  4 6 8<br/>\n</code>\n</p><p>\n  and the sum is 40.\n</p><p>\n  In Sample Case #2, the optimal way to finish the painting is:\n</p><p>\n<code>2000000000 1000000000</code>\n</p><p>\n  and the sum is 3000000000; modulo 10<sup>9</sup>+7, it is 999999986.\n</p><p>\n  In Sample Case #3, the task is impossible. No matter what value you choose\n  for the cell in row 2, it will be too different from at least one of the\n  two neighboring filled-in cells.\n</p><p>\n  In Sample Case #4, the two cells that Cody-Jamal filled in already have\n  brightness values that are too far apart, so it is impossible to continue.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":26}],"title":"Slate Modern","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201902","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2017"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
