{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1555126200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000051635","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Our first Round 1 of 2019 presented three problems that looked complex, but\n  all of them could be tackled with short solutions! <i>Pylons</i> mashed\n  together two sci-fi pop culture franchises and asked you to hop around a grid\n  in a safe way; it could be solved constructively, but it much easier if you\n  thought about brute force, which is sometimes the right approach in the real\n  world and even in coding contests! <i>Golf Gophers</i> allowed a lot of\n  flexibility in interacting with a system, but the best approach turned out\n  not to require much of it. Finally, <i>Alien Rhyme</i> could be solved using\n  a trie.\n</p><p>\n  Because all three problems could be solved with the right insights and short\n  pieces of code, we were not <i>too</i> surprised to see a perfect score come\n  in after only 25 minutes and 41 seconds. We were even less surprised that it\n  came from last year's (and the previous year's, etc.) Code Jam champion,\n  <b>Gennady.Korotkevich</b>. Fittingly enough, the next perfect score (at\n  31:59) came from last year's Distributed Code Jam champion, <b>Radewoosh</b>.\n  <b>ksun48</b> was the third to a perfect score, at 37:03. In all, we had\n  almost 300 perfect scores! Somewhat unusually for a Code Jam round, our third\n  (and highest-valued) problem got more submissions than either of the first\n  two &mdash; perhaps it was a little more approachable for experienced\n  competitive programmers. \n</p><p>\n  Thanks to everyone for competing! We got at least one full submission in 23\n  different languages. The cutoff for the top 1500 tentatively appears to be\n  45 points plus a sufficiently small penalty time. As usual, it will be a few\n  days before we finalize results, but the top 1500 will advance to Round 2 and\n  earn a shot to pick up a Code Jam T-shirt. Anyone who did not advance will\n  have two more chances to do so; Round 1B is coming up in two weeks!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Pylons: Written by Ian Tullis. Prepared by Jonathan Irvin Gunawan and Pi-Hsun\n  Shih.\n</p><p>\n  Golf Gophers: Written by Ian Tullis. Prepared by Pablo Heiber.\n</p><p>\n  Alien Rhyme: Written by Pablo Heiber. Prepared by Micah Stairs.\n</p><p>\n  Solutions and other problem preparation and review by Patrick Au, Liang Bai,\n  Darcy Best, Carlos Guia, Jonathan Irvin Gunawan, Md Mahbubul Hasan,\n  Andy Huang, Pi-Hsun Shih, Anubhav Srivastava, Reyno Tilikaynen, Kevin Tran,\n  and Adilet Zhaxybay.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Pylons: Ian Tullis</li>\n  <li>Golf Gophers: Ian Tullis</li>\n  <li>Alien Rhyme: Adilet Zhaxybay</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1555117200000,"tasks":[{"analysis":"<h3>Test set 1</h3>\n<p>\n  There are a few impossible cases for this problem. If we experiment with\n  some small grids, we can find that in addition to the 2 x 2 grid given as\n  a sample case, the 2 x 3, 2 x 4, and 3 x 3 cases have no solution.\n  (Because of symmetry, the 3 x 2 and 4 x 2 cases are also impossible.)\n</p><p>\n  In the 2 x 3 grid, we can notice that the middle cell of the top row shares a\n  row, column, or diagonal with every other cell; the same is true of the\n  central cell of the 3 x 3 grid. In each case, we cannot go from that cell\n  to any other cells, or vice versa, so the grid is unsolvable.\n</p><p>\n  In the 2 x 4 grid, we can try starting in the second cell of the top row;\n  then we find that we are forced into a series of three moves that\n  eventually take us to the third cell of the bottom row, from which there are\n  no other moves; we can never move out of that set of four cells that we\n  visited. Since the same is true of the other set of four cells, there is no\n  solution.\n</p><p>\n  The other cases in test set 1 are all solvable, though. One strategy is\n  to make mostly \"knight moves\" &mdash; two unit cells in one direction, and\n  one unit cell in the other. We may not be able to solve a grid using only\n  knight moves &mdash; see\n  <a href=\"https://en.wikipedia.org/wiki/Knight%27s_tour\">this article</a>\n  for more information &mdash; so we can sprinkle in other legal moves as\n  well. For instance, we can solve the 3 x 4 case by visiting the cells in\n  the following order:\n</p>\n<code>\n  02 05 10 07<br/>\n  09 12 01 04<br/>\n  06 03 08 11<br/>\n</code>\n<p>\n  And here is a solution for the 3 x 5 case, which makes many steps that are\n  wider than knight moves:\n</p>\n<code>\n  04 14 09 12 07<br/>\n  06 11 01 15 03<br/>\n  02 08 13 10 05<br/>\n</code>\n<p>\n  Because of symmetry, the only remaining cases are 2 x 5, 4 x 4, and 4 x 5,\n  and we can solve these by hand if we choose, or we can use a brute force\n  algorithm.\n</p>\n<h3>Test set 2</h3>\n<p>\n  There are multiple strategies for dealing with test set 2. One class of\n  approach is <i>constructive</i>. For example, we can devise general\n  solutions for 2 x N and 3 x N grids, for arbitrary N, and then divide up\n  the grid into horizontal strips of height 2, plus one more strip of height 3\n  if needed. Unfortunately, this can be tricky to get right. We need to make\n  sure that the solutions to the subproblems do not violate the rules &mdash;\n  the last move in one subproblem cannot be in the same row, column, or diagonal\n  as the first move in another. Moreover, we might struggle to come up with\n  our general 2 x N and 3 x N solutions.\n</p><p>\n  The Code Jam team's first successful constructive solution included\n  multiple cases for 2 x N (depending on whether N is odd, 0 mod 4, or\n  2 mod 4), and multiple cases for 3 x N (which entailed adding pairs of\n  columns to the left and right of our hardcoded 3 x 4 and 3 x 5 solutions,\n  bouncing between those columns to avoid breaking rules). It also made each\n  such solution start near the left edge of each strip and end near the right\n  edge, to avoid diagonal interactions among subproblems / strips.\n</p><p>\n  Is there an easier way? Let's take a step back. The problem imposes some\n  constraints, but one can observe that it is not too difficult to solve the\n  larger test set 1 cases by hand. This suggests that there are many possible\n  solutions, and we might expect even more as the grid's dimensions get\n  larger. (We could use\n  <a href=\"https://en.wikipedia.org/wiki/Ore%27s_theorem\">Ore's theorem</a>\n  to establish the existence of at least one solution for sufficiently large\n  grids.) So, our intuition might suggest at this point that the best approach\n  is some kind of brute force.\n</p><p>\n  We might consider using backtracking solutions. One possible concern is that\n  these solutions, whether they are breadth-first or depth-first, proceed in\n  an orderly fashion that might be more likely to leave us with tough\n  \"endgames\" in which the constraints are impossible. For example, if our\n  solution somehow solves all but the bottom row of the grid, then all hope\n  for the universe is lost!\n</p><p>\n  We can try these solutions anyway, or we can rely on our occasional friend,\n  randomness! We can pick a random starting cell, repeatedly choose valid\n  moves uniformly at random from the space of all allowed moves from our\n  current cell, and, if we run out of available moves, give up and start over.\n  For any case except for the impossible ones mentioned above, this approach\n  finds a solution very quickly.\n</p><p>\n  Many problems cannot be approached with random or brute-force solutions, but\n  identifying the problems that can be (in Code Jam or the real world) is a\n  useful skill!\n</p>\n<h3>There's even a greedy algorithm</h3>\n<p>\n  We are aware of other approaches. For example, we know that there is at\n  least one implementation of the following idea that solves every possible\n  test in the test set 1 and 2 limits: repeatedly greedily select an unvisited\n  cell that has the largest count of unvisited \"neighbors\", where we define a\n  cell's neighbors as those cells that share a row, column, or diagonal with\n  that cell. (We can either rule out specific impossible cases beforehand,\n  since there are not very many, or infer impossibility by comparing the number\n  of unvisited cells with the largest count of unvisited neighbors.)\n</p><p>\n  Although we do not provide a proof here, intuitively, it is advantageous to\n  prevent any one row, column, or diagonal from having too many unvisited cells,\n  relative to other rows, columns, and diagonals. For example, if we are close\n  to the end of our journey, and a majority of our remaining unvisited cells\n  are in the same column, we are doomed.\n</p><p>\n  Given the relatively small number of possible test cases for this problem,\n  it is not too hard to check all of them to verify that a solution works, and\n  that may be much easier than proving correctness! That is a rare luxury to\n  have for a Code Jam problem!\n</p>\n","id":"0000000000104e03","statement":"<h3>Problem</h3>\n<p>\n  Our Battlestarcraft Algorithmica ship is being chased through space by\n  persistent robots called Pylons! We have just teleported to a new galaxy to\n  try to shake them off of our tail, and we want to stay here for as long as\n  possible so we can buy time to plan our next move... but we do not want to\n  get caught!\n</p><p>\n  This galaxy is a flat grid of <b>R</b> rows and <b>C</b> columns; the rows\n  are numbered from 1 to <b>R</b> from top to bottom, and the columns are\n  numbered from 1 to <b>C</b> from left to right. We can choose which cell to\n  start in, and we must continue to jump between cells until we have visited\n  each cell in the galaxy <i>exactly</i> once. That is, we can never revisit a\n  cell, including our starting cell.\n</p><p>\n  We do not want to make it too easy for the Pylons to guess where we will go\n  next. Each time we jump from our current cell, we must choose a destination\n  cell that does not share a row, column, or diagonal with that current cell.\n  Let (i, j) denote the cell in the i-th row and j-th column; then a jump\n  from a current cell (r, c) to a destination cell (r', c') is invalid if and\n  only if any of these is true:\n</p>\n<ul>\n  <li>r = r'</li>\n  <li>c = c'</li>\n  <li>r - c = r' - c'</li>\n  <li>r + c = r' + c'</li>\n</ul>\n<p>\n  Can you help us find an order in which to visit each of the\n  <b>R</b> &times; <b>C</b> cells, such that the move between any pair of\n  consecutive cells in the sequence is valid? Or is it impossible for us to\n  escape from the Pylons?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of one line containing two\n  integers <b>R</b> and <b>C</b>: the numbers of rows and columns in this\n  galaxy.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>y</code> is a string of uppercase letters: either\n  <code>POSSIBLE</code> or <code>IMPOSSIBLE</code>, according to whether it is\n  possible to fulfill the conditions in the problem statement. Then, if it is\n  possible, output <b>R</b> &times; <b>C</b> more lines. The i-th of these\n  lines represents the i-th cell you will visit (counting starting from 1), and\n  should contain two integers r<sub>i</sub> and c<sub>i</sub>: the row and\n  column of that cell. Note that the first of these lines represents your\n  chosen starting cell.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>T</b> = 16.<br/>\n  2 &le; <b>R</b> &le; 5.<br/>\n  2 &le; <b>C</b> &le; 5.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>R</b> &le; 20.<br/>\n  2 &le; <b>C</b> &le; 20.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2 2\n2 5\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n2 3\n1 1\n2 4\n1 2\n2 5\n1 3\n2 1\n1 5\n2 2\n1 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, no matter which starting cell we choose, we have nowhere\n  to jump, since all of the remaining cells share a row, column, or diagonal\n  with our starting cell.\n</p><p>\n  In Sample Case #2, we have chosen the cell in row 2, column 3 as our starting\n  cell.  Notice that it is fine for our final cell to share a row, column, or\n  diagonal with our starting cell. The following diagram shows the order in\n  which the cells are visited:\n</p>\n<table>\n  <tr><td>2</td><td>4</td><td>6</td><td>10</td><td>8</td></tr>\n  <tr><td>7</td><td>9</td><td>1</td><td>3</td><td>5</td></tr>\n</table>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Pylons","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  In the first test set there are only up to <b>N</b> = 6 words with up to\n  50 characters in each of them. We can simply use brute force to try all ways of grouping\n  words into pairs (allowing some words not to be in any pair &ndash; we will effectively\n  discard these words), try all choices of an accent-suffix for every pair, and check that\n  none of the pairs have the same accent-suffix. Finally, we choose the maximum\n  size across all valid groupings.\n</p>\n<h3>Test set 2</h3>\n<p>\n  Let's notice how the size of an accent-suffix affects the chance of multiple words\n  sharing it. In case we have words <code>CODEJAM</code>, <code>JAM</code>, <code>HUM</code>\n  and <code>HAM</code>, accent-suffix <code>JAM</code> can be part of only two words,\n  whereas a shorter accent-suffix <code>M</code> fits all four words. This leads\n  to the following observation: for two words that we want to pair, it is never\n  suboptimal to choose their longest available common suffix as the accent-suffix\n  &ndash; this way we are still making sure that they rhyme, and we are allowing shorter\n  accent-suffixes to be used by other pairs. Notice that any other pair that could\n  use the longer suffix can also use any shorter suffix. For example, if we want\n  words <code>CODEJAM</code> and <code>JAM</code> rhyme, we should choose\n  <code>JAM</code> as their accent-suffix, and allow\n  suffix <code>M</code> to be potentially used by <code>HUM</code>\n  and <code>HAM</code>.\n</p>\n<p>\n  In this problem it is all about common suffixes of the words. In order to\n  better operate with word suffixes, let's actually reverse the words first (so now\n  original word suffixes are prefixes of reversed words), and build a\n  <a href=\"https://en.wikipedia.org/wiki/Trie\">trie</a> (also often called prefix tree)\n  on the reversed words. This is how a trie containing the words <code>CODEJAM</code>,\n  <code>JAM</code>, <code>HUM</code> and <code>HAM</code> looks:\n</p>\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"calc(1*470px)\" height=\"calc(1*557px)\" viewBox=\"0 0 470 557\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"Artboard\">\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"249\" cy=\"33\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"249\" cy=\"103\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"349\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Hum\" stroke=\"#FF0000\" stroke-width=\"3\" fill=\"#D8D8D8\" cx=\"349\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"189\" cy=\"173\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"309\" cy=\"173\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"229\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Ham\" stroke=\"#FF0000\" stroke-width=\"3\" fill=\"#D8D8D8\" cx=\"229\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"139\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Jam\" stroke=\"#FF0000\" stroke-width=\"3\" fill=\"#D8D8D8\" cx=\"139\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"119\" cy=\"313\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"109\" cy=\"383\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"99\" cy=\"453\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"91\" cy=\"523\" r=\"20\"></circle>\n            <circle id=\"Codejam\" stroke=\"#FF0000\" stroke-width=\"3\" fill=\"#D8D8D8\" cx=\"91\" cy=\"523\" r=\"20\"></circle>\n            <text id=\"M\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"239.025909\" y=\"110\">M</tspan>\n            </text>\n            <text id=\"U\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"301.143096\" y=\"181\">U</tspan>\n            </text>\n            <text id=\"H\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"341.10794\" y=\"251\">H</tspan>\n            </text>\n            <text id=\"H\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"221.10794\" y=\"251\">H</tspan>\n            </text>\n            <text id=\"A\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"181.428253\" y=\"181\">A</tspan>\n            </text>\n            <text id=\"J\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"133.057159\" y=\"251\">J</tspan>\n            </text>\n            <text id=\"E\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"112.371612\" y=\"322\">E</tspan>\n            </text>\n            <text id=\"D\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"101.359893\" y=\"391\">D</tspan>\n            </text>\n            <text id=\"O\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"90.7212213\" y=\"462\">O</tspan>\n            </text>\n            <text id=\"C\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"82.2661432\" y=\"532\">C</tspan>\n            </text>\n            <path d=\"M249.5,53.5 L249.5,81.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M249.5,81.5 L252.5,70.7 L246.5,70.7 L249.5,81.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M236.5,119.5 L204.5,157.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M204.5,157.5 L213.7514,151.171366 L209.161932,147.306552 L204.5,157.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M177.5,190.5 L152.5,225.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M152.5,225.5 L161.218573,218.455393 L156.336172,214.967964 L152.5,225.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M133.5,262.5 L123.5,291.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M123.5,291.5 L129.856818,282.267944 L124.18458,280.312 L123.5,291.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M116.5,333.5 L111.5,361.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M111.5,361.5 L116.351822,351.395554 L110.445256,350.34081 L111.5,361.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M105.5,403.5 L101.5,431.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M101.5,431.5 L105.997199,421.23281 L100.057502,420.384281 L101.5,431.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M98.5,473.5 L94.5,501.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M94.5,501.5 L98.9971991,491.23281 L93.0575022,490.384281 L94.5,501.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M262.5,118.5 L294.5,156.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M294.5,156.5 L289.838068,146.306552 L285.2486,150.171366 L294.5,156.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M198.5,191.5 L218.5,223.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M218.5,223.5 L215.320006,212.751621 L210.232017,215.931615 L218.5,223.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M318.5,191.5 L338.5,223.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M338.5,223.5 L335.320006,212.751621 L330.232017,215.931615 L338.5,223.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n        </g>\n    </g>\n</svg>\n\n<p>\n  Let's also mark the trie nodes where some of the input words end. Since\n  we are guaranteed that all the words are unique, we can use a simple\n  boolean flag. In the picture above, trie nodes where a word ends are marked in red.\n</p>\n<p>\n  Now we can solve the problem as follows: for a trie node <i>v</i>, let <code>f(v)</code> be\n  the minimum possible number of unpaired words that use accent-suffixes whose reverses\n  end in the node <i>v</i> or the subtree under it.\n  The answer to the problem is then <code>N - f(root)</code>, since <code>f(root)</code> represents\n  all usable accent-suffixes.\n</p>\n<p>\n  How do we calculate the values of <code>f(v)</code>? If <i>v</i> does not have\n  any children nodes, we set <code>f(v)</code> to be 1, since we know that in our trie all\n  leaf nodes are the end of a word. If node <i>v</i> has children, we can calculate\n  <code>f(v)</code> with the following algorithm assigning the result to <code>r</code>:\n</p>\n<pre>\n  r = sum(f(c) for all c where c is a child node of v)\n  if node v is marked (there is a word that ends at v): r = r + 1\n  if v is not the root and f(v) &ge; 2: r = r - 2\n</pre>\n<p>\n  First, we simply count the number of unpaired words recursively.\n  Finally, we let two of those words be paired using the prefix that ends in the node\n  <i>v</i>, which represents suffixes of original words, as the accent-suffix.\n</p>\n<p>\n  In our example trie we would get the following values of <code>f(v)</code>:\n</p>\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"calc(1*470px)\" height=\"calc(1*557px)\" viewBox=\"0 0 470 557\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <defs></defs>\n    <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <g id=\"Artboard\">\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"249\" cy=\"33\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"249\" cy=\"103\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"349\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Hum\" stroke=\"#FF0000\" stroke-width=\"3\" fill=\"#D8D8D8\" cx=\"349\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"189\" cy=\"173\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"309\" cy=\"173\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"229\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Ham\" stroke=\"#FF0000\" stroke-width=\"3\" fill=\"#D8D8D8\" cx=\"229\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"139\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Jam\" stroke=\"#FF0000\" stroke-width=\"3\" fill=\"#D8D8D8\" cx=\"139\" cy=\"243\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"119\" cy=\"313\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"109\" cy=\"383\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"99\" cy=\"453\" r=\"20\"></circle>\n            <circle id=\"Oval\" stroke=\"#979797\" fill=\"#D8D8D8\" cx=\"91\" cy=\"523\" r=\"20\"></circle>\n            <circle id=\"Codejam\" stroke=\"#FF0000\" stroke-width=\"3\" fill=\"#D8D8D8\" cx=\"91\" cy=\"523\" r=\"20\"></circle>\n            <text id=\"M\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"239.025909\" y=\"110\">M</tspan>\n            </text>\n            <text id=\"U\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"301.143096\" y=\"181\">U</tspan>\n            </text>\n            <text id=\"H\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"341.10794\" y=\"251\">H</tspan>\n            </text>\n            <text id=\"H\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"221.10794\" y=\"251\">H</tspan>\n            </text>\n            <text id=\"A\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"181.428253\" y=\"181\">A</tspan>\n            </text>\n            <text id=\"J\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"133.057159\" y=\"251\">J</tspan>\n            </text>\n            <text id=\"E\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"112.371612\" y=\"322\">E</tspan>\n            </text>\n            <text id=\"D\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"101.359893\" y=\"391\">D</tspan>\n            </text>\n            <text id=\"O\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"90.7212213\" y=\"462\">O</tspan>\n            </text>\n            <text id=\"C\" font-family=\"SFUIDisplay-Regular, SF UI Display\" font-size=\"24\" font-weight=\"normal\" letter-spacing=\"0.00286989589\" fill=\"#000000\">\n                <tspan x=\"82.2661432\" y=\"532\">C</tspan>\n            </text>\n            <path d=\"M249.5,53.5 L249.5,81.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M249.5,81.5 L252.5,70.7 L246.5,70.7 L249.5,81.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M236.5,119.5 L204.5,157.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M204.5,157.5 L213.7514,151.171366 L209.161932,147.306552 L204.5,157.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M177.5,190.5 L152.5,225.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M152.5,225.5 L161.218573,218.455393 L156.336172,214.967964 L152.5,225.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M133.5,262.5 L123.5,291.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M123.5,291.5 L129.856818,282.267944 L124.18458,280.312 L123.5,291.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M116.5,333.5 L111.5,361.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M111.5,361.5 L116.351822,351.395554 L110.445256,350.34081 L111.5,361.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M105.5,403.5 L101.5,431.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M101.5,431.5 L105.997199,421.23281 L100.057502,420.384281 L101.5,431.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M98.5,473.5 L94.5,501.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M94.5,501.5 L98.9971991,491.23281 L93.0575022,490.384281 L94.5,501.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M262.5,118.5 L294.5,156.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M294.5,156.5 L289.838068,146.306552 L285.2486,150.171366 L294.5,156.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M198.5,191.5 L218.5,223.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M218.5,223.5 L215.320006,212.751621 L210.232017,215.931615 L218.5,223.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path d=\"M318.5,191.5 L338.5,223.5\" id=\"Line\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <path id=\"Line-decoration-1\" d=\"M338.5,223.5 L335.320006,212.751621 L330.232017,215.931615 L338.5,223.5 Z\" stroke=\"#000000\" fill=\"#000000\" stroke-linecap=\"square\"></path>\n            <g id=\"Group\" transform=\"translate(30.000000, 27.000000)\" font-size=\"14\" font-family=\"Courier\" letter-spacing=\"0.00334821199\" fill=\"#000000\" font-weight=\"normal\">\n                <text id=\"f(v)-=-1\">\n                    <tspan x=\"91.8472377\" y=\"500\">f(v) = 1</tspan>\n                </text>\n                <text id=\"f(v)-=-1\">\n                    <tspan x=\"98.8472377\" y=\"430\">f(v) = 1</tspan>\n                </text>\n                <text id=\"f(v)-=-1\">\n                    <tspan x=\"109.847238\" y=\"360\">f(v) = 1</tspan>\n                </text>\n                <text id=\"f(v)-=-1\">\n                    <tspan x=\"119.847238\" y=\"292\">f(v) = 1</tspan>\n                </text>\n                <text id=\"f(v)-=-0\">\n                    <tspan x=\"3.84723773\" y=\"219\">f(v) = 0</tspan>\n                </text>\n                <text id=\"f(v)-=-1\">\n                    <tspan x=\"195.847238\" y=\"261\">f(v) = 1</tspan>\n                </text>\n                <text id=\"f(v)-=-1\">\n                    <tspan x=\"53.8472377\" y=\"149\">f(v) = 1</tspan>\n                </text>\n                <text id=\"f(v)-=-0\">\n                    <tspan x=\"111.847238\" y=\"80\">f(v) = 0</tspan>\n                </text>\n                <text id=\"f(v)-=-0\">\n                    <tspan x=\"112.847238\" y=\"10\">f(v) = 0</tspan>\n                </text>\n                <text id=\"f(v)-=-1\">\n                    <tspan x=\"352.847238\" y=\"219\">f(v) = 1</tspan>\n                </text>\n                <text id=\"f(v)-=-1\">\n                    <tspan x=\"312.847238\" y=\"149\">f(v) = 1</tspan>\n                </text>\n            </g>\n        </g>\n    </g>\n</svg>\n\n<p>\n  Proving the algorithm above correctly calculates f(v) is straightforward. First notice that only\n  words that are represented in the trie at or below v are pairable with the set of accent-suffixes\n  represented by v or its subtree. Then we can proceed by induction: f is pretty clearly correct\n  for a single node tree, as there is no pairing possible. Assume by the inductive hypotheses\n  f works correctly on all proper subtrees under v. The pairing implied by the construction of f(v)\n  &mdash; adding any remaining pair of words to the recursive result &mdash;\n  is valid: we are only pairing two words with the accent-suffix\n  represented by v, and the rest is valid by the inductive hypotheses.\n  To show that the pairing it is also of maximum size, notice that,\n  by inductive hypothesis, there is no way to pair more than\n  <code>sum(f(c) for all c where c is a child node of v)</code> words with accent-suffixes\n  that are represented by the subtree but not by v directly. This is because words in different\n  subtrees of v cannot be matched with a longer accent-suffix than the one represented by v, and\n  the accent-suffix represented by v can add at most a single pair to the total.\n</p>\n<p>\n  Note how we calculate the values of <code>f(v)</code> in a recursive manner,\n  and <code>f(v)</code> is calculated exactly once for each possible <code>v</code>.\n  Since the algorithm itself takes constant time in addition to the time of the recursion,\n  we can calculate all <code>f(v)</code> values in O(T) time,\n  where T is a total number of nodes in the trie. We can bound T\n  by the total length of all words, or by <b>N</b> &times; m where m is the maximum word length.\n</p><p>\n  Finally, there are less efficient but simpler implementations that also work. For example, sort\n  the reversed words alphabetically and take any two adjacent words with a longest common prefix,\n  pair them, remove them from the list, and repeat. This simple-to-implement algorithm basically\n  constructs the same pairing our recursive formulation does. This shifts some\n  implementation complexity onto the correctness proof. If you are faster with proofs than with\n  code, it might be an overall gain in solving speed.\n</p>\n","id":"0000000000104e05","statement":"<h3>Problem</h3>\n<p>\nDuring some extraterrestrial exploration, you found evidence of alien poetry! Your team of\nlinguists has determined that each word in the alien language has an accent on exactly one\nposition (letter) in the word; the part of the word starting from the accented letter is called\nthe accent-suffix. Two words are said to rhyme if both of their accent-suffixes are equal.\nFor example, the words <code>PROL</code> and <code>TARPOL</code> rhyme if the accented letter\nin both is the <code>O</code> or the <code>L</code>, but they do not rhyme if the accented\nletters are the <code>R</code>s, or the <code>R</code> in <code>PROL</code> and the\n<code>P</code> in <code>TARPOL</code>, or the <code>O</code> in <code>PROL</code> and the\n<code>L</code> in <code>TARPOL</code>.\n</p><p>\nYou have recovered a list of <b>N</b> words that may be part of an alien poem. Unfortunately,\nyou do not know which is the accented letter for each word. You believe\nthat you can discard zero or more of these words, assign accented letters to the remaining\nwords, and then arrange those words into pairs such that each word rhymes only with the other\nword in its pair, and with none of the words in other pairs.\n</p><p>\nYou want to know the largest number of words that can be arranged into pairs in this way.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.\n<b>T</b> test cases follow. Each test case starts with a line with a single integer <b>N</b>.\nThen, <b>N</b> lines follow, each of which contains a string <b>W<sub>i</sub></b> of uppercase English letters, representing\na distinct word. Notice that the same word can have different accentuations in different test\ncases.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where <code>x</code>\nis the test case number (starting from 1) and <code>y</code> is the size of the largest subset\nof words meeting the criteria described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; length of <b>W<sub>i</sub></b> &le; 50, for all i.<br/>\n<b>W<sub>i</sub></b> consists of uppercase English letters, for all i.<br/>\n<b>W<sub>i</sub></b> &ne; <b>W<sub>j</sub></b>, for all i &ne; j.\n  (Words are not repeated within a test case.) <br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 6.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2\nTARPOL\nPROL\n3\nTARPOR\nPROL\nTARPRO\n6\nCODEJAM\nJAM\nHAM\nNALAM\nHUM\nNOLOM\n4\nPI\nHI\nWI\nFI\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 0\nCase #3: 6\nCase #4: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the two words can rhyme with an appropriate accent assignment,\n  as described above, so the largest subset is the entire input.\n</p><p>\n  In Sample Case #2, no two words can rhyme regardless of how we assign accents, because any\n  two suffixes will differ at least in the last letter. Therefore, the largest subset\n  is the empty one, of size 0.\n</p><p>\n  In Sample Case #3, we can use the entire set of words if we accentuate\n  <code>CODEJAM</code> and <code>JAM</code> at the <code>J</code>s,\n  <code>HAM</code> and <code>NALAM</code> at their last <code>A</code>s and <code>HUM</code>\n  and <code>NOLOM</code> at the <code>M</code>s.\n</p><p>\n  In Sample Case #4, any two words can be made to rhyme, but always by making the accented letter\n  the <code>I</code>. Therefore, if we add two pairs to the subset, words from different pairs\n  will rhyme. We can, thus, only form a subset of size 2, by choosing any 2 of the input words.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":27}],"title":"Alien Rhyme","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n<p>\n  The difficulty of this problem stems from the fact that the windmills can\n  loop around. If we have a windmill with 5 blades, and we find it with blade\n  number 2 pointing downward in the morning, does that mean that 2 gophers\n  rotated it? or that 7 did? or 12? In general, if a windmill has B blades, and\n  we find it in position P, all that we can say for sure is that some number\n  (P + K &times; B) of gophers (for some integer K) tampered with it during the\n  night.\n</p><p>\n  Because of this, we might reason that we should put as many blades as\n  possible (that is, 18) on each windmill, and then hope that none of those\n  windmills is visited by more than 17 gophers, in which case the total number\n  of rotations of all blades equals the total number of gophers. This turns out\n  to be a reasonable hope! It is hard to directly calculate the probability\n  that none of the 18 blades will be turned more than 17 times on a given\n  night, but a quick simulation can tell us that even in the worst case of 100\n  gophers, the probability of this happening is about 0.00017. Since we can\n  run this same experiment 365 times and take the maximum result that we\n  find, the chances of a wrong answer (due to getting a misleading result all\n  365 times) are infinitesimally small.\n</p>\n\n<h3>Test set 2</h3>\n<p>\n  In test set 2, we only have 7 nights to work with, and the number of gophers\n  can be quite large, so we cannot reasonably hope that the windmills will\n  not loop. Now what? We might consider using different numbers of blades on\n  each windmill during a given night, but it's hard to see how that buys us\n  anything.\n</p><p>\n  Suppose that, on one night, we try putting two blades on every windmill.\n  At first this doesn't seem to help &mdash; shouldn't the resulting data\n  should be almost pure noise? However, we can observe that if the number of\n  gophers is odd, the total number of turns (across all windmills) will be odd,\n  and if the number of gophers is even, that total number will be even. So\n  we have a way of determining the parity of the number of gophers, no matter\n  how they happen to turn the blades!\n</p><p>\n  We can extend this idea to find out how many gophers there are modulo any\n  number of our choice between 2 and 18. Since we only get 7 nights, though,\n  we should choose our numbers carefully. One promising idea is to make them\n  all prime, and there are seven primes in the range we can use: 2, 3, 5, 7,\n  11, 13, and 17. Then we can try to use the construction suggested by the\n  <a href=\"https://en.wikipedia.org/wiki/Chinese_remainder_theorem\">Chinese remainder theorem</a>\n  to uniquely determine the number of gophers. However, this method would only\n  work for any number of gophers up to 2 &times; 3 &times ... &times; 17 =\n  510510; it cannot distinguish 510511 gophers from 1 gopher! We are in\n  trouble, since we might have up to 10<sup>6</sup> gophers.\n</p><p>\n  The final insight that we need is that the Chinese remainder theorem only\n  requires its moduli to all be <i>relatively</i> prime, not necessarily prime.\n  So we can use 16 in place of 2, and 9 in place of 3. This lets us identify any\n  number of gophers up to 5 &times; 7 &times; 9 &times; 11 &times; 13 &times;\n  16 &times; 17 = 12252240, which easily covers what we need. (We can also\n  get away with using the numbers 12 through 18, for example; we leave the\n  details to the reader.)\n</p><p>\n  Notice that we do not really need to do any calculations based on the Chinese\n  remainder theorem; since the number of possible answers is relatively small,\n  we can check all of them until we find the one that has the appropriate\n  residue for each of our chosen moduli.\n</p>\n\n<h4>Test set 1 appendix</h4>\n<p>\n  To prove that the probability of at least one blade rotating more than 17 times\n  is about 0.00017, we can solve a related problem:\n</p><p>\n  \"Count the number of integer arrays of length <b>L</b> such that each array\n  element is one of 1, 2, ..., <b>U</b> and each number appears at most\n  <b>B</b> times in the array.\"\n</p><p>\n  This related problem is equivalent to counting\n  <a href=\"https://en.wikipedia.org/wiki/Partition_(number_theory)\">integer partitions</a>\n  with constraints on the size of each partition.\n</p><p>\n  We can solve this related problem using\n  <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">Dynamic Programming</a>.\n  First, we choose how many times <b>U</b> appears in the array; say it\n  appears K times, with 0 &le; K &le; min(<b>B</b>,<b>L</b>). Once we know K,\n  we have to choose where those K values go. Using\n  <a href=\"https://en.wikipedia.org/wiki/Combination\">combinations</a>,\n  we can see that there are <code>C(<b>L</b>, K)</code> possible options. For\n  each option, we can treat the <b>L</b>-K other spaces as an array that must\n  contain the numbers 1, 2, ..., <b>U</b>-1 such that no number appears more\n  than <b>B</b> times, which is a subproblem of our original problem, so we may\n  recurse. If we sum over all possible values for K, we have the total number\n  of valid arrays.\n</p>\n<p>\n  If we solve the above problem with <b>L</b> = 100, <b>U</b> = 18, <b>B</b> = 17,\n  we see that there are\n  336647783248234011860927063629187654598455062446560501834487820535956663161762533555609870639313859125191714928476256971520000\n  (or approximately 3.366 &times; 10<sup>125</sup>) arrays such that no number\n  appears more than 17 times. These arrays can represent which windmill the\n  gophers select in a <i>good</i> configuration out of the 18<sup>100</sup>\n  possible configurations. This gives us the probability quoted above.\n</p>\n","id":"0000000000104f1a","statement":"<h3>Problem</h3>\n<p>\n  Last year, a bunch of pesky gophers took up residence in our orchard. We\n  tried to change our line of work by opening up a miniature golf course, but\n  it looks like the gophers have followed us here! Once again, we need to\n  figure out how many gophers there are, but we cannot observe them directly\n  because they are secretive and nocturnal, whereas we like to sleep at night.\n  We do know there are between 1 and <b>M</b> gophers, inclusive.\n</p><p>\n  Our mini golf course is famous for having a small electronic windmill on each\n  of its 18 holes. The i-th windmill has 2 &le; <b>B</b><sub>i</sub> &le; 18\n  blades, which are numbered from 0 to <b>B</b><sub>i</sub>-1, clockwise. Each\n  night, before going to sleep, we turn off the windmills and set each one such\n  that blade 0 is pointing downward, which is important so that the windmills\n  can charge up properly for the next day. However, we have noticed that when\n  we wake up, the windmills have been disturbed. Since our mini golf course is\n  in a windless area, we think the mischievous gophers must be responsible!\n</p><p>\n  We know that every night, all of the gophers emerge, one by one; each of them\n  chooses one of the windmills independently and uniformly at random and\n  rotates it counterclockwise by one blade. So, for example, for a windmill\n  with 3 blades for which 0 is pointing downward, the first gopher to interact\n  with it turns it so that 1 is pointing downward, and then the next gophers to\n  interact with that windmill make the downward-pointing blade have number 2,\n  then 0, then 1, and so on.\n</p><p>\n  We have devised a plan. We designed our windmills so that we can easily\n  change the number of blades (to modulate the difficulty of our course),\n  and we will now take advantage of this! Each night, before going to sleep, we\n  can choose the number of blades on each of the 18 windmills, within the given\n  limits; we do not have to use the same number of blades on each windmill, or\n  make the same choices every night. In the morning, we will observe the number\n  on each windmill's downward-pointing blade.\n</p><p>\n  We have <b>N</b> nights in which to figure out G, the number of gophers.\n  Can you help us?\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the\n  information in the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\">\n  Interactive Problems section</a> of our FAQ.\n</p><p>\n  Initially, your program should read a single line containing three integers\n  <b>T</b>, <b>N</b> and <b>M</b>, the number of test cases, the number of\n  nights allowed per test case and the maximum number of gophers, respectively.\n  Then, you need to process <b>T</b> test cases.\n</p><p>\n  In each test case, your program processes up to <b>N</b> + 1 exchanges\n  with our judge. You may make up to <b>N</b> exchanges of the following form:\n</p>\n<ul>\n  <li>Your program outputs one line with eighteen integers between 2 and 18,\n    inclusive; the i-th of these represents the number of blades you want the\n    i-th windmill to have on that night.\n  </li>\n  <li>The judge responds with one line with eighteen integers; the i-th of\n    these represents the number on the downward-pointing blade of the i-th\n    windmill in the morning, after the gophers have worked their mischief. If\n    you sent invalid data (e.g., a number out of range, or a malformed line),\n    the judge instead responds with <code>-1</code>.\n  </li>\n</ul>\n<p>\n  On each night, for each gopher, the choice of which windmill the gopher turns\n  is uniform at (pseudo)-random, and independent of any other choice by any\n  gopher (including itself) on any night.\n</p><p>\n  After making between 0 and <b>N</b> exchanges as explained above, you must\n  make one more exchange of the following form:\n</p>\n<ul>\n  <li>Your program outputs one integer: your guess for G, the number of\n    gophers.</li>\n  <li>\n    The judge responds with one line with a single integer: <code>1</code> if\n    your answer is correct, and <code>-1</code> if it is not (or you have\n    provided a malformed line).\n  </li>\n</ul>\n<p>\n  After the judge sends <code>-1</code> to your input stream (because of either\n  invalid data or an incorrect answer), it will not send any other output.\n  If your program continues to wait for the judge after receiving\n  <code>-1</code>, your program will time out, resulting in a Time Limit\n  Exceeded error. Notice that it is your responsibility to have your program\n  exit in time to receive a Wrong Answer judgment instead of a Time Limit\n  Exceeded error. As usual, if the memory limit is exceeded, or your program\n  gets a runtime error, you will receive the appropriate judgment.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 20.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>N</b> = 365.<br/>\n  <b>M</b> = 100.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>N</b> = 7.<br/>\n  <b>M</b> = 10<sup>6</sup>.<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U23viZdm0TenTdqY3uLSH06WUZZ2ofw_kGhRBrmjlqxOOF_GoUN-eW7F5lfqxyOeoOq0GcZbxYfh7GnpRDv/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n<p>\n  This interaction corresponds to Test set 1. Suppose that, unbeknownst to us,\n  the judge has decided that there are 10 gophers.\n</p>\n<pre>\n  t, n, m = readline_int_list()   // Reads 20 into t, 365 into n and 100 into m.\n  // Choose numbers of blades for day 1.\n  printline 2 2 2 2 18 3 3 3 3 3 3 4 4 4 4 5 2 2 to stdout\n  flush stdout\n  // Reads 0 0 0 0 0 0 1 2 1 0 1 2 0 0 0 0 1 0 into res.\n  res = readline_int_list()\n  // Choose numbers of blades for day 2.\n  printline 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 to stdout\n  flush stdout\n  // Reads 0 1 1 2 0 0 1 0 0 0 0 0 0 1 0 0 0 0 into res.\n  res = readline_int_list()\n  printline 8 to stdout        // We make a wrong guess even though we could\n  flush stdout                 // have investigated for up to 363 more nights.\n  verdict = readline_int()     // Reads -1 into verdict (judge has decided our\n                               //   solution is incorrect)\n  exit                         // Exits to avoid an ambiguous TLE error\n</pre>\n<p>\n  Notice that even though the guess was consistent with the information we\n  received from the judge, we were still wrong because we did not find the\n  correct value.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Golf Gophers","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"}],"ticket":{"challenge_id":"0000000000051635","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2019"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
