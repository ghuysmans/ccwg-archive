{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1465662600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201bf3","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nIn the last of our many online rounds, contestants faced four problems.\n<i>Teaching Assistant</i> presents a somewhat complex situation, but\nthe problem has a simple greedy solution. <i>Forest University</i> poses\nthe challenge of uniformly sampling tree traversals, and can be solved\nvia simulation. <i>Rebel Against The Empire</i> is a 3D geometry / graph\nproblem with a potentially tricky implementation. Finally, <i>Go++</i>\nis a \"wild card\" problem about concurrency; it has a surprisingly simple\nanswer, although it is tough to see it!\n</p><p>\n52 minutes into the contest, every dataset had been solved at least once;\ncontestants raced to solve the three toughest datasets (the Larges for\nB, C, and D). apiad was first to 100 points on the scoreboard at 1:50:30,\nbut had C-large wrong. xyz111 had the first complete set of correct\nsubmissions, but with enough penalties to push the total time to\n2:42:09; nobody else registered a perfect score, though, so that record stood.\nGo++ ultimately had more correct Large attempts than Rebel (perhaps in part\nbecause its point value was higher), and so it turned out to be necessary to\nsolve it to make the top 25, although the cutoff line was <i>very</i> close\nright up until the end.\n</p><p>\nCongratulations to everyone who made it this far and participated in\nthe round. 25 contestants plus our defending champion\n(Gennady.Korotkevich) will head to New York to face off in this year's\nFinals on\nAugust 5.\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>Teaching Assistant</i>): Written by Devendra Agarwal.\nPrepared by Karol Pokorski.\n</p><p>\nProblem B (<i>Forest University</i>): Written and prepared by Petr\nMitrichev.\n</p><p>\nProblem C (<i>Rebel Against The Empire</i>): Written by Onufry\nWojtaszczyk. Prepared by Yerzhan Utkelbayev.\n</p><p>\nProblem D (<i>Go++</i>): Written by David Arthur. Prepared by Igor\nNaverniouk.\n</p>\nSolutions and other problem preparation and review by Shane Carr, John\nDethridge, Minh Doan, Jackson Gatenby, Pablo Heiber, Andy Huang, Taman\n(Muhammed) Islam, Dominik Schmid, and Ian Tullis.\n</p><p>\nAnalysis authors:\n</p>\n<ul>\n<li>Teaching Assistant: Saurav Keshari Aryal, Alex Meed, and Steve Thomas</li>\n<li>Forest University: John Dethridge, Petr Mitrichev, and Ian Tullis</li>\n<li>Rebel Against The Empire: Pablo Heiber, Ian Tullis, and Onufry Wojtaszczyk</li>\n<li>Go++: Alex Meed</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1465653600000,"tasks":[{"analysis":"The intended solution is roughly as follows:\n<ul>\n<li>Treat it at a graph problem. We have a graph with N nodes, and each edge is\n  available in an interval of time.</li>\n<li>For each node, order the edges by, say, availability start time. As long as\n  we have at least one edge available, we can jump back and forth. And,\n  obviously we can arrive on an asteroid only when there's at least one edge\n  open. So, there are \"gaps\" such that you need to leave the asteroid between\n  the gap, because there will be no edges in between. So, we can split each\n  node into multiple nodes across these gaps (note that the number of edges\n  doesn't grow, so the size of the whole graph is still O(N^2)).\n</li>\n<li>Now we run a Dijkstra's on the new graph. When we arrive in a node, we can\n  only take the outgoing edges which haven't been closed yet (and the time at\n  which we take them is the max of the current time and the time in which they\n  open).</li>\n<li>Done.</li>\n</ul>\n","id":"0000000000201b70","statement":"<h3>Problem</h3>\n<p>\nYou are a rebel against the evil Galactic Empire, and you are on the run!\n</p><p>\nYou have sabotaged the Empire's Factory of Evil, and imperial security\nforces will be after you soon! The factory is located on asteroid 0 in a system\nof <b>N</b> numbered asteroids. Your getaway ship, the Century Quail, is\nlocated on asteroid 1, and if you can get there, you will be able to fly away\nsafely.\n</p><p>\nEach asteroid is a single point in space with a velocity, and you move through\nspace along with whichever asteroid you are currently on. Your Asteroid Jumper\nwill allow you to instantaneously jump between any two asteroids in the system.\nLong jumps are scarier than short ones (and the vacuum of space is terrifying),\nso you want to minimize the maximum distance you need to jump. However,\nstarting now, if you ever spend more than a continuous <b>S</b> seconds without\njumping, the imperial security forces will catch you. That is, the interval\nfrom now until your first jump, and each interval between subsequent jumps,\nmust be less than or equal to <b>S</b>. You may jump at <i>any</i> instant;\nit does not have to be after an integer number of seconds have elapsed. You\nescape the instant you jump to asteroid 1.\n</p><p>\nThe i-th asteroid starts at position (<b>x<sub>i</sub></b>,\n<b>y<sub>i</sub></b>, <b>z<sub>i</sub></b>) in space, and it will move a\ntotal distance of (<b>V<sub>xi</sub></b>, <b>V<sub>yi</sub></b>,\n<b>V<sub>zi</sub></b>) each second. This movement is continuous throughout time;\nit does not update discretely each second. (It is also possible for an\nasteroid to be stationary.) Nothing happens if asteroids occupy the same point\nin space at the same time. You can only travel between two asteroids by\njumping, even if they happen to occupy the same point at the instant of your\njump.\n</p><p>\nIn the escape plan that minimizes the maximum jump distance, what is that\nmaximum jump distance?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. The first line of each test case contains two integers:\n<b>N</b> (the number of asteroids) and <b>S</b> (the limit on how long you can\ngo without jumping). Next, there are <b>N</b> lines describing the asteroids.\nThe i-th of these lines (counting starting from 0) contains six integers: the\ninitial (<b>x<sub>i</sub></b>, <b>y<sub>i</sub></b>, <b>z<sub>i</sub></b>)\nposition of the i-th asteroid in space, and the distance (\n<b>V<sub>xi</sub></b>, <b>V<sub>yi</sub></b>, <b>V<sub>zi</sub></b>) it moves\nin a single second.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\na floating-point number: the distance of the longest jump you will have to make\nin order to get away. <code>y</code> will be considered correct if it is within\nan absolute or relative error of 10<sup>-4</sup> of the correct answer. See the\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an\nexplanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n2 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>S</b> &le; 100.<br/>\n-500 &le; <b>x<sub>i</sub></b> &le; 500.<br/>\n-500 &le; <b>y<sub>i</sub></b> &le; 500.<br/>\n-500 &le; <b>z<sub>i</sub></b> &le; 500.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n<b>V<sub>xi</sub></b> = 0.<br/>\n<b>V<sub>yi</sub></b> = 0.<br/>\n<b>V<sub>zi</sub></b> = 0.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n-500 &le; <b>V<sub>xi</sub></b> &le; 500.<br/>\n-500 &le; <b>V<sub>yi</sub></b> &le; 500.<br/>\n-500 &le; <b>V<sub>zi</sub></b> &le; 500.<br/>\n<p>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3 7\n0 0 0 0 0 0\n1 2 2 0 0 0\n1 1 1 0 0 0\n5 10\n0 0 0 0 0 0\n35 0 0 -1 0 0\n1 54 0 0 -2 0\n2 -150 0 0 10 0\n4 0 0 -1 0 0\n3 1\n-10 2 0 1 0 0\n0 0 10 0 0 -1\n-10 -2 0 1 0 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.7320508\nCase #2: 2.0000000\nCase #3: 4.0000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nSample case #1 is the only sample case that could appear in the Small dataset.\nAny of the sample cases could appear in the Large dataset.\n</p><p>\nIn sample case #1, we start on a stationary asteroid at (0, 0, 0), and our ship\nis on an asteroid at (1, 2, 2). There is another asteroid at (1, 1, 1). One\noption is to jump directly to our ship, which is a distance of 3 away. Another\noption is to jump to the other asteroid, which is a distance of sqrt(3) away,\nand then jump to the ship from there, which is a distance of sqrt(2) away. The\nmaximum jump distance is 3 for the first option and sqrt(3) for the second\noption, so the second option is preferable.\n</p><p>\nNote that the value of <b>S</b> does not matter in the Small cases. Since all\nof the asteroids are stationary, there is no reason to wait around; we can make\nall jumps instantaneously.\n</p><p>\nIn sample case #2, we start on a stationary asteroid at (0, 0, 0). We can wait\nthere for 4 seconds for asteroid 4 to come very close, jump onto it, fly for 1\nsecond on it, and then jump back at time 5 back to asteroid 0 (the distance\nbetween the two asteroids is 1 at this moment). There we wait 10 seconds,\ncutting it very close to being caught, and then jump to the speeding asteroid 3\nat time 15. Two seconds later, asteroid 3 flies by asteroid 2, and we jump to\nasteroid 2. At time 27, we can jump from asteroid 2 to asteroid 0. There we\npatiently wait until time 35 when asteroid 1 reaches us, then we can jump onto\nit and escape.\nThe longest jump we made was from asteroid 0 to asteroid 3 at time 15, and the\ndistance we jumped was 2.\n</p><p>\nIn sample case #3, the security forces are really active! You could, of course,\nwait one second and jump directly to asteroid 1, but a better choice - that\nallows you to make jumps no longer than 4 - is to jump back and forth between\nasteroids 0 and 2; while waiting for asteroid 1 to get close, and only then\njump to it.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Rebel Against The Empire","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>go++: Analysis</h2>\n<p>\nTo make the analysis a tiny bit easier to follow, we'll typeset strings\n(<b>B</b>, <b>G</b>, and output from the Go++ programs) in monospace font,\ninstructions from the first program in normal font, and instructions from the\nsecond program with an underline.\n</p><p>\nFirst, let's try to figure out when the problem is impossible to solve. It's\nclearly impossible when <b>B</b> is in <b>G</b>; that case is even in the\nsample input. What about otherwise?\n</p><p>\nSurprisingly, <i>if </i><b>B</b><i> is not in </i><b>G</b><i>, the problem is\nalways solvable</i>.\n</p><p>\nTo prove this, I'll construct two Go++ programs that, when run as described in\nthe problem statement, can produce <i>any</i> <b>L</b>-length string\n<i>except</i> <b>B</b>. That sounds harder than making one that just produces\nthe strings in <b>G</b>, but sometimes, making the problem more difficult is a\ngreat way to gain the insight you need to solve the original problem. For this\nproblem in particular, the set <b>G</b> is a red herring!\n</p>\n<h3>The first program</h3>\n<p>\nGiven an input string <b>B</b>, construct the first program as follows:\n<ol>\n<li>Start with the inverse of every character of <b>B</b> (<code>0</code>\n&#8614; 1, <code>1</code> &#8614; 0).</li>\n<li>Add a ? instruction after every 0 or 1 instruction.</li>\n</ol>\nFor instance, if <b>B</b> = <code>111</code>, which could appear on the Small\ninput, the first program is 0?0?0?. If <b>B</b> = <code>010</code>, which could\nonly appear on the Large input, the first program is 1?0?1?.\n</p><p>\nWhy does this work? Notice that by default, this program generates the opposite\nof <b>B</b>. In order to generate a different string, we need to override one\nor more of the ? instructions; that is, the programs need to be interleaved\nsuch that right before the ? from the first program, some other instruction\nfrom the second program changes what it prints. For instance, given the first\nprogram 1?0?1?, we can print <code>011</code> instead of <code>101</code> using\nthe second program <u>01</u>, if it's interleaved as follows:\n1<u>0</u>?0<u>1</u>?1?. In order to print <b>B</b>, we need to override all\nthree ? instructions.\n</p><p>\nSo how do we prevent that from happening? We write a second program that cannot\noverride all three ? instructions. Our solution differs for the Small and Large\ninputs.\n</p>\n<h3>The second program (Small)</h3>\n<p>\nFor the Small input, <b>B</b> is always a string of <code>1</code>s. That means\nthe first program is always 0?, repeated <b>L</b> times. For instance, if\n<b>B</b> = <code>111</code>, the first program is 0?0?0?.\n</p><p>\nOur second program needs to be able to override any two of those ?\ninstructions; that way, we can print any output with up to two <code>1</code>s.\nHowever, we can't override all three ? instructions, since that means our\nprogram might print <b>B</b>. So we need a second program that contains\n<b>L</b>-1 <u>1</u>s, but not <b>L</b> <u>1</u>s. The solution to this is\nfairly simple: our second program simply consists of <u>1</u>, repeated\n<b>L</b>-1 times. For instance, if <b>B</b> = <code>111</code>, the second\nprogram is <u>11</u>.\n</p>\n<h3>The second program (Large)</h3>\n<p>\nTo solve the problem for arbitrary <b>B</b>, we need a second program that,\nwhen taken as a string, has every (<b>L</b>-1)-length string as a subsequence\n(so we can print any string except <b>B</b>), but doesn't have <b>B</b> as a\nsubsequence. (Here, we use \"subsequence\" to mean any set of elements, ordered\nas they appear in the original sequence; they need not be adjacent.) We'll\ndiscuss how to produce such a program shortly.\n</p><p>\nNow, with our first program and this hypothetical second program, we can\nproduce any <b>L</b>-length string except <b>B</b>. That's because the second\nprogram has every possible subsequence of length <b>L</b>-1, so we can override\nup to <b>L</b>-1 of the ? instructions of the first program. However, we cannot\noverride all <b>L</b> of them to produce <b>B</b>, because the second program\ndoesn't have <b>B</b> as a subsequence.\n</p><p>\nThere are many ways to generate the second program. This one won't produce the\nshortest program, but it is perhaps the easiest to explain:\n<ol>\n<li>Start with a copy of <b>B</b>, excluding the last character.</li>\n<li>Replace each character with a two-character sequence as follows:\n<code>0</code> &#8614; <u>10</u>, <code>1</code> &#8614; <u>01</u>.</li>\n</ol>\nFor instance, if <b>B</b> = <code>010</code>, the second program is\n<u>1001</u>. The first <code>0</code> becomes <u>10</u>, the <code>1</code>\nbecomes <u>01</u>, and we ignore the last character of <b>B</b>.\n</p><p>\nWe outlined the two requirements above for the second program to be valid:\n<ul>\n<li>The second program must have every (<b>L</b>-1)-length string as a\nsubsequence.</li>\n<li>The second program must not contain <b>B</b> as a subsequence.</li>\n</ul>\nNow, we will show that the steps above give us a second program that satisfies\nthese requirements.\n</p><p>\nTo get any (<b>L</b>-1)-length subsequence, split the second program into pairs\nof adjacent instructions. Each pair contains a 0 and a 1, since that's how we\nbuilt the program. So we just pick one character from each pair, and we have\nany (<b>L</b>-1)-length string!\n</p><p>\nNow, let's try to get <b>B</b> as a subsequence of our second program. Say\n<b>B</b> = <code>010</code> and the second program is <u>1001</u>. In order to\nget 010 as a subsequence, we start from finding the first 0 in <u>1001</u>,\nwhich occurs at the second character. Next we find the first 1 after that,\nwhich is the fourth character. The pattern continues: because of how we've\nbuilt the second program, we always go through two characters whenever we try\nto find <b>B</b> as a subsequence. And because the second program only has\n2<b>L</b>-2 characters, we can't find all of <b>B</b> as a subsequence.\nTherefore, our second program is valid.\n</p>\n","id":"0000000000201bf4","statement":"<h3>Problem</h3>\n<p>\nThe Go language was designed to have a simple API and to support\nmulti-threading. The Code Jam team wants to push these goals to the limit, so\nwe are proposing a new language called Go++.\n</p><p>\nThe Go++ language uses one register, which stores one boolean value (0 or 1).\nThis register is initialized to 0. The language has three instructions:\n<ul>\n<li><code>0</code>, which sets the register to 0.\n<li><code>1</code>, which sets the register to 1.\n<li><code>?</code>, which prints the current register value.\n</ul>\nSimple, right? To support multi-threading, we allow two different Go++ programs\nto run simultaneously while sharing the one register. Each instruction executes\natomically &mdash; that is, one instruction must completely finish before the\nnext instruction can start. However, the two programs may be interleaved in any\nway that preserves the relative order within each program.\n</p><p>\nFor example, here are the only six ways in which the two programs\n<code>1?</code> and <code><u>?0</u></code> could be executed together. (The\nunderline on the second program is just to distinguish its instructions from\nthe instructions in the first program.)\n<ul>\n<li><code><u>?0</u>1?</code>, which will print <code>01</code>. (Remember that\nthe register is initialized to 0.)</li>\n<li><code><u>?</u>1<u>0</u>?</code>, which will print <code>00</code>.</li>\n<li><code><u>?</u>1?<u>0</u></code>, which will print <code>01</code>.</li>\n<li><code>1<u>?0</u>?</code>, which will print <code>10</code>.</li>\n<li><code>1<u>?</u>?<u>0</u></code>, which will print <code>11</code>.</li>\n<li><code>1?<u>?0</u></code>, which will print <code>11</code>.</li>\n</ul>\n</p><p>\nNote that the output string always consists of <code>0</code>s and\n<code>1</code>s, and never <code>?</code>s, since <code>?</code> is not a state\nthe register can be in.\n</p><p>\nUsually, programmers write programs to produce a desired output, but your task\nwill be to write two programs that <i>won't</i> produce an <i>undesired</i>\noutput! Specifically, you will be given a \"bad\" string <b>B</b> of length\n<b>L</b>, and a set <b>G</b> of <b>N</b> \"good\" strings, all of\nlength <b>L</b>. You must produce two Go++ programs (not necessarily of the\nsame length), which, when run in the way described here, could produce\n<i>all</i> of the strings in <b>G</b>, but could <i>not</i> produce the string\n<b>B</b>. It is fine if the programs could also produce other strings that are\nnot <b>B</b> and not in <b>G</b>. Note that there must be a combined total of\nexactly <b>L</b> <code>?</code> instructions in the two programs. The combined\nnumber of instructions in the two programs must not exceed 200.\n</p><p>\nFor example, for <b>B</b> = <code>11</code> and <b>G</b> = { <code>10</code>,\n<code>00</code> }, the programs <code>?</code> and <code>10?1</code> would be\none valid answer. They can produce every string in <b>G</b>, but they cannot\nproduce <b>B</b>, no matter how they are interleaved. (They can also produce\nthe string <code>01</code>, which is not <b>B</b> and is not in <b>G</b>, but\nthat is fine.) However, the programs <code>1?</code> and <code>?0</code> would\nnot be a valid answer, since (as we saw above) they can produce <b>B</b>. The\nprograms <code>00</code> and <code>??</code> would not be a valid answer, since\nthey cannot produce every string in <b>G</b>.\n</p><p>\nCan you produce two programs that satisfy the conditions, or determine that the\ntask is <code>IMPOSSIBLE</code>?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow; each consists of three lines. The first line of each test\ncase has two integers <b>N</b> and <b>L</b>: the number of strings in <b>G</b>,\nand the length of the <b>B</b> string and the strings in <b>G</b>. The second\nline has <b>N</b> different strings of length <b>L</b>: the strings in\n<b>G</b>. The third line has one string of length <b>L</b>: the bad string\n<b>B</b>. <b>B</b> and all of the strings in <b>G</b> are made up of only\n<code>0</code>s and/or <code>1</code>s.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: IMPOSSIBLE</code>,\nif no programs will satisfy the conditions; otherwise, output\n<code>Case #x: y z</code>, where <code>x</code> is the test case number\n(starting from 1) and <code>y</code> and <code>z</code> are your two programs\nthat satisfy the conditions. The combined number of instructions in your\nprograms must not exceed 200. Each program must contain at least one\ninstruction. There must be a combined total of exactly <b>L</b> <code>?</code>\ninstructions in the two programs.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\n1 &le; <b>L</b> &le; 50.<br/>\nAll strings in <b>G</b> are different.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n<b>B</b> consists entirely of <code>1</code>s.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n<b>B</b> may be any string consisting of <code>0</code>s and/or\n<code>1</code>s.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 2\n10 00\n11\n3 2\n11 10 00\n01\n4 2\n00 01 10 11\n11\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: ? 10?1\nCase #2: 1?? 0\nCase #3: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe sample output displays one set of answers to the sample cases. Other\nanswers may be possible.\n</p><p>\nSample case #1 is the one described in the problem statement.\n</p><p>\nSample case #2 would not appear in the Small dataset.\n</p><p>\nSample case #3 is obviously <code>IMPOSSIBLE</code> because <b>B</b> is\nin <b>G</b>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":28}],"title":"Go++","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Teaching Assistant: Analysis</h2>\n<p>\nLet's define N as the number of days in the test. Notice that since a student is\nnot allowed to do nothing on a test day, the student must request at least N/2\nproblem sets. Further, there is no reason to request more than that, since the\nextras cannot be submitted.\n</p><p>\nWe'll begin with a dynamic programming solution that is sufficient for the Small\ndataset, and then discuss a mathematical formula that solves the Large dataset.\n</p>\n<h3>A dynamic programming approach</h3>\n<p>\nBecause we can only submit the problem we requested most recently, we can view\nthe problems that we hold as a stack, where requesting corresponds to pushing\nand submitting the most recently requested problem corresponds to popping.\n</p><p>\nConsider what happens on day 1. Clearly, we must request a problem set, and we\nnow have to pick a day to submit it. Now, between the request and the\nsubmission, we can push to and pop from the stack, but after we are finished,\nthe stack must contain the problem we requested on day 1, and nothing else.\nThat means we need to have an even number of days between our request on day 1\nand the corresponding submission.\n</p><p>\nWe can think of the period of time between our request and our submission as a\nsubproblem, and the time after the submission as another subproblem. Each of\nthose subproblems must leave the stack the way they found it, so we can use the\nsame set of rules that we used above for every subproblem.\n</p><p>\nNow, we'll express how to solve the problem in terms of recursion. At each\nstage, we'll be looking at some range of days, from day i to day j. So the\nsubproblem (i,j) is to find the best possible score we can get over the days\nfrom i to j. We'll also say we can't touch the existing entries on the stack\n(corresponding to any days before i), and must leave the stack as we found it.\nWe can then solve the subproblem as we did the original problem: request a\nproblem set on day i, then pick where in the (i,j) interval to submit it such\nthat there's an even number of days between the request and the submission.\n</p><p>\nAt this point, each of our choices divides the subproblem into two additional,\npossibly-empty subproblems. For a subproblem of length 6, for example, here are\nthe ways to place the request and submission:\n</p>\n<center><pre><code>_ _ _ _ _ _\n&darr;\nR S _ _ _ _\nR _ _ S _ _\nR _ _ _ _ S</code></pre></center>\n<p>\nGiven the pairs of request and submission days, how do we decide which type of\nproblem set to request? If we request the type that doesn't match the\nassistant's mood on request day, the best score we can get is 5 points. But we\nalways get at least that much by requesting the type that matches the\nassistant's mood, so we should always do that. Then, the score we get when we\nsubmit just depends on whether the assistant's mood on submit day matches the\ntype of problem we requested: we get 10 points total if they match, and 5 if\nthey don't.\n</p><p>\nThe empty subproblems are the base cases of our recursion. For larger problems,\nwe find, for each possible submission point, the score we get from requesting\nand submitting that problem set (10 if the assistant's mood on request day\nmatches its mood on submit day, 5 otherwise), plus the optimal scores of the\nsubproblems. We can use this to recursively find the solution to the original\nproblem; memoizing the solutions for the subproblems yields a DP solution.\nBecause the memoization table is size O(N<sup>2</sup>) and it takes O(N)\niterations to fill each cell, this algorithm is O(N<sup>3</sup>), which is\nsufficient to solve the Small problem.\n</p>\n<h3>A formulaic approach</h3>\n<p>\nIt's also possible to solve the problem with a simple mathematical formula based\non the input.\n</p><p>\nCount the number of even- and odd-numbered days on which the assistant is in the\nmood for Coding and Jamming. That gives us four numbers, which we'll call CE,\nCO, JE, and JO (for instance, CE is the number of even-numbered days on which\nthe assistant is in the mood for Coding). We will show that the maximum possible\nscore is:\n</p><center><p>\nS = 10 * (min(CE, CO) + min(JE, JO)) + 5 * abs(CE - CO).\n</p></center><p>\nWe'll first show that this is an upper bound (we can't get a score higher than\nS), then show that it is tight (we can get a score equal to S).\n</p><p>\nFirst, note that any request/submit pair for the same problem (which we'll just\ncall a pair) must have one even and one odd day; that is, for any problem set,\nit was either requested on an odd day and submitted on an even day, or vice\nversa. That must be true because we need an even number of days between the\nrequest and the submission. Now, since we need an even Coding day and an odd\nCoding day to make a pair where both days are Coding, the amount of those pairs\nthat we can make is equal to the minimum of CE and CO. We can apply the same\nlogic to Jamming. Then, we can pair up the leftovers; the amount of leftover\npairs is the amount by which CE and CO differ (you can show that JE and JO\ndiffer by the same amount). No matter how we pair up the leftovers, there is no\nway to form more matched pairs.\n</p><p>\nTo show that this bound is tight, we will construct a solution that achieves\nthat upper bound. We make a list of the days in order. Then, whenever we see two\nadjacent days with the same mood, mark the first one as a request and the second\nas a submission, then remove those two days from our list. Observe that we can\ncontinue making pairs on this list, and they'll be valid on the real list (it's\nimpossible for a new pair to be halfway inside and halfway outside any pair that\nwe've removed, since we only remove pairs when there's nothing inside them).\nContinue this process until we can't anymore. At this point, since there aren't\nany adjacent days with the same mood, the mood must alternate between days. But\nthat means that all even-numbered days have the same mood, and all odd-numbered\ndays have the other mood. So we can pair all of those up, completing the proof.\n</p>\n<h3>A greedy approach</h3>\n<p>\nIf you're curious, it's also possible to use a greedy stack-based algorithm to\nsolve the Large problem. Our algorithm proceeds from left to right, and at each\npoint decides whether to request or submit. We maintain a stack of problem sets\nthat we hold, where a request is a push and a submit is a pop, then select our\naction each day as follows:\n<ol>\n<li>If we have no unsubmitted problem sets, request.</li>\n<li>If we've made N/2 requests thus far, where N is the number of days in the test, submit.</li>\n<li>If the top of the stack contains a problem set that matches the assistant's mood, submit.</li>\n<li>Otherwise, request.</li>\n</ol>\n</p><p>\nIt's fairly difficult to see why this is valid on its own, but we can show that\nthis also obeys the formula that we give above.\n</p><p>\nBoth algorithms (the stack algorithm and the adjacent pair algorithm) find an\nadjacent pair with the same mood some number of times; we'll call these hits.\nPairs with a different mood are misses. It remains to prove that the stack\nalgorithm gets the optimal number of hits.\n</p><p>\nIn most cases, both algorithms hit and miss in the same places. Intuitively,\nsteps 3 and 4 of the stack algorithm correspond to finding and removing\nadjacent pairs with the same mood. Then, steps 1 and 2 clean up the remaining\nunmatched pairs.\n</p><p>\nThere are some corner cases, however, where the algorithms don't precisely\nmatch. Take the input CJCJJC, for example: the stack algorithm produces RRRSSS,\nwhile the adjacent-pairs algorithm results in RRSRSS.\n</p><p>\nAll of these corner cases occur when there's an unmatched pair that the stack\nalgorithm doesn't match, failing to see that there's a matched pair later on at\nthe same level. In other words, they all look like the following. (You can swap\nthe Js and Cs, but we'll use the case that we show below without loss of\ngenerality.)\n</p>\n<center><pre><code>\n... J ... C ... J ... J ...\n</center></pre></code>\n<p>\nThen, the stack algorithm requests for the first two and submits for the last\ntwo, while the adjacent pairs algorithm matches the second pair, then the first\npair. Notice that these have the same result either way: there's always one\nunmatched pair and one matched pair. Hence, the algorithms both produce the\noptimal score, even though they may attain it in different ways.\n</p>\n","id":"0000000000201c90","statement":"<h3>Problem</h3>\n<p>\nYou are taking a programming course which is graded using problem sets of\ndifferent types.  The course goes for a positive even number of days. You\nstart the course with no problem sets. On each day of the course, you\n<i>must</i> do <i>exactly one</i> of the following:\n<ul>\n<li>Request a \"Coding\" problem set.</li>\n<li>Request a \"Jamming\" problem set.</li>\n<li>Submit a problem set for grading. You must have at least one\nproblem set to choose this option. If you have multiple problem sets, you\nmust submit the one among those that was <b>requested most recently</b>,\nregardless of its type.\n</li>\n</ul>\n<p>\nAll problem sets are different. There is no requirement on how many sets of\neach type must be submitted. Once you submit a set, you no longer\nhave that set. Any problem sets that you have not submitted before the end\nof the course get you no points.\n</p><p>\nThe problem sets are requested from and submitted to an\nartificially-intelligent teaching assistant. Strangely, the assistant has\ndifferent moods &mdash; on each day it is in the mood for either \"Coding\" or\n\"Jamming\".\n</p>\n\n<ul>\n<li>When you request a problem set:\n<ul>\n<li>If the requested topic matches the assistant's mood, it assigns a problem set worth a\nmaximum of 10 points.</li>\n<li>If the requested topic does not match its mood, it assigns a problem set\nworth a maximum of 5 points.</li>\n</ul>\n</li>\n<li>When you submit a problem set:\n<ul>\n<li>If the topic of the submitted set matches the assistant's mood that day, it\ngives you the maximum number of points for that set.</li>\n<li>If the topic of the submitted set does not match its mood that day, it\ngives you 5 points fewer than the maximum number of points for that set.</li>\n</ul>\n</li>\n</ul>\n<p>\nFor example:\n</p>\n<ul>\n<li>f you request a \"Coding\" problem set on a day in which the assistant is in\na \"Coding\" mood, and submit it on a day in which it is in a \"Jamming\" mood, you\n will earn 5 points: the problem set is worth a maximum of 10, but\nthe assistant gives 5 points fewer than that.</li>\n<li>If you request a \"Jamming\" problem set on a day in which the assistant is\nin a \"Coding\" mood, and submit it on a day in which it is in a \"Jamming\" mood,\nyou will earn 5 points: the set is worth a maximum of 5, and the assistant\ngives you the maximum number of points.</li>\n</ul>\n<p>\nThanks to some help from a senior colleague who understands the assistant very\nwell, you know what sort of mood the assistant will be in on each\nday of the course. What is the maximum total score that you will be able to\nobtain?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>; <b>T</b>\ntest cases follow. Each test case consists of one line with a string <b>S</b>\nof <code>C</code> and/or <code>J</code> characters. The i-th character of\n<b>S</b> denotes the assistant's mood on the i-th day of the course. If it is\n<code>C</code>, it is in the mood for \"Coding\"; if it is <code>J</code>, it is\nin the mood for \"Jamming\".\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe maximum number of points you can obtain for that case.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\nThe length of <b>S</b> is even.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n2 &le; the length of <b>S</b> &le; 50.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n2 &le; the length of <b>S</b> &le; 20000.<br/>\nThe sum of lengths of all <b>S</b> in the dataset is at most 150000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\nCCJJ\nCJCJ\nCJJC\nCJJJ\nCCCCCC\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 20\nCase #2: 10\nCase #3: 20\nCase #4: 15\nCase #5: 30\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThis strategy is optimal for sample case #1:<br>\nDay 1: Request a \"Coding\" problem set (call it C1).<br>\nDay 2: Submit C1.<br>\nDay 3: Request a \"Jamming\" problem set (call it J1).<br>\nDay 4: Submit J1.<br>\n</p><p>\nThe following strategy is optimal for sample cases #2, #3, and #4: request C1,\nrequest J1, submit J1, submit C1.\n</p><p>\nFor case #2, for example, note that you could <i>not</i> request\nC1, request J1, and then submit C1. Only the most recently\nrequested problem set can be submitted.\n</p><p>\nIn sample case #5, you can alternate between requesting a\n\"Coding\" problem set on one day, and submitting it on the next day.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Teaching Assistant","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Forest University: Analysis</h2>\n<h3>An unusual problem</h3>\n<p>\nSmall-only problems are relatively rare in Code Jam. Sometimes, as with 2012's Proper Shuffle from Round 1A 2014, this is because we have a randomized solution in mind and want contestants to be able to try again if necessary, even if the probability of a contestant's optimal solution actually failing due to chance is very small. The Forest University problem is Small-only for both of these reasons. We could have added another Small dataset small enough to solve precisely via dynamic programming, but we didn't think it would add useful resolution to help us pick our 26 advancers.\n</p><p>\nClearly, with up to 100 courses, there are far too many course sequences to enumerate. The problem has an unusually relaxed tolerance for less precise answers, so it is a natural candidate for a <a href=\"https://en.wikipedia.org/wiki/Monte_Carlo_method\" target=\"_blank\">simulation-based</a> approach: we can generate course schedules and check whether they contain the cool substrings. Unusually for a simulation problem, though, the challenge here is to figure out how to do the simulation correctly even once! How do we sample the set of all course sequences uniformly at random?\n</p>\n<h3>A weighted-sampling method</h3>\n<p>\nSome pen and paper analysis of a small forest can reveal a simple rule that is sufficient to guide our simulations. Let's consider a case with five courses A, B, C, D, and E; A and E are basic, A is the prerequisite of both B and D, and B is the prerequisite of C.\n</p>\n<p>\nThen there are fifteen possible orders in which to take the courses: ABCDE, ABCED, ABDCE, ABDEC, ABECD, ABEDC, ADBCE, ADBEC, ADEBC, AEBCD, AEBDC, AEDBC, EABCD, EABDC, EADBC. Notice that four-fifths of these begin with A and one-fifth begin with E. A is a root node with a total of 4 descendants (including itself); E is a root node with a total of 1 descendant (including itself). This is a promising pattern, and it is not coincidental! It suggests a method for building up a course string while sampling uniformly: keep choosing one of the available courses, with probability proportional to the size of that course's subtree (itself plus all its descendants).\n</p><p>\nTo apply this method to the example above: we start with an empty course string, and at first, we can only choose either A or E. A has 4 descendants including itself, and E has 1, so we choose A with probability 4/5 and E with probability 1/5. Suppose that we choose A. Now we have three choices for the next course: B, D, and E. B has 2 descendants including itself; D has 1; E has 1. So, we choose B with probability 2/4, D with probability 1/4, and E with probability 1/4. Suppose that we choose D. Now we have two choices: B and E; we choose these with probability 2/3 and 1/3, respectively. We continue in this way until we've built a full sequence.\n</p><p>\nWhy does this work? Speaking more generally: let's add a single root node to be the parent of all nodes with no prerequisites.  We can now recursively compute, for each subtree, a schedule of just the classes in that subtree. Suppose that the subtree has root node V and size S. First, we compute a schedule for each subtree whose root is one of the children of V. Then, we put V first in the new schedule we are creating, and we choose an assignment (uniformly at random) of the remaining S-1 positions to each of the subtrees, such that each subtree is assigned as many positions as it has nodes. Then, we copy the ordering for each subtree into that subtree's positions. This results in a uniformly randomly chosen schedule.\n</p><p>\nSince we are picking a uniformly random assignment for each subtree, then interleaving them together uniformly randomly, the fraction of possible orders in which a given top-level course (i.e. the root of a certain subtree) appears first can be computed using a multinomial coefficient. For example, if we have to interleave A elements from one subtree and B elements from another subtree, the total number of ways to do so is (A+B)! / (A! &times; B!). The number of these ways that start with an element from subtree A is (A+B-1)! / ((A-1)! &times; B!), and the number of these ways that start with an element from subtree B is (A+B-1)! / (A! &times; (B-1)!). The ratio between these is (A! &times; (B-1)!) / ((A-1)! &times; B!), and this reduces to A / B. This explains why it suffices to sample proportionately to the size of each subtree.\n</p>\n<h3>A surprisingly elegant method</h3>\n<p>\nGenerating a random sequence is equivalent to assigning distinct numbers from 1 to <b>N</b> to\nnodes in our forest, in such a way that the number of a node is smaller than the number of all its descendants. Let's start with any of the <b>N</b>! possible assignments, chosen uniformly. Now let's go through nodes from top to bottom, and if a node is not the smallest in its subtree, we swap its number with the smallest. This generates sequences uniformly, since each sequence can be obtained from P different permutations, where P is the product of sizes of subtrees of all nodes. The probability that a given node X is the smallest (once it's available to be chosen) is proportional to the size of the tree it is rooting, because any of those nodes that get the smallest number will \"give\" it to X.\n</p>\n<h3>But will we get a precise enough answer?</h3>\n<p>\nIf we check <i>K</i> uniformly generated sequences, and the true probability to find a given substring is <i>p</i>, then the fraction of those <i>K</i> sequences that contain this substring follows a binomial distribution with parameters <i>K</i>, <i>p</i>, which we can approximate with a normal distribution with mean p and standard deviation sqrt(<i>p</i> &times;\n(1 - <i>p</i>) / <i>K</i>).\n(<a href=\"https://en.wikipedia.org/wiki/Binomial_distribution#Normal_approximation\" target=\"_blank\">This Wikipedia article</a> has some guidelines on when this approximation is valid.) If we run 10000 iterations, this is at most 0.5 / 100=5e-3, so the required precision of 3e-2 is 6 standard deviations. So, the probability of having one particular answer incorrect is roughly 1 in 500 million, which means that the probability of having at least one of the 500 required answers incorrect is at most 1 in a million.\n</p><p>\nThe error bounds are generous enough that, with a fast enough implementation, the problem is solvable in slower languages such as Python.\n</p>\n","id":"0000000000201d1c","statement":"<h3>Problem</h3>\n<p>\nThe Forest University offers its students <b>N</b> courses, which must all be\ntaken to obtain the degree. The courses can only be taken one at a time - you\nmust complete a course before starting another. Each course is either\n<i>basic</i>, which means one can take it without any prior knowledge, or\n<i>advanced</i>, in which case exactly one other course is its\n<i>prerequisite</i>.\n</p><p>\nA student must take the prerequisite for a course before taking the course,\nalthough they do not need to be taken immediately one after the other. A course\nmight be the prerequisite for multiple other courses. There are no prerequisite\ncycles. Any sequence of the <b>N</b> courses that meets the rules for\nprerequisites is valid for obtaining the degree.\n</p><p>\nWhen you graduate, the university commemorates the sequence of courses you have\ntaken by printing an abbreviated version of it on your graduation hat. More\nprecisely, this abbreviated version is a string consisting of the first letter\nof the name of each course you have taken, in the order you have taken them.\nFor example, if you have taken a Coding course and a Jamming course, in that\norder, your graduation hat will say <code>CJ</code>. It is considered trendy to\nhave certain <i>cool words</i> as a substring of the string on one's graduation\nhat.\n</p><p>\nConsider all possible valid sequences in which the courses can be taken. For\neach cool word, you need to find the fraction of those sequences that have the\ncool word as a substring (at least once) of the string on the corresponding\ngraduation hat. Note that we're interested in the fraction of possible course\nsequences, <i>not</i> the fraction of possible different graduation hat\nstrings. (Since multiple courses may start with the same letter, there may be\nfewer possible strings than course sequences.)\n</p><p>\nSomewhat unusually for Code Jam, we are only looking for an approximate answer\nto this problem; pay careful attention to the output format.\n</p>\n\n<h3>Solving this problem</h3>\n<p>\nThis problem has only 1 Small input and no Large input. You will be able to\nretry the input (with a time penalty).\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each test case consists of five lines, in this order, which\ncontain the following:\n</p>\n<ol>\n<li>the number <b>N</b> of courses.</li>\n<li><b>N</b> integers; the i-th of these integers gives the number of the\nprerequisite course for the i-th course, or 0 if the i-th course is basic. The\ncourses are numbered from 1 to <b>N</b>.</li>\n<li><b>N</b> uppercase English letters (without whitespace in between), with\nthe i-th character giving the first letter of the i-th course's name.</li>\n<li>the number <b>M</b> of cool words.</li>\n<li><b>M</b> cool words, each of which consists only of uppercase English\nletters.</li>\n</ol>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing\n<code>Case #x: y<sub>1</sub> y<sub>2</sub> ... y<sub><b>M</b></sub></code>,\nwhere <code>x</code> is the test case number (starting from 1) and\n<code>y<sub>i</sub></code> is the fraction of valid course sequences that will\nhave the i-th cool word as a substring of the string on the graduation hat.\n</p><p>\n<code>y<sub>i</sub></code> will be considered correct if it is within an\nabsolute error of 0.03 of the correct answer. See the\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an\nexplanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n\n<h3>Small dataset (Test Set 1 - Visible)</h3>\n<p>\nTime limit: 300 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>N</b> &le; 100.<br/>\n1 &le; <b>M</b> &le; 5.<br/>\nThe length of each cool word is between 1 and 20.<br/>\nEach cool word consists of uppercase English letters only.<br/>\nThere are no cycles formed by the prerequisites.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n2\n0 1\nCJ\n4\nCJ C D JC\n3\n0 1 0\nBAA\n3\nAA AAB ABA\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1.0 1.0 0.0 0.0\nCase #2: 0.67 0.0 0.33\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe sample output displays one set of acceptable answers to the sample cases.\nOther answers are possible within the allowed precision.\n</p><p>\nIn sample case #1, course 1 (<code>C</code>) is a basic course that is a\nprerequisite for the advanced course 2 (<code>J</code>). The only way to\ncomplete the courses is to take course 1 and then course 2. This creates the\nstring <code>CJ</code>. So the cool words <code>CJ</code>, <code>C</code>,\n<code>D</code>, and <code>JC</code> are present as substrings in 1, 1, 0, and 0\nout of 1 possible cases, respectively.\n</p><p>\nIn sample case #2, the basic course 1 (<code>B</code>) is a prerequisite for\nthe advanced course 2 (<code>A</code>), and course 3 (<code>A</code>) is\nanother basic course. There are three possible ways of completing the courses:\n</p>\n<ol>\n<li>take course 1, then course 2, then course 3 (string: <code>BAA</code>)</li>\n<li>take course 1, then course 3, then course 2 (string: <code>BAA</code>)</li>\n<li>take course 3, then course 1, then course 2 (string: <code>ABA</code>)</li>\n</ol>\n<p>\nThe cool words <code>AA</code>, <code>AAB</code>, and <code>ABA</code> are\npresent as substrings in 2, 0, and 1 out of 3 possible cases, respectively.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":25}],"title":"Forest University","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201bf3","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2016"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
