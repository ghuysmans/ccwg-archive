{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1398483000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433162","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1A was our biggest non-Qualification round ever, with 6685 contestants who downloaded at least one input. Contestants faced three challenging problems: <i>Charging Chaos</i> was not a very hard problem, but the problem limits were a little bit misleading for some of the contestants, so they overrated the problem, and <b>41%</b> of attempts on the Large input failed as a consequence. <i>Full Binary Tree</i> was a directly described problem, could be solved with a greedy approach for depth-first-traversal algorithm, and unlike problem A, only <b>13%</b> of the Large input attempts failed for this problem.\n</p>\n<p>\nThe toughest problem of all was the non-traditional <i>Proper Shuffle</i> (same style as last year's Good Luck problem). The problem required some knowledge of classifiers and probability, and gave contestants the opportunity to retry (since it was just one small input set). It didn't help most of them, though: <b>85%</b> of the people who attempted the problem got it wrong.\n</p>\n<p>\nAt the end of the day, <b>54%</b> of our contestants solved something, and 198 people got <i>everything</i> right (That is really a huge number!).\n<p>\nWe hope everybody enjoyed the round! Congratulations to the Top 1000, who have now made it to Round 2; and to everyone else, we'll see you in 1B and 1C!\n</p>\n\n<hr/>\n<p>Cast</p>\n\n<p>Problem A. <i>Charging Chaos</i> Written by David Arthur. Prepared by Jonathan Wills, Hackson Leung and Jonathan Paulson.</p>\n\n<p>Problem B. <i>Full Binary Tree</i> Written by Ahmed Aly. Prepared by Greg Tener and Ahmed Aly.</p>\n\n<p>Problem C. <i>Proper Shuffle</i> Written by Petr Mitrichev. Prepared by Jonathan Paulson and Petr Mitrichev.</p>\n\n<p>\nContest analysis presented by Felix Halim, Topraj Gurung, Zong-Sian Li, Mohammad Kotb, Jonathan Paulson, Jonathan Shen, Mahbubul Hasan, Petr Mitrichev, and Timothy Loh.\n</p>\n\n<p>\nSolutions and other problem preparation by John Dethridge, Karim Nosseir, Nikolay Kurtov, Patrick Nguyen and Sean Henderson.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1398474000000,"tasks":[{"analysis":"<h3><b>Brute force algorithm:</b></h3>\n<p>\nGiven a tree with <b>N</b> nodes, there are <b>2<sup>N</sup></b> subsets of nodes that can be deleted from the tree. The brute force algorithm is to simply check all possible node deletions and pick the one where the remaining nodes form a full binary tree and the number of nodes deleted is minimum. Note that when a set of nodes are deleted from the tree, the remaining nodes may not be a tree anymore (since the tree may become disconnected).\n</p>\n\n<p>\nLet’s say there are <b>M</b> remaining nodes after deletion. One way to check whether the remaining nodes form a full binary tree is to first check whether it is still a tree. This can be done by performing a simple breadth-first or depth-first search to check that the remaining nodes are in one connected component. Next, we need to find a root in that tree where all its subtrees have either zero or two children. This leads to an O(<b>M<sup>2</sup></b>) algorithm for checking if the remaining nodes form a full binary tree.\n</p>\n\n<p>\nAnother way to check whether a graph is a full binary tree is via counting which is linear O(<b>M</b>):\n<ul>\n<li>For the trivial case where <b>M</b> equals to 1, it is a full binary tree.</li>\n<li>For <b>M</b> &gt; 1, it must satisfy that there is exactly one node having degree two and the rest of the nodes must have degree either one or three. Also, the number of remaining edges must be equal to <b>M - 1</b> to signify that it is a tree, and not a disconnected graph.</li>\n</ul>\n</p>\n\n<p>\nTherefore, using different methods for checking whether the resulting graph is full binary tree or not you end up with a brute force algorithm that runs in O(<b>2<sup>N</sup> * N<sup>2</sup></b>) or O(<b>2<sup>N</sup> * N</b>), which is sufficient to solve the small dataset. But it is not sufficient to solve the large dataset where <b>N</b> = 1000. In the following sections, we address the large dataset.\n</p>\n\n<h3><b>Quadratic algorithm:</b></h3>\n<p>\nThe insight to the quadratic algorithm is that minimizing the number of deleted nodes is equivalent to maximizing the number of nodes that are not deleted.\n</p>\n\n<p>\nLet’s pick a root for the tree. The parent-child relationship is defined based on the chosen root. For each node, we will make a decision to delete it or keep it with the goal of maximizing the size of the full binary subtree. We now investigate the various cases for each node. If a node has only one child, then we have to remove that child (as it violates the full binary tree condition of having 0 or 2 children). Therefore, the size of that subtree is only <b>one</b> node (i.e. we only count the node itself). If it has more than one candidate children, we have to pick two of them as the children of the node. But which two? We pick the two which retain the maximum number of nodes in their own subtrees, which we will demonstrate later.\n</p>\n\n<p>\nWe can implement the above idea via a greedy post-order depth-first-traversal from a chosen root. During the traversal, we determine the maximum number of nodes we can retain in each subtree to form a full binary tree. The function <code>maxSubtreeNodes(node, parent)</code> is as follows:\n<ul>\n<li>The function’s parameters are the current node and its parent.</li>\n<li>If the current node has 0 or 1 children then the number of nodes in this subtree is 1.</li>\n<li>Otherwise, we have at least two subtrees and we should recursively call the function for each child of the current node. Remember, we want to maximize the number of nodes retained in the current node’s subtree, therefore we keep the two children that have the largest subtrees rooted at those children. We return the size of the two largest subtrees + 1 (1 to account the current node).</li>\n</ul>\n</p>\n\n<p>\nFinally, given this function the minimum number of nodes to be deleted for a given root node is:\n<code><pre>\nN - maxSubtreeNodes(root, 0)  // 0 as the root does not have a parent.\n</pre></code>\n</p>\n\n<p>\nWe can run the <code>maxSubtreeNodes(root, 0)</code> function by picking each of the <b>N</b> nodes as the root. We pick the root node that minimizes <code>N - maxSubtreeNodes(root, 0)</code>. As <code>maxSubtreeNodes(root, 0)</code> is a depth-first-traversal on a tree, it runs in O(<b>N</b>) time. Also, we run the traversal <b>N</b> times picking each node as the root. Therefore, the time complexity is O(<b>N<sup>2</sup></b>).\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U29JPWLXdbiTFUCuQcNQVjA9D2IEeP9x5oqYM-zVUQT6ZTL1a7QZJJCi2FxfOELQKl_5sXaA_nZNxAkSNBigN00wDyhlAZpDg/full_binary_tree_figure_1.png\">\n\n<p>\nFigure 1 shows an example where we demonstrate running <code>maxSubtreeNodes(1, 0)</code>. Node 8 is deleted as it is the only child for node 7. Then node 7 is deleted for the same reason. After that, node 1 will have to choose only two children among nodes 2, 3, and 4. These 3 subtrees have sizes 1, 3, and 1, respectively. So node 1 will choose the maximum two subtrees which are nodes 3 and 4 (note we could choose node 2 instead of node 4 too). So for <code>maxSubtreeNodes(1, 0)</code>, the maximum number of nodes to keep is 5 (nodes 1, 3, 4, 5, and 6). Equivalently, the minimum number of nodes to be deleted is 3 (nodes 2, 7 and 8).\n</p>\n\n<p>Here is the pseudo-code for this algorithm:</p>\n<code><pre>\nminDeletions = infinity\nfor root = 1 to N:\n  minDeletions = min(minDeletions, N - maxSubtreeNodes(root, 0))\n\ndef maxSubtreeNodes(currentNode, parent):\n  maximumTwoNumbers = {}  // Structure that keeps track of \n  // the maximum two numbers.\n  for x in neighbors of currentNode:\n     if x == parent:\n       continue\n     update maximumTwoNumbers with maxSubtreeNodes(x, currentNode)\n  if size of maximumTwoNumbers == 2:\n    return 1 + sum(maximumTwoNumbers)\n  return 1\n</pre></code>\n\n\n<h3><b>Linear algorithm:</b></h3>\n<p>\nThe previous quadratic algorithm is sufficient to solve the large dataset but you might be interested in a solution with better time complexity. We present here a linear time algorithm which is based on the quadratic time algorithm.\n</p>\n\n<p>\nIn the quadratic algorithm, we take O(<b>N</b>) to compute the size of the largest two subtrees for any root node (remember, we brute force over all <b>N</b> possible root nodes). So our goal in the linear time algorithm is to compute the size of the largest two subtrees for any node in constant time. To do so, we will precompute the three largest children subtrees (not only two unlike in the quadratic algorithm). We will explain why we need three largest children in a subsequent paragraph.\n</p>\n\n<p>\nSo let's define our precomputation table structure. It is a one-dimensional array of objects called top3, which is defined as follows:\n<code>\n<pre>\n  class top3:\n    class pair:\n      int size\n      int subtreeRoot\n    pair children[3]  // children is sorted by the size value.\n    int parent\n</pre>\n</code>\n</p>\n\n<p>\nIn the greedy DFS function <code>maxSubtreeNodes(node, parent)</code>, there are only <b>2 * (N-1)</b> different parameter pairs for the function (a parameter pair is the node, parent pair, and also there are exactly <b>N-1</b> edges in any tree). The key to our linear algorithm is to run DFS once on the given tree from some root node (say from node 1), and during this traversal for every node, to store the three largest subtrees among its children while also keeping track of the parent of the node. We will explain later why we need to keep track of the parent. This DFS traversal will be O(<b>N</b>) as it visits every node exactly once.\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1avHyYzJjgTJfqIJ0XMPSkMmASegbXC1HEl4FUd1DWQv7Noh4jnWhChO8B6Wf4ouEeHQ5z4qJZbLNhEelnMp0PA_XTRMzCzA/full_binary_tree_figure_2.png\">\n\n<p>\nFigure 2 is an illustration figure for the stored top3 objects for every node after calling <code>maxSubtreeNodes(1, 0)</code>. For node 2, {1, 5} means the subtree rooted at the child node 5 has maximum size 1, and “Parent: 1” means the parent of node 2 is 1.\n</p>\n\n<p>\nBut still after doing this precomputation there is something missing in our calculation. We assumed that node 1 is the root but in the original quadratic algorithm, we need to try all nodes as root. We now show how we can avoid having to try all nodes as root. In the function described above, for any node its parent is not considered as a candidate to be put in that node’s top3 children array. We now describe an example to show how we account for the parent of a particular node. In the example, we will use the parent’s information to update the top3 array for the current node.\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1zbDmDzuk2xZ1pZzkDgZq_AJwKfUoIsPknB33ylgTBaXbc7C-ZqgBGGbzZlJVwa-d8sWy-wkXCzJEeh4-OJiTMJcGaeGlokQ/full_binary_tree_figure_3.png\">\n\n<p>\nWe describe a local update process to fix the top3 array for node 2. Remember that node 2’s parent is node 1 (see Figure 2). Let us pretend that node 2 is picked as the root (shown in Figure 3). We then look at its parent’s (node 1’s) top3 array. Note that the top element in the top3 array for node 1 is in fact node 2! We update node 2’s top3 array using node 1’s top3 array, therefore we exclude the result for node 2 from node 1’s top3 array. After excluding node 2 from the top3 array of node 1, the resulting pair describing node 1 is {5, 1} (i.e. size of subtree rooted at node 1 excluding node 2 is 5: nodes 1, 3, 4, 7 and 8). We now update the top3 array for node 2 with {5,1}. Therefore, now node 2’s top3 array is: {5,1}, {1,5}, {1,6}, and the size of the largest full binary tree rooted at node 2 is 7 (5 + 1 from the first two children, and 1 to count node 2 itself).\n</p>\n\n<p>\nWe perform the local update process described in the previous paragraph in a pre-order depth-first-traversal starting from node 1. Note that when doing the local update, excluding the current node from its parent’s top3 array might result in an array with only one element. In such cases, the parent’s subtree (excluding the current node) should be of size 1. \n</p>\n\n<p>\nWell, you might be still wondering why we need the three largest subtrees and not two. Observe in Figure 3, if we had stored only the top 2 instead of the top 3 subtrees in node 1 (meaning only {3,2} and {3,4}) and we excluded node 2 during the local update, then we will only have the pair {3,4} which describes node 4 but ignores node 3! This would be incorrect as node 3 is part of a full binary tree rooted at node 1. Therefore we keep information for the largest three subtrees.\n</p>\n\n\n\n","id":"0000000000432a8f","statement":"<h3>Problem</h3>\n<p>\nA tree is a connected graph with no cycles.\n\n<p>\nA rooted tree is a tree in which one special vertex is called the root. If there is an edge between <b>X</b> and <b>Y</b> in a rooted tree, we say that <b>Y</b> is a child of <b>X</b> if <b>X</b> is closer to the root than <b>Y</b> (in other words, the shortest path from the root to <b>X</b> is shorter than the shortest path from the root to <b>Y</b>).\n\n<p>\nA full binary tree is a rooted tree where every node has either exactly 2 children or 0 children.\n\n<p>\nYou are given a tree <b>G</b> with <b>N</b> nodes (numbered from <b>1</b> to <b>N</b>). You are allowed to delete some of the nodes. When a node is deleted, the edges connected to the deleted node are also deleted. Your task is to delete as few nodes as possible so that the remaining nodes form a full binary tree for some choice of the root from the remaining nodes.\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. The first line of each test case contains a single integer <b>N</b>, the number of nodes in the tree. The following <b>N</b>-1 lines each one will contain two space-separated integers: <b>X<sub>i</sub></b> <b>Y<sub>i</sub></b>, indicating that <b>G</b> contains an undirected edge between <b>X<sub>i</sub></b> and <b>Y<sub>i</sub></b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>x</b>: <b>y</b>\", where <b>x</b> is the test case number (starting from 1) and <b>y</b> is the minimum number of nodes to delete from <b>G</b> to make a full binary tree.\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b> &le; <b>N</b><br/>\nEach test case will form a valid connected tree.\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>N</b> &le; 15.<br/>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n2 &le; <b>N</b> &le; 1000.<br/>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n2 1\n1 3\n7\n4 5\n4 2\n1 2\n3 1\n6 4\n3 7\n4\n1 2\n2 3\n3 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 2\nCase #3: 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first case, <b>G</b> is already a full binary tree (if we consider node 1 as the root), so we don't need to do anything.\n\n<p>\nIn the second case, we may delete nodes 3 and 7; then 2 can be the root of a full binary tree.\n\n<p>\nIn the third case, we may delete node 1; then 3 will become the root of a full binary tree (we could also have deleted node 4; then we could have made 2 the root).","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Full Binary Tree","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem is a bit unusual for a programming contest problem since it does not require the solution to be exactly correct. In fact, even the best solutions may get wrong answer due to random chance. That being said, there exist solutions that can correctly classify, with high probability of success, whether a permutation was generated using the BAD algorithm or the GOOD algorithm. One such solution is to generate many samples of BAD and GOOD permutations and to look at their frequency distribution according to some scoring functions. Knowing the distributions of the scores, we can create a simple classifier to distinguish the GOOD and the BAD permutations. Note that while the solution seems to be very simple, the amount of analysis needed and the number of trial and errors to produce a good scoring function are not trivial. The rest of the analysis explains the intuition to construct a good scoring function.\n</p>\n\n<h4>\n<b>What makes a GOOD permutation?</b>\n</h4>\n<p>\nIf a permutation of a sequence of <b>N</b> numbers is GOOD, then the probability of each number ending up in a certain position in the permutation is exactly <b>1 / N</b>. In the GOOD algorithm, this is true for every step. In the first step, the probability of each number ending up in the first position is exactly <b>1 / N</b> since the length of the sequence is initially <b>N</b>. Now the number in the first position is fixed (i.e., it will not be swapped again in the next steps), we can ignore it in the second step and only consider the remaining sequence of <b>N - 1</b> numbers. Whichever number that gets chosen in the second step did not get chosen in the first step (<b>(N - 1) / N</b> chance), and got chosen in the second step (<b>1 / (N - 1)</b> chance), so every number has a <b>1 / N</b> chance of ending in the second position. Continuing this logic, in the end, every number has a uniform <b>1 / N</b> probability to end up in any position in the permutation sequence.\n</p>\n\n<h4><b>Why is the BAD algorithm BAD?</b></h4>\n<p>\nLet’s examine the BAD algorithm. At first, the BAD algorithm may look “innocent” that in <b>step i</b> it picks an element at random position and swaps it to the element at position <b>i</b>. However, a deeper look will reveal that the direction in which <b>i</b> is progressing makes the resulting permutation become BAD (i.e., it is not uniform). To see this, imagine we are currently at step i and we pick a random number <b>X</b> at position j where j happens to be less than i. Then <b>X</b> can never be swapped to lesser position than i in the next steps. The number <b>X</b> can only be swapped to higher positions in the permutation. This creates some bias in the permutation.\n</p>\n\n<p>\nLet’s examine the frequency of seeing the number i that ends up in position j in the permutation for all i,j. We illustrate the frequency in the figures below. The x-axis (from left-to-right) is the original position of the numbers (from 0 to N - 1). The y-axis (from bottom-to-top) is the position of numbers in the permutation generated by the algorithm (from 0 to N - 1). For this illustration, we use N = 100. We run each algorithm (the GOOD and the BAD separately) 20K times and record the event that number i (in the original position) ends up in position j (in the permutation). The intensity of the pixel at position x=i, y=j represent the frequency of the events. The darker the color represent the higher frequency of occurrence.\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U02UykaEKHnCPRh9LZmxDY8DEAU3YJoFaCpNU_4EJBQIpYb4oCbtgRMkcuyjEM1ySnc5R_jcegwrEE/good_vs_bad.png\">\n<p>\nWe can observe that the GOOD algorithm uniformly distributes the numbers from the original positions to the resulting permutation positions. While the BAD algorithm tends to distribute the lower numbers in the original positions to the higher positions in the permutation (notice the darker region on the top left corner).\n</p>\n\n\n<h2><b>A Simple Classifier</b></h2>\n<p>\nWith the above insights, we can devise a simple scoring function to classify the BAD permutation by counting the number of elements in the permutation that move to lower positions compared to its original position. See the following pseudo-code for such a scoring function:\n</p>\n<code>\n<pre>\ndef f(S):\n  score = 0\n  for i in 0 .. N-1:\n    if S[i] &lt;= i:\n      score++\n  return score\n</pre>\n</code>\n\n<p>\nThe scoring function <b>f</b> takes in a permutation sequence <b>S</b> of length <b>N</b> and returns how many numbers in the permutation sequence that ends up at position that is less than or equal to its original position. If the permutation sequence <b>S</b> is generated by the GOOD algorithm, we expect that the score should be close to 500 for N = 1000. If <b>S</b> is generated by the BAD algorithm, we expect that the score should be significantly lower than 500 (since the lower numbered elements tends to move to higher position). If we run 10K samples for each algorithm and plot the frequency distribution of the scores, we will get the following graph:\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3iHW0TSzTTmWrS33FFkmivNwfGA51LKBzTqcY4d5gwX5C70iVVr9vwvj_1w3Y_SBlOq9rcG-p7l8Ta6w/shuffle_chart.png\">\n\n<p>\nThe GOOD algorithm produces samples with scores clustered near <b>500</b> while the BAD algorithm produces samples with scores near <b>472</b>. Knowing these scores, we can build a very simple classifier that decides whether a given permutation sequence <b>S</b> is generated by the GOOD or the BAD algorithm with high probability. We can simply check the score of <b>f(S)</b> whether it is near 472 (BAD) or 500 (GOOD), as depicted in the following pseudo-code:\n</p>\n\n<code>\n<pre>\nif <b>f(S)</b> &lt; <b>(472 + 500) / 2</b>:\n  S is produced by the BAD algorithm\nelse:\n  S is produced by the GOOD algorithm\n</pre>\n</code>\n\n\n<h4><b>How accurate is the classifier?</b></h4>\n<p>\nThe good thing about being a programmer is that we do not always need formal proofs. We can roughly guess the accuracy of the classifier by generating a number of GOOD / BAD permutations each with 50% probability and check how many permutations are correctly classified using our simple classifier. According to our simulation, the simple classifier achieves around 94.05% accuracy. The simple classifier is good enough to correctly solve 109 test cases out of 120 test cases: this will happen in roughly 94.58% of all inputs. In the unlucky situation that your input is in the other 5.42%, you can download another one. 5.42% seems to be a lot to be given to chance though. What if you were only allowed one submission? In the next section we'll explore one idea out of many that offer higher chances of success.\n</p>\n\n<h2><b>Naive Bayes Classifier</b></h2>\nLet <b>S</b> be the input permutation. We want to find <b>P(GOOD | S)</b>, the probability that the GOOD algorithm was used, given that we saw the permutation <b>S</b>. By <a href=\"http://en.wikipedia.org/wiki/Bayes%27_theorem\" target=\"_blank\">Bayes’ theorem</a> it follows that:\n<pre>\n<b>P(GOOD | S) = P(S | GOOD) * P(GOOD) / (P(S | GOOD) * P(GOOD) + P(S | BAD) * P(BAD))</b>\n</pre>\n\n<p>\nwhere: \n<ul>\n<li>P(S | GOOD) is the probability that S is generated by the GOOD algorithm</li>\n<li>P(S | BAD) is the probability that S is generated by the BAD algorithm</li>\n<li>P(GOOD) is the probability that the permutation is chosen from the GOOD set</li>\n<li>P(BAD) is the probability that the permutation is chosen from the BAD set</li>\n</ul>\n</p>\n\n<p>\nSince we know that P(GOOD) and P(BAD) is equally likely since each algorithm has the same probability to be used, then we can simplify the rule to:\n</p>\n\n<pre>\n<b>P(GOOD | S) = P(S | GOOD) / (P(S | GOOD) + P(S | BAD))</b>\n</pre>\n\n<p>\nIf <b>P(GOOD | S) &gt; 0.5</b>, it means that the permutation <b>S</b> is more likely generated by the GOOD algorithm. By substituting <b>P(GOOD | S)</b> with the right hand side of the rule in <b>P(GOOD | S) &gt; 0.5</b> and performing some algebraic manipulation, we can further simplify the expression to <b>P(S | GOOD) &gt; P(S | BAD)</b>.\n</p>\n\n<p>\nWe know the exact value for <b>P(S | GOOD)</b> is <b>1/N!</b> since there are N! possible permutations. Hence, we only need to find <b>P(S | BAD)</b>. If we can find <b>P(S | BAD)</b>, we will have an optimal algorithm. Unfortunately, we do not know how to efficiently compute <b>P(S | BAD)</b> precisely. The best algorithm we know is intractable for large N = 1000.\n</p>\n\n<p>\nNevertheless, we can borrow an idea from machine learning and make a simplifying <a href=\"http://en.wikipedia.org/wiki/Naive_Bayes_classifier\" target=\"_blank\">Naive Bayes</a> assumption: let’s assume that the movement of each element is independent. Now we can approximate P(S | BAD):\n</p>\n\n<pre>\n<b>P(S | BAD)  ≈  P(S[0] | BAD) * P(S[1] | BAD) * ... * P(S[N-1] | BAD)</b>\n</pre>\n\n<p>\nwhere <b>P(S[0] | BAD)</b> is the probability that the first element in a random permutation generated by BAD is in fact <b>S[0]</b>. Without the independence assumption, we would have terms like <b>P(S[1] | BAD + S[0])</b>, which means \"the probability that the second element is in fact <b>S[1]</b> given that BAD is used to generate the permutation and that <i>the first element is <b>S[0]</b></i>\". Naive Bayes allows us to remove the <i>italicized</i> assumption, which makes the calculation tractable (but not completely accurate). \n</p>\n\n<p>\nTo be fair, we should make the same simplifying assumption for <b>P(S | GOOD)</b>. Luckily, this is easy; in the GOOD algorithm, each element has a <b>1 / N</b> chance of moving to each position, so <b>P(S | GOOD) = 1 / N<sup>N</sup></b> regardless of what <b>S</b> we are given.\n</p>\n\n<p>\nNow, let’s see how we can implement the Naive Bayes classifier. Let <b>P<sub>k</sub>[i][j]</b> be the probability that number <b>i</b> ends up at position <b>j</b> after <b>k</b> steps of the BAD algorithm. We are interested in the probabilities where <b>k = N</b> (i.e., after N steps have been performed). We can compute <b>P<sub>k</sub></b> from <b>P<sub>k-1</sub></b> in O(<b>N<sup>2</sup></b>) time by simulating all possible swaps. <b>P<sub>0</sub></b> is easy; nothing has moved, so we just have the identity matrix. See the pseudo-code below. <b>P<sub>k</sub>[i][j]</b> is the <b>prev[i][j]</b> variable which will contain the probability of number <b>i</b> ends up at position <b>j</b> after <b>k</b> steps generated by the BAD algorithm.\n</p>\n\n<code>\n<pre>\n  prev[i][i] = 1.0 for all i, otherwise 0.0  // An identity matrix.\n  pmove = 1.0 / N  // Probability of a number being swapped.\n  pstay = 1.0 - pmove  // Probability of a number not being swapped.\n\n  for k in 0 .. N-1:\n      for i in 0 .. N-1:\n          next[i][k] = 0\n          for j in 0 .. N-1:\n              next[i][k] += prev[i][j] * pmove  // (1)\n              if j != k:\n                  next[i][j] = prev[i][j] * pstay +\n                               prev[i][k] * pmove  // (2)\n      Copy next to prev\n\n</pre>\n</code>\n\n<p>\nNote for (1): P[i][k] for the next step is equal to:  (P[i][j] in the previous step) * (move probability to k).\nNote for (2): P[i][j] for the next step is equal to:   (P[i][j] in the previous step) * (staying probability at j) +\n  (P[i][k] in the previous step) * (move probability to j).\n</p>\n\n<p>\nThe above algorithm runs in O(<b>N<sup>3</sup></b>). It may take several seconds (or minutes if implemented in a slow scripting language) to finish. However, we can run this offline (before we download the input), and store the resulting probability matrix in a file. Note that the above algorithm can also be optimized to O(<b>N<sup>2</sup></b>) if needed. See Gennady Korotkevich's solution for GCJ 2014 Round 1A for an implementation.\n</p>\n\n<p>\nNext, we compute the approximation probability of <b>P(S | BAD)</b> as described previously.\n<code>\n<pre>\n  bad_prob = 1.0\n  for i in 0 .. N:\n    bad_prob = bad_prob * prev[S[i]][i]\n</pre>\n</code>\n</p>\n\n<p>\nFinally, to produce the output, we compare it with <b>P(S | GOOD)</b> and see which one is greater.\n<code>\n<pre>\n  good_prob = 1.0 / N^N\n  if good_prob &gt; bad_prob:                             \n    S is produced by the GOOD algorithm\n  else:\n    S is produced by the BAD algorithm\n</pre>\n</code>\n</p>\n\n<p>\nNote that the pseudo code above is dealing with very small probability that may cause underflow in the actual implementation. One way to avoid this problem is to use sum of the logarithm of the probabilities instead of the product of the probabilities.\n</p>\n\n<p>\nEmpirically, the Naive Bayes classifier has a success rate of about <b>96.2%</b>, which translates into solving at least 109 cases correctly out of 120 in <b>99.8%</b> of all inputs.\n</p>\n\n<p>\nFinally, in this editorial we described two methods to solve this problem. There are likely other solutions that perform even better and we invite the reader to try come up with such solutions.\n</p>\n\n\n\n\n\n\n\n\n","id":"0000000000432ade","statement":"<h3>Problem</h3>\n<p>\nA <i>permutation</i> of size <b>N</b> is a sequence of <b>N</b> numbers, each between 0 and <b>N</b>-1, where each number appears exactly once. They may appear in any order.\n</p>\n<p>\nThere are many (<b>N</b> <i>factorial</i>, to be precise, but it doesn't matter in this problem) permutations of size <b>N</b>. Sometimes we just want to pick one at random, and of course we want to pick one at random <i>uniformly</i>: each permutation of size <b>N</b> should have the same probability of being chosen.\n</p>\n<p>\nHere's the pseudocode for one of the possible algorithms to achieve that goal (we'll call it the <i>good</i> algorithm below):\n</p>\n<code>\n<pre>for <b>k</b> in 0 .. <b>N</b>-1:\n  <b>a</b>[<b>k</b>] = <b>k</b>\nfor <b>k</b> in 0 .. <b>N</b>-1:\n  <b>p</b> = randint(<b>k</b> .. <b>N</b>-1)\n  swap(a[<b>k</b>], a[<b>p</b>])</pre>\n</code>\n<p>\nIn the above code, <code>randint(<b>a</b> .. <b>b</b>)</code> returns a uniform random integer between <b>a</b> and <b>b</b>, inclusive.\n</p>\n<p>\nHere's the same algorithm in words. We start with the <i>identity</i> permutation: all numbers from 0 to <b>N</b>-1 written in increasing order. Then, for each <b>k</b> between 0 and <b>N</b>-1, inclusive, we pick an independent uniform random integer <b>p</b><sub><b>k</b></sub> between <b>k</b> and <b>N</b>-1, inclusive, and swap the element at position <b>k</b> (0-based) in our permutation with the element at position <b>p</b><sub><b>k</b></sub>.\n</p>\n<p>\nHere's an example for <b>N</b>=4. We start with the identity permutation:\n</p>\n<p>\n0 1 2 3\n</p>\n<p>\nNow <b>k</b>=0, and we pick a random <b>p</b><sub>0</sub> between 0 and 3, inclusive. Let's say we picked 2. We swap the 0th and 2nd elements, and our permutation becomes:\n</p>\n<p>\n2 1 0 3\n</p>\n<p>\nNow <b>k</b>=1, and we pick a random <b>p</b><sub>1</sub> between 1 and 3, inclusive. Let's say we picked 2 again. We swap the 1st and 2nd elements, and our permutation becomes:\n</p>\n<p>\n2 0 1 3\n</p>\n<p>\nNow <b>k</b>=2, and we pick a random <b>p</b><sub>2</sub> between 2 and 3, inclusive. Let's say we picked 3. We swap the 2nd and 3rd elements, and our permutation becomes:\n</p>\n<p>\n2 0 3 1\n</p>\n<p>\nNow <b>k</b>=3, and we pick a random <b>p</b><sub>3</sub> between 3 and 3, inclusive. The only choice is 3. We swap the 3rd and 3rd elements, which means that the permutation doesn't change:\n</p>\n<p>\n2 0 3 1\n</p>\n<p>\nThe process ends now, and this is our random permutation.\n</p>\n<p>\nThere are many other algorithms that produce a random permutation uniformly. However, there are also many algorithms to generate a random permutation that look very similar to this algorithm, but are not uniform &mdash; some permutations are more likely to be produced by those algorithms than others.\n</p>\n<p>\nHere's one bad algorithm of this type.\nTake the <i>good</i> algorithm above, but at each step, instead of picking <b>p</b><sub><b>k</b></sub> randomly between <b>k</b> and <b>N</b>-1, inclusive, let's pick it randomly between 0 and <b>N</b>-1, inclusive.\nThis is such a small change, but now some permutations are more likely to appear than others!\n</p>\n<p>\nHere's the pseudocode for this algorithm (we'll call it the <i>bad</i> algorithm below):\n</p>\n<code>\n<pre>for <b>k</b> in 0 .. <b>N</b>-1:\n  <b>a</b>[<b>k</b>] = <b>k</b>\nfor <b>k</b> in 0 .. <b>N</b>-1:\n  <b>p</b> = randint(0 .. <b>N</b>-1)\n  swap(a[<b>k</b>], a[<b>p</b>])</pre>\n</code>\n<p>\n<p>\nIn each test case, you will be given a permutation that was generated in the following way: first, we choose either the good or the bad algorithm described above, each with probability 50%. Then, we generate a permutation using the chosen algorithm. Can you guess which algorithm was chosen just by looking at the permutation?\n</p>\n<h3>Solving this problem</h3>\n<p>\nThis problem is a bit unusual for Code Jam. You will be given <b>T</b>&nbsp;=&nbsp;120 permutations of <b>N</b>&nbsp;=&nbsp;1000 numbers each, and should print an answer for each permutation &ndash; this part is as usual. However, you don't need to get all of the answers correct! Your solution will be considered correct if your answers for at least <b>G</b>&nbsp;=&nbsp;109 cases are correct. However, you must follow the output format, even for cases in which your answer doesn't turn out to be correct. The <i>only</i> thing that can be wrong on any case, yet still allow you to be judged correct, is swapping GOOD for BAD or vice versa; but you should still print either GOOD or BAD for each case.\n</p>\n<p>\nIt is guaranteed that the permutations given to you were generated according to the method above, and that they were generated independently of each other.\n</p>\n<p>\nThis problem involves randomness, and thus it might happen that even the best possible solution doesn't make 109 correct guesses for a certain input, as both the good and the bad algorithms can generate any permutation. Because of that, this problem doesn't have a Large input, and has just the Small input which you can try again if you think you got unlucky. Note that there is the usual 4-minute penalty for incorrect submissions if you later solve that input, even if the only reason you got it wrong was chance.\n</p>\n<p>\nIn our experience with this problem, that <i>did happen</i> (getting wrong answer just because of chance); so if you are confident that your solution should be working, but it failed, it might be a reasonable strategy to try again with the same solution which failed.\n</p>\n<p>\nGood luck!\n</p>\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b> (which will always be 120). Each test case contains two lines: the first line contains the single integer <b>N</b> (which will always be 1000), and the next line contains <b>N</b> space-separated integers - the permutation that was generated using one of the two algorithms.\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>x</b>: <b>y</b>\", where <b>x</b> is the test case number (starting from 1) and <b>y</b> is either \"GOOD\" or \"BAD\" (without the quotes). You should output \"GOOD\" if you guess that the permutation was generated by the first algorithm described in the problem statement, and \"BAD\" if you guess that the permutation was generated by the second algorithm described in the problem statement.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 60 seconds.<br/>\nMemory limit: 1 GB.<br/>\n<b>T</b> = 120<br/>\n<b>G</b> = 109<br/>\n<b>N</b> = 1000<br/>\nEach number in the permutation will be between 0 and <b>N</b>-1 (inclusive), and each number from 0 to <b>N</b>-1 will appear exactly once in the permutation.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\n0 1 2\n3\n2 0 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: BAD\nCase #2: GOOD\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Note</h3>\nThe sample input doesn't follow the limitations from the problem statement - the real input will be much bigger.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":45}],"title":"Proper Shuffle","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem is looking for the minimum number of switches that need to be flipped so that all devices can be charged at the same time. All devices can be charged at the same time if each of the outlets can be paired with exactly one device and vice versa. An outlet can be paired with a device if both have the same electric flow after flipping some switches.\n</p>\n<p>\nWe observe that flipping the same switch two times (or an even number of times) is equivalent to not flipping the switch at all. Also, flipping the same switch an odd number of times is equivalent to flipping the switch exactly once. Thus, we only need to consider flipping the <i>i-th</i> switch once or not at all.\n</p>\n<p>\nLet’s define a <b>flip-string</b> of 0s and 1s of length <b>L</b> as a way to flip the switches. If the <i>i-th</i> character of the string is 1, it means we flip the <i>i-th</i> switch (otherwise we do not flip the <i>i-th</i> switch). A flip-string is <b>good</b> if the resulting outlets’ electric flows (after the flips) allow all the devices to be charged at the same time. We can check whether a flip-string is good by flipping the bits in the outlets’ electric flow according to the flip-string and then checking whether each device’s electric flow can be matched exactly to one outlet with the same electric flow and vice versa. We can use hashing to perform the check and thus the complexity to check whether a flip-string is good is O(<b>LN</b>). Note that we can (optionally) encode the flip-string into a 64-bit number and reduce the complexity of the check to O(N).\n</p>\n<h4>\n<b>\nBrute force algorithm:\n</b>\n</h4>\n<p>\nA naive brute force solution is to try all the <b>2<sup>L</sup></b> possible flip-strings and check whether it is a good flip-string and keep the one that has the least number of 1s in the string (i.e., it has the minimum number of flips). The time complexity of this algorithm is O(<b>2<sup>L</sup>  * LN</b>). For the small dataset where the maximum for <b>L</b> is 10, this brute force algorithm is sufficient. However, it is really slow for the large dataset where <b>L</b> can be as large as 40.\n</p>\n<h4>\n<b>\nBetter algorithm:\n</b>\n</h4>\n<p>\nTo improve the naive brute force algorithm we need two more observations. First is that there are only a few good flip-strings. If we can efficiently generate only the good flip-strings, we can improve the algorithm complexity significantly. The second observation is that given a device’s electric flow (of <b>L</b> bits) and an outlet’s electric flow (of <b>L</b> bits), we can generate a flip-string that will flip the outlet’s electric flow such that it matches the device’s electric flow. There are only <b>N<sup>2</sup></b> possible pairs of devices and outlets. Thus, only <b>N<sup>2</sup></b> flip-strings need to be generated. Note that the generated flip-strings <b>may or may not be</b> a good flip-string. However, all other flip-strings that are not generated by any pair is guaranteed to <b>not</b> be a good flip-string. With these observations, we can reduce the complexity of the naive algorithm down to O(<b>N<sup>2</sup> * LN</b>), which is fast enough for the large input.\n</p>\n<p>\nThe last (optional) observation we can make is that since a device must be plugged in to exactly one outlet, we can further reduce the number of possible flip-strings from <b>N<sup>2</sup></b> down to <b>N</b>. The <b>N</b> possible flip-strings can be generated by pairing any one device with the <b>N</b> outlets.\n</p>","id":"00000000004334c7","statement":"<h3>Problem</h3>\n<p>Shota the farmer has a problem. He has just moved into his newly built farmhouse, but it turns out that the outlets haven't been configured correctly for all of his devices. Being a modern farmer, Shota owns a large number of smartphones and laptops, and even owns a tablet for his favorite cow Wagyu to use. In total, he owns <b>N</b> different devices.\n\n<p>As these devices have different specifications and are made by a variety of companies, they each require a different electric flow to charge. Similarly, each outlet in the house outputs a specific electric flow. An electric flow can be represented by a string of 0s and 1s of length <b>L</b>.\n\n<p>Shota would like to be able to charge all <b>N</b> of his devices at the same time. Coincidentally, there are exactly <b>N</b> outlets in his new house. In order to configure the electric flow from the outlets, there is a master control panel with <b>L</b> switches. The i<sup>th</sup> switch flips the i<sup>th</sup> bit of the electric flow from each outlet in the house. For example, if the electric flow from the outlets is:\n\n<pre>\nOutlet 0: 10\nOutlet 1: 01\nOutlet 2: 11\n</pre>\n\n<p>Then flipping the second switch will reconfigure the electric flow to:\n\n<pre>\nOutlet 0: 1<b>1</b>\nOutlet 1: 0<b>0</b>\nOutlet 2: 1<b>0</b>\n</pre>\n\n<p>\nIf Shota has a smartphone that needs flow \"11\" to charge, a tablet that needs flow \"10\" to charge, and a laptop that needs flow \"00\" to charge, then flipping the second switch will make him very happy!\n</p>\n\n<p>Misaki has been hired by Shota to help him solve this problem. She has measured the electric flows from the outlets in the house, and noticed that they are all different. Decide if it is possible for Shota to charge all of his devices at the same time, and if it is possible, figure out the minimum number of switches that needs to be flipped, because the switches are big and heavy and Misaki doesn't want to flip more than what she needs to.\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case consists of three lines. The first line contains two space-separated integers <b>N</b> and <b>L</b>. The second line contains <b>N</b> space-separated strings of length <b>L</b>, representing the initial electric flow from the outlets. The third line also contains <b>N</b> space-separated strings of length <b>L</b>, representing the electric flow required by Shota's devices.\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #<b>x</b>: <b>y</b>\", where <b>x</b> is the case number (starting from 1) and <b>y</b> is the minimum number of switches to be flipped in order for Shota to charge all his devices. If it is impossible, <b>y</b> should be the string \"NOT POSSIBLE\" (without the quotes). Please note that our judge is not case-sensitive, but it is strict in other ways: so although \"not &nbsp;possible\" will be judged correct, any misspelling will be judged wrong. We suggest copying/pasting the string NOT POSSIBLE into your code.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\nNo two outlets will be producing the same electric flow, initially.<br/>\nNo two devices will require the same electric flow.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 10.<br>\n2 &le; <b>L</b> &le; 10.\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 150.<br>\n10 &le; <b>L</b> &le; 40.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3 2\n01 11 10\n11 00 10\n2 3\n101 111\n010 001\n2 2\n01 10\n10 01\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: NOT POSSIBLE\nCase #3: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h4>Explanation</h4>\n<p>In the first example case, Misaki can flip the second switch once. The electric flow from the outlets becomes:\n<pre>\nOutlet 0: 00\nOutlet 1: 10\nOutlet 2: 11\n</pre>\n<p>Then Shota can use the outlet 0 to charge device 1, the outlet 1 to charge device 2, outlet 2 to charge device 0. This is also a solution that requires the minimum amount number of switches to be flipped.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Charging Chaos","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433162","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2014"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
