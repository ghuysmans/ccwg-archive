{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1560011400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000051707","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  If you want a ticket to the Finals, it all comes down to Round 3! With only\n  two and a half hours and four problems, you have to know what you can solve,\n  and solve it <i>fast</i>. The competitors are among the best in the world,\n  and there is little room for error!\n</p><p>\n  The round opened with <i>Zillionim</i>, an interactive coin-taking game in\n  which it was far from trivial to outsmart even a randomly playing AI.\n  <i>Pancake Pyramid</i> was the obligatory pancake problem &mdash; actually, we\n  almost didn't have one at all this year! It was challenging, but approachable\n  with more \"standard\" techniques. <i>Datacenter Duplex</i> and\n  <i>Napkin Folding</i> were more unusual, and the latter in particular was a\n  very difficult geometry problem. (We wonder how many folded pieces of paper we\n  created on our contestants' desks!) Napkin Folding was worth a lot of points,\n  but not enough to render the other problems unnecessary.\n</p><p>\n  After half an hour, each of the first three problems had been fully solved at\n  least once. Contestants vied to be the first to finish A + B + C + the first\n  test set of D, knowing that the second test set of D was a real monster that\n  probably wouldn't get 25 solves. <b>ACRushTC</b> was the first to hit 61\n  points, at 1:37:35, followed by <b>rng..58</b> with 1:41:03 and our longtime\n  defending champion <b>Gennady.Korotkevich</b> with 1:41:47. The Code Jam\n  staff eagerly watched to see if someone would fully solve D, but alas,\n  nobody did. That made 61 (or a fast enough 57) the (unofficial) advancement\n  bar.\n</p><p>\n  If you ranked high enough, we will be in touch about the Finals. As always,\n  though, making it to Round 3 is a major accomplishment, and you will soon\n  have the shirt to prove it! Even if you just watched the contest, preparing\n  for next year, you have our thanks and our best wishes for success in 2020.\n  In the meantime, though, get ready for the Finals on August 9!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Zillionim: Written by Pablo Heiber and Igor Naverniouk. Prepared by Pablo\n    Heiber.\n</p><p>\n  Pancake Pyramid: Written by Andy Huang. Prepared by John Dethridge.\n</p><p>\n  Datacenter Duplex: Written by Pablo Heiber. Prepared by Jonathan Irvin\n    Gunawan and Micah Stairs.\n</p><p>\n  Napkin Folding: Written by Pablo Heiber. Prepared by Timothy Buzzelli.\n</p><p>\n  Solutions and other problem preparation and review by David Arthur,\n  Liang Bai, Darcy Best, Timothy Buzzelli, Jonathan Irvin Gunawan,\n  Md Mahbubul Hasan, Igor Naverniouk, Trung Thanh Nguyen, Pi-Hsun Shih,\n  Micah Stairs, Ian Tullis and Tony Wong.\n</p>\n\n<p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Zillionim: Ian Tullis</li>\n  <li>Pancake Pyramid: Darcy Best and Jacek Jurewicz</li>\n  <li>Datacenter Duplex: Pablo Heiber</li>\n  <li>Napkin Folding: Timothy Buzzelli</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1560002400000,"tasks":[{"analysis":"<p>\n  There may not be a <i>zillion</i> possible solutions to this problem, but\n  there are more than we can discuss in this analysis! We'll only touch on a\n  few here, some of which work, and some of which don't. You're welcome to\n  share yours in the\n  <a href=\"https://groups.google.com/forum/#!forum/google-code\">Code Jam Google Group</a>!\n</p>\n<h3>Random play</h3>\n<p>\n  What if we always choose a move uniformly at random from among all available\n  moves, just like the AI does? Intuitively, since the overall number of coins\n  is large relative to the size of any one move, going first or second is not\n  very important (given that in this case, both sides are playing randomly and\n  not using any strategy), and every game is close to a fair coin flip. Suppose\n  that we have a 50% chance of winning a game with this strategy; then, per the\n  binomial distribution, we have only about an 0.0004% chance of winning 300 or\n  more games out of 500. So this approach won't even get us the 1 point for\n  test set 1!\n</p>\n<h3>A mirror strategy</h3>\n<p>\n  If we were allowed to go first in this game, we could guarantee a win using\n  the following strategy. Imagine a \"center line\" drawn between the\n  (10<sup>12</sup> / 2)-th and ((10<sup>12</sup> / 2) + 1)-th coins, dividing\n  the coins into two regions of equal size. On the first turn, we could take\n  the group of 10<sup>10</sup> coins bisected by this line &mdash; that is,\n  the coins numbered from ((10<sup>12</sup> - 10<sup>10</sup>) / 2) + 1 to\n  ((10<sup>12</sup> + 10<sup>10</sup>) / 2). Then, after every move by the\n  opponent, we could make the same move, but reflected across this center\n  line. For example, if the opponent were to take the 10<sup>10</sup> coins\n  starting from coin number 2, we would respond by taking the group of\n  10<sup>10</sup> coins starting from the next-to-last coin and going left.\n  We would always be guaranteed a move, by symmetry, so the opponent would\n  have to eventually lose.\n</p><p>\n  Sadly, we cannot move first, but we can try to adapt this strategy by just\n  making the mirrored version of the opponent's move. This will always be\n  possible unless the opponent makes a move that crosses the center line, in\n  which case we cannot mirror it. But if the opponent happens to move close to\n  the center line without crossing it &mdash; specifically, taking a coin fewer\n  than 10<sup>10</sup> / 2 coins away from the center without crossing the\n  center &mdash; then they will ensure their own defeat. If they do happen\n  to make a move that crosses the center line, we can abandon our strategy and\n  move randomly.\n</p><p>\n  We can run a local simulation and find that this strategy does better than\n  randomness, winning around 57.5% of the time. Unfortunately, this only gives\n  us about a 14% chance of passing test set 1. Moreover, because our moves\n  depend on the judge's moves, we cannot easily tweak the judge's randomness;\n  we only get some control over that once the judge has made a move that hurts\n  our strategy. So, all in all, it's probably best to abandon this approach.\n</p>\n<h3>A 2 &times; 10<sup>10</sup> strategy</h3>\n<p>\n  Let's call a remaining set of (at least 10<sup>10</sup>) contiguous coins a\n  \"run\". Observe that a \"run\" of exactly 2 &times; 10<sup>10</sup> remaining\n  coins can be very useful for us. We have the option of taking the first\n  10<sup>10</sup> or the last 10<sup>10</sup> coins from that run, and leaving\n  a run of exactly 10<sup>10</sup> coins (and therefore one possible move)\n  behind. On the other hand, if we take any other group of 10<sup>10</sup>\n  coins from that run, we will leave no moves behind, \"destroying\" the run.\n  Also notice that if the AI happens to move within this run, it will virtually\n  always make the second type of move; the odds of it happening to choose the\n  first or last 10<sup>10</sup> coins are negligible.\n</p><p>\n  Because of this, a run of exactly 2 &times; 10<sup>10</sup> coins lets us\n  control the parity of the game. Suppose, as a thought experiment, that the\n  only remaining runs are of exactly 2 &times; 10<sup>10</sup> coins each, and\n  that it is our turn. If the number of remaining runs is odd, we can move in\n  a way that destroys one of the runs, and then the AI will do the same, and so\n  on until we leave the AI with no moves. If the number of remaining runs is\n  even, we can take the first 10<sup>10</sup> coins from one run, leaving the\n  other 10<sup>10</sup> behind as a smaller run. Now the AI is in the same bad\n  \"even number of remaining runs\" situation that we were just in.\n</p><p>\n  We can set up a situation like this by making many moves early on that leave\n  behind runs of exactly 2 &times; 10<sup>10</sup> coins. For example, we\n  can repeatedly choose the largest remaining run of size\n  3 &times; 10<sup>10</sup> or greater, and start from the\n  (2 &times; 10<sup>10</sup> + 1)-th coin from the left in that group, leaving\n  a run of exactly size 2 &times; 10<sup>10</sup> behind (in addition to any\n  leftover piece to the right of our move). Then, as long as there are still\n  runs larger than 2 &times; 10<sup>10</sup> but smaller than 3 &times;\n  10<sup>10</sup>, we can use our moves to destroy them by moving in their\n  centers. Our goal is to eliminate all runs larger than 2 &times;\n  10<sup>10</sup> before the AI randomly destroys all of our runs of 2 &times;\n  10<sup>10</sup>. Intuitively, we do not need to worry too much about this,\n  since the AI is more likely to move within some remaining larger runs than\n  within our last remaining run of 2 &times; 10<sup>10</sup> runs, so it will\n  usually be helping us out! Once all runs are of size\n  2 &times; 10<sup>10</sup> or smaller, and we have at least one run of size\n  2 &times; 10<sup>10</sup>, we have imposed the near-lockdown situation\n  described above.\n</p><p>\n  We hope you will forgive us for not trying to calculate an exact success\n  probability for the above strategy, but one can use a local simulation to\n  show that it wins, e.g., all 100000 of 100000 games. The chances of it losing\n  more than one of 500 games are vanishingly small... and even if the worst\n  somehow happens, in this case, we do have some control over the overall\n  randomness, and we can try again with a slight tweak.\n</p>\n<h3>Other parity-based strategies</h3>\n<p>\n  In Round 1C this year, we had\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/00000000000516b9/0000000000134cdf\">Bacterial Tactics</a>\n  , another problem about a turn-taking game. You may recall that the analysis\n  brought up the\n  <a href=https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem>Spragueâ€“Grundy theorem</a>\n  ; can we use a similar parity-based strategy here?\n</p><p>\n  As in our 2 &times; 10<sup>10</sup> strategy, we can try to keep the number\n  of remaining runs even for the AI by moving in the middle of a run if there\n  is an even number of runs, or otherwise taking the left end of some other\n  large run. Empirically, this strategy solves TS1, and it even solves TS2 if\n  we always take the largest remaining run. It ends up being similar to our\n  best strategy described above, even though it does not allow for such fine\n  control.\n</p><p>\n  We can even achieve a perfect solution for this problem by exhaustively\n  calculating Grundy numbers and storing them using run-length encoding!\n  However, it is possible to arrive at the 2 &times; 10<sup>10</sup> idea above,\n  which is good enough, without knowing anything about this theory.\n</p>\n","id":"0000000000158f1a","statement":"<h3>Problem</h3>\n<p>\n  Zillionim is a turn-based game for two players. Initially, 10<sup>12</sup> coins are\n  arranged end-to-end in a single line, numbered from 1 to 10<sup>12</sup> from left to right.\n  During a turn, a player must select 10<sup>10</sup> consecutive coins and remove them.\n  Two coins that were not originally consecutive do not become consecutive even if all of\n  the coins in between them are removed.\n</p><p>\n  On their turn, a player makes a valid move if possible, and then it is their opponent's turn.\n  If a player cannot make a valid move on their turn, they lose the game (and the opponent wins\n  the game).\n</p><p>\n  Because our engineers are still hard at work training our machine learning model to play\n  Zillionim, we have created a simple AI that plays Zillionim by making random moves.\n  The AI always gets the first turn.\n  On each of the AI's turns, the AI determines all valid moves and chooses one of them uniformly\n  at random.\n</p><p>\n  Can you beat this AI... at least most of the time?\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the\n  information in the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\">Interactive Problems section</a>\n  of our FAQ.\n</p><p>\n  Initially, your program should read a single line containing two integers\n  <b>T</b>, the number of test cases, and <b>W</b>, the minimum number of games you need to win\n  for your solution to be considered correct. Then, you need to process <b>T</b> test cases,\n  each of which is a single game of Zillionim.\n</p><p>\n  Each test case is processed by making exchanges with the judge until one player wins\n  the game. For each exchange, the judge first outputs a single line with a\n  single integer <b>P</b>, to be interpreted as follows:\n</p><ul>\n<li>If 1 &le; <b>P</b> &le; 10<sup>12</sup> - 10<sup>10</sup> + 1, then the AI has removed\n  coins numbered <b>P</b>, <b>P</b> + 1, ..., <b>P</b> + 10<sup>10</sup> - 1 and it is your\n  turn. Note that this means there is at least one valid move remaining for you to play.\n  The AI always plays a valid move.</li>\n<li>If <b>P</b> = <code>-2</code>, your last move caused you to win the current game.</li>\n<li>If <b>P</b> = <code>-3</code>, the AI has made a move that caused it to win the current game.\n  Notice that in this case, the judge does not send you the AI's last move.</li>\n<li>If <b>P</b> = <code>-1</code>, the last information you sent to the judge was malformed data or an\n  invalid move (out of range or attempting to remove coins that were not there),\n  meaning that you will get a Wrong Answer verdict for not playing correctly (more below).</li>\n</ul><p>\n  After receiving a positive integer <b>P</b>, you should send back a single line with a positive\n  integer Q (1 &le; Q &le; 10<sup>12</sup> - 10<sup>10</sup> + 1)\n  representing that you are removing coins numbered Q, Q + 1, ..., Q + 10<sup>10</sup> - 1.\n  Each of these coins must not have been previously removed during the current game.\n</p><p>\n  After the judge sends a <code>-2</code> or <code>-3</code>, if it was the last game,\n  the judge will terminate and so should your program. Otherwise, the judge will proceed\n  to send data corresponding to the first exchange of the next game. The judge\n  will not check how many games you have won or lost until all games have been processed correctly.\n  For example, if you win <b>T</b> - 1 games and then send malformed data during the last game,\n  you will receive a Wrong Answer verdict, regardless of the value of <b>W</b>.\n</p><p>\n  After receiving a <code>-1</code>, your program should terminate to receive a\n  Wrong Answer verdict. If your program continues to wait for the judge after receiving\n  <code>-1</code>, your program will time out, resulting in a Time Limit Exceeded error.\n  Notice that it is your responsibility to have\n  your program exit normally and within the time limit to receive a Wrong Answer verdict\n  instead of a Runtime Error or Time Limit Exceeded.\n</p><p>\n  The seed for the random generator is predetermined (and is different) for each game.\n  This means that two submissions that make the exact same sequence of moves in a given game\n  will receive the exact same sequence of moves from the AI for that game. It also means the play\n  of the AI in a game does not depend, even in the pseudo-random generation sense, on the\n  plays made in previous games within the same test set.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 50 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n<b>T</b> = 500.<br/>\n-3 &le; <b>P</b> &le; 10<sup>12</sup> - 10<sup>10</sup> + 1.<br/>\n<b>P</b> &ne; 0.<br/>\n<b>P</b> represents a valid play or valid information about the game's status,\n  as explained above.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n<b>W</b> = 300.<br/>\n</p>\n\n<h4>Test set 2 (Visible)</h4>\n<p>\n<b>W</b> = 475.<br/>\n</p>\n\n<h4>Test set 3 (Visible)</h4>\n<p>\n<b>W</b> = 499.<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1-hMTDeRuMCisy2fpKoJ7Ma70Ruo9N6efa0e4b5azf7uE_gTnMYhOFJHjD0Yr9MB0oGJxV9itWdOSRArhL/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n\n<p>\n  For simplicity, the following interaction uses 50 coins in total instead of 10<sup>12</sup>, and\n  each move removes 10 consecutive coins instead of 10<sup>10</sup>. The rules are otherwise the\n  same.\n</p>\n\n<pre>\n  t, w = readline_int_list()   // reads 500 into t and 300 into w\n  p = readline_int()           // reads 23 into p; this is the beginning of the first game. The\n                               //   AI has taken coins 23 through 32, inclusive.\n  printline 38 to stdout       // we decide to take coins 38 through 47, inclusive\n  flush stdout\n  p = readline_int()           // reads 3 into p. The AI has taken coins 3 through 12, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n                               //  (and this is our only remaining move!)\n  flush stdout\n  p = readline_int()           // reads -2 into p. We won the first game since the AI had no move.\n  p = readline_int()           // reads 32 into p; this is the beginning of the second game. The\n                               //   AI has taken coins 32 through 41, inclusive.\n  printline 13 to stdout       // we decide to take coins 13 through 22, inclusive\n  flush stdout\n  p = readline_int()           // reads -3 into p. We don't know the AI's move, but it left us\n                               //   with no valid move, so we lost the second game.\n  p = readline_int()           // reads 10 into p; this is the beginning of the third game. The\n                               //   AI has taken coins 10 through 19, inclusive.\n  printline 0 to stdout        // we select an invalid index (coin numbering starts at 1!)\n  flush stdout\n  p = readline_int()           // reads -1 into p -- we have made a mistake!\n  exit                         // exits to avoid an ambiguous TLE error\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":1},{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":6}],"title":"Zillionim","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<p>\nWe can start by modeling the problem as a graph where each cell of the input matrix represents\na node. Orthogonally adjacent cells with the same label are connected by edges, and we can\noptionally add edges connecting diagonally adjacent cells with the same label. The goal is to\nend up with exactly two\n<a href=\"https://en.wikipedia.org/wiki/Connected_component_(graph_theory)\">connected components</a>.\n</p>\n<h3>Test set 1</h3>\n<p>\nTest set 1 can be solved with\n<a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">dynamic programming</a>,\niterating over columns. When considering the i-th column from left to right,\nwe can summarize the state of the connections we have added in the submatrix S of columns 1\nthrough i by recording:\n(1) whether we have seen (at least one cell of) each of A and B so far, and (2) whether any\ntwo cells on the i-th column that contain the same label but are not orthogonally adjacent are\nconnected by a path in S. Then, we can use brute force, and consider all possible\nchoices of how to connect each of the up to 3 cell corners between columns i and i+1\n(there are at most 4 rows in Test set 1). There are 3 possibilities for each corner, \\, / and\nno connection, but it can be reduced by noticing if at least one of the connections is valid, it is\nalways optimal to use one, which reduces the number of choices per corner to 2 at the most. If\nat any point we discover a new isolated A component that cannot be connected to previously seen As,\nwe have failed, and same is true for B. If we finish, we can then use a second pass to reconstruct\none choice of diagonal connections that led to solving the problem.\n</p><p>\nThis seemingly simple idea has several technical details that we are omitting here.\nSome of them can be simplified by\nstarting and ending the process in columns that contain both As and Bs and preprocessing\nto check if any leftmost or rightmost columns that contain only one type already disconnect\nthe other type.\n</p><p>\nThe overall time complexity of this solution is exponential in <b>R</b>, because we are trying all\ncombinations of O(<b>R</b>) corners and recording the connected status of O(<b>R</b>) cells\nat each state, and linear in <b>C</b>,\nwith the exact formula depending on how the technical details are handled. As long as the base of\nthe exponential factor is not too large, this is fast enough to pass within the\ntime limit.\n</p>\n<h3>Test set 2</h3>\n<p>\nThe key observation is: after we decide to add some edges (diagonal adjacencies),\ntwo cells c and d containing the same label X end up separated regardless of\nany future decisions if and only if one of the following two conditions holds:\n</p><ul>\n<li>1. There is a cycle of cells labeled Y &ne; X in the graph, with one of c and d\nbeing inside the cycle and the other one being outside.</li>\n<li>2. There is a path of cells labeled Y &ne; X in the graph with the first and\nlast cells of the path being border cells of the matrix, with c and d being on opposite sides of\nthe path.</li>\n</ul><p>\nLet us use G to denote the graph with no diagonal edges added and H to denote\nthe final graph with all edges added. Consider the border of the matrix.\nSuppose that it contains two cells c and d labeled X that are not connected in G. Since they\nare not connected in G, that means, going around the border, there are cells e and f labeled\nY &ne; X such that e is in between c and d in clockwise order and f is between c and d in\ncounter-clockwise order. That means neither c and d nor e and f can be connected in H\nwith a path of only border cells. Therefore, if c and d are connected in H, the path connecting\nthem disconnects e and f, and vice versa. So, by the second condition, having two cells on the\nborder with the same label that are disconnected in G results in an impossible case.\n</p><p>\nNotice that there is never an incentive to generate an edge from a diagonal adjacency to connect\ntwo cells that are already connected. Per the paragraph above, if a case is possible, then\nall border cells with the same label are already connected in G. Therefore, if an algorithm\nnever adds an edge from a diagonal adjacency that connects two cells that are already\nconnected, it will never generate a path between two border cells.\nAdditionally, if we never connect cells that are already connected, any cycle in H is a cycle\nthat was already present in G, so again, if we end up in a disconnected situation, the case must\nhave been impossible from the start, before we added any connections.\n</p><p>\nThese observations directly suggest the following algorithm: consider each diagonal adjacency\nand generate an edge if and only if it will connect two previously disconnected cells. If both\nchoices work, we can choose either, since we already established that the decision of not connecting\npreviously connected cells is enough to guarantee an algorithm will not generate an H with more\nthan 2 connected components when a different one with exactly 2 was possible. After this process,\ncheck if there are 2 connected components or more than 2, and print the results.\n</p><p>\nIf we implement the algorithm above using a\n<a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure\">union-find</a> to maintain\nthe connected components, we need O(<b>R</b> &times; <b>C</b>) checks for whether two cells\nare connected and O(<b>R</b> &times; <b>C</b>) connections (joins). Since union-find provides\nalmost constant amortized time for both operations, the overall time complexity of the algorithm\nis quasilinear.\n</p><p>\nAn equivalent algorithm is to calculate the connected components of G first and then use shortest\npaths to join any two components of the same label until we cannot do it anymore. Since shortest\npaths cannot create new cycles, an argument similar to the one above proves that this\nsolution is also correct. This solution can be implemented in linear time if the partial minimum\npath tree graph is reused for each new connection we need.\n</p>\n","id":"0000000000158f1c","statement":"<h3>Problem</h3>\n<p>\n  Two companies, Apricot Rules LLC and Banana Rocks Inc., are sharing the same datacenter.\n  The datacenter is a matrix of <b>R</b> rows and <b>C</b> columns, with each cell containing\n  a single server tower. Each tower contains intellectual property belonging to exactly one of\n  the two companies.\n</p><p>\n  At first, they built walls on the edges between cells assigned to different companies.\n  This allowed orthogonally adjacent cells belonging to the same company to remain connected.\n  Also, two cells x and y are considered connected if x is connected to a cell that is, directly\n  or indirectly, connected to y. With this definition, it was possible that two cells\n  assigned to the same company were not connected, which was unacceptable.\n</p><p>\n  Both companies agreed to build narrow hallways running through cell corners that allow two\n  diagonally adjacent cells to be connected directly. Let us write (i, j) to represent the cell at\n  row i and column j. At most one narrow hallway can be built through any given vertex, which means\n  either (i, j) and (i + 1, j + 1) can be connected, or (i + 1, j) and (i, j + 1) can be connected,\n  or neither pair, but not both. Of course, only hallways between cells assigned to the same company\n  can be built.\n</p><p>\n  Given a matrix where each cell is labeled <code>A</code> or <code>B</code> depending\n  on which company it is assigned to, find a way to add\n  connections through diagonal adjacencies such that all <code>A</code>s are\n  connected and all <code>B</code>s are connected.\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case begins with one line containing\n  two integers <b>R</b> and <b>C</b>, the number of rows and columns of the\n  matrix representing the datacenter. Then, there are <b>R</b> more\n  lines containing <b>C</b> characters each. The j-th character on the i-th of these lines\n  <b>M<sub>i,j</sub></b>\n  is either <code>A</code> or <code>B</code>, indicating which company owns the cell at (i, j).\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, first output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1) and\n  <code>y</code> is <code>IMPOSSIBLE</code> if there is no way to assign the\n  diagonal connections such that the <code>A</code> cells are connected and\n  the <code>B</code> cells are connected,\n  or <code>POSSIBLE</code> otherwise. Then, if you output <code>POSSIBLE</code>,\n  output <b>R</b> - 1 more lines of <b>C</b> - 1 characters each.\n  These characters must correspond to a valid arrangement as described in the statement above.\n  The j-th character of the i-th of those lines must be <code>\\</code> if cells (i, j)\n  and (i + 1, j + 1) are to be connected, <code>/</code> if cells (i + 1, j) and (i, j + 1)\n  are to be connected, or <code>.</code> if neither pair is to be connected.\n</p>\n\n<h3>Limits</h3>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  2 &le; <b>C</b> &le; 100.<br/>\n  <b>M<sub>i,j</sub></b> = uppercase <code>A</code> or uppercase <code>B</code>,\n    for all i and j.<br/>\n  <b>M<sub>i,j</sub></b> = uppercase <code>A</code> for at least one pair of i and j.<br/>\n  <b>M<sub>i,j</sub></b> = uppercase <code>B</code> for at least one pair of i and j.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  2 &le; <b>R</b> &le; 4.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  2 &le; <b>R</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 2\nAB\nBA\n2 3\nAAB\nABB\n3 4\nBBAA\nBABA\nBBAA\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: IMPOSSIBLE\nCase #2: POSSIBLE\n..\nCase #3: POSSIBLE\n//\\\n.//\n\n  </pre>\n  </td></tr></table>\n  </div>\n  </sampleio>\n\n<p>\n  In Sample Case #1, the pair of <code>A</code> cells and the pair of <code>B</code> cells\n  need to be connected, but since both connections would have to cross the same vertex,\n  at most one of the connections can exist.\n</p><p>\n  In Sample Case #2, the cells are already connected in the required way in the input,\n  so no additional connections are necessary. Note that you can add unnecessary valid\n  connections, so another valid answer would be <code>//</code>, but <code>\\.</code>\n  would be wrong.\n</p><p>\n  In Sample Case #3, there are also multiple solutions, one of which is displayed.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Datacenter Duplex","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  For Test Set 1, we want to find exactly one folding segment such that when we\n  fold the napkin across the segment, the regions on either side of the segment line up perfectly.\n  Because the folding segment must split the napkin into two symmetric regions,\n  we can show that each of the folding segment's endpoints either coincides with\n  a vertex of the polygon defining the napkin, or is the midpoint of an edge of\n  the polygon. If we tried to make a folding segment connecting any\n  other points, the two parts of the split edge could not possibly line up perfectly. Thus, all we\n  need to do is try every line segment connecting any pair of points that are\n  vertices or midpoints of the polygon's edges. Then, for each potential folding\n  segment, we check whether it is valid by making sure it is fully contained within\n  the polygon and that the two regions it creates are symmetric across the\n  folding line segment.\n</p><p>\n  <a href=\"https://en.wikipedia.org/wiki/Intersection_(Euclidean_geometry)#Two_line_segments\">Checking for intersections between line segments</a> can be\n  done by using only integers.\n  <a href=\"https://en.wikipedia.org/wiki/Reflection_(mathematics)#Reflection_across_a_line_in_the_plane\">Reflecting points across a line</a>\n  or taking the midpoint of a side normally\n  could produce points with non-integer coordinates. But we can scale up our points\n  initially such that if the reflection were to produce a point with non-integer coordinates,\n  it could not possibly be one of the valid endpoints for folding line segments. Of course, we can\n  also choose to work with fractions.\n</p><p>\n  With <b>N</b> points in our polygon, we have 2&times;<b>N</b>\n  points to choose from for our folding segment's endpoints. Each potential\n  folding segment can be checked in O(<b>N</b>) time. Because there are\n  O(<b>N</b><sup>2</sup>) possible segments to check, this results in an\n  O(<b>N</b><sup>3</sup>) overall time complexity.\n</p><p>\n  Note that in order to check for symmetry across a folding segment, we cannot\n  just check that the sets of vertices of the polygons defining each region are\n  symmetrical. Rather, we must show that for every edge of the polygon of one\n  region, there exists exactly one edge in the polygon defining the second\n  region which is symmetric across the folding line segment. In other words, the order in\n  which the points appear on each side matters.\n</p><p>\n  Finally, we can note that if a given line is indeed an axis of symmetry of the polygon,\n  then it is guaranteed that it doesn't intersect the polygon more than twice. This means\n  that we don't need an explicit check in the code for the folding segment not to intersect\n  the polygon outside its endpoints. A similar simplification can be applied to the solution of\n  Test set 2, coming up next.\n</p>\n\n<h3>Test Set 2</h3>\n<p>\n  Since we want to draw a neat folding pattern of <b>K</b>-1 non-intersecting\n  line segments, we must partition our napkin into <b>K</b> regions of identical\n  size and shape, all of which are symmetric with other regions sharing common line\n  segments. Each of these <b>K</b> regions is a polygon with edges that are made up of folding\n  line segments and/or edges or parts of edges from the polygon defining the napkin. It can be\n  shown that at least two of these regions are only adjacent to one line segment\n  in our folding pattern, with the other edges that define the region's polygon\n  coming from the original polygon. Let's call these regions <i>corner regions</i>.\n</p><p>\n  If we have a corner region, we can reflect that region across its one folding\n  line segment to find the region that must be adjacent to it. If we keep\n  reflecting these regions across the edges of their polygons, being careful not\n  to create intersecting regions or leave the polygon defining the napkin, we\n  can reconstruct the neat folding pattern. Thus, every neat folding pattern can\n  be uniquely defined by just one folding line segment connecting two points on\n  the border of the polygon defining the napkin. That segment cuts off a corner\n  region which can be successively reflected to give us the entire folding\n  pattern.\n</p><p>\n  We need to consider pairs of points on the napkin's border defining a folding line segment.\n  For a given candidate folding line segment,\n  we can successively reflect the corner region we form to get the full\n  folding pattern. If we use more than <b>K</b>-1 reflections, or, if after we finish\n  reflecting we don't end up creating the original polygon, we know that the\n  chosen line segment does not give us a neat folding pattern.\n</p><p>\n  Now all that remains is to select all pairs of points on the napkin's border.\n  Clearly we cannot test every pair of points with rational coordinates, because\n  there are infinitely many such points. Rather, we can show that the endpoints of the line\n  segments in our neat folding pattern must be either vertices or points on\n  the polygon's edges that are X/Y of the way between consecutive vertices, where\n  1 &le; X &le; Y-1 and 2 &le; Y &le; <b>K</b> (the proof for this is below).\n  Therefore, we can create all of\n  these candidate points and check every pair. With <b>K</b> &le; 10 and\n  <b>N</b> &le; 200, there are at most 6400 candidate points for the vertices of\n  the line segments in our neat folding pattern. This puts an upper bound of\n  6400<sup>2</sup> on the number of pairs that we might need to check. But, we can reduce this\n  significantly by only considering pairs which create a corner region with an\n  <a href=\"https://en.wikipedia.org/wiki/Polygon#Area\">area</a>\n  equal to 1/<b>K</b> of the napkin's area. Every point can pair with at\n  most 2 other points to create a line segment which is fully within the polygon\n  and splits off a corner region with the proper area. Therefore, we only need\n  to check these pairs.\n</p><p>\n  We can check if a single line segment from a pair of points gives us a valid\n  folding pattern in O(<b>N</b>) time if we are careful to stop once a\n  reflection creates a point which is not on the border of one of our polygon's\n  line segments. We can precompute all the valid points and use a\n  <a href=\"https://en.wikipedia.org/wiki/Hash_table\">hash table</a> for this\n  check. Because all of the points are of the form X/Y &times; p, where p is a point\n  with integer coordinates and Y is between 2 and <b>K</b>, we can multiply\n  everything by <a href=\"https://en.wikipedia.org/wiki/Least_common_multiple\">lcm</a>(2, 3, ..., <b>K</b>) at the beginning and then work in integers,\n  dividing and simplifying fractions only for the output.\n</p><p>\n  To summarize, the algorithm requires these steps:\n</p><ul>\n  <li>1. Compute all possible endpoints. (O(<b>N</b> &times; <b>K</b><sup>2</sup>))</li>\n  <li>2. Find candidate segments to create a corner region. (O(<b>N</b> &times; <b>K</b><sup>2</sup>)).</li>\n  <li>3. For each candidate, fold it up to <b>K</b>-1 times, checking that everything is valid.</li>\n</ul><p>\nThere are up to O(<b>N</b> &times; <b>K</b><sup>2</sup>) possible endpoints. If we fix one endpoint\nP and iterate the other, we can compute the area as we advance, finding the up to 2 segments that\nhave an endpoint in P in O(<b>N</b> &times; <b>K</b><sup>2</sup>) time. So step 2 takes\nO(<b>N</b><sup>2</sup> &times; <b>K</b><sup>4</sup>) time in total. For step 3, each unfolding\nrequires reflecting the current region and finding new folding segments. All of that is linear in\nthe size of the region, and the sum over the sizes of all regions is at most the total number\nof endpoints plus 2 &times; <b>K</b> shared ones,\nso this takes O(<b>N</b> &times; <b>K</b><sup>2</sup>) time overall. Putting it all\ntogether, the algorithm takes O(<b>N</b><sup>2</sup> &times; <b>K</b><sup>4</sup>) time in total.\nIt is possible to make it significantly more efficient than that, but the implementation is\ncomplicated enough as it is.\n</p>\n<h3>Appendix</h3>\n<p>To prove that all folding segments endpoints are X/Y of the way between consecutive vertices for\n1 &le; X &le; Y-1 and 2 &le; Y &le; <b>K</b>,\nwe can prove that the number of folding segments that are incident on a non-vertex point of the\ninput polygon is odd or zero. If that's true, let P be an endpoint and Q and R be the two vertices\nand/or folding segment endpoints that are closest to P towards each side over the same polygon\nedge E as P. Then, by reflection PQ and PR are equal. By repeating this over E we can see that\nE is divided into equal length sections by every point that is a folding segment endpoint.\n</p><p>\nNow we prove that the number of incident folding segments in a non-vertex point of the polygon is\nodd or zero. Assume that P is a point over an edge E of the polygon with\nI &gt; 1 of incident folding segments. Let Q<sub>i</sub> for i = 1, 2, ..., I\nbe the non-P endpoints of each of those segments, in clockwise order. Let Q<sub>0</sub> be the\nreflection of Q<sub>2</sub> across PQ<sub>1</sub> and Q<sub>I+1</sub> the reflection of\nQ<sub>I-1</sub> across PQ<sub>I</sub>. Notice both those points have to be on E. Now, the I+1\nangles Q<sub>i</sub>Q<sub>i+1</sub> for i = 0, 1, ..., I are all equal. Let R<sub>i</sub> be the\nreflection of Q<sub>i</sub> across E. Now, because Q<sub>i</sub> must reflect onto Q<sub>i+2</sub>,\nthe length of PQ<sub>0</sub>, PQ<sub>2</sub>, PQ<sub>4</sub>, ..., PQ<sub>I</sub> are all equal,\nand equal to the lengths of PR<sub>2</sub>, PR<sub>4</sub>, ..., PR<sub>I</sub>. Since the angles\nbetween two consecutive segments of those are also all equal,\nQ<sub>0</sub>Q<sub>2</sub>Q<sub>4</sub>...Q<sub>I</sub>R<sub>I</sub>R<sub>I-2</sub>...R<sub>2</sub>\nis a regular polygon. All points have rational coordinates because they\nare either input points, endpoints of folding segments, or reflections calculated from other\npoints with rational coordinates. It is known that the only regular polygon whose vertices have\nrational coordinates in 2 dimensions is the square, which means\nI / 2 + 1 + I / 2 = 4, which implies I = 3 is odd.\n</p><p>\nThe following picture illustrates the above proof for the case I = 4. P is the point in the center,\nand line segments of the same color are guaranteed to be of the same length.\n</p>\n<svg width=\"400\" height=\"300\" viewbox=\"0 0 400 300\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M80.000 150.000L156.008 45.384L278.992 85.344L278.992 214.656L156.008 254.616Z\" fill=\"none\" stroke=\"#24C1E0\" stroke-width=\"2\" />\n<path d=\"M190.000 150.000L80.000 150.000M190.000 150.000L156.008 45.384M190.000 150.000L278.992 85.344M190.000 150.000L278.992 214.656M190.000 150.000L156.008 254.616\" fill=\"none\" stroke=\"#1A73E8\" stroke-width=\"3\" />\n<path d=\"M190.000 150.000L80.783 70.649M190.000 150.000L231.717 21.607M190.000 150.000L325.000 150.000M190.000 150.000L231.717 278.393M190.000 150.000L80.783 229.351\" stroke=\"#EA4335\" stroke-width=\"2\" fill=\"none\" />\n<style>.label { font: 18px Arial, sans-serif; }.s { font-size: 14px; }</style><text color=\"#202124\" x=\"11.000\" y=\"155.000\" class=\"label\">R<tspan baseline-shift=\"-4\" class=\"s\">0</tspan> = Q<tspan baseline-shift=\"-4\" class=\"s\">0</tspan></text>\n<text color=\"#202124\" x=\"54.602\" y=\"63.893\" class=\"label\">Q<tspan baseline-shift=\"-4\" class=\"s\">1</tspan></text>\n<text color=\"#202124\" x=\"129.918\" y=\"35.873\" class=\"label\">Q<tspan baseline-shift=\"-4\" class=\"s\">2</tspan></text>\n<text color=\"#202124\" x=\"238.717\" y=\"29.607\" class=\"label\">Q<tspan baseline-shift=\"-4\" class=\"s\">3</tspan></text>\n<text color=\"#202124\" x=\"286.992\" y=\"85.344\" class=\"label\">Q<tspan baseline-shift=\"-4\" class=\"s\">4</tspan></text>\n<text color=\"#202124\" x=\"331.000\" y=\"155.000\" class=\"label\">Q<tspan baseline-shift=\"-4\" class=\"s\">5</tspan> = R<tspan baseline-shift=\"-4\" class=\"s\">5</tspan></text>\n<text color=\"#202124\" x=\"288.992\" y=\"219.656\" class=\"label\">R<tspan baseline-shift=\"-4\" class=\"s\">4</tspan></text>\n<text color=\"#202124\" x=\"238.717\" y=\"276.393\" class=\"label\">R<tspan baseline-shift=\"-4\" class=\"s\">3</tspan></text>\n<text color=\"#202124\" x=\"146.901\" y=\"276.491\" class=\"label\">R<tspan baseline-shift=\"-4\" class=\"s\">2</tspan></text>\n<text color=\"#202124\" x=\"62.175\" y=\"242.870\" class=\"label\">R<tspan baseline-shift=\"-4\" class=\"s\">1</tspan></text>\n</svg><p>\nA consequence of this proof is that for any non-vertex point on the original polygon,\nit must be adjacent to exactly 0, 1 or 3 folding line segments.\n</p>\n","id":"0000000000159170","statement":"<h3>Problem</h3>\n<p>\n  Chalk has been actively traveling the world with his friends taking pictures\n  in all the coolest places. Most recently, he made his way to Europe, where he\n  studied the history of\n  <a href=\"https://en.wikipedia.org/wiki/Napkin_folding\">napkin folding</a>.\n  Ever since, Chalk has been collecting a wide variety of napkins to\n  practice the art of napkin folding.\n</p><p>\n  Chalk's napkins can be defined as\n  <a href=\"https://en.wikipedia.org/wiki/Simple_polygon\">simple polygons</a>.\n  A simple polygon is a polygon in which no edges intersect except for adjacent\n  edges which meet at their shared vertex. Each vertex of the polygon is on\n  exactly two edges.\n</p><p>\n  Chalk folds his napkins by first drawing a <i>folding pattern</i> on them. A\n  folding pattern is a set of <b>K</b>-1 line segments\n  which are drawn on the napkin. Each line segment connects two points with rational\n  coordinates on the border of the polygon defining the napkin and is fully contained\n  in the polygon. No two line segments in a folding pattern may touch or overlap, except possibly at\n  common endpoints. A folding pattern of <b>K</b>-1 line segments\n  splits the napkin into <b>K</b> polygonal regions. Two points\n  are in the same region if there exists some continuous line (not necessarily\n  straight) between them which does not intersect any edge of the polygon or any line segment in\n  the folding pattern &mdash; even at endpoints.\n</p><p>\n  Chalk is only interested in <i>neat folding patterns</i>. A\n  folding pattern is <i>neat</i> if any two regions that\n  are adjacent to the same folding line segment <i>F</i> are\n  <a href=\"https://en.wikipedia.org/wiki/Reflection_symmetry\">symmetric</a> with\n  respect to <i>F</i>. This means that folding the napkin along\n  that line segment would result in the two regions lining up perfectly.\n</p><p>\n  The following picture illustrates a neat folding pattern with <b>K</b>=8 regions.\n</p>\n<p style=\"text-align:center\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"290pt\" height=\"290pt\" viewBox=\"0 0 290 290\" version=\"1.1\">\n<g id=\"surface1\">\n<path style=\"fill-rule:nonzero;fill:rgb(73.631287%,83.984375%,100%);fill-opacity:1;stroke-width:7.9701;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:10;\" d=\"M 1925.3125 1918.789062 L 1925.3125 973.867188 L 2870.195312 973.867188 L 2870.195312 28.984375 L 1925.3125 28.984375 L 980.390625 973.867188 L 980.390625 1918.789062 L 35.507812 1918.789062 L 35.507812 2863.671875 L 980.390625 2863.671875 L 1925.3125 1918.789062 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 35.507812 1918.789062 L 980.390625 2863.671875 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 980.390625 973.867188 L 1925.3125 973.867188 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 980.390625 973.867188 L 1925.3125 1918.789062 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 980.390625 1918.789062 L 980.390625 2863.671875 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 980.390625 1918.789062 L 1925.3125 1918.789062 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 1925.3125 28.984375 L 1925.3125 973.867188 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 1925.3125 28.984375 L 2870.195312 973.867188 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 192.613281 C 195.363281 191.046875 194.097656 189.777344 192.53125 189.777344 C 190.964844 189.777344 189.695312 191.046875 189.695312 192.613281 C 189.695312 194.179688 190.964844 195.449219 192.53125 195.449219 C 194.097656 195.449219 195.363281 194.179688 195.363281 192.613281 Z M 195.363281 192.613281 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 192.613281 C 289.855469 191.046875 288.585938 189.777344 287.019531 189.777344 C 285.453125 189.777344 284.183594 191.046875 284.183594 192.613281 C 284.183594 194.179688 285.453125 195.449219 287.019531 195.449219 C 288.585938 195.449219 289.855469 194.179688 289.855469 192.613281 Z M 289.855469 192.613281 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 287.101562 C 289.855469 285.535156 288.585938 284.265625 287.019531 284.265625 C 285.453125 284.265625 284.183594 285.535156 284.183594 287.101562 C 284.183594 288.667969 285.453125 289.9375 287.019531 289.9375 C 288.585938 289.9375 289.855469 288.667969 289.855469 287.101562 Z M 289.855469 287.101562 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 287.101562 C 195.363281 285.535156 194.097656 284.265625 192.53125 284.265625 C 190.964844 284.265625 189.695312 285.535156 189.695312 287.101562 C 189.695312 288.667969 190.964844 289.9375 192.53125 289.9375 C 194.097656 289.9375 195.363281 288.667969 195.363281 287.101562 Z M 195.363281 287.101562 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 192.613281 C 100.875 191.046875 99.605469 189.777344 98.039062 189.777344 C 96.472656 189.777344 95.207031 191.046875 95.207031 192.613281 C 95.207031 194.179688 96.472656 195.449219 98.039062 195.449219 C 99.605469 195.449219 100.875 194.179688 100.875 192.613281 Z M 100.875 192.613281 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 98.121094 C 100.875 96.558594 99.605469 95.289062 98.039062 95.289062 C 96.472656 95.289062 95.207031 96.558594 95.207031 98.121094 C 95.207031 99.6875 96.472656 100.957031 98.039062 100.957031 C 99.605469 100.957031 100.875 99.6875 100.875 98.121094 Z M 100.875 98.121094 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 98.121094 C 6.386719 96.558594 5.117188 95.289062 3.550781 95.289062 C 1.984375 95.289062 0.714844 96.558594 0.714844 98.121094 C 0.714844 99.6875 1.984375 100.957031 3.550781 100.957031 C 5.117188 100.957031 6.386719 99.6875 6.386719 98.121094 Z M 6.386719 98.121094 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 3.632812 C 6.386719 2.066406 5.117188 0.800781 3.550781 0.800781 C 1.984375 0.800781 0.714844 2.066406 0.714844 3.632812 C 0.714844 5.199219 1.984375 6.46875 3.550781 6.46875 C 5.117188 6.46875 6.386719 5.199219 6.386719 3.632812 Z M 6.386719 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 3.632812 C 100.875 2.066406 99.605469 0.800781 98.039062 0.800781 C 96.472656 0.800781 95.207031 2.066406 95.207031 3.632812 C 95.207031 5.199219 96.472656 6.46875 98.039062 6.46875 C 99.605469 6.46875 100.875 5.199219 100.875 3.632812 Z M 100.875 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 98.121094 C 195.363281 96.558594 194.097656 95.289062 192.53125 95.289062 C 190.964844 95.289062 189.695312 96.558594 189.695312 98.121094 C 189.695312 99.6875 190.964844 100.957031 192.53125 100.957031 C 194.097656 100.957031 195.363281 99.6875 195.363281 98.121094 Z M 195.363281 98.121094 \"/>\n</g>\n</svg></p>\n<p>\n  Chalk has been successfully folding his collection of napkins using\n  neat folding patterns. But he has some napkins in his collection that\n  he has not been able to find a neat folding pattern for. For each\n  of those napkins, Chalk needs your help to find a neat folding pattern\n  with <b>K</b> regions or determine that no such neat folding pattern exists.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case starts with a line containing two\n  integers <b>N</b> and <b>K</b>: the number of points in the polygon defining\n  Chalk's napkin and the number of regions to split the napkin into with a\n  neat folding pattern containing <b>K</b>-1 line segments.\n</p><p>\n  The polygon defining the napkin is represented as a list of the <b>N</b>\n  vertices, as encountered when traveling along the perimeter of the polygon\n  in the clockwise direction, with the first vertex being chosen arbitrarily.\n  The next <b>N</b> lines represent that list. The i-th of these\n  contains two integers <b>X<sub>i</sub></b> and <b>Y<sub>i</sub></b>,\n  indicating that the i-th point is located at\n  (<b>X<sub>i</sub></b>, <b>Y<sub>i</sub></b>) in two-dimensional space.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code> is\n  <code>POSSIBLE</code> if it is possible to make a neat folding pattern\n  with <b>K</b> regions and <code>IMPOSSIBLE</code> otherwise.\n</p><p>\n  If it is possible to make a neat folding pattern with <b>K</b> regions, output <b>K</b>-1\n  more lines listing the segments of a neat folding pattern with <b>K</b> regions, in any order.\n  Each line should represent a different segment as\n  <code>A<sub>x</sub> A<sub>y</sub> B<sub>x</sub> B<sub>y</sub></code>, where\n  (<code>A<sub>x</sub></code>, <code>A<sub>y</sub></code>) and\n  (<code>B<sub>x</sub></code>, <code>B<sub>y</sub></code>) are the two endpoints\n  of the segment, in any order. Each of <code>A<sub>x</sub></code>, <code>A<sub>y</sub></code>,\n  <code>B<sub>x</sub></code>, and <code>B<sub>y</sub></code> should be in the\n  form <code>N/D</code> where <code>N</code> and <code>D</code> are positive\n  integers (written with no leading zeroes) sharing no common prime factors,\n  and representing the rational number <code>N</code>/<code>D</code>. There\n  must be no whitespace between <code>N</code> and <code>/</code>, or between\n  <code>/</code> and <code>D</code>.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 60 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  3 &le; <b>N</b> &le; 200.<br/>\n  1 &le; <b>X<sub>i</sub></b> &le; 1000, for all i.<br/>\n  1 &le; <b>Y<sub>i</sub></b> &le; 1000, for all i.<br/>\n  The <b>N</b> points are given in clockwise order.<br/>\n  No two adjacent edges of the polygon are collinear.<br/>\n  The polygon is a simple polygon with strictly positive area.<br/>\n  No two edges intersect except for adjacent edges at their shared endpoint.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>K</b> = 2.\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  2 &le; <b>K</b> &le; 10.\n</p>\n\n<h3>Sample</h3>\n\n<div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input 1</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output 1</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">\n4\n4 2\n1 1\n1 2\n2 2\n2 1\n3 2\n1 1\n1 2\n2 1\n8 2\n1 3\n3 5\n5 5\n4 4\n7 3\n5 1\n4 2\n3 1\n8 2\n1 3\n3 5\n4 4\n5 5\n7 3\n5 1\n4 2\n3 1\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: POSSIBLE\n1/1 2/1 2/1 1/1\nCase #2: POSSIBLE\n1/1 1/1 3/2 3/2\nCase #3: IMPOSSIBLE\nCase #4: POSSIBLE\n1/1 3/1 7/1 3/1\n  </pre>\n  </td></tr></table>\n</div>\n<br/>\n<div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input 2</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output 2</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">\n1\n10 8\n4 1\n3 1\n2 2\n2 3\n1 3\n1 4\n2 4\n3 3\n3 2\n4 2\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: POSSIBLE\n3/1 1/1 4/1 2/1\n3/1 1/1 3/1 2/1\n2/1 2/1 3/1 2/1\n2/1 2/1 3/1 3/1\n2/1 3/1 3/1 3/1\n2/1 3/1 2/1 4/1\n1/1 3/1 2/1 4/1\n  </pre>\n  </td></tr></table>\n</div>\n<p>\n  Note: Sample 2 is not valid for Test set 1. Only Sample 1 will be tested prior to\n  running Test set 1 (the same way samples normally are). Moreover, Sample 2\n  will <u>not</u> be tested prior to running Test set 2.\n</p>\n<br/>\n<p>\n  For Sample Case #1, a neat folding pattern with <b>K</b>=2 can be drawn using any of\n  the 4 dashed lines:\n<br/>\n</p><p style=\"text-align:center\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"290pt\" height=\"290pt\" viewBox=\"0 0 290 290\" version=\"1.1\">\n<g id=\"surface1\">\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(73.631287%,83.984375%,100%);fill-opacity:1;\" d=\"M 3.550781 287.101562 L 287.019531 287.101562 L 287.019531 3.632812 L 3.550781 3.632812 Z M 3.550781 287.101562 \"/>\n<path style=\"fill:none;stroke-width:7.9701;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:10;\" d=\"M 2870.195312 28.984375 L 35.507812 28.984375 L 35.507812 2863.671875 L 2870.195312 2863.671875 L 2870.195312 28.984375 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 35.507812 28.984375 L 2870.195312 2863.671875 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%,100%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 35.507812 1446.328125 L 2870.195312 1446.328125 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,100%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 35.507812 2863.671875 L 2870.195312 28.984375 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,100%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 1452.851562 28.984375 L 1452.851562 2863.671875 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 287.101562 C 6.386719 285.535156 5.117188 284.265625 3.550781 284.265625 C 1.984375 284.265625 0.714844 285.535156 0.714844 287.101562 C 0.714844 288.667969 1.984375 289.9375 3.550781 289.9375 C 5.117188 289.9375 6.386719 288.667969 6.386719 287.101562 Z M 6.386719 287.101562 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 3.632812 C 6.386719 2.066406 5.117188 0.800781 3.550781 0.800781 C 1.984375 0.800781 0.714844 2.066406 0.714844 3.632812 C 0.714844 5.199219 1.984375 6.46875 3.550781 6.46875 C 5.117188 6.46875 6.386719 5.199219 6.386719 3.632812 Z M 6.386719 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 3.632812 C 289.855469 2.066406 288.585938 0.800781 287.019531 0.800781 C 285.453125 0.800781 284.183594 2.066406 284.183594 3.632812 C 284.183594 5.199219 285.453125 6.46875 287.019531 6.46875 C 288.585938 6.46875 289.855469 5.199219 289.855469 3.632812 Z M 289.855469 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 287.101562 C 289.855469 285.535156 288.585938 284.265625 287.019531 284.265625 C 285.453125 284.265625 284.183594 285.535156 284.183594 287.101562 C 284.183594 288.667969 285.453125 289.9375 287.019531 289.9375 C 288.585938 289.9375 289.855469 288.667969 289.855469 287.101562 Z M 289.855469 287.101562 \"/>\n</g>\n</svg>\n</p><p>\n  For Sample Case #2, a neat folding pattern with <b>K</b>=2 can be drawn as follows:\n<br/>\n</p><p style=\"text-align:center\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"290pt\" height=\"290pt\" viewBox=\"0 0 290 290\" version=\"1.1\">\n<g id=\"surface1\">\n<path style=\"fill-rule:nonzero;fill:rgb(73.631287%,83.984375%,100%);fill-opacity:1;stroke-width:7.9701;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:10;\" d=\"M 2870.195312 28.984375 L 35.507812 28.984375 L 35.507812 2863.671875 L 2870.195312 28.984375 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 35.507812 28.984375 L 1452.851562 1446.328125 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 287.101562 C 6.386719 285.535156 5.117188 284.265625 3.550781 284.265625 C 1.984375 284.265625 0.714844 285.535156 0.714844 287.101562 C 0.714844 288.667969 1.984375 289.9375 3.550781 289.9375 C 5.117188 289.9375 6.386719 288.667969 6.386719 287.101562 Z M 6.386719 287.101562 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 3.632812 C 6.386719 2.066406 5.117188 0.800781 3.550781 0.800781 C 1.984375 0.800781 0.714844 2.066406 0.714844 3.632812 C 0.714844 5.199219 1.984375 6.46875 3.550781 6.46875 C 5.117188 6.46875 6.386719 5.199219 6.386719 3.632812 Z M 6.386719 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 287.101562 C 289.855469 285.535156 288.585938 284.265625 287.019531 284.265625 C 285.453125 284.265625 284.183594 285.535156 284.183594 287.101562 C 284.183594 288.667969 285.453125 289.9375 287.019531 289.9375 C 288.585938 289.9375 289.855469 288.667969 289.855469 287.101562 Z M 289.855469 287.101562 \"/>\n</g>\n</svg>\n</p><p>\n  For Sample Case #3, there are no neat folding patterns:\n<br/>\n</p><p style=\"text-align:center\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"290pt\" height=\"196pt\" viewBox=\"0 0 290 196\" version=\"1.1\">\n<g id=\"surface1\">\n<path style=\"fill-rule:nonzero;fill:rgb(73.631287%,83.984375%,100%);fill-opacity:1;stroke-width:7.9701;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:10;\" d=\"M 980.390625 33.90625 L 35.507812 978.789062 L 980.390625 1923.671875 L 1925.3125 1923.671875 L 1452.851562 1451.210938 L 2870.195312 978.789062 L 1925.3125 33.90625 L 1452.851562 506.328125 L 980.390625 33.90625 \" transform=\"matrix(0.1,0,0,-0.1,0,196)\"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 98.121094 C 6.386719 96.554688 5.117188 95.285156 3.550781 95.285156 C 1.984375 95.285156 0.714844 96.554688 0.714844 98.121094 C 0.714844 99.6875 1.984375 100.957031 3.550781 100.957031 C 5.117188 100.957031 6.386719 99.6875 6.386719 98.121094 Z M 6.386719 98.121094 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 3.632812 C 100.875 2.066406 99.605469 0.796875 98.039062 0.796875 C 96.472656 0.796875 95.207031 2.066406 95.207031 3.632812 C 95.207031 5.199219 96.472656 6.46875 98.039062 6.46875 C 99.605469 6.46875 100.875 5.199219 100.875 3.632812 Z M 100.875 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 3.632812 C 195.363281 2.066406 194.097656 0.796875 192.53125 0.796875 C 190.964844 0.796875 189.695312 2.066406 189.695312 3.632812 C 189.695312 5.199219 190.964844 6.46875 192.53125 6.46875 C 194.097656 6.46875 195.363281 5.199219 195.363281 3.632812 Z M 195.363281 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 148.121094 50.878906 C 148.121094 49.3125 146.851562 48.042969 145.285156 48.042969 C 143.71875 48.042969 142.449219 49.3125 142.449219 50.878906 C 142.449219 52.441406 143.71875 53.710938 145.285156 53.710938 C 146.851562 53.710938 148.121094 52.441406 148.121094 50.878906 Z M 148.121094 50.878906 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 98.121094 C 289.855469 96.554688 288.585938 95.285156 287.019531 95.285156 C 285.453125 95.285156 284.183594 96.554688 284.183594 98.121094 C 284.183594 99.6875 285.453125 100.957031 287.019531 100.957031 C 288.585938 100.957031 289.855469 99.6875 289.855469 98.121094 Z M 289.855469 98.121094 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 192.609375 C 195.363281 191.046875 194.097656 189.777344 192.53125 189.777344 C 190.964844 189.777344 189.695312 191.046875 189.695312 192.609375 C 189.695312 194.175781 190.964844 195.445312 192.53125 195.445312 C 194.097656 195.445312 195.363281 194.175781 195.363281 192.609375 Z M 195.363281 192.609375 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 148.121094 145.367188 C 148.121094 143.800781 146.851562 142.53125 145.285156 142.53125 C 143.71875 142.53125 142.449219 143.800781 142.449219 145.367188 C 142.449219 146.929688 143.71875 148.203125 145.285156 148.203125 C 146.851562 148.203125 148.121094 146.929688 148.121094 145.367188 Z M 148.121094 145.367188 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 192.609375 C 100.875 191.046875 99.605469 189.777344 98.039062 189.777344 C 96.472656 189.777344 95.207031 191.046875 95.207031 192.609375 C 95.207031 194.175781 96.472656 195.445312 98.039062 195.445312 C 99.605469 195.445312 100.875 194.175781 100.875 192.609375 Z M 100.875 192.609375 \"/>\n</g>\n</svg>\n</p><p>\n  For Sample Case #4, there are two possible neat folding patterns with <b>K</b>=2:\n<br/>\n</p><p style=\"text-align:center\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"290pt\" height=\"196pt\" viewBox=\"0 0 290 196\" version=\"1.1\">\n<g id=\"surface1\">\n<path style=\"fill-rule:nonzero;fill:rgb(73.631287%,83.984375%,100%);fill-opacity:1;stroke-width:7.9701;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:10;\" d=\"M 980.390625 33.90625 L 35.507812 978.789062 L 980.390625 1923.671875 L 1452.851562 1451.210938 L 1925.3125 1923.671875 L 2870.195312 978.789062 L 1925.3125 33.90625 L 1452.851562 506.328125 L 980.390625 33.90625 \" transform=\"matrix(0.1,0,0,-0.1,0,196)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 35.507812 978.789062 L 2870.195312 978.789062 \" transform=\"matrix(0.1,0,0,-0.1,0,196)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%,100%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 1452.851562 506.328125 L 1452.851562 1451.210938 \" transform=\"matrix(0.1,0,0,-0.1,0,196)\"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 98.121094 C 6.386719 96.554688 5.117188 95.285156 3.550781 95.285156 C 1.984375 95.285156 0.714844 96.554688 0.714844 98.121094 C 0.714844 99.6875 1.984375 100.957031 3.550781 100.957031 C 5.117188 100.957031 6.386719 99.6875 6.386719 98.121094 Z M 6.386719 98.121094 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 3.632812 C 100.875 2.066406 99.605469 0.796875 98.039062 0.796875 C 96.472656 0.796875 95.207031 2.066406 95.207031 3.632812 C 95.207031 5.199219 96.472656 6.46875 98.039062 6.46875 C 99.605469 6.46875 100.875 5.199219 100.875 3.632812 Z M 100.875 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 148.121094 50.878906 C 148.121094 49.3125 146.851562 48.042969 145.285156 48.042969 C 143.71875 48.042969 142.449219 49.3125 142.449219 50.878906 C 142.449219 52.441406 143.71875 53.710938 145.285156 53.710938 C 146.851562 53.710938 148.121094 52.441406 148.121094 50.878906 Z M 148.121094 50.878906 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 3.632812 C 195.363281 2.066406 194.097656 0.796875 192.53125 0.796875 C 190.964844 0.796875 189.695312 2.066406 189.695312 3.632812 C 189.695312 5.199219 190.964844 6.46875 192.53125 6.46875 C 194.097656 6.46875 195.363281 5.199219 195.363281 3.632812 Z M 195.363281 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 98.121094 C 289.855469 96.554688 288.585938 95.285156 287.019531 95.285156 C 285.453125 95.285156 284.183594 96.554688 284.183594 98.121094 C 284.183594 99.6875 285.453125 100.957031 287.019531 100.957031 C 288.585938 100.957031 289.855469 99.6875 289.855469 98.121094 Z M 289.855469 98.121094 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 192.609375 C 195.363281 191.046875 194.097656 189.777344 192.53125 189.777344 C 190.964844 189.777344 189.695312 191.046875 189.695312 192.609375 C 189.695312 194.175781 190.964844 195.445312 192.53125 195.445312 C 194.097656 195.445312 195.363281 194.175781 195.363281 192.609375 Z M 195.363281 192.609375 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 148.121094 145.367188 C 148.121094 143.800781 146.851562 142.53125 145.285156 142.53125 C 143.71875 142.53125 142.449219 143.800781 142.449219 145.367188 C 142.449219 146.929688 143.71875 148.203125 145.285156 148.203125 C 146.851562 148.203125 148.121094 146.929688 148.121094 145.367188 Z M 148.121094 145.367188 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 192.609375 C 100.875 191.046875 99.605469 189.777344 98.039062 189.777344 C 96.472656 189.777344 95.207031 191.046875 95.207031 192.609375 C 95.207031 194.175781 96.472656 195.445312 98.039062 195.445312 C 99.605469 195.445312 100.875 194.175781 100.875 192.609375 Z M 100.875 192.609375 \"/>\n</g>\n</svg>\n</p><p>\n  For the test set 2 sample case, a neat folding pattern with <b>K</b>=8 can be drawn as follows:\n<br/>\n</p><p style=\"text-align:center\"><svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"290pt\" height=\"290pt\" viewBox=\"0 0 290 290\" version=\"1.1\">\n<g id=\"surface1\">\n<path style=\"fill-rule:nonzero;fill:rgb(73.631287%,83.984375%,100%);fill-opacity:1;stroke-width:7.9701;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(0%,0%,0%);stroke-opacity:1;stroke-miterlimit:10;\" d=\"M 1925.3125 1918.789062 L 1925.3125 973.867188 L 2870.195312 973.867188 L 2870.195312 28.984375 L 1925.3125 28.984375 L 980.390625 973.867188 L 980.390625 1918.789062 L 35.507812 1918.789062 L 35.507812 2863.671875 L 980.390625 2863.671875 L 1925.3125 1918.789062 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 35.507812 1918.789062 L 980.390625 2863.671875 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 980.390625 973.867188 L 1925.3125 973.867188 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 980.390625 973.867188 L 1925.3125 1918.789062 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 980.390625 1918.789062 L 980.390625 2863.671875 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 980.390625 1918.789062 L 1925.3125 1918.789062 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 1925.3125 28.984375 L 1925.3125 973.867188 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\"fill:none;stroke-width:11.9553;stroke-linecap:butt;stroke-linejoin:miter;stroke:rgb(100%,0%,0%);stroke-opacity:1;stroke-dasharray:29.8883,29.8883;stroke-miterlimit:10;\" d=\"M 1925.3125 28.984375 L 2870.195312 973.867188 \" transform=\"matrix(0.1,0,0,-0.1,0,290)\"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 192.613281 C 195.363281 191.046875 194.097656 189.777344 192.53125 189.777344 C 190.964844 189.777344 189.695312 191.046875 189.695312 192.613281 C 189.695312 194.179688 190.964844 195.449219 192.53125 195.449219 C 194.097656 195.449219 195.363281 194.179688 195.363281 192.613281 Z M 195.363281 192.613281 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 192.613281 C 289.855469 191.046875 288.585938 189.777344 287.019531 189.777344 C 285.453125 189.777344 284.183594 191.046875 284.183594 192.613281 C 284.183594 194.179688 285.453125 195.449219 287.019531 195.449219 C 288.585938 195.449219 289.855469 194.179688 289.855469 192.613281 Z M 289.855469 192.613281 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 289.855469 287.101562 C 289.855469 285.535156 288.585938 284.265625 287.019531 284.265625 C 285.453125 284.265625 284.183594 285.535156 284.183594 287.101562 C 284.183594 288.667969 285.453125 289.9375 287.019531 289.9375 C 288.585938 289.9375 289.855469 288.667969 289.855469 287.101562 Z M 289.855469 287.101562 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 287.101562 C 195.363281 285.535156 194.097656 284.265625 192.53125 284.265625 C 190.964844 284.265625 189.695312 285.535156 189.695312 287.101562 C 189.695312 288.667969 190.964844 289.9375 192.53125 289.9375 C 194.097656 289.9375 195.363281 288.667969 195.363281 287.101562 Z M 195.363281 287.101562 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 192.613281 C 100.875 191.046875 99.605469 189.777344 98.039062 189.777344 C 96.472656 189.777344 95.207031 191.046875 95.207031 192.613281 C 95.207031 194.179688 96.472656 195.449219 98.039062 195.449219 C 99.605469 195.449219 100.875 194.179688 100.875 192.613281 Z M 100.875 192.613281 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 98.121094 C 100.875 96.558594 99.605469 95.289062 98.039062 95.289062 C 96.472656 95.289062 95.207031 96.558594 95.207031 98.121094 C 95.207031 99.6875 96.472656 100.957031 98.039062 100.957031 C 99.605469 100.957031 100.875 99.6875 100.875 98.121094 Z M 100.875 98.121094 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 98.121094 C 6.386719 96.558594 5.117188 95.289062 3.550781 95.289062 C 1.984375 95.289062 0.714844 96.558594 0.714844 98.121094 C 0.714844 99.6875 1.984375 100.957031 3.550781 100.957031 C 5.117188 100.957031 6.386719 99.6875 6.386719 98.121094 Z M 6.386719 98.121094 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 6.386719 3.632812 C 6.386719 2.066406 5.117188 0.800781 3.550781 0.800781 C 1.984375 0.800781 0.714844 2.066406 0.714844 3.632812 C 0.714844 5.199219 1.984375 6.46875 3.550781 6.46875 C 5.117188 6.46875 6.386719 5.199219 6.386719 3.632812 Z M 6.386719 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 100.875 3.632812 C 100.875 2.066406 99.605469 0.800781 98.039062 0.800781 C 96.472656 0.800781 95.207031 2.066406 95.207031 3.632812 C 95.207031 5.199219 96.472656 6.46875 98.039062 6.46875 C 99.605469 6.46875 100.875 5.199219 100.875 3.632812 Z M 100.875 3.632812 \"/>\n<path style=\" stroke:none;fill-rule:nonzero;fill:rgb(0%,0%,0%);fill-opacity:1;\" d=\"M 195.363281 98.121094 C 195.363281 96.558594 194.097656 95.289062 192.53125 95.289062 C 190.964844 95.289062 189.695312 96.558594 189.695312 98.121094 C 189.695312 99.6875 190.964844 100.957031 192.53125 100.957031 C 194.097656 100.957031 195.363281 99.6875 195.363281 98.121094 Z M 195.363281 98.121094 \"/>\n</g>\n</svg></p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":39}],"title":"Napkin Folding","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n  We can make a couple of useful observations at the outset. First, if we have an interval of\n  length 1 or 2, we do not\n  need to add any pancakes for it to have the pyramid property, so we can ignore the restriction of length\n  &ge; 3 in the problem. Second, for any interval, the \"peak\" in the optimal answer\n  is the largest stack in the original interval (we leave this for you to think about). If there\n  are multiple largest stacks in an interval, we will take the leftmost largest\n  stack as the peak.\n</p>\n<h3>O(<b>S</b><sup>3</sup>) &mdash; Too slow</h3>\n<p>\n  For each of the ((<b>S</b> + 1) choose 2) intervals, determine where the peak will be located once the interval is\n  turned into a pyramid. Once we know where the peak will be, we have two smaller problems: we need\n  a non-decreasing sequence to the peak's left and a non-increasing sequence to the peak's right.\n  To compute how many pancakes we need in the non-decreasing interval, we may simply sweep from the\n  leftmost point and add pancakes until no stack in the interval to the left of the i-th stack is strictly taller than\n  the i-th stack. By maintaining the running maximum as we sweep, we can compute the number of needed\n  pancakes needed per interval in O(<b>S</b>) operations. Since there are O(<b>S</b><sup>2</sup>) intervals, this\n  algorithm requires O(<b>S</b><sup>3</sup>) operations in total.\n</p>\n<h3>O(<b>S</b><sup>2</sup>) &mdash; Test Set 1</h3>\n<p>\n  The ideas above lay the framework for a quicker solution. Instead of independently recomputing the number of\n  pancakes needed to make an interval non-decreasing (or non-increasing), we can use\n  the results from other intervals. Say we know the index of largest stack of pancakes in the range\n  [L, R] (call this index M[L, R]) and the smallest number of pancakes needed to make the interval\n  [L, R] into a non-decreasing sequence (call this number X[L, R]). We can compute both M[L, R+1]\n  and X[L, R+1] in O(1) time since the height at M[L, R+1]=max(<b>P<sub>M[L, R]</sub></b>, <b>P<sub>R+1</sub></b>)\n  and X[L, R+1] = X[L, R] + (<b>P<sub>R+1</sub></b> - <b>P<sub>M[L, R+1]</sub></b>). Similarly, we can store\n  Y[L, R], which is the smallest number of pancakes needed to make the interval [L, R] into a\n  non-increasing sequence.\n</p><p>\n  For any interval [L, R], the smallest number of pancakes needed to turn the interval into a\n  pyramid is simply X[L, M[L, R]] + Y[M[L, R], R]. The precomputation takes O(<b>S</b><sup>2</sup>) time and\n  memory and the second step uses O(1) time per interval to compute the answer. Thus, in total, this\n  is O(<b>S</b><sup>2</sup>).\n</p>\n<h3>O(<b>S</b> log <b>S</b>) &mdash; Test Set 2</h3>\n<p>\n  The above strategy will be too slow and require too much memory to handle the larger bounds. For\n  this test set, we will still use the same underlying idea of needing the number of pancakes to\n  make an interval non-decreasing or non-increasing. But instead of computing X and Y, we will\n  compute cumulative values: define X'[L, R] = X[L, R] + X[L+1, R] + ... + X[R, R] and\n  Y'[L, R] = Y[L, L] + Y[L, L+1] + ... + Y[L, R]. Now, instead of focusing on the left and right\n  endpoints, we will base our strategy on the peaks of the intervals.\n</p><p>\n  Initially, we do not know the value of X' or Y' for any interval. In our analysis, we will\n  assume that we only know the X' and Y' values for maximal intervals. That is, if two intervals\n  are side-by-side, we will merge them (we will never have intersecting intervals).\n  For example, if we know X'[L, k] and X'[k+1, R], we will merge these together into\n  X'[L, R] and forget about X'[L, k] and X'[k+1, R]. The full process of how to merge is explained\n  below. In particular, this means that any given stack is in at most one known interval for X'\n  and one known interval for Y'.\n</p><p>\n  We will process the peaks from smallest to largest. When we process the i-th stack, we are only\n  interested in intervals that have stack i as their peak. If X'[L, i-1] is computed for some value\n  of L, then L must be the furthest left index such that P<sub>L</sub>, P<sub>L+1</sub>, ...\n  , P<sub>i-1</sub> are all less than P<sub>i</sub> (since we are processing the stacks from\n  smallest to largest). Similarly, if Y'[i+1, R] is computed for some value R, then R must be the\n  furthest right index such that P<sub>i+1</sub>, P<sub>i+2</sub>, ...\n  , P<sub>R</sub> are all at least P<sub>i</sub>. If such L and R exist, then we can compute the\n  number of pancakes needed over all intervals that have i as their peak:\n</p><p>\n  X'[L, i-1] * (R - i + 1) + Y'[i+1, R] * (i - L + 1)\n</p><p>\n  Note that if we don't know X'[L, i-1] for any L, then <b>P<sub>i-1</sub></b> &ge; <b>P<sub>i</sub></b>, so i\n  cannot be a peak with any interval that includes both i-1 and i. The answer for those intervals\n  will be computed later when we consider stack i-1 as the peak (and likewise for stack i+1 if we do\n  not know Y'[i+1, R] for any R). In these cases, we may use X' = 0 (or Y' = 0). Note that since our\n  intervals are maximal and we are computing from smallest to largest,\n  <b>P<sub>L-1</sub></b> &ge; <b>P<sub>i</sub></b> (similarly,\n  <b>P<sub>R+1</sub></b> &gt; <b>P<sub>i</sub></b>).\n</p><p>\n  Now we want to merge X'[L, i-1], X'[i+1, R] and stack i into X'[L, R]. We will do this in two\n  steps. First, note that X'[L, i] = X'[L, i-1]: since we are processing the stacks from smallest to\n  largest, P<sub>i</sub> can be freely added as the right endpoint of any non-decreasing sequence in this\n  range. Now let's merge X'[L, i] and X'[i+1, R]. Observe that X'[L, R] sums over intervals that\n  end at the R-th stack. If an interval starts in the range [i+1, R], then it is already counted\n  in X'[i+1, R]. If an interval starts in [L, i], then we can start with some sequence in [L, i],\n  but since <b>P<sub>i</sub></b> is the peak, every value on the right must be exactly\n  <b>P<sub>i</sub></b>. The number of pancakes needed to bring every value in [i+1, R] up to\n  <b>P<sub>i</sub></b> can be computed in O(1) time using cumulative sums. Thus, the full merge is:\n</p><p>\n  X'[L, R] = X'[i+1, R] + (X'[L, i-1] +\n  <b>P<sub>i</sub></b> &times; (i-L+1) &times; (<b>P<sub>i+1</sub></b> + ... + <b>P<sub>R</sub></b>))\n</p><p>\n  The Y' values can be computed similarly. In terms of complexity, we need to sort the stacks at the\n  beginning in O(<b>S</b> log <b>S</b>) time and the remaining steps take constant time per peak,\n  so O(<b>S</b>) overall. This means the algorithm takes O(<b>S</b> log <b>S</b>) time.\n</p>\n<h3>O(<b>S</b>)</h3>\n<p>\n  Although the O(<b>S</b> log <b>S</b>) solution is fast enough to solve test\n  set 2, an O(<b>S</b>) solution is also possible! We present a sketch of the\n  idea here, which can be read independently of the solution above.\n</p><p>\n  To make things easier, we pretend that the stacks all have different heights.\n  Each time we compare the heights of two stacks of identical height, we break\n  the tie by assuming that the stack with the larger index is higher.\n</p><p>\n  Let us think through the solution starting from the end. For each stack, we\n  want to compute the pyramidification cost for all the ranges in which this\n  stack is the highest; in such cases, it will be the peak of the pyramid. Then\n  we can sum all of those values for all of the stacks, and that will be our\n  overall result.\n</p><p>\n  In order to compute those pyramidification costs, we can compute the\n  following for each stack <i>s</i>:\n</p>\n<ul>\n  <li>The nearest higher stack to the left of <i>s</i> (possibly an infinitely\n    high \"guard\" stack appended to the beginning of the sequence); call this\n    the \"left blocker\". Let D<sub>L</sub> be the absolute distance (in stacks)\n    from <i>s</i> to the left blocker.</li>\n  <li>The nearest higher stack to the right of <i>s</i> (or guard stack)\n    stack added after the sequence); call this \"right blocker\". Let\n    D<sub>R</sub> be the absolute distance (in stacks) from <i>s</i> to the\n    right blocker.</li>\n  <li>The pyramidification cost for all the ranges that end with <i>s</i> and\n    in which <i>s</i> is the highest; call this \"left pyramidification cost\"\n    C<sub>L</sub>.</li>\n  <li>The pyramidification cost for all the ranges that start with <i>s</i> and\n    in which <i>s</i> is the highest; call this \"right pyramidification cost\"\n    C<sub>R</sub>.</li>\n</ul>\n<p>\n  Then the pyramidification cost for <i>s</i> can be calculated as\n  C<sub>L</sub> &times; D<sub>R</sub> + C<sub>R</sub> &times; D<sub>L</sub>.\n</p><p>\n  Now, how can we compute C<sub>L</sub> and D<sub>L</sub> for each stack?\n  (The solution is analogous for C<sub>R</sub> and D<sub>R</sub>; the only\n  major difference is that the inequality used to compare stacks is strict\n  on one side and non-strict on the other, due to tie-breaking.)\n</p><p>\n  We can traverse the stacks from left to right, keeping a\n  <a href=\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\">Stack</a>\n  structure (capital S to avoid confusion) X that remembers the longest\n  decreasing sequence of stacks ending on the current stack. We iterate through the stacks\n  and when seeing a stack s we consume from X all stacks that are lower than s,\n  adding their contributions to the current left pyramidification cost. Let t' = s\n  at the beginning, and later t' = the previously consumed stack. The\n  contribution of a consumed lower stack t is the number of pancakes missing between t and t'\n  (calculated in constant time, if we precompute the cumulative sum of stack\n  sizes) multiplied by the distance to the left blocker of t'.\n  The left blocker of s is the first stack we can't consume from X, because it's higher than s.\n  Once we're done with s, we add s to X and keep going.\n</p>\n","id":"00000000001591be","statement":"<h3>Problem</h3>\n<p>\n  You have just finished cooking for some diners at the Infinite House of\n  Pancakes. There are <b>S</b> stacks of pancakes in all, and you have arranged\n  them in a line, such that the i-th stack from the left (counting starting\n  from 1) has <b>P<sub>i</sub></b> pancakes.\n</p><p>\n  Your supervisor was about to bring out the stacks to the customers, but\n  then it occurred to her that a picture of the stacks might make for a good\n  advertisement. However, she is worried that there might be too many stacks,\n  so she intends to remove the L leftmost stacks and the R rightmost stacks,\n  where L and R are nonnegative integers such that L + R &le; <b>S</b> - 3.\n  (Notice that at least 3 stacks of pancakes will remain after the removal.)\n</p><p>\n  Your supervisor also thinks the remaining stacks will look aesthetically\n  pleasing if they have the <i>pyramid property</i>. A sequence of N stacks\n  of heights H<sub>1</sub>, H<sub>2</sub>, ... , H<sub>N</sub> has the pyramid\n  property if there exists an integer j (1 &le; j &le; N) such that\n  H<sub>1</sub> &le; H<sub>2</sub> &le; ... &le; H<sub>j-1</sub> &le; H<sub>j</sub> and\n  H<sub>j</sub> &ge; H<sub>j+1</sub> &ge; ... &ge; H<sub>N-1</sub> &ge; H<sub>N</sub>.\n  (It is possible that this sequence might not look much like a typical\n  \"pyramid\" &mdash; a group of stacks of the same size has the pyramid\n  property, and so does a group in which the stack heights are nondecreasing\n  from left to right, among other examples.)\n</p><p>\n  Note that the sequence of stacks remaining after your supervisor removes\n  the L leftmost and R rightmost stacks might not yet have the pyramid\n  property... but you can fix that by adding pancakes to one or more of the\n  stacks! The <i>pyramidification cost</i> of a sequence of stacks is the\n  minimum total number of pancakes that must be added to stacks to give the\n  sequence the pyramid property.\n</p><p>\n  While your manager is carefully deciding which values of L and R to choose,\n  you have started to wonder what the sum of the pyramidification costs over\n  all valid choices of L and R is. Compute this sum, modulo the prime\n  10<sup>9</sup>+7 (1000000007).\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line containing one integer\n  <b>S</b>: the number of stacks of pancakes. Then, there is one more line\n  containing <b>S</b> integers <b>P<sub>1</sub></b>, <b>P<sub>2</sub></b>,\n  ..., <b>P<sub>S</sub></b>. The i-th of these is the number of pancakes in the\n  i-th stack from the left.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the sum of the pyramidification costs over all valid choices of L and R,\n  modulo the prime 10<sup>9</sup>+7 (1000000007).\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>P<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n</p>\n\n<h4>Test set 1 (Visible)</h4>\n<p>\n  <b>S</b> = 3000, for up to 20 test cases.<br/>\n  3 &le; <b>S</b> &le; 500, for all remaining cases.<br/>\n</p>\n\n<h4>Test set 2 (Hidden)</h4>\n<p>\n  <b>S</b> = 10<sup>6</sup>, for up to 1 test case.<br/>\n  <b>S</b> = 10<sup>5</sup>, for up to 3 test cases.<br/>\n  3 &le; <b>S</b> &le; 10000, for all remaining cases.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3\n2 1 2\n5\n1 6 2 5 7\n4\n1000000000 1 1 1000000000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 16\nCase #3: 999999991\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, your supervisor must choose L = 0 and R = 0, so that is\n  the only scenario you need to consider. The optimal strategy for that\n  scenario is to add a single pancake to the middle stack. Although the\n  resulting sequence of stacks looks flat, notice that it has the pyramid\n  property; in fact, any index will work as the j value.\n<p>\n  In Sample Case #2, here are all possible choices of L and R, the\n  corresponding remaining stacks, and what you should do in each scenario.\n</p>\n<ul>\n  <li>L = 0, R = 0: H = [1 6 2 5 7]. The optimal solution is to add\n    four pancakes to the third stack and one pancake to the fourth stack. Then\n    we have [1 6 6 6 7], which has the pyramid property with j = 5.</li>\n  <li>L = 0, R = 1: H = [1 6 2 5]. The optimal solution is to add\n    three pancakes to the third stack. Then we have [1 6 5 5], which has the\n    pyramid property with j = 2.</li>\n  <li>L = 0, R = 2: H = [1 6 2]. This already has the pyramid property\n    with j = 2.</li>\n  <li>L = 1, R = 0: H = [6 2 5 7]. The optimal solution is to add\n    four pancakes to the second stack and one pancake to the third stack. Then\n    we have [6 6 6 7], which has the pyramid property with j = 4.</li>\n  <li>L = 1, R = 1: H = [6 2 5]. The optimal solution is to add three\n    pancakes to the second stack. Then we have [6 5 5], which has the pyramid\n    property with j = 1.</li>\n  <li>L = 2, R = 0: H = [2 5 7]. This already has the pyramid property\n    with j = 3.</li>\n</ul>\n<p>\n  So the answer is (5 + 3 + 0 + 5 + 3 + 0) modulo (10<sup>9</sup> + 7), which\n  is 16.\n</p><p>\n  In Sample Case #3, we only need to add extra pancakes to create the pyramid\n  property when L = 0 and R = 0. In that case, it is optimal to add 999999999\n  pancakes to each of the second and third stacks. (We hope the diners are\n  hungry!) So the answer is (999999999 + 999999999) modulo\n  (10<sup>9</sup> + 7) = 999999991.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":17}],"title":"Pancake Pyramid","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000051707","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2019"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
