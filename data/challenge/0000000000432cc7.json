{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1253989800000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432cc7","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>Code Jam contestants never cease to surprise us, and their performance on this round was no exception.  Our tough implementation problem proved to be so tough that only 10% more people solved it than our tough algorithmic problem; and so many people were familiar with the theorems needed for Problem C that 362 of you breezed right through it.  Meanwhile Russia and East Asia dominated the top 10, with 9 out of the 10 top spots.  But with all else said and done, first place was no surprise to anyone: ACRush, 2008 Code Jam Champion, finished all four problems less than halfway through the competition, and almost 30 minutes faster than everyone else.\n</p>\n<p>Congratulations to the top 500 competitors, who will win a Code Jam t-shirt and advance to the next round!\n</p>\n<br/>\n<hr/>\n<p class=\"problem-item\">Cast</p>\n<p>Problem A. <i>Crazy Rows</i> Written by Cosmin Negruseri. Prepared by Igor Naverniouk and Marius Andrei.</p>\n<p>Problem B. <i>A Digging Problem</i> Written by Mohamed Eldawy. Prepared by Ante Derek, Marius Andrei and Jonathan Wills.</p>\n<p>Problem C. <i>Stock Charts</i> Written by Bartholomew Furrow. Prepared by Xiaomin Chen and Bartholomew Furrow.</p>\n<p>Problem D. <i>Watering Plants</i> Written by John Dethridge. Prepared by Tomek Czajka and John Dethridge.</p>\n<p>Contest analysis presented by Xiaomin Chen, Cosmin Negruseri, Bartholomew Furrow and John Dethridge.</p>\n<p>Solutions and other problem preparation provided by Pablo Dal Lago, Petr Mitrichev, F&aacute;bio Moreira and Ruoming Pang.</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1253980800000,"tasks":[{"analysis":"\n<p>\nIt will come as no great surprise, but the author of this problem came up with it while reading a local newspaper's end-of-year economics summary, seeing a number of overlaid charts in it and then wondering how to minimize the number of charts needed.\n</p>\n<h3>Charts and DAGs</h3>\n<p>\nConsider two simple charts: A and B.  They can be related to each other in one of three ways: all of A's values can be strictly less than all of B's values (A &lt; B), in which case they can appear on the same overlaid chart; their lines can cross (A \\ B), in which case they can't appear on the same overlaid chart; or all of A's values can be strictly greater than all of B's values (A &gt; B), in which case they can appear on the same overlaid chart.\n</p>\n<p>\nGiven this sort of relationship we can construct a graph, where the nodes are simple charts and there is an edge from A to B iff A &gt; B.  This gives us a directed, acyclic graph that is its own (non-reflexive) transitive closure.  Any directed path in the DAG represents a valid composite chart.  To solve the problem, then, we want to find the minimum number of paths that we need so that all nodes are part of exactly one path.\n</p>\n<p>\nHow would we find the paths? We may start from a chart that is relatively high, then find one below it, and keep adding lower charts, until we cannot find more. This completes our first overlaid charts. We start the same process for the second path, and so on. In any step, there might be several choices for the next chart we can use. In order to minimize the number of paths, we need to make a good choice in each step.\n</p>\n<p>\nNow, behold, the Aha moment of this problem.\n</p>\n<h3>Solution from maximum matching</h3>\n<p>\n<br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U23axM2EA_JbLS1OxAEuo9r4K9-alZauWKVtcBnojnwpL6ZitEPe6LzsXK8flOUg9Az0Lw/stock.png\"/>\n<br/><br/>\nFor the DAG with <i>n</i> points, we make a bipartite graph with <i>n</i> points on each side. Draw an edge from X<sub>A</sub> to Y<sub>B</sub> if the relation A &gt; B holds, i.e., B can be the next chart below A. Observe (yes, you really need to see it, instead of hear it!) how any path in the DAG corresponds to a series of edges in the bipartite graph; and how any matching of the bipartite graph corresponds to a way to partition the DAG into paths. Any unmatched point X<sub>A</sub> on the left side corresponds to the lowest point on a path (the lowest chart on an overlaid graph). Each path has exactly one such point. We want to minimize the number of paths, the same as minimizing the number of unmatched points on the left side. That is, we want to find the maximum matching in a bipartite graph.\n</p>\n<p>\nHere is the judge's solution in C++.\n<pre>\nnamespace Solver {\nint N,K;\nbool cbn[111][111]; // can be next\nint prev[111];\nbool visited[111];\n\nbool FindNextDfs(int a) {\n  if(a&lt;0) return true;\n  if(visited[a]) return false;\n  visited[a]=true;\n  for (int i=0;i&lt;N;i++) if(cbn[a][i]) {\n      if(FindNextDfs(prev[i])) {\n        prev[i]=a;\n        return true;\n      }\n    }\n  return false;\n}\n\nint Solve(const vector&lt;vector&lt;int&gt; &gt;&amp; stock) {\n  N=stock.size(); K=stock[0].size();\n  int i,j,k;\n  for(i=0;i&lt;N;i++) {\n    for(j=0;j&lt;N;j++) {\n      if(i==j) cbn[i][j]=false;\n      else {\n        cbn[i][j]=true;\n        for(k=0;k&lt;K;k++)\n          if(stock[i][k]&lt;=stock[j][k]) cbn[i][j]=false;\n      }\n    }\n  }\n  memset(prev, -1, sizeof(prev));\n  int ret=0;\n  for(i=0;i&lt;N;i++) {\n    memset(visited, 0, sizeof(visited));\n    if(!FindNextDfs(i)) ret++;\n  }\n  return ret;\n}\n</pre>\nNote that this is indeed the bipartite matching program. We named the variables as if we are really constructing the set of paths and unaware of the bipartite graph. In fact, it's a worthy exercise to go over this without bipartite matching in your mind.\n</p>\n<p>\nThis completes the solution of our problem. But we may continue with more stories.\n</p>\n<h3>Theoretical background</h3>\n<p>In combinatorics, DAGs are called <i>partially ordered sets</i>, or <i>posets</i>. A directed path is called a <i>chain</i> in the poset. An independent set in the DAG, corresponding to a set of points where no '&gt;' relation holds between any two of them, is called an <i>anti-chain</i>. Our problem is then, given a poset, find the minimum number of chains needed to cover all the points.<br/>\nIf we see an anti-chain of size &alpha;, we need at least &alpha; chains to cover the set, because each chain can contain at most one of these points. Suppose we find the maximum anti-chain to be of size &alpha;*, we know the answer must be at least &alpha;*. Is this enough though?<br/>\nWe are ready to introduce one of the classical theorems in combinatorics.\n</p>\n<p>\n<i>Theorem</i> (Dilworth 1950) In a poset, the minimum number of chains needed to cover the whole set equals the size of the biggest anti-chain.\n</p>\n<p>\nDilworth's theorem is closely related to other classical theorems in combinatorics. In fact it is equivalent to Hall's marriage theorem on bipartite graphs, and the max-flow-min-cut theorem.\n</p>\n<p>\nThe number in Dilworth's theorem is (naturally) called the width of the poset. Our algorithm above thus finds the width of a poset. Interested readers might find, in our input file, perturbed copies of the following posets:\n<ul>\n<li>The complete Boolean lattice: All the 2<sup>k</sup> subsets of a k-element set, where A &gt; B if B is a subset of A. All the &lceil;k/2&rceil;-subsets form a maximum anti-chain of size (k choose &lceil;k/2&rceil;), and indeed we can partition the Boolean lattice into this many chains. (This is called the Sperner's theorem.)</li>\n<li>All the integers from 1 to n, A &gt; B if A is a multiple of B. The set of all the prime numbers seems to be a big anti-chain. But it is not big enough. We leave it as an exercise to prove that the width of this poset is &lceil;n/2&rceil;.</li>\n</ul>\n</p>\n\n<h3>More information</h3>\n<p>\n<a href=\"http://www.google.com/search?q=partially+ordered+set\" target=\"_blank\">Partially ordered set</a> -\n<a href=\"http://www.google.com/search?q=dilworth's+theorem\" target=\"_blank\">Dilworth's theorem</a>\n</p>\n","id":"0000000000432a83","statement":"<h3>Problem</h3>\n\n<p>\nYou're in the middle of writing your newspaper's end-of-year economics summary, and you've decided that you want to show a number of charts to demonstrate how different stocks have performed over the course of the last year.  You've already decided that you want to show the price of <b>n</b> different stocks, all at the same <b>k</b> points of the year.\n</p>\n<p>\nA <i>simple chart</i> of one stock's price would draw lines between the points (0, price<sub>0</sub>), (1, price<sub>1</sub>), ... , (k-1, price<sub>k-1</sub>), where price<sub>i</sub> is the price of the stock at the <i>i</i>th point in time.\n</p>\n<p>\nIn order to save space, you have invented the concept of an <i>overlaid chart</i>.  An overlaid chart is the combination of one or more simple charts, and shows the prices of multiple stocks (simply drawing a line for each one).  In order to avoid confusion between the stocks shown in a chart, the lines in an overlaid chart may not cross or touch.\n</p>\n<p>\nGiven a list of <i>n</i> stocks' prices at each of <i>k</i> time points, determine the minimum number of overlaid charts you need to show all of the stocks' prices.\n</p>\n\n<h3>Input</h3><p>\nThe first line of input will contain a single integer <b>T</b>, the number of test cases.  After this will follow <b>T</b> test cases on different lines, each of the form:\n<pre>\nn k\nprice<sub>0,0</sub> price<sub>0,1</sub> ... price<sub>0,k-1</sub>\nprice<sub>1,0</sub> price<sub>1,1</sub> ... price<sub>1,k-1</sub>\n...\nprice<sub>n-1,0</sub> price<sub>n-1,1</sub> ... price<sub>n-1,k-1</sub>\n</pre>\n</p>\n<p>\nWhere price<sub>i,j</sub> is an integer, the price of the <i>i</i>th stock at time <i>j</i>.\n</p>\n<h3>Output</h3>\n<p>\nFor each test case, a single line containing \"Case #X: Y\", where <i>X</i> is the number of the test-case (1-indexed) and <i>Y</i> is the minimum number of overlaid charts needed to show the prices of all of the stocks.\n</p>\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100<br/>\n2 &le; <b>k</b> &le; 25<br/>\n0 &le; price<sub>i,j</sub> &le; 1000000<br/>\n</p>\n<h3>Small Input</h3>\n<p>\nTime limit: 20 seconds.<br/>\n1 &le; <b>n</b> &le; 16<br/>\n</p>\n<h3>Large Input</h3>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>n</b> &le; 100<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3 4\n1 2 3 4\n2 3 4 6\n6 5 4 3\n3 3\n5 5 5\n4 4 6\n4 5 4\n5 2\n1 1\n2 2\n5 4\n4 4\n4 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 3\nCase #3: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<!--\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"problem-item-gray\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"problem-item-gray\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<code>\n3<br/>\n3 4<br/>\n1 2 3 4<br/>\n2 3 4 6<br/>\n6 5 4 3<br/>\n3 3<br/>\n5 5 5<br/>\n4 4 6<br/>\n4 5 4<br/>\n5 2<br/>\n1 1<br/>\n2 2<br/>\n5 4<br/>\n4 4<br/>\n4 1<br/>\n</code>\n</td>\n<td>\n<code>\nCase #1: 2<br/>\nCase #2: 3<br/>\nCase #3: 2<br/>\n</code>\n</td></tr></table>\n</div>\n!-->\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":21}],"title":"Stock Charts","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem involves finding circles that enclose other circles.  The problem of finding a circle surrounding a set of points is the fairly well-known minimal enclosing circle problem, but changing the points to circles makes the problem slightly trickier.\n</p>\n\n<p>\nOne solution is to do a binary search to find the minimum sprinkler radius.  This reduces the problem to the problem of determining whether two sprinklers of a given radius can cover all the plants.  To solve this, we can make the assumption that any sprinkler used in the solution either:\n<ul>\n<li> covers exactly one plant, or\n<li> the boundary of the sprinkler touches the boundary of at least two of the plants it covers.\n</ul> This assumption is safe because if a sprinkler covers more than one plant but does not have two plants on its boundary, the sprinkler can be shifted and rotated, while still covering the same plants, until it does.  Given this assumption, we can create a set of candidate sprinkler locations including:\n<ul>\n<li> a sprinkler centered on each plant, and\n<li> for each pair of plants, the set of sprinklers covering those plants and touching their boundary (there are 0, 1, or 2 of these per pair.)\n</ul>\nThen we check every pair of candidate sprinklers, and see if any of them together cover every plant.\n</p>\n\n<p>\nA second solution is to directly find the minimum sprinkler radius.  To do this, we can use a slightly different simplifying assumption -- that every sprinkler either:\n<ul>\n<li> covers exactly one plant (using the same radius as the plant),\n<li> covers two plants which touch the edge of the sprinkler and whose centers are collinear with the center of the sprinkler, or\n<li> covers three plants which touch the edge of the sprinkler.\n</ul>\nThis assumption is safe because any other sprinkler can be shrunk to a sprinkler of smaller radius that covers the same set of plants.  We try each set of plants of size 1,2 or 3, create the corresponding sprinkler from the three cases above, and check its radius and which set of plants it covers.  Then we find the pair of sprinklers that covers every plant using the minimum maximum radius.\n</p>\n\n<p>\nFinding the circle which touches 3 given circles is harder than the equivalent problem for 3 points.  Here are three possible approaches:\n<ol>\n<li>The set of points where a sprinkler can be centered in order to touch two plants is a hyperbola, so we could algebraically compute the intersection of two of those hyperbolae.\n<li>We can use a gradient-descent approach to find numerically the point minimizing the function from potential centers of sprinklers to the radius required for a sprinkler centered at that location to cover all three plants.  <li>We can subtract from the radius of each of the three plants the radius of the smallest plant, then compute an inversion about that plant's center.  Then we find appropriate tangents to the two inverted plants, re-invert to find the corresponding circle, and add back the radius of the smallest plant.\n</ol>\n</p>\n","id":"0000000000432ad3","statement":"<h3>Problem</h3>\n<p>\nIn your greenhouse you have a number of plants which you need to water.\n</p>\n<p>\nEach of the plants takes up an area which is a circle.  No two of the plants overlap or touch each other.\n</p>\n<p>\nYou are going to buy two sprinklers.  Each of the sprinklers will spray everything within a circle of radius <b>R</b> with water.\n</p>\n<p>\nOne of the sprinklers will run in the morning, and one will run at night.  For you to be satisfied that a plant will get enough water, either the whole area of the plant must be watered in the morning, or the the whole area of the plant must be watered at night.  So each of the circles representing a plant must be completely in one or both of the two circles representing the area the sprinklers can water. \n</p>\n<p>\nGiven the location and radius of each of the plants, find the minimum radius <b>R</b> so that it is possible to place the two sprinklers to water all the plants.  The sprinklers will be installed on the ceiling, so a sprinkler's position can be inside the area of a plant.\n</p>\n\n<h3>Input</h3>\n<p>\n<ul>\n<li>One line containing an integer <b>C</b>, the number of test cases in the input file.\n</ul>\nFor each test case, there will be:\n<ul>\n<li>One line containing <b>N</b>, where <b>N</b> is the number of plants you have.\n<li><b>N</b> lines, one for each plant, containing three integers \"<b>X</b> <b>Y</b> <b>R</b>\", where  (<b>X</b>, <b>Y</b>) are the coordinates of the center of the plant, and <b>R</b> is the radius of the plant.\n</ul>\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case:\n<ul>\n<li>One line containing the string \"Case #x: R\" where <i>x</i> is the number of the test case, starting from 1, and <b>R</b> is the minimum radius of the sprinklers.\n</ul>\nAny answer with absolute or relative error of at most 10<sup>-5</sup> will be accepted.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\nAll numbers in the input file are integers.<br/>\n1 &le; <b>X</b> &le; 1000<br/>\n1 &le; <b>Y</b> &le; 1000<br/>\n1 &le; <b>R</b> &le; 100\n</p>\n\n<h3>Small Input</h3>\n<p>\nTime limit: 30 seconds.<br/>\n1 &le; <b>C</b> &le; 10<br/>\n1 &le; <b>N</b> &le; 3\n</p>\n<h3>Large Input</h3>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>C</b> &le; 30<br/>\n1 &le; <b>N</b> &le; 40\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n3\n20 10 2\n20 20 2\n40 10 3\n3\n20 10 3\n30 10 3\n40 10 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 7.000000\nCase #2: 8.000000\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first case, a sprinkler of radius at least 7 centered at (20,15) will water the first two plants.  A sprinkler of radius at least 3 will water the plant at (40,10).\n</p>\n<p>\nIn the second case, one of the two sprinklers will need a radius of at least 8.  Note that the plant at (30,10) must be covered entirely by one of the two sprinklers.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Watering Plants","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe setup of this problem, where you can go left, right and down but\nnever up hints that some dynamic programming solution is the way to go,\nbut the details are a bit involved.\n</p>\n<p>\nWhen we're on a row we need to know which are the rock cells that\nwere dug previously so that we know how much we can move left or\nright. This means that we could have a state in our algorithm be (i,\nj, air_holes) where i is the current row, j is the current column and\nair_holes is the set of cells on row i that were dug previously or\nwere empty. Filling the values for these states in the whole matrix\nwould take exponential time as air_holes can take on as many as 2^C\nvalues. This would be enough to solve the small input, but for\nthe large we need to improve our algorithm a bit.\n</p>\n<p>\nFirst let's observe that it only makes sense to dig out cells that will form a connected empty zone. After we fall one row, we'll be able to use just the current zone of empty boxes. Now our state is (i, j, start, end) where start is the starting column index of the current empty zone and end is the index of the zone's end\ncolumn. This idea yields a polynomial solution, as we have O(R * C^3)\npossible states and there are at most C^2 different states that we can create on the next row.\n</p>\n<p>\nBut we can improve on this solution. It doesn't make\nsense to change directions after we started to dig; if we're moving\nright, it doesn't matter how many empty cells we have on the left. This\nchanges the state to (i, j, dir, count) where dir is the current\ndirection (left or right), and count is the number of empty cells in\nthat direction. This reduces the state space to O(R * C^2).\n</p>\n<p>\nThe implementation details are somehow tricky, and you have to make sure you don't fall more than F steps -- a detail we've skipped here. There are many possible ways to implement this problem, some of which result in much simpler code than others. We encourage you to download and study various correct implementations from the scoreboard.\n</p>\n<p>\nBefore the contest began, we evaluated this problem as the second easiest in the contest; but the many details needed to solve it resulted in this problem having the\nsecond-smallest number of successful solutions.\n</p>\n\n<h3>Something related</h3>\n<p>\nIf you are among our older contestants, this problem may bring back sweet memories of the classic game <a href=\"http://www.google.com/search?q=lode+runner\" target=\"_blank\">Lode Runner</a>, and perhaps memories of many happy days associated with it.\n</p>\n","id":"0000000000432bdc","statement":"<h3>Problem</h3>\n<p>\nThe cave is on fire and there is smoke everywhere! You are trying to dig your way to the bottom of the cave where you can breathe. The problem is that there are some air holes inside the cave, and you don't want to fall too much or you will get hurt.\n</p>\n<p>\nThe cave is represented as an <b>R</b> x <b>C</b> matrix with air holes and solid rock cells. You start at position (1, 1), which is in the top-left corner.\nYou can move one cell at a time, left or right, if that cell is empty (an air hole). After moving, if the cell below is empty, you fall down until you hit solid rock or the bottom of the cave. The falling distance must be at most <b>F</b>,or you will get hurt. You must reach the bottom of the cave without getting hurt. While falling you cannot move left or right.\n</p>\n<p>\nYou can also \"dig\", turning a cell that contains solid rock into an air hole. The cell that you dig can be one of two cells: the one to your right and below, or the one to your left and below.  The cell above the one you are digging has to be empty. While falling you cannot dig.\n</p>\n<p>\nYour goal is not only to get to the bottom of cave, but also to \"dig\" as few cells as possible.\n</p>\n<p>\nLet's describe the operations with a concrete example:\n<br/><br/><br/>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2wrfK97W6mpx-G5Ll8-M0XSyeXMKYaQm_qgt76bHHCsYQTn4NPZMyjZKrc4xt8oYm_4djTXg/digging.png\">\n<br/>\n</p>\n<p>\nYou start at (1, 1) and move right 3 times to position (1, 4), just like the picture.<br/>\nYou dig the rock at position (2, 5). Cell \"A\" becomes empty.<br/>\nYou move right one position and since there is no cell below you fall 3 cells to position (4, 5).\nYou dig the rock at position (5, 6). Cell \"B\" becomes empty.<br/>\nYou move right one position and since there is no cell below you fall 1 cell to position (5, 6).<br/>\nYou have reached the bottom of the cave by digging 2 cells.\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of input gives the number of cases, <b>N</b>. <b>N</b> test cases follow.\nThe first line of each case is formatted as\n<pre>R C F</pre>\nwhere <b>R</b> is the number of rows in the cave, <b>C</b> is the number of columns in the cave, and <b>F</b> is the maximum distance you can fall without getting hurt.<br/>\nThis is followed by <b>R</b>, rows each of which contains <b>C</b> characters. Each character can be one of two things:\n<ul>\n<li># for a solid rock</li>\n<li>. for an air hole</li>\n</ul>\nThe top-left cell will always be empty, and the cell below it will be a solid rock.\n</p>\n\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line in the format\n<pre>Case #X: No/Yes [D]</pre>\nwhere <b>X</b> is the case number, starting from 1. Output \"No\" if you cannot reach the bottom of the cave. Output \"Yes <b>D</b>\" if the bottom of the cave can be reached and the minimum number of cells that need digging is <b>D</b>.\n</p>\n\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>N</b> &le; 50<br/>\n1 &le; <b>F</b> &lt; <b>R</b>\n</p>\n\n<h3>Small dataset</h3>\n<p>\nTime limit: 40 seconds.<br/>\n2 &le; <b>R</b> &le; 10<br/>\n2 &le; <b>C</b> &le; 6<br/>\n</p>\n\n<h3>Large dataset</h3>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>R</b> &le; 50<br/>\n2 &le; <b>C</b> &le; 50<br/>\n</p>\n\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 2 1\n.#\n##\n3 3 1\n...\n###\n###\n3 2 1\n..\n#.\n..\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: No\nCase #2: Yes 3\nCase #3: No\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":17}],"title":"A Digging Problem","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Reformulation of the problem</h3>\n<p>\nIt is easy to see, for each row, only the position of the last '1' matters. We can re-formulate the problem\n<blockquote>\n<i>CR</i>: Given a list of numbers (a<sub>0</sub>, ... a<sub>N-1</sub>). You are allowed to swap adjacent numbers. Find the minimum number of swaps needed so that the i-th number is at most <i>i</i> in the final configuration.\n</blockquote>\n</p>\n<br/>\n<h3>The well known special case</h3>\nPerhaps many of you know the following special case.\n<blockquote>\n<i>CR*</i>: Given a permutation (x<sub>0</sub>, ... x<sub>N-1</sub>) of the numbers 0 to <i>N-1</i>. You are allowed to swap adjacent numbers. Find the minimum number of swaps needed in order to sort the list in increasing order.\n</blockquote>\nPerhaps you also know the complete solution to CR*. It is very simple and elegant, and important to our problem. So we produce here.<br/>\n<i>Solution (to CR*).</i> Define the <i>disorder</i> of the list to be the number of pairs i &lt; j, where x<sub>i</sub> &gt; x<sub>j</sub>. In one swap (of adjacent numbers), the total number of disorder is changed by exactly one. (Check it!) Therefore, let the disorder of initial configuration be <i>D</i>, you need at least <i>D</i> swaps. <i>D</i> swaps is also sufficient -- as long as the list is not sorted, there exist adjacent pairs in wrong order. You can swap any of such pairs and decrease the disorder by 1. &nbsp;&nbsp;&nbsp;&loz;\n</p>\n<p>\nIn particular,\n<blockquote>\n(1) One type of optimal solutions of CR* involves first to swap the number 0 all the way to the left, then let it stay there forever.\n</blockquote>\n</p>\n<br/>\n<h3>Solution to our problem</h3>\n<p>\nImagine we know which of the a<sub>i</sub>'s will finally go to position 0, and which one will go to position 1, etc., then we can simply use the algorithm for CR*. But there might be multiple candidates for a single position. For example, there might be several i's such that a<sub>i</sub> = 0, and even some a<sub>i</sub> = -1.\n</p>\n<p>\nBelow is the judge's C++ solution. b[i] is the \"decoded\" position where a[i] will be in the final configuration. The algorithm says: For those candidates for position 0, pick the leftmost one. Then in the rest, for those candidates for position 1, pick the leftmost one. And so on.\n<pre>\n  // -1 means no position is assigned for a[j].\n  for(i=0;i&lt;N;i++) b[j]=-1;\n  for(i=0;i&lt;N;i++) {\n    for(j=0;j&lt;N;j++) if(b[j]&lt;0 &amp;&amp; a[j]&lt;=i) {\n        b[j]=i; break;\n      }\n  }\n  int r=0;\n  for(i=0;i&lt;N;i++) for(j=i+1;j&lt;N;j++) \n    if(b[i]&gt;b[j]) r++;\n  // output r as the answer\n</pre>\nNote that, once the b[i]'s are fixed, you only need to count the disorders as in CR*; no real swapping needs to be simulated.\n</p>\n<br/>\n\n<h3>Proof of our solution</h3>\n<p>\nThe key observation is, for multiple candidates for position 0, you will never need to swap any two of them. Suppose you do swap, say <i>u</i> and <i>v</i>, both are at most 0. I can simply <i>ignore</i> it, and <i>pretend</i> that they are swapped (i.e., exchange the roles of <i>u</i> and <i>v</i> thereafter). The final configuration is still a good one. Thus we proved that, for all the candidates for position 0, the leftmost one, call it <i>u*</i>, will finally go to position 0.\n</p>\n<p>\nNow, imagine we have decoded the final positions for every one. Then (1) tells us that there is one solution where we first move <i>u*</i> all the way to the left, and never worry about it again. Therefore we now face the next question: Which of the rest of the numbers should go to position 1? <br/>\nThis is exactly the same problem, but with one number fewer.&nbsp;&nbsp;&nbsp;&loz;\n</p>\n\n","id":"0000000000433157","statement":"<h3>Problem</h3>\n<p>\nYou are given an <b>N</b> x <b>N</b> matrix with 0 and 1 values. You can swap any two <i>adjacent</i> rows of the matrix.\n</p>\n<p>\nYour goal is to have all the 1 values in the matrix below or on the main diagonal.  That is, for each X where 1 &le; X &le; N, there must be no 1 values in row X that are to the right of column X.\n</p>\n<p>\nReturn the minimum number of row swaps you need to achieve the goal.\n</p>\n<h3>Input</h3>\n<p>The first line of input gives the number of cases, <b>T</b>. <b>T</b> test cases follow.<br/>\nThe first line of each test case has one integer, <b>N</b>. Each of the next <b>N</b> lines contains <b>N</b> characters. Each character is either 0 or 1.\n</p>\n\n<h3>Output</h3>\n<p>For each test case, output\n<pre>Case #X: K</pre>\nwhere <b>X</b> is the test case number, starting from 1, and <b>K</b> is the minimum number of row swaps needed to have all the 1 values in the matrix below or on the main diagonal.<br/>\n<p>\nYou are guaranteed that there is a solution for each test case.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 60<br>\n</p>\n\n<h3>Small dataset</h3>\n<p>\n1 &le; <b>N</b> &le; 8<br>\n</p>\n<h3>Large dataset</h3>\n<p>\n1 &le; <b>N</b> &le; 40<br>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2\n10\n11\n3\n001\n100\n010\n4\n1110\n1100\n1100\n1000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 2\nCase #3: 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<!--\n<h3>Sample</h3>\n<div class=\"problem-io-wrapper\">\n<table>\n<tr>\n<td>\n<br/>\n<span class=\"problem-item-gray\">Input</span>\n<br/>&nbsp;\n</td>\n<td>\n<br/>\n<span class=\"problem-item-gray\">Output</span>\n<br/>&nbsp;\n</td>\n</tr>\n<tr>\n<td>\n<code>\n3<br/>\n2<br/>\n10<br/>\n11<br/>\n3<br/>\n001<br/>\n100<br/>\n010<br/>\n4<br/>\n1110<br/>\n1100<br/>\n1100<br/>\n1000<br/>\n</code>\n</td>\n<td>\n<code>\nCase #1: 0<br>\nCase #2: 2<br>\nCase #3: 4<br>\n<br/>\n</code>\n</td></tr></table>\n</div>\n!-->\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Crazy Rows","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432cc7","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2009"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
