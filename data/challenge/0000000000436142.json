{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1622910600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000436142","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\r\n  Round 3 started with <i>Build-A-Pair</i>, a punny but not puny problem\r\n  that required the right greedy approach in order to save lots of casework,\r\n  and the time that comes with it. As in most recent Round 3s,\r\n  there was a significant step up in difficulty going into the second problem.\r\n  <i>Square Free</i>, a problem a lot more appropriate this year than the past one,\r\n  required a combination of graph theory, a clever ad-hoc insight, and iterative\r\n  improvements to solve.\r\n</p><p>\r\n  Of course, the last two problems are where the key to getting to the finals was hidden.\r\n  <i>Fence Design</i> was the always scary geometry problem. It could be solved in many\r\n  different ways. Knowing your geometry theorems and algorithms could definitely put you\r\n  on the right path, but all of them required the right customization to solve the problem.\r\n  Finally, the path to solve <i>Binary Search Game</i> was hardly monotonic. The right model\r\n  and usual game theory could get you some points, but some advanced arithmetic manipulation\r\n  was needed for the full amount.\r\n</p><p>\r\n  There were a flurry of submissions for Build-A-Pair early in the contest, but it took several\r\n  minutes until someone managed to get the full score. Square Free was also solved shortly\r\n  afterwards, but it took 54 minutes for the first full solution to Binary Search Game to arrive,\r\n  and over 75 minutes for Fence Design to get solved.\r\n</p><p>\r\n  Because there were a lot of partially correct solutions to the last two problems, the\r\n  scoreboard jumped around a lot. <b>Gennady.Korotkevich</b> was the only one to get to a full\r\n  100 points for solid first place. <b>xll114514</b> and <b>Um_nik</b> rounded out the top 3\r\n  by getting 81 points (all but Test Set 2 of Fence Design), and 12 other coders also managed\r\n  to get to 81.\r\n  In the end, a total of 683 people submitted something, with 601 of them getting points.\r\n  The unofficial cutoff to get to the finals is 55 points and low enough penalty,\r\n  which corresponds to solving the first two problems\r\n  and Test Set 1 of the last two. Congratulations to all contestants for tackling such a hard\r\n  set!\r\n</p><p>\r\n  In about two months, our finalists will face off in the World Finals! The Finals will take\r\n  place virtually for a second year in a row. Finalist or not, everyone who advanced to Round 3\r\n  will be able to remember their accomplishment by wearing the coveted Code Jam 2021 shirt!\r\n  We will be sharing lots of video content during the finals, so please tune in\r\n  to share the excitement with us!\r\n</p>\r\n<hr>\r\n<p>\r\n  <b>Cast</b>\r\n</p>\r\n<p>\r\n  Build a Pair: Written by Pablo Heiber. Prepared by Artem Iglikov.\r\n</p><p>\r\n  Square Free: Written by Ian Tullis. Prepared by Darcy Best and Timothy Buzzelli.\r\n</p><p>\r\n  Fence Design: Written by Pablo Heiber. Prepared by Pablo Heiber and Timothy Buzzelli.\r\n</p><p>\r\n  Binary Search Game: Written by Yui Hosaka. Prepared by Petr Mitrichev.\r\n</p><p>\r\nSolutions and other problem preparation and review by Andy Huang, Artem Iglikov, Darcy Best,\r\nDeepika Naryani, Hannah Angara, Joe Simons, John Dethridge, Kevin Tran, Liang Bai, Max Ward,\r\nMd Mahbubul Hasan, Mekhrubon Turaev, Mohamed Yosri Ahmed, Nafis Sadique, Pablo Heiber,\r\nPetr Mitrichev, Sadia Atique, Swapnil Gupta, Timothy Buzzelli, Vaibhav Tulsyan, and Yui Hosaka.\r\n</p><p>\r\nAnalysis authors:\r\n</p><ul>\r\n  <li>Build a Pair: Artem Iglikov.</li>\r\n  <li>Square Free: Darcy Best.</li>\r\n  <li>Fence Design: Pablo Heiber.</li>\r\n  <li>Binary Search Game: Kevin Tran.</li>\r\n</ul>\r\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1622901600000,"tasks":[{"analysis":"<h3>\n  Test Set 1\n</h3>\n<p>\n  With the total number of digits up to 8 we can iterate through all possible pairs of numbers we\n  can construct from these digits and choose the optimal one. One way to do this is to iterate\n  through all possible permutations of the given digits and then split every permutation into two\n  in all possible ways as if it were a string. For every such a split we can construct the numbers\n  and calculate the answer. Be careful though, as numbers should not start with 0, every split where\n  0 is the first digit in a number is not valid.</p>\n<p>\n  If we denote the length of $$$D$$$ as $$$N$$$, then this takes $$$O(N! \\times N^2)$$$ time.\n</p>\n<h3>\n  Test Set 2\n</h3>\n<p>\n  First we can calculate the lengths of each resulting number. These should be\n  as close as possible, which means in case $$$N$$$ is even, each number must have exactly\n  $$$N / 2$$$ digits, and if $$$N$$$ is odd, then the larger number must have\n  $$$\\lceil N / 2\\rceil$$$ digits and the smaller number must have $$$\\lfloor N / 2 \\rfloor$$$\n  digits.\n</p>\n<p>\n  Further we will refer to the larger number as $$$A$$$ and to the smaller number as $$$B$$$.\n</p>\n<p>\n  Now, let's deal with the case when $$$N$$$ is odd. In such a case, we can iterate through all\n  non-zero digits and try them as the first digit of $$$A$$$ and $$$B$$$.\n  Now we would want to make $$$A$$$ as\n  small as possible (as it is already larger than $$$B$$$), and $$$B$$$ as large as possible.\n  Luckily, these two goals are complementary: we can use the $$$\\lfloor N / 2 \\rfloor$$$ smallest\n  remaining digits to construct the rest of $$$A$$$ (just take them in non-decreasing order),\n  and use the rest to construct $$$B$$$ (by taking them in non-increasing order).\n  Notice that choosing the leading digits greedily is also possible, but care must be taken to\n  not choose zero. This way of simply trying everything only takes $$$O(b^2 \\times N)$$$ time\n  anyway, where $$$b$$$ is the base ($$$10$$$), which is fast enough for the\n  limits of the problem.\n</p>\n<p>\n  The case when $$$N$$$ is even is trickier, as just choosing the first digits does not\n  give us a unique way to construct the rest of $$$A$$$ and $$$B$$$, because there is no\n  guarantee that $$$A$$$ will be larger. However, we can use similar technique as part of the\n  solution.\n</p>\n<p>\n  Note that if we have a prefix of length $$$i$$$ $$$A_1 A_2 \\dots A_i$$$ of $$$A$$$ and prefix\n  $$$B_1 B_2 \\dots B_i$$$ of $$$B$$$, we can guarantee that $$$A$$$ will be larger than $$$B$$$\n  no matter what digits we use further if and only if there is a $$$k \\le i$$$ such that\n  $$$A_j = B_j$$$ for all $$$1 \\le j \\lt k$$$ and $$$A_k > B_k$$$. This gives us the following\n  algorithm: choose all possible ways to construct $$$A_1 A_2 \\dots A_{k-1}$$$ and\n  $$$B_1 B_2 \\dots B_{k-1}$$$, then iterate through all possible $$$A_k$$$ and $$$B_k$$$, then\n  construct the rest of $$$A$$$ and $$$B$$$ so that the former is as small as possible and the\n  latter is as large as possible, using the same technique as above. For each of these\n  possibilities, update the answer with the difference between the constructed numbers.\n  Note, as before, that we need to make sure that the numbers we construct do not start with 0.\n</p>\n<p>\n  The time complexity of such an algorithm is $$$O(2^{N / 2})$$$ for selecting\n  $$$A_1 A_2 \\dots A_{k-1}$$$ and $$$B_1 B_2 \\dots B_{k-1}$$$ (these are pairs of equal\n  digits, so we cannot have more than $$$N / 2$$$ of them, and the order among them is irrelevant,\n  as long as we do not start with zero), $$$O(b^2)$$$ for selecting $$$A_k$$$ and $$$B_k$$$,\n  and $$$O(N)$$$ for constructing the numbers once we got the prefixes.\n  Overall this gives us $$$O(2^{N / 2} \\times b^2 \\times N$$$, which is really fast in practice\n  with a good implementation.\n</p>\n<p>\n  The algorithm can be optimized further, but it is not required for the given constraints. There\n  are ways to use the fact that number of digits is limited to reduce $$$2^{N/2}$$$ to something\n  with $$$b$$$ (the base) instead of $$$N$$$ in the exponent. There is also a way to greedily\n  solve the full problem in linear time. Moreover, if the input and output are given in\n  <a href=\"https://en.wikipedia.org/wiki/Run-length_encoding\" target=\"_blank\">run-length encoding</a>,\n  it can be solved in linear time in that encoding of the input, which is $$$O(\\log N)$$$.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2SfE9walEu5F_p-PJTVIS-Lr70NKFWvH6D4_NRnhTQGe9F4KczI0P2F0MZJyJ-YnpdSONQChJJ/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000813aa8","statement":"<h3>Problem</h3>\n<p>\nYou want to build a pair of positive integers. To do that, you are given a list of decimal\ndigits to use. You must use every digit in the list exactly once, but you get to choose which ones\nto use for the first integer and which ones to use for the second integer.\nYou also get to choose the order of the digits within each integer, except you cannot put a zero\nas the most significant (leftmost) digit in either integer. Note that you cannot choose just\na zero for one integer either, because it would not be positive.\n</p><p>\nFor example, you could be given the list $$$[1, 0, 2, 0, 4, 3]$$$. Two of the valid pairs you can\nbuild are $$$(200, 143)$$$ and $$$(3, 12400)$$$. The following pairs, on the other hand,\nare not valid:\n<ul>\n<li>$$$(0102, 34)$$$: has a leading zero.</li>\n<li>$$$(0, 12340)$$$: has a non-positive integer.</li>\n<li>$$$(10, 243)$$$ and $$$(12300, 47)$$$: the list of digits in each of these pairs is not\n  exactly equal to the given list of digits.</li>\n</ul>\n</p><p>\nGiven the list of digits to use, what is the minimum absolute difference between the two built\nintegers that can be achieved?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ lines follow.\nEach line describes a test case with a single string of digits $$$\\mathbf{D}$$$. Each character of $$$\\mathbf{D}$$$ is\na digit you must use.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from $$$1$$$) and $$$y$$$\nis the minimum possible absolute difference between the two integers built from $$$\\mathbf{D}$$$\naccording to the rules above.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 5 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\nEach character of $$$\\mathbf{D}$$$ is a decimal digit.<br/>\nAt least two characters of $$$\\mathbf{D}$$$ are not <code>0</code>.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\n$$$2 \\le$$$ the length of $$$\\mathbf{D} \\le 8$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Visible Verdict)</h4>\n<p>\n\n$$$2 \\le$$$ the length of $$$\\mathbf{D} \\le 36$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U37QCTs60RSp2Ipl1lZp-nwwK2J5eV1-rf5Fd-ljCxU1kJdx15y5b_zXDeA86OrdYAkBOQdiyaBlK904dxwt8VPc2o-6A3Xn4ZZy5s/build-a-pair_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n1234\n0011\n07080\n0899\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1fNHyagiOX_W3W7gQEKMGOtm4c7SZD5nVzMJx8cYGVqj-zArs_hRH6rcDFvGTyXV_sW3dFIZ327dV5CooN1nbcDzG2KsqW3FeOE1Y2/build-a-pair_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 7\nCase #2: 0\nCase #3: 620\nCase #4: 1\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  The optimal pair of integers to build are $$$31$$$ and $$$24$$$ for Sample Case #1,\n  $$$10$$$ and $$$10$$$ for Sample Case #2, $$$700$$$ and $$$80$$$ for Sample Case #3,\n  and $$$89$$$ and $$$90$$$ for Sample Case #4.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":3},{"type":1,"type__str":"VISIBLE","value":12}],"title":"Build-A-Pair","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem asks us to find a\n<a href=\"https://en.wikipedia.org/wiki/Point-set_triangulation\" target=\"_blank\">triangulation</a>\nof the given set of points that uses two particular edges. Many of the arguments that follow are\nreferenced in the linked article, so you can use it as an introduction.\n</p><p>\nThe first step to solve this problem is to notice some properties of the finished job.\nLet $$$P$$$ be the input set of poles and $$$F$$$ be a maximum set of fences with endpoints\nin $$$P$$$ that do not intersect other than at endpoints.\n</p><p>\n1. The fences that are the edges of the\n<a href=\"https://en.wikipedia.org/wiki/Convex_hull#Finite_point_sets\" target=\"_blank\">\n  convex hull</a> of $$$P$$$ are in $$$F$$$. <br/>\nProof: By definition, the edges of the convex hull do not intersect with any other possible\nfence. Therefore, they can be added to any set of fences that do not contain them without\ngenerating any invalid intersections, so any maximum set contains them all.\n</p><p>\n2. The size of $$$F$$$ is at most $$$3\\mathbf{N} - 3 - c$$$ where $$$c$$$ is the size of the convex hull of\n$$$P$$$. <br/>\nProof: Consider the graph where poles are nodes and fences in $$$F$$$ are the edges. The graph is\nplanar, so the generalized form of\n<a href=\"https://en.wikipedia.org/wiki/Planar_graph#Euler's_formula\" target=\"_blank\">\n  Euler's formula</a> applies. The formula states that $$$\\mathbf{N} + A = K + |F|$$$, where $$$A$$$\nis the number of internal areas (not counting the outside) and $$$K$$$ the\nnumber of connected components of the graph.\n</p><p>\nNotice that each edge on the convex hull is adjacent to exactly one internal area, and other\nedges are adjacent to at most two internal areas. Therefore, the sum of the number of sides of\nall internal areas is at least $$$3A$$$ and that is counting each convex hull edge once\nand each other edge at most twice, so $$$3A \\le c + 2(|F| - c) = 2|F| - c$$$, which means\n$$$A \\le (2|F| - c) / 3$$$. Replacing that in Euler's formula we obtain\n$$$\\mathbf{N} + (2|F| - c) / 3 \\ge K + |F|$$$. It follows that\n$$$3\\mathbf{N} + 2|F| - c \\ge 3K + 3|F|$$$, and then $$$3\\mathbf{N} - c - 3K \\ge |F|$$$. Since $$$K \\ge 1$$$,\nwe obtain $$$|F| \\le 3\\mathbf{N} - 3 - c$$$.\n</p><p>\n3. The size of $$$F$$$ is at least $$$3N - 3 - c$$$. <br/>\nProof: By induction. The base case is when all points in $$$P$$$ are on the convex hull.\nFor that case, consider a set of all edges in\nthe convex hull of $$$P$$$ plus any\n<a href=\"https://en.wikipedia.org/wiki/Polygon_triangulation\" target=\"_blank\">triangulation</a>\nof $$$P$$$. This set has exactly $$$2N - 3$$$ edges, which is equal to $$$3\\mathbf{N} - 3 - c$$$ when\n$$$\\mathbf{N} = c$$$, proving that there exists a set of at least that size without any invalid\nintersections.\n</p><p>\nIf there exists a point $$$p$$$ not on the convex hull of $$$P$$$, consider an optimal set of\nedges for $$$P - {p}$$$, which by inductive hypotheses has size $$$3(\\mathbf{N} - 1) - 3 - c$$$.\nBecause $$$|F| = 3(\\mathbf{N} - 1) -  c - 3$$$, and $$$3(\\mathbf{N} - 1) - c - 3K \\ge |F|$$$ from (2), $$$K$$$,\nthe number of connected components, must be exactly one. Similarly, every internal area\nmust be a triangle, with all edges in the convex hull being adjacent to one of them and\nall edges not in the convex hull being adjacent to two of them.\nBy definition, $$$p$$$ is not on the convex hull. By the fact that there are no collinear triples,\n$$$p$$$ is not in an existing edge. Thus, $$$p$$$ is strictly contained in one of these triangles.\nTherefore, we can add\nedges from $$$p$$$ to each of the $$$3$$$ vertices of the triangle that contains $$$p$$$ to get a\nsolution for our problem of size $$$3(\\mathbf{N} - 1) - 3 - c + 3 = 3\\mathbf{N} - 3 - c$$$.\n</p><p>\nFrom (2) and (3) above we know the exact number of fences we need to build (given the size\nof the convex hull of the set of poles). Moreover, we know that such an answer contains the convex\nhull of $$$P$$$ and every internal area delimited by fences in the output is a triangle.\nWe can use this to devise algorithms to generate optimal sets.\n</p>\n<h3>Test Set 1</h3>\n<p>\nThere are many possible solutions for Test Set 1. For example, the procedure in the proof of\npoint (3) above shows how to solve the problem with no pre-placed fences. There are ad-hoc ways\nto get around the problems with pre-placed fences, but they take a lot of work, and there is\nsomething simpler.\n</p><p>\nThe proofs above show that any maximal set of fences is also maximum (notice that we only\nused maximality in our reasoning). Therefore, we can simply add fences to a set as long as they\ndo not intersect with any previously added fence. This algorithm can accommodate pre-placed\nfences quite easily: simply start with them. There are $$$O(\\mathbf{N}^2)$$$ potential fences to\nconsider, and for each one we need to check whether it intersects any of the fences we already\nhave. Since the solution overall is of size $$$O(\\mathbf{N})$$$ this means checking $$$O(\\mathbf{N}^3)$$$\nintersections. Checking a pair of line segments to see if they intersect can be done in\nconstant time, which means this algorithm takes $$$O(\\mathbf{N}^3)$$$ time overall.\n</p>\n<h3>Test Set 2</h3>\n<p>\nAs in Test Set 1, there are lots of algorithms that solve this problem without considering\nthe pre-placed fences, but only some of them are easy enough to adapt to them.\nFor example, the procedure from the proof of (3) can be implemented efficiently: if the order\nin which we process points is randomized and we keep the current triangles in a tree-like structure\nto perform the search for a triangle efficiently, we can get an expected $$$O(\\mathbf{N} \\log \\mathbf{N})$$$\ntime complexity. This leads to an algorithm similar to the\n<a href=\"https://en.wikipedia.org/wiki/Delaunay_triangulation#Incremental\" target=\"_blank\">\nincremental algorithm to compute a Delauney triangulation</a>.\n</p><p>\nAnother option is to modify the\n<a href=\"https://en.wikipedia.org/wiki/Graham_scan\" target=\"_blank\">Graham Scan</a>\nalgorithm to efficiently find the convex hull to keep not only a convex hull of the visited points,\nbut also all the triangles for the points inside it.\n</p><p>\nUnfortunately, while the algorithms above can work with a lot of ad-hoc code to accommodate\nthe pre-placed fences, they become really cumbersome. Below we present some better alternatives.\n</p><p>\nLet $$$x$$$ be the intersection of both lines that are the infinite extension of a pre-placed fence.\nSince the fences don't intersect, $$$x$$$ can occur on one of them, but not on both.\nLet us call any pre-placed fence that does not contain $$$x$$$ $$$f_1$$$, and\nthe other fence $$$f_2$$$.\nBy their definitions, all of $$$f_2$$$ is on the same side of the line that extends\n$$$f_1$$$. We can recognize which fence can be $$$f_1$$$ by comparing whether the\n<a href=\"https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon\" target=\"_blank\">\norientation</a> of the two endpoints of a potential $$$f_1$$$ and each endpoint of $$$f_2$$$ is\nthe same (that is, checking whether both endpoints of the candidate $$$f_2$$$ lie on the same\nside of the line that goes through $$$f_1$$$).\n</p>\n<h4>Sweep-line</h4>\n<p>\nWe can solve the problem without pre-placed fences with a\n<a href=\"https://en.wikipedia.org/wiki/Sweep_line_algorithm\" target=\"_blank\">sweep-line</a> that\nconsiders the points in order of x-coordinate and maintains a convex hull of all the already seen\npoints, as in the\n<a href=\"https://en.wikipedia.org/wiki/Convex_hull_algorithms\" target=\"_blank\">monotone chain convex hull\nalgorithm</a>. When considering a new point $$$p$$$, we simply connect it to all points from the\nalready-seen set that do not cause intersections from $$$p$$$. Notice that those points are\na continuous range of the right side of the convex hull of the already-seen set.\nTherefore, we can find those points efficiently with\n<a href=\"https://en.wikipedia.org/wiki/Ternary_search\" target=\"_blank\">ternary searches</a>\non its right side.\n</p><p>\nTo accommodate pre-placed fences, we first rotate the plane to make $$$f_2$$$ vertical (possibly\nscaling everything to use only integers) and then run the sweep line algorithm only on points that\nare on the same side of the line that goes through $$$f_1$$$ as $$$f_2$$$ (including both endpoints\nof $$$f_2$$$ and neither endpoint of $$$f_1$$$). Since $$$f_2$$$ is now vertical, it will be\nincluded by the algorithm in the set when its second endpoint is processed. After that, we rotate\neverything again to make $$$f_1$$$ vertical, and start the algorithm from the set and\nconvex hull we already have (the endpoints of $$$f_1$$$ will be the first two points that are\nprocessed in this second pass). As before, $$$f_1$$$ will be added naturally by the algorithm.\n</p><p>\nNotice the accommodation of the pre-placed fences only requires linear time work, so the overall\nalgorithm, just as the version without pre-placed fences, requires $$$O(\\mathbf{N} \\log \\mathbf{N})$$$ time\noverall.\n</p>\n<h3>Divide and conquer</h3>\n<p>\nThis divide and conquer algorithm also has a correlate to computing the convex hull. The idea is\nsimple: divide the set of points with a line that goes through $$$2$$$ points,\ncompute the result of each side (both of which include those $$$2$$$ points), and then combine.\n</p><p>\nLet us call the two recursive results $$$P$$$ and $$$Q$$$. The convex hulls of both are convex\npolygons with a shared side. Then, we keep two current poles $$$p$$$ and $$$q$$$.\nInitially, both $$$p$$$ and $$$q$$$ are on the same endpoint of the shared side. Both move away\nfrom that shared side: $$$p$$$ through consecutive vertices of $$$P$$$ and $$$q$$$ through\nconsecutive vertices of $$$Q$$$. Initially we move them both together. After that, let\n$$$p_0$$$ and $$$q_0$$$ be the previous pole where $$$p$$$ and $$$q$$$ were, respectively,\nand $$$p_1$$$ and $$$q_1$$$ be the next value for each (that is, $$$p_0p$$$ and  $$$pp_1$$$ are\nadjacent sides of the convex hull of $$$P$$$ and $$$q_0q$$$ and $$$qq_1$$$ are adjacent sides\nof the convex hull of $$$Q$$$). Then,\n<ul>\n  <li>If $$$p_1q$$$ does not intersect $$$p_0p$$$, we set $$$p = p_1$$$.</li>\n  <li>If $$$q_1p$$$ does not intersect $$$q_0q$$$, we set $$$q = q_1$$$.</li>\n  <li>Otherwise, we stop.</li>\n</ul>\nEach time we move one, we add the fence connecting the current $$$p$$$ and $$$q$$$ to the result.\nWhen we are done, we do the same starting from the other endpoint of the shared side.\n</p><p>\nTo divide evenly, we can pick any point $$$x$$$, sort the other points by angle, and pick the\nmedian as $$$y$$$, dividing by the line that goes through $$$x$$$ and $$$y$$$.\nAlternatively, we can pick points randomly. On average, the split of\npoints would be about even (as we did in the proposed solution for\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051708/000000000016c77f#analysis\" target=\"_blank\">\nJuggle Struggle: Part 1</a>).\n</p><p>\nThe work done to combine takes linear time and the work done to split takes either\n$$$O(\\mathbf{N} \\log \\mathbf{N})$$$ time for the sorting version or linear time\nfor the randomized version. Using the\n<a href=\"https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\" target=\"_blank\">\nMaster theorem</a> we can then see that using the randomized version, the overall algorithm takes\n$$$O(\\mathbf{N} \\log \\mathbf{N})$$$ time, and using the sorting version, the overall running time is\n$$$O(\\mathbf{N} \\log^2 \\mathbf{N})$$$.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3VqfirIfU8uQ3RcVD22lKO0HmfK9GLaarNVqtaDjEY6QF6Udik0lOGl5_Gd2TAf4VIHkkm9NZ_/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000813bc7","statement":"<h3>Problem</h3>\n<p>\nYou are hired as a temporary employee of the Fence Construction Company and have\nbeen tasked with finishing the design of the fencing for a field.\nEach fence must run in a straight line between two poles.\nEach pole occupies a single point and the location of each pole is fixed.\nNo three poles are collinear.\nFences cannot intersect each other, except possibly at their endpoints (the poles).\n</p><p>\nThe design was started by someone else, but they quit the project after adding exactly\ntwo fences. You need to finish their design. To impress your bosses and clients,\nyou want the design to have as many fences as possible, regardless of\ntheir lengths.\n</p><p>\nGiven the positions of the poles and the already-built fences, please find a way to add\nas many fences as possible such that no pair of fences (new or existing)\nintersect each other, except possibly at their endpoints (the poles).\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case starts with a single line containing an integer $$$\\mathbf{N}$$$, indicating the number of poles.\nThen, $$$\\mathbf{N}$$$ lines follow. The $$$i$$$-th of these lines contains two integers\n$$$\\mathbf{X_i}$$$ and $$$\\mathbf{Y_i}$$$, representing the X and Y coordinates of the $$$i$$$-th pole's position.\nThe last two lines for each test case represent the two existing fences. These two\nlines contain two integers each: $$$\\mathbf{P_k}$$$ and $$$\\mathbf{Q_k}$$$, representing\nthat the $$$k$$$-th existing fence runs between the $$$\\mathbf{P_k}$$$-th and the $$$\\mathbf{Q_k}$$$-th pole\n(poles are numbered starting from $$$1$$$).\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is the maximum\nnumber of fences that can be added to the design (not including the existing ones).\nThen, output $$$y$$$ more lines. Each line must contain two distinct integers\n$$$i$$$ and $$$j$$$ (both between $$$1$$$ and $$$\\mathbf{N}$$$, inclusive),\nrepresenting a different fence that connects the $$$i$$$-th and $$$j$$$-th poles.\nNo pair of the $$$y+2$$$ fences (the existing fences as well as the ones\nyou have added) may overlap, except possibly at their endpoints.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 50$$$.<br/>\n$$$-10^9 \\le \\mathbf{X_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n$$$-10^9 \\le \\mathbf{Y_i} \\le 10^9$$$, for all $$$i$$$.<br/>\n$$$(\\mathbf{X_i}, \\mathbf{Y_i}) \\neq (\\mathbf{X_j}, \\mathbf{Y_j})$$$, for all $$$i \\neq j$$$.<br/>\n$$$1 \\le \\mathbf{P_k} \\lt \\mathbf{Q_k} \\le \\mathbf{N}$$$, for all $$$k$$$.<br/>\nThe existing fences do not intersect, except possibly at their endpoints.<br/>\nNo three poles are collinear.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n\n$$$4 \\le \\mathbf{N} \\le 100$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\nTime limit: 90 seconds.<br/>\n\n$$$4 \\le \\mathbf{N} \\le 10^5$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3GCDRDkqzoZNvbyfCJTL3HjwfAh8jhjF5CaoFUxFngBsCUwMBHsvWNCqtw2SM67LDnPmSGoNyPmj9DgyklCg6I_Y7iba4rQtLLMk8/fence_design_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n4\n0 0\n0 1\n1 1\n1 0\n1 2\n3 4\n5\n0 0\n0 1\n1 1\n1 0\n2 3\n1 2\n3 5\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3hBDMmbbZ4AE_U68JIiEYQiSTFqR1TD9hZM1DKeYYsOqhlZjixwX7J0lp1p0j9GQmlcjmm3cTRdyXCsix5O-malKtBrE1NriARoiK5/fence_design_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 3\n1 4\n2 3\n4 2\nCase #2: 6\n5 4\n2 4\n5 2\n1 4\n4 3\n3 2\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\nThe following pictures show the poles and fences in the given samples. The fences with the wider\nblue line on them are the existing ones, and the rest show the way of adding a maximum number of\nfences shown in the sample output.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U01Rpuiw9ajhhSfJxxVfqLlekHe-mbzAvrv9pz5ZhkYKBcR8SPWGcuyJglXladqhpVnYPKBexM_ufk/sample1.png\" style=\"max-width:245px;\" alt=\"Illustration of Sample Case #1\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U12LDVX85UWVHbsLlDcwY4S2PMZg4TODHc038JpMyzJLYNt6EhX3C8y8NJJSqcSh3r09RG0WU5cRn0/sample2.png\" style=\"max-width:400px;\" alt=\"Illustration of Sample Case #2\">\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Fence Design","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  In general, we will build all grids with the correct row and column sums,\n  then check each one to see if there are squares in them.\n  In Test Set 1, the size of the input is at most $$$6 \\times 6$$$. This means that\n  there are $$$2^{36}$$$ different possible grids, which is too many to generate, so we\n  must make use of the row sum constraints. We do this by building the grid one cell at a time. As\n  you fill in each cell, ensure that corresponding row and column sums are still possible.\n  For example, if the row sum should be 3, but there are already 3 <code>/</code>s in this\n  row, you cannot put another <code>/</code>. Similarly, if the desired row sum is 3,\n  but there are already $$$\\mathbf{R}-3$$$ <code>\\</code>s in the row, you cannot put another\n  <code>\\</code>. Once we are done filling out the grid,\n  we check if there are any squares in the grid that we have made. If there are no squares,\n  we are done! Otherwise, we move on to the next possible grid. If we finish searching\n  all possible grids and we have not found any, then it is impossible.\n</p><p>\n  Are we sure this is fast enough? Each row either needs 0, 1, 2, 3, 4, 5, or 6\n  <code>/</code>s in it. There are $$$\\binom{6}{0} = 1$$$ choices with 0 <code>/</code>s,\n  $$$\\binom{6}{1} = 6$$$ choices with 1 <code>/</code>s,\n  $$$\\binom{6}{2} = 15$$$ choices with 2 <code>/</code>s,\n  $$$\\binom{6}{3} = 20$$$ choices with 3 <code>/</code>s,\n  $$$\\binom{6}{4} = 15$$$ choices with 4 <code>/</code>s,\n  $$$\\binom{6}{5} = 6$$$ choices with 5 <code>/</code>s, and\n  $$$\\binom{6}{6} = 1$$$ choices with 6 <code>/</code>s.\n  Thus, each row has at most 20 different valid choices. So this algorithm will explore\n  at most $$$20^6$$$ different grid. In practice, we will get nowhere near this bound.\n  In particular, there is at most one valid row for the bottom row (since we must\n  satisfy the column sum constraints). This alone reduces the search space to\n  at most $$$20^5$$$, but this, too, is an overestimate since there will be\n  a lot of pruning throughout the search.\n</p><p>\n  Checking for squares can be done in several ways. The easiest is to iterate over\n  all possible places that the top-most row of the square can be (and which consecutive\n  columns the <code>/\\</code> are in). Then, for each possible size of square (1, 2, 3),\n  just check the corresponding grid entries on the four sides of the square.\n</p>\n\n<h3>Test Set 2</h3>\n<p>\n  The bounds for Test Set 2 are much too large to exhaustively search all grids,\n  so we will need an insight. We call a grid that satisfies the row and column constraints\n  a <i>configuration</i>. First, let's discuss how to find <i>some</i> configuration\n  (it may or may not be square free). To do this, we will set this up as a graph and run\n  <a href=\"https://en.wikipedia.org/wiki/Maximum_flow_problem\" target=\"_blank\">maximum flow</a>\n  on it. There are $$$\\mathbf{R}$$$ vertices that represent the rows and $$$\\mathbf{C}$$$ vertices that represent\n  the columns. We will put an edge with capacity 1 between every pair of (row, column)\n  vertices. We will then connect the $$$i$$$&NoBreak;-&NoBreak;th row vertex to a super-row\n  vertex with capacity $$$\\mathbf{S_i}$$$ and connect the $$$i$$$&NoBreak;-&NoBreak;th column vertex to a\n  super-column vertex with capacity $$$\\mathbf{D_i}$$$.\n</p><p>\n  We now run flow through the network using the super-row vertex as the source and\n  the super-column vertex as the sink. If the network is saturated (that is, every edge\n  leaving the source has flow = capacity), then we have a solution. If there is flow\n  in the edge between row $$$r$$$ and column $$$c$$$, then the corresponding entry in the\n  grid is a <code>/</code>, otherwise it is a <code>\\</code>. If the flow is not saturated,\n  then it is impossible to make a grid with the appropriate row and column sums. We leave\n  a formal proof of the bijection between configurations and valid flows on the described\n  network as an exercise.\n</p><p>\n  At this point, we have <i>some</i> configuration, but it may have squares in it.\n  We will discuss three different ways to produce a grid that is square free.\n</p>\n\n<h4>Lexicographically Smallest Configuration</h4>\n<p>\n  In this solution, we notice that the\n  <a href=\"https://en.wikipedia.org/wiki/Lexicographic_order\" target=\"_blank\">lexicographically smallest</a>\n  configuration (treating <code>\\</code> as smaller than <code>/</code> reading in\n  <a href=\"https://en.wikipedia.org/wiki/Row-_and_column-major_order\" target=\"_blank\">row-major order</a>)\n  is square-free! At first this is not obvious. However, think about two rows\n  ($$$r_i \\lt r_j$$$) and two columns ($$$c_k \\lt c_{\\ell}$$$). If\n  $$$(r_i, c_k) = /, (r_i, c_{\\ell}) = \\backslash, (r_j, c_k) = \\backslash, (r_j, c_{\\ell}) = /$$$,\n  then this grid is not the lexicographically smallest configuration. Why? Because we can\n  swap all four of those without breaking the row or column constraints, while giving us a\n  smaller configuration\n  ($$$(r_i, c_k) = \\backslash, (r_i, c_{\\ell}) = /,\n      (r_j, c_k) = /, (r_j, c_{\\ell}) = \\backslash$$$).\n  This means that a lexicographically smallest configuration has no squares in the grid, because\n  the top-most row of a square must contain <code>/\\</code> in the same columns in which\n  the bottom-most row of the square has <code>\\/</code>.\n</p><p>\n  How do we find the lexicographically smallest configuration? There are two ways:\n  (1) give the edge between row $$$r$$$ and column $$$c$$$ a cost of\n  $$$2^{r-1+(c-1)\\mathbf{R}}$$$ and run\n  <a href=\"https://en.wikipedia.org/wiki/Minimum-cost_flow_problem\" target=\"_blank\">minimum-cost maximum-flow</a>.\n  This will guaranteed find the lexicographically smallest, but the edge-costs will be\n  huge (up to $$$2^{\\mathbf{RC}-1}$$$).\n  (2) We will run maximum flow iteratively. Say we have run maximum flow. Go through the\n  edges in row-major order of their corresponding cell. If there is no flow going through an\n  edge, then it is a\n  <code>\\</code>. Great! This is the smallest this can be, so remove this edge from the graph\n  to lock that in. If there is flow going through the edge, then we \"unpush\" the flow from that\n  edge (decrease the flow from the sink to the column vertex to the row vertex to the source by 1)\n  and temporarily change that edge's capacity to 0. We then run flow again. If the flow\n  is still saturated, then we know there exists a configuration where this entry in the\n  grid is a <code>\\</code>, so we can permanently remove this edge from the graph.\n  If it is not saturated, then we must put that edge back into the graph, and this entry\n  is forced to be a <code>/</code>.\n</p><p>\n  Complexity-wise, the first run of maximum flow takes $$$O( (\\mathbf{RC})^2 )$$$ time. Then, for each\n  flow we run, we must only push one unit of flow through, which only takes a single\n  augmenting path, so $$$O(\\mathbf{RC})$$$ time per edge. Thus, in total, this takes $$$O( (\\mathbf{RC})^2 )$$$\n  time. Note that you can also fully re-run maximum flow for each edge instead of only pushing one\n  unit of flow with a sufficiently optimized flow implementation.\n</p>\n\n<h4>Minimum-Cost Maximum-Flow</h4>\n<p>\n  In the Lexicographically Smallest Configuration solution, we described how you can use\n  minimum-cost maximum flow to solve this problem with exponential edge costs. Here, we will\n  solve the problem using only polynomial sized edge costs. This solution makes use\n  of the same idea as the previous one: we want to avoid\n  $$$(r_i, c_k) = /, (r_i, c_{\\ell}) = \\backslash, (r_j, c_k) = \\backslash, (r_j, c_{\\ell}) = /$$$,\n  but other than that, we do not need a lexicographically smallest configuration.\n  If we set the edge cost between row $$$r$$$ and column $$$c$$$ to be $$$r \\times c$$$,\n  then we will not get this configuration, since swapping all of these symbols does\n  not affect the row/column sums and strictly decreases the total cost.\n  The total cost is reduced by $$$i \\times k + j \\times \\ell$$$ and increased by\n  $$$i \\times \\ell + j \\times k$$$, which is a net decrease of $$$(i - j)(k - \\ell) > 0$$$\n  since $$$i \\lt j$$$ and $$$k \\lt \\ell$$$.\n</p>\n\n<h4>Flip-Flop!</h4>\n<p>\n  Another solution is to simply find some configuration, then check it for squares. If there\n  are no squares, then we are done! If there is a square, consider the top-most and bottom-most\n  row in the square. We will swap the top <code>/\\</code> with the bottom <code>\\/</code>.\n  This does not affect the row/column sums. In doing this, we have broken the current square, but\n  may have created another square. We continue breaking squares until we do not find\n  any. This process must eventually finish since at each swap, we are always making our grid\n  lexicographically smaller. You can never do more than $$$O( (\\mathbf{RC})^2 )$$$ swaps of this form.\n</p>\n\n<h3>Common Mistake</h3>\n<p>\n  Be careful! Just because the sum of the $$$\\mathbf{S_i}$$$&NoBreak;s is equal to the sum of the\n  $$$\\mathbf{D_i}$$$&NoBreak;s does not mean that a configuration exists! One example is the following input,\n  where those sums coincide, yet there are no grids that meet all the per-row and per-column\n  requirements.\n\n<pre>\n4 6\n2 0 6 6\n4 2 2 2 2 2\n</pre>\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2lEMFW7B9LYNZuw2Z0tmg2GFsHNmnKtsr-IaDOXxsMbij5VXqUl2XjJ6GXV1XxVzWfBs2qbXlc/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000813e1a","statement":"<h3>Problem</h3>\n<p>\nWe have a matrix of square cells with $$$\\mathbf{R}$$$ rows and $$$\\mathbf{C}$$$ columns. We need to draw a diagonal in each\ncell. Exactly one of two possible diagonals must be drawn in each cell: the <i>forward slash</i>\ndiagonal, which connects the bottom-left and the top-right corners of the cell,\nor the <i>backslash</i> diagonal, which connects the top-left and the bottom-right\ncorners of the cell.\n</p><p>\nFor each row and column, we want to draw a specific number of\ndiagonals of each type. Also, after all the diagonals are drawn, the matrix should be\n<i>square free</i>. That is, there should be no squares formed using the diagonals we added.\n</p><p>\nFor example, suppose we have a matrix with $$$4$$$ rows and $$$4$$$ columns.\nThe number next to each row is the exact number of forward slash diagonals there must be in\nthat row. The number below each column is the exact number of forward slash diagonals\nthere must be in that column.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U25Yj1E58siITNJY-exsKxaS32lSxFEoT3ykBLwhFIiGcfhsRwrAtyBmFYHLiFpFo85C4sZV2ODOfJG9tCJmA/sample1empty.png\" style=\"max-width:300px;\" alt=\"An empty 4 by 4 matrix with row and column totals.\">\n</p><p>\nThere are multiple ways to fill the matrix respecting those per-row and per-column amounts.\nBelow we depict three possibilities:\n</p>\n<div align=center>\n  <div style=\"display: inline-block; flex-direction: column; padding: 40px 60px 0 60px;\">\n    <div>\n      <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0IoPWp4TKVsncWxDCyOMvQGdJ2khqokpFdZ45TtMqHfGFsGlF8t22Pc9cNcg7DawZkUj2JTUazJpHO/sample1a.png\" style=\"max-width: 300px;\" alt=\"First way to fill the above matrix\">\n    </div>\n  </div>\n  <div style=\"display: inline-block; flex-direction: column; padding: 40px 60px 0 60px;\">\n    <div>\n      <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1sDL7NJ6R1_bIg_ZN__5oXDPgVIrT6_J2VKBClvNJBt9wKRHTSqq7WcvMhD6k_MDK_GBcEO9nlaBVy/sample1b.png\" style=\"max-width: 300px;\" alt=\"Second way to fill the above matrix\">\n    </div>\n  </div>\n  <div style=\"display: inline-block; flex-direction: column; padding: 40px 60px 0 60px;\">\n    <div>\n      <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2LmkeKJPDG0H2A6Q13wB91pulYk4UMWYOJV4PwDNCcfqKGHqQWcIy5WMamoj2ip5n4b7R7efjOrkTW/sample1c.png\" style=\"max-width: 300px;\" alt=\"Third way to fill the above matrix\">\n    </div>\n  </div>\n</div>\n<p>\nThe first two matrices are not square free, while the third matrix is.\nIn the first matrix, there is a square of side-length $$$2$$$ diagonals with its vertices in the\nmiddle of each side of the matrix. In the second matrix, there is a square of side-length $$$1$$$\ndiagonal drawn in the bottom-right corner. In the third matrix, there is no square.\nThe third matrix would then be a valid drawing according to all the rules.\n</p><p>\nGiven the size of the matrix and the exact number of forward slash diagonals that must be drawn\nin each row and column, produce any square free matrix that satisfies the row and column\nconstraints, or say that one does not exist.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\nEach test case consists of exactly three lines. The first line of a test case contains\n$$$\\mathbf{R}$$$ and $$$\\mathbf{C}$$$, the number of rows and columns of the matrix. The second line\nof a test case contains $$$\\mathbf{R}$$$ integers $$$\\mathbf{S_1}, \\mathbf{S_2}, \\dots, \\mathbf{S_R}$$$. $$$\\mathbf{S_i}$$$\nis the exact number of forward slash diagonals that\nmust be drawn in the $$$i$$$&NoBreak;-&NoBreak;th row from the top. The third line\nof a test case contains $$$\\mathbf{C}$$$ integers $$$\\mathbf{D_1}, \\mathbf{D_2}, \\dots, \\mathbf{D_C}$$$. $$$\\mathbf{D_i}$$$\nis the exact number of forward slash diagonals that\nmust be drawn in the $$$i$$$&NoBreak;-&NoBreak;th column from the left.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\nwhere $$$x$$$ is the test case number (starting from 1) and $$$y$$$ is\n<code>IMPOSSIBLE</code> if there is no filled matrix that follows all rules\nand <code>POSSIBLE</code> otherwise. If you output <code>POSSIBLE</code>,\noutput $$$\\mathbf{R}$$$ more lines with $$$\\mathbf{C}$$$ characters each.\nThe $$$j$$$&NoBreak;-&NoBreak;th character of the $$$i$$$&NoBreak;-&NoBreak;th of these lines\nmust be <code>/</code> if the diagonal drawn in the $$$i$$$&NoBreak;-&NoBreak;th row from the top\nand $$$j$$$&NoBreak;-&NoBreak;th column from the left in your proposed matrix is a forward slash\ndiagonal, and <code>\\</code> otherwise. Your proposed matrix must be valid according to\nall rules.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 15 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n$$$1 \\le \\mathbf{T} \\le 100$$$.<br/>\n$$$0 \\le \\mathbf{S_i} \\le \\mathbf{C}$$$, for all $$$i$$$.<br/>\n$$$0 \\le \\mathbf{D_i} \\le \\mathbf{R}$$$, for all $$$i$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\n$$$2 \\le \\mathbf{R} \\le 6$$$.<br/>\n$$$2 \\le \\mathbf{C} \\le 6$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n\n$$$2 \\le \\mathbf{R} \\le 20$$$.<br/>\n$$$2 \\le \\mathbf{C} \\le 20$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U37mlscotVxyJYNkMuECgXa00mn0W7CXqpl90cNM-kxNyFqsY5x2i9wUS1XGz1dJTfJTj0Zq_0y1MWlhSAHg6ADLeoqsVX6xf5lvQ/square_free_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n4 4\n3 2 3 3\n3 3 2 3\n2 3\n1 1\n1 1 1\n2 3\n1 2\n1 1 1\n3 3\n2 0 2\n2 0 2\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2nD-S0nzOnY3YrHhmO5ot_bXGOVQLN5Xi_AhTXLNghxW-fV3hjw6tCZ1WLTMDBG3AokrHaJrC7VttN2BlylQvDgtLtGmsBHeOmUC0/square_free_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: POSSIBLE\n//\\/\n\\/\\/\n///\\\n/\\//\nCase #2: IMPOSSIBLE\nCase #3: POSSIBLE\n\\\\/\n//\\\nCase #4: POSSIBLE\n/\\/\n\\\\\\\n/\\/\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Sample Case #1 is the one explained above.\n</p>\n<p>\n  In Sample Case #2, there must be a total of $$$2$$$ forward slash diagonals according to the\n  sum of the row totals, but a total of $$$3$$$ according to the sum of the column totals. It\n  is therefore impossible to follow all rules.\n</p>\n<p>\n  In Sample Case #3 the only matrices that follow the row and column totals are the following:\n</p>\n<div align=center>\n  <div style=\"display: inline-block; flex-direction: column; padding: 40px 60px 0 60px;\">\n    <div>\n      <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0pRE76vjADmJIbADVC8fQ_hr-uGlTsd4ZTmFDMytlqKgmlYJncUwVL47P4L3URr99nXIe0uEnGlM7S/sample2a.png\" style=\"max-width: 300px;\" alt=\"First way to fill the Sample Case 2 matrix\">\n    </div>\n  </div>\n  <div style=\"display: inline-block; flex-direction: column; padding: 40px 60px 0 60px;\">\n    <div>\n      <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0sT97eG0mFTWwiQ1f1XtdTvCG_upeET4R2kfWe5KjDZtPTv_nkYNizQwDqIveGnjEta9fOJS2o37v7/sample2b.png\" style=\"max-width: 300px;\" alt=\"Second way to fill the Sample Case 2 matrix\">\n    </div>\n  </div>\n  <div style=\"display: inline-block; flex-direction: column; padding: 40px 60px 0 60px;\">\n    <div>\n      <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0Wb7-mqQRmuAcDkuX3GWfSt5bOddrr4WrQ1Esev7NPRY7iXhVXL-03A7gkJsm__7hHXYvdT0TF8VM4/sample2c.png\" style=\"max-width: 300px;\" alt=\"Third way to fill the Sample Case 2 matrix\">\n    </div>\n  </div>\n</div>\n<p>\nSince the first two contain a square, the third one is the only valid output for this case.\n</p><p>\n  In Sample Case #4 there is only one way to fill the matrix that follows the row and column\n  totals, shown in the picture below. Note that it produces a single rectangle,\n  shown in blue in the picture. But, since that rectangle is not a square, the matrix is\n  square free.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3uF1yb-zQErQlE6i-jBdvDVKAtAVc_fALtRGob_05zy9iTvDwTxXjMITiQoYujQDziP2mNU4DKcgs/sample4.png\" style=\"max-width:300px;\" alt=\"Only way to fill the Sample Case 4 matrix.\">\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Square Free","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>\n  Test Set 1\n</h3>\n<p>\n  Let $$$f(k)$$$ be the number of ways in which the game ends with a score $$$\\geq k$$$. Then,\n  the number of ways in which the game ends with a score of exactly $$$k$$$ is $$$f(k) - f(k+1)$$$.\n  Therefore, the answer is\n$$$$\\begin{align}\n  \\sum_{k=1}^{\\mathbf{M}} k(f(k) - f(k+1)) &= \\sum_{k=1}^{\\mathbf{M}} k f(k) - \\sum_{k=1}^{\\mathbf{M}} k f(k+1) \\\\\n  &= \\sum_{k=1}^{\\mathbf{M}} kf(k) - \\sum_{k=2}^{\\mathbf{M}+1} (k-1)f(k) \\\\\n  &= f(1) - \\mathbf{M} f(\\mathbf{M}+1) + \\sum_{k=2}^{\\mathbf{M}} (k - (k-1)) f(k) \\\\\n  &= \\sum_{k=1}^{\\mathbf{M}} f(k).\n\\end{align}$$$$\n  Notice in the last step that $$$f(\\mathbf{M}+1) = 0$$$ by definition.\n</p><p>\n  Let us now focus on calculating $$$f(k)$$$. For each card, we only care about whether its value\n  is $$$\\geq k$$$ or not.\n  Let $$$S$$$ be a fixed subset of cards which have value $$$\\geq k$$$ (we will go through\n  all $$$2^\\mathbf{N}$$$ such subsets).\n  We can assign a score of $$$0$$$ (for cards outside of $$$S$$$)\n  or $$$1$$$ (for cards in $$$S$$$) to each consecutive subsequence of cells on the board that can\n  be presented to players, in increasing order of length. Notice that only subsequences of cells\n  whose length is a power of $$$2$$$ and who are \"aligned\" can be presented to a player. That is,\n  sequences containing cells of the form $$$i2^j+1,i2^j+2,\\dots,i2^j+2^j$$$ for each $$$j$$$\n  between $$$0$$$ and $$$\\mathbf{L}$$$, inclusive, and each $$$i$$$ between $$$0$$$ and $$$2^{\\mathbf{L}-j}-1$$$,\n  inclusive. There are $$$2^\\mathbf{L} + 2^{\\mathbf{L}-1} + \\cdots + 2 + 1 = 2^{\\mathbf{L}+1} - 1$$$ valid combinations\n  to go through. If we know the score for sequences of shorter lengths, we can decide\n  the score for a sequence by checking whose turn it is (it is Alice's turn if and only if\n  $$$j$$$ and $$$\\mathbf{L}$$$ have the same parity) and picking either the maximum or the\n  minimum score of its two halves. If the score assigned by this to the full sequence is $$$0$$$,\n  then there is no way to finish with a score $$$\\geq k$$$ with combination $$$S$$$. Otherwise,\n  we need to compute the number of ways in which this can happen. This is simply the number\n  of original card values that yield $$$S$$$, which is $$$(\\mathbf{M}-k+1)^t (k-1)^{\\mathbf{N}-t}$$$ where\n  $$$t$$$ is the number of cards that are $$$\\geq k$$$ in $$$S$$$.\n</p><p>\n  Overall, this solution takes $$$O(\\mathbf{M} \\times 2^\\mathbf{N} \\times 2^\\mathbf{L})$$$ time, which is fast enough\n  to pass Test Set 1.\n</p>\n<h3>\n  Test Set 2\n</h3>\n<p>\n  Note that the expression $$$(\\mathbf{M}-k+1)^t (k-1)^{\\mathbf{N}-t}$$$ from the previous solution, if we\n  consider $$$k$$$ the only variable, expands into a polynomial of degree at most $$$\\mathbf{N}$$$.\n  Consequently $$$f(k)$$$ is also a polynomial in $$$k$$$ of degree at most $$$\\mathbf{N}$$$ (as it is the\n  sum of such polynomials).\n</p><p>\n  If $$$f(k)$$$ is a polynomial of degree at most $$$\\mathbf{N}$$$, then $$$g(x) = \\sum_{k=1}^{x} f(k)$$$\n  is a polynomial in $$$x$$$ of degree at most $$$\\mathbf{N}+1$$$.\n  This is a consequence of <a href=\"https://en.wikipedia.org/wiki/Faulhaber%27s_formula\" target=\"_blank\">\n  Faulhaber's formula</a>.\n</p>\n<p>\n  Thus, the polynomial $$$g(x)$$$ can be fully determined by evaluating it at $$$\\mathbf{N} + 2$$$\n  different points, say $$$g(0), g(1), \\ldots, g(\\mathbf{N}+1)$$$.\n  We can evaluate those values in the same way as Test Set 1 and then use\n  <a href=\"https://en.wikipedia.org/wiki/Lagrange_polynomial\" target=\"_blank\">interpolation</a>\n  to find $$$g(\\mathbf{M})$$$.\n</p><p>\n  This yields an algorithm that takes time $$$O(\\mathbf{N} \\times 2^\\mathbf{N} \\times 2^\\mathbf{L})$$$\n  to evaluate $$$\\mathbf{N} + 2$$$ points of $$$f(k)$$$, plus the time complexity of evaluating\n  $$$g(\\mathbf{M})$$$ using interpolation.\n  The latter can be done by evaluating the Lagrange polynomial in a straightforward way in\n  $$$O(\\mathbf{N}^2)$$$, and there are faster methods too, but this does not impact the overall runtime.\n</p><p>\n  To speed up the calculation of $$$g(0), g(1), \\ldots, g(\\mathbf{N}+1)$$$, we find a way to reduce the\n  $$$2^\\mathbf{N}$$$ factor.\n  Note that if a card's index appears only once (or not at all) in the board,\n  we can do without fixing its value in advance (as being $$$\\geq k$$$ or not).\n  We can fix the values that are repeated in the board and then run the greedy algorithm\n  but instead of scores $$$0$$$ and $$$1$$$ we compute, for each subsequence, the number\n  of ways that it can be made $$$1$$$ by assigning the values of cards whose indices are\n  not repeated in the board. The decisions can still be made greedily, but instead of\n  doing all the combinatorics at the end, we do them at each decision point.\n</p><p>\n  With this optimization, we only need to run the greedy algorithm $$$2^X$$$ times per each value\n  of $$$g$$$ that we need, where $$$X$$$ is the number of cards whose indices appear more than once\n  in the board. There can be at most $$$2^{\\mathbf{L}-1}$$$ of those cards, so we have\n  reduced the time complexity of the first step to $$$O(\\mathbf{N} \\times 2^{2^{\\mathbf{L}-1}} \\times 2^\\mathbf{L})$$$.\n  This is finally enough to pass Test Set 2.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0Ml52aBcDsITgXk2bnyfIj-I3qAahmgCNqwfx--Uc3MAq5tMcIlap-3PwkC5aeBdO4rtvk5lO0/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n","id":"0000000000813e1b","statement":"<h3>Problem</h3>\n<p>\n  Alice and Bob are going to play the Binary Search game. The game is played on a board\n  consisting of a single row of $$$2^\\mathbf{L}$$$ cells.\n  Each cell contains an integer between $$$1$$$ and $$$\\mathbf{N}$$$, inclusive. There are also $$$\\mathbf{N}$$$ cards\n  numbered $$$1$$$ through $$$\\mathbf{N}$$$. Before the game starts, the referee writes an integer between\n  $$$1$$$ and $$$\\mathbf{M}$$$, inclusive, on each card, in one of the $$$\\mathbf{M}^\\mathbf{N}$$$ ways in which that\n  can be done. Alice and Bob know the integers in the cells and\n  on each card before they start playing.\n</p><p>\n  The game proceeds alternating turns, with Alice having the first turn. There are $$$\\mathbf{L}$$$ turns in\n  total, which means Alice plays $$$\\lceil \\mathbf{L} / 2 \\rceil$$$ turns and Bob plays\n  $$$\\lfloor \\mathbf{L} / 2 \\rfloor$$$ turns. During a turn, a player can eliminate either the leftmost\n  half or the rightmost half of the remaining cells. For example, let us consider a board\n  that contains the numbers $$$[2, 4, 1, 1, 4, 5, 2, 5]$$$. In her first turn,\n  Alice must choose to eliminate one half, leaving either\n  $$$[2, 4, 1, 1]$$$ or $$$[4, 5, 2, 5]$$$. If she eliminates the leftmost half and leaves\n  $$$[4, 5, 2, 5]$$$, then Bob must choose between leaving $$$[4, 5]$$$ and $$$[2, 5]$$$.\n  If he were to leave $$$[2, 5]$$$, the game's final turn would have Alice choosing between\n  $$$[2]$$$ and $$$[5]$$$.\n</p><p>\n  When the game is over, they look at the number $$$X$$$ in the only remaining cell.\n  The <i>score</i> of the game is the integer written on card number $$$X$$$.\n  In the example above, if Alice were to eliminate $$$[5]$$$ and leave $$$[2]$$$ in her final turn,\n  the score of the game would be the number the referee wrote on card number $$$2$$$.\n</p><p align=center>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0mu2saUDLSJvj6-NmedPwVBnFYpb_nNNjE4rkGV8WmzZ3Q8dN4qWD21QsW22RuY1RYz73lMC8oGb4/example.png\" style=\"max-height:350px;\" alt=\"Illustration of example given in the problem statement\"/>\n</p><p>\n  Alice plays optimally to maximize the score of the game, while Bob plays optimally to minimize it.\n  They are given a fixed board with integers $$$\\mathbf{A_1}, \\mathbf{A_2}, \\dots \\mathbf{A_{2^L}}$$$ in its cells.\n  For maximal fairness, they will play $$$\\mathbf{M}^\\mathbf{N}$$$ games, and the referee will choose a\n  different way to write integers on the cards for each one. That means that for any given way\n  of writing integers on the cards, Alice and Bob will play exactly one game with it.\n  Given the game parameters and the fixed board contents,\n  please determine the sum of the scores of all those games.\n  Since the output can be a really big number, we only ask you to output the remainder of dividing\n  the result by the prime $$$10^9+7$$$ ($$$1000000007$$$).\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, $$$\\mathbf{T}$$$. $$$\\mathbf{T}$$$ test cases follow.\n  Each test case consists of exactly two lines.\n  The first line of each test case contains the three integers $$$\\mathbf{N}$$$, $$$\\mathbf{M}$$$, and $$$\\mathbf{L}$$$.\n  The second line contains $$$2^{\\mathbf{L}}$$$ integers $$$\\mathbf{A_1}, \\mathbf{A_2}, \\dots, \\mathbf{A_{2^L}}$$$,\n  where $$$\\mathbf{A_i}$$$ is the integer contained in the $$$i$$$-th cell from the left of\n  the board.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #$$$x$$$: $$$y$$$</code>,\n  where $$$x$$$ is the test case number (starting from $$$1$$$) and $$$y$$$ is\n  the sum of scores of all $$$\\mathbf{M}^{\\mathbf{N}}$$$ games, modulo the prime $$$10^9+7$$$ ($$$1000000007$$$).\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds.<br/>\nMemory limit: 1 GB.<br/>\n\n  $$$1 \\le \\mathbf{T} \\le 12$$$.<br/>\n  $$$1 \\le \\mathbf{L} \\le 5$$$.<br/>\n  $$$1 \\le \\mathbf{A_i} \\le \\mathbf{N}$$$, for all $$$i$$$.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n\n  $$$1 \\le \\mathbf{N} \\le 8$$$.<br/>\n  $$$1 \\le \\mathbf{M} \\le 100$$$.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n\n  $$$1 \\le \\mathbf{N} \\le 32$$$.<br/>\n  $$$1 \\le \\mathbf{M} \\le 10^9$$$.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2rt4edRBkGWaZN6nlCIjq480JLKCk5YkYYwQceVAy5LJIWJLUKyAy4X30ILrPmKDFKIogZjX2yD9x4Uj5f3spBRbAVDYDsp_FRlixLZTgvclg/binary_search_game_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n2 2 2\n2 1 1 1\n4 3 2\n3 1 1 4\n5 100 3\n2 4 1 1 4 5 2 5\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1P4lyfWk4pxCG60no4Woo4u-McOmJhN1rvp1nbfrnzfk4B3V-2sGBrdtbetx3XovFNZsjshV7DPMTkKyI9_Sg4j--rFqqERikiY9Oo1YEqbvH3/binary_search_game_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 6\nCase #2: 144\nCase #3: 991661422\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, there are $$$4$$$ ways to write the integers on the blank cards:\n  $$$[1, 1]$$$, $$$[1, 2]$$$, $$$[2, 1]$$$, and $$$[2, 2]$$$. In the first two\n  ways, no matter what Alice chooses in her first turn, Bob can always make the number in the\n  last remaining cell be a $$$1$$$, and card $$$1$$$ contains a $$$1$$$, which means\n  those two games have a score of $$$1$$$.\n  In the last two ways, Alice can start by eliminating the leftmost half of the board, leaving\n  $$$[1, 1]$$$ for Bob, who then has no choice but to leave $$$[1]$$$ at the end.\n  Since card $$$1$$$ has a $$$2$$$ on it in these ways, the score of both of these games\n  is $$$2$$$. The sum of all scores is therefore $$$1+1+2+2=6$$$.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":26}],"title":"Binary Search Game","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000436142","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2021"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
