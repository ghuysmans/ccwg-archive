{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1460253600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201bee","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nThis year, we had 58,520 registrants, 27,170 contestants with at least one solved dataset on the scoreboard, and 1,710 contestants with perfect scores!\nWe had a full 27 hours of coding fun, with the first correct submission at 2\nminutes and 15 seconds. For the fourth year in a row, xiaowuc1 had the first\ncorrect submission of the Qualification Round! xiaowuc1 was also the third to a\nperfect score (49:13), behind Lewin in first place (40:51) and Endagorion in\nsecond place (47:47).\n</p><p>\nThe first problem, Counting Sheep, was a relatively simple \"try it and see\"\nimplementation exercise. Revenge of the Pancakes playfully alluded to\nInfinite House of Pancakes, a\nharder pancake-related problem from last year's Qualification round, but\nadmitted a much simpler solution. Coin Jam was an unusual exercise in \"mining\"\nfor \"coins\" with certain properties... or easily constructing them outright,\nif you found the right math trick! Finally, Fractiles was a more complex\nproblem about logic and information.\n</p><p>\nCongratulations to our 22,154 competitors who earned at least 30 points and\nadvanced to the Round 1 contests; we'll see you soon in Round 1A!\n</p>\n<hr>\n<p>\n<b>Cast</b>\n</p><p>\nProblem A (<i>Counting Sheep</i>): Written and prepared by Ian Tullis.\n</p><p>\nProblem B (<i>Revenge of the Pancakes</i>): Written and prepared by Ian Tullis.\n</p><p>\nProblem C (<i>Coin Jam</i>): Written and prepared by Ian Tullis.\n</p><p>\nProblem D (<i>Fractiles</i>): Written by Pablo Heiber and Ian Tullis. Prepared\nby Jackson Gatenby and Pablo Heiber.\n</p>\n<p>\nSolutions and other problem preparation and review by David Arthur, Minh Doan,\nSumudu Fernando, Jackson Gatenby, Taman (Muhammed) Islam, Sean Lip, Igor\nNaverniouk, Karol Pokorski, Steve Thomas, Yerzhan Utkelbayev, and Jonathan\nWills.\n</p>\n<p>\nAnalysis authors:\n</p>\n<ul>\n<li>Counting Sheep: Ian Tullis</li>\n<li>Revenge of the Pancakes: Timothy Loh and Pablo Heiber</li>\n<li>Coin Jam: Timothy Loh</li>\n<li>Fractiles: Pablo Heiber</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1460156400000,"tasks":[{"analysis":"<p>\nOne approach here is to enumerate strings of length <b>N</b> and see if they\nare jamcoins. To iterate over potential jamcoins, we can iterate over the\nbase-2 interpretations (odd numbers between 2<sup><b>N</b>-1</sup>+1 and\n2<sup><b>N</b></sup>-1, inclusive) and use a recursive method to convert these\nto different bases.\n</p><p>\nFor the Small dataset, it is sufficient to use\n<a href=\"https://en.wikipedia.org/wiki/Trial_division\">trial division</a> to\nfind factors of potential jamcoins. Concretely, we can look for a nontrivial\ndivisor of an integer <i>k</i> by testing divisibility of every integer in\nincreasing order from 2 to the square root of <i>k</i>, inclusive and stopping\nif we find one. Searching past the square root of the number is not needed as\nif <i>k</i> has some nontrivial divisor <i>d</i>, then <i>k / d</i> is also a\nnon-trivial divisor and the smaller of <i>d</i> and <i>k / d</i> is at most the\nsquare root of <i>k</i>. A sample implementation of this in C++ looks like this:\n</p>\n<pre><code>long long convertBinaryToBase(int x, int base) {\n  // Some languages have built-ins which make this easy.\n  // For example, in Python, we can avoid recursion and\n  // just return int(bin(x)[2:], base)\n  if (x == 0)\n    return 0;\n  return base * convertBinaryToBase(x / 2, base) + (x % 2);\n}\n\nlong long findFactor(long long k) {\n  for (long long d = 2; d * d &lt;= k; d++)\n    if (k % d == 0)\n      return d;\n  return 0;\n}\n\nvoid printCoins(int N, int X) {\n  for (long long i = (1 &lt;&lt; N-1) + 1; X &gt; 0; i += 2) {\n    vector&lt;long long&gt; factors;\n    for (int base = 2; base &lt;= 10; base++) {\n      long long x = convertBinaryToBase(i, base);\n      long long factor = findFactor(x);\n      if (!factor)\n        break;\n      factors.push_back(factor);\n    }\n    if (factors.size() &lt; 9)\n      continue;\n\n    cout &lt;&lt; convertBinaryToBase(i, 10);\n    for (long long factor : factors)\n      cout &lt;&lt; \" \" &lt;&lt; factor;\n    cout &lt;&lt; endl;\n    X -= 1;\n  }\n}\n</code></pre>\n<p>\nSolving the large test case may present unique challenges, depending on the\nprogramming language used. We're given that <b>N</b> = 32, which means that in\nbase 10 we'll have 32-digit numbers, which we can't store in a 64-bit integer.\nThese numbers are also large enough that running the trial division algorithm\non a single prime would take a huge amount of time, potentially longer than the\nduration of this contest! While we can solve these issues by stopping the trial\ndivision early (say, after checking up to 1000) and using arbitrary precision\nintegers, there's actually a much nicer approach!\n</p><p>\nWe can make some observations about jamcoins if we look at the output to the\nSmall dataset from our program above. Considering the first 50 jamcoins of\nlength 16, we find that 18 of them have divisors \"3 2 3 2 7 2 3 2 3\" and 11 of\nthem have divisors \"3 2 5 2 7 2 3 2 11\". What's the pattern in these numbers?\nThe numbers 5, 7, 11 from the second list provide a useful hint: they're one\nmore than their respective bases. Giving this some thought, we can notice that\nthe second list of divisors is formed by taking the smallest prime factor of\n<i>b</i>+1 for each base <i>b</i>. This suggests that <i>b</i>+1 is always a\ndivisor for each of these 11 jamcoins, and we can easily verify that this is true.\nUnderstanding the other common divisor list is left as an exercise for the\nreader.\n</p><p>\nNote that <i>b</i>+1 in base <i>b</i> is 11<sub><i>b</i></sub>. A simple test\nexists to determine divisibility of 11 in base-10: a number is divisible by 11\nif the sum of its digits in odd positions and the sum of its digits in even\npositions differ by a multiple of 11. This\n<a href=\"https://en.wikipedia.org/wiki/Divisibility_rule\">divisibility rule</a>\nfor 11 can be extended to a simple rule: a string of <code>0</code>s and\n<code>1</code>s which starts and ends with a <code>1</code> and has the same\nnumber of <code>1</code>s at odd and even indices is divisible by <i>b</i>+1 when\ninterpreted as a base-<i>b</i> number. Such a string is therefore a jamcoin,\nbut not every jamcoin necessarily matches this condition. A stricter condition\nthat may be easier to notice is that a string of <code>0</code>s and\n<code>1</code>s which starts and ends with a <code>1</code> is a jamcoin if all\n<code>1</code>s are paired, i.e. it matches the regular expression\n<code>11(0|11)*11</code>. For example, in any base <i>b</i>,\n11011<sub><i>b</i></sub> = 1001<sub><i>b</i></sub> &times; 11<sub><i>b</i></sub>.\n</p><p>\nThe last example here also suggests a more general rule. Consider any string\n<code>p</code> of <code>0</code>s and <code>1</code>s with at least two\ncharacters, which starts and ends with a <code>1</code>. Any string which is\n<code>p</code> repeated multiple times with any number of <code>0</code>s\nbetween repetitions is a jamcoin. In the previous example we have\n<code>p</code> = <code>11</code> and this general rule can be expressed as the\nregular expression <code>(1[01]*1)(0*\\1)+</code>. For example, in any base <i>b</i>,\n<u>11101</u>000<u>11101</u>0<u>11101</u><sub><i>b</i></sub> =\n11101<sub><i>b</i></sub> &times; 100000001000001<sub><i>b</i></sub>.\n</p><p>\nWe can use any of these rules to mine jamcoins easily. The Python 2 code below\nmines jamcoins with exactly 5 pairs of <code>11</code>s, which finds enough for\nboth the Small and Large datasets.\n</p>\n<pre><code>def printCoins(N, X):\n  # N digits, 10 1s, N-10 0s\n  for i in range(N-10):\n    for j in range(N-10-i):\n      for k in range(N-10-i-j):\n        l = N-10-i-j-k\n        assert l &gt;= 0\n        template = \"11{}11{}11{}11{}11\"\n        output = template.format(\"0\"*i, \"0\"*j, \"0\"*k, \"0\"*l)\n        factors = \"3 2 5 2 7 2 3 2 11\"\n        print output, factors\n        X -= 1\n        if X == 0:\n          return\n  # If we get here, we didn't mine enough jamcoins!\n  assert False\n</code></pre>\n","id":"0000000000201b6d","statement":"<h3>Problem</h3>\n<p>\nA <i>jamcoin</i> is a string of <b>N</b> &ge; 2 digits with the following\nproperties:\n</p>\n<ul>\n<li>Every digit is either <code>0</code> or <code>1</code>.</li>\n<li>The first digit is <code>1</code> and the last digit is <code>1</code>.</li>\n<li>If you interpret the string in any base between 2 and 10, inclusive, the\nresulting number is not prime.</li>\n</ul>\n<p>\nNot every string of <code>0</code>s and <code>1</code>s is a jamcoin. For\nexample, <code>101</code> is not a jamcoin; its interpretation in base 2 is 5,\nwhich is prime. But the string <code>1001</code> is a jamcoin: in bases 2\nthrough 10, its interpretation is 9, 28, 65, 126, 217, 344, 513, 730, and 1001,\nrespectively, and none of those is prime.\n</p><p>\nWe hear that there may be communities that use jamcoins as a form of currency.\nWhen sending someone a jamcoin, it is polite to prove that the jamcoin is\nlegitimate by including a nontrivial divisor of that jamcoin's interpretation\nin each base from 2 to 10. (A nontrivial divisor for a positive integer\n<i>K</i> is some positive integer other than 1 or <i>K</i> that evenly divides\n<i>K</i>.) For convenience, these divisors must be expressed in base 10.\n</p><p>\nFor example, for the jamcoin <code>1001</code> mentioned above, a possible set\nof nontrivial divisors for the base 2 through 10 interpretations of the jamcoin\nwould be: 3, 7, 5, 6, 31, 8, 27, 5, and 77, respectively.\n</p><p>\nCan you produce <b>J</b> different jamcoins of length <b>N</b>, along with\nproof that they are legitimate?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow; each consists of one line with two integers <b>N</b> and\n<b>J</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output <b>J</b>+1 lines. The first line must consist of\nonly <code>Case #x:</code>, where <code>x</code> is the test case number\n(starting from 1). Each of the last <b>J</b> lines must consist of a jamcoin of\nlength <b>N</b> followed by nine integers. The i-th of those nine integers\n(counting starting from 1) must be a nontrivial divisor of the jamcoin when\nthe jamcoin is interpreted in base i+1.\n</p><p>\nAll of these jamcoins must be different. You cannot submit the same jamcoin\nin two different lines, even if you use a different set of divisors each time.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n<b>T</b> = 1. (There will be only one test case.)<br/>\nIt is guaranteed that at least <b>J</b> distinct jamcoins of length <b>N</b>\nexist.\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n<b>N</b> = 16.<br/>\n<b>J</b> = 50.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n<b>N</b> = 32.<br/>\n<b>J</b> = 500.<br/>\n</p>\n\n<p>\nNote that, unusually for a Code Jam problem, you already know the exact\ncontents of each input file. For example, the Small dataset's input file will\nalways be exactly these two lines:\n</p>\n<code>\n1<br/>\n16 50<br/>\n</code>\n<p>\nSo, you can consider doing some computation before actually downloading an\ninput file and starting the clock.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">1\n6 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\n100011 5 13 147 31 43 1121 73 77 629\n111111 21 26 105 1302 217 1032 513 13286 10101\n111001 3 88 5 1938 7 208 3 20 11\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn this sample case, we have used very small values of <b>N</b> and <b>J</b>\nfor ease of explanation. Note that this sample case would not appear in either\nthe Small or Large datasets.\n</p><p>\nThis is only one of multiple valid solutions. Other sets of jamcoins could have\nbeen used, and there are many other possible sets of nontrivial base 10\ndivisors. Some notes:\n</p>\n<ul>\n<li>\n<code>110111</code> could not have been included in the output because, for\nexample, it is 337 if interpreted in base 3 (1*243 + 1*81 + 0*27 + 1*9 + 1*3 +\n1*1), and 337 is prime.\n</li><li>\n<code>010101</code> could not have been included in the output even though\n<code>10101</code> is a jamcoin, because jamcoins begin with <code>1</code>.\n</li><li>\n<code>101010</code> could not have been included in the output, because\njamcoins end with <code>1</code>.\n</li><li>\n<code>110011</code> is another jamcoin that could have also been used in the\noutput, but could not have been added to the end of this output, since the\noutput must contain exactly <b>J</b> examples.\n</li><li>\nFor the first jamcoin in the sample output, the first number after\n<code>100011</code> could not have been either 1 or 35, because those are\ntrivial divisors of 35 (<code>100011</code> in base 2).\n</li>\n</ul>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Coin Jam","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThis problem is more about analyzing an existing algorithm than writing a new one. Once you\nunderstand how more complex artwork depends on the original sequence, you can solve the problem\nwith a short piece of code.\n</p><p>\nThe first thing to notice is that if the original sequence is all <code>L</code>s, the artwork will\nbe all <code>L</code>s, no matter what the value of <b>C</b> is. If we choose some set of tiles\nthat all turn out to be <code>L</code>s for some original sequence other than all <code>L</code>s,\nthen our solution is invalid, because we won't be able to tell whether the artwork was based on\nthat original sequence or on an original sequence of all <code>L</code>s. This means we have to\ncome up with a set of positions to check out such that for any original sequence besides all\n<code>L</code>s, we will see at least one <code>G</code>.\n</p>\n<h3>Small dataset</h3>\n<p>\nIn the Small dataset, since we can check as many tiles as the length of the original sequence, we\nmay be tempted to try to reconstruct it in full. And while this is possible (we'll get there in a\nmoment), there is an easier alternative. The simplest solution, as it turns out, is to always\noutput the integers 1 through <b>K</b>. It can be easily proved that it works with the following\ntwo-case analysis. Let us call the original sequence <i>O</i>, and let <i>A</i><sub><i>i</i></sub>\nbe the artwork of complexity <i>i</i> for a fixed <i>O</i>.\n</p><p>\n1. Suppose that <i>O</i> starts with an <code>L</code>. Let us prove that each\n<i>A</i><sub><i>i</i></sub> starts with <i>O</i>. This is trivially true for\n<i>A</i><sub>1</sub> = <i>O</i>. Now, if <i>A</i><sub><i>i</i></sub> starts with <i>O</i>, it also\nstarts with an <code>L</code>, and since the transformation maps that first <code>L</code> into a\ncopy of <i>O</i>, <i>A</i><sub><i>i</i>+1</sub> starts with <i>O</i>. By induction, each\n<i>A</i><sub><i>i</i></sub> starts with <i>O</i>. Then, by checking positions 1 through <b>K</b>,\nwe are checking a copy of the original sequence <i>O</i>, so if there are any <code>G</code>s in\n<i>O</i>, we will see a <code>G</code>.\n</p><p>\n2. Suppose instead that <i>O</i> starts with a <code>G</code>. Let us prove that each\n<i>A</i><sub><i>i</i></sub> starts with a <code>G</code>. This is trivially true for\n<i>A</i><sub>1</sub> = <i>O</i>. Now, if <i>A</i><sub><i>i</i></sub> starts with a <code>G</code>,\nthen <i>A</i><sub><i>i</i>+1</sub> also starts with a <code>G</code>, since the transformation maps\nthat <code>G</code> at the start of <i>A</i><sub><i>i</i></sub> to <b>K</b> <code>G</code>s at the\nstart of <i>A</i><sub><i>i</i>+1</sub>. By induction, each <i>A</i><sub><i>i</i></sub> starts with\n<code>G</code>. Then, since we are checking position 1, we will see a <code>G</code>.\n</p><p>\nSince we will see at least one <code>G</code> for any original sequence that is not all\n<code>L</code>s, and only <code>L</code>s for the original sequence that is all <code>L</code>s,\nwe have answered the question successfully. Notice that this also proves that there is no\nimpossible case in the Small dataset.\n</p><p>\nThe proofs above hint at another possible solution for the Small dataset that gets enough\ninformation from the tiles to know the entire <i>O</i>. We will explain it not only because it is\ninteresting, but also because it is a stepping stone towards a solution for the Large dataset.\n</p><p>\nWe have seen that position 1 of any <i>A</i><sub><i>i</i></sub> is always equal to position 1 of\n<i>O</i>. Is there any position in <i>A</i><sub><i>i</i></sub> that is always equal to position 2\nof <i>O</i>? It turns out that there is, and the same is true for any position of <i>O</i>.\n</p><p>\nConsider position 2 of <i>O</i> as an example. It is position 2 in <i>A</i><sub>1</sub> = <i>O</i>.\nWhen <i>A</i><sub>2</sub> is produced from <i>A</i><sub>1</sub>, the tile at position 2 of\n<i>A</i><sub>1</sub> determines which tiles will appear at positions <b>K</b> + 1 through\n<b>K</b> + <b>K</b> of <i>A</i><sub>2</sub>. In particular, the second of those tiles, the tile\nat position <b>K</b> + 2 of <i>A</i><sub>2</sub>, is the same as the tile at position 2 of\n<i>A</i><sub>1</sub>. Then, it follows that position <b>K</b> + 2 of <i>A</i><sub>2</sub> generates\npositions <b>K</b>*(<b>K</b> + 2 - 1) + 1 through <b>K</b>*(<b>K</b> + 2) of\n<i>A</i><sub>3</sub>, and the second of those tiles, at position\n<b>K</b>*(<b>K</b> + 2 - 1) + 2 of <i>A</i><sub>3</sub>, is also a copy of position 2 of\n<i>O</i>. You can follow this further to discover which position of <i>A</i><sub><b>C</b></sub> is\nequal to position 2, or you can write a program to do it for you. Similarly, for each position of\n<i>O</i> there is exactly one \"fixed point\" position in <i>A</i><sub><b>C</b></sub> that is always\nequal in value, and you can get those with a program by generalizing the procedure described for\nposition 2. If you check out all of those positions, you obtain a different result for every\npossible <i>O</i>, which makes the solution valid.\n</p>\n<h3>Large dataset</h3>\n<p>\nThe reasoning that we just used to find fixed points will help us solve the Large. Each position\nin <i>A</i><sub><i>i</i></sub> generates <b>K</b> positions in <i>A</i><sub><i>i</i>+1</sub>. So,\nindirectly, each position in <i>A</i><sub><i>i</i></sub> also generates <b>K</b><sup>2</sup>\npositions in <i>A</i><sub><i>i</i>+2</sub>, <b>K</b><sup>3</sup> positions in\n<i>A</i><sub><i>i</i>+3</sub>, and so on. Let us say that a position in\n<i>A</i><sub><i>i</i>+d</sub> is a descendant of a position <i>p</i> in\n<i>A</i><sub><i>i</i></sub> if it was generated from a position in\n<i>A</i><sub><i>i</i>+<i>d</i>-1</sub> generated from a position in\n<i>A</i><sub><i>i</i>+<i>d</i>-2</sub> ... generated from position <i>p</i> in\n<i>A</i><sub><i>i</i></sub>. Notice that a <code>G</code> in any given position of any\n<i>A</i><sub><i>i</i></sub> implies a <code>G</code> in all descendant positions. However, if there\nis an <code>L</code> in position <i>p</i> of <i>A</i><sub><i>i</i></sub>, a descendant position\n(<i>p</i> - 1)*<b>K</b>+<i>d</i> (with 1 &le; <i>d</i> &le; <b>K</b>) of\n<i>A</i><sub><i>i</i>+1</sub> will be equal to position <i>d</i> of <i>O</i>. So, position\n(<i>p</i> - 1)*<b>K</b>+<i>d</i> of <i>A</i><sub><i>i</i>+1</sub> is an <code>L</code> if and only\nif both position <i>p</i> of <i>A</i><sub><i>i</i></sub> and position <i>d</i> of <i>O</i> are\n<code>L</code>s. If we take this further, we arrive at a key insight: any position of any\n<i>A</i><sub><i>i</i></sub> is an <code>L</code> if and only if a particular set of positions in\n<i>O</i> are <code>L</code>s.\n</p><p>\nWe can find those positions by thinking about the orders in which the descendants at each level\nwere produced. For instance, for <b>K</b>=3, position 8 of <i>A</i><sub>3</sub> is descendant\nnumber 2 of position 3 of <i>A</i><sub>2</sub>, which in turn is descendant number 3 of position\n1 of <i>A</i><sub>1</sub>. That means that position 8 of <i>A</i><sub>3</sub> is <code>L</code>\nif and only if positions 2, 3 and 1 of <i>O</i> are all <code>L</code>s. So, just by looking at\nposition 8 of <i>A</i><sub>3</sub>, we know whether the original sequence had a\n<code>G</code> in at least one of those three positions.\n</p><p>\nGeneralizing this, if we start at position <i>p</i><sub>1</sub> of <i>A</i><sub>1</sub> = <i>O</i>,\nand take its <i>p</i><sub>2</sub>-th descendant in <i>A</i><sub>2</sub>, and then take its\n<i>p</i><sub>3</sub>-th descendant in <i>A</i><sub>3</sub>, and so on, until taking the\n<i>p</i><sub><b>C</b></sub>-th descendant in <i>A</i><sub><b>C</b></sub>, we have a single position\nthat tells us whether the original sequence has a <code>G</code> in positions\n<i>p</i><sub>1</sub>, <i>p</i><sub>2</sub>, ..., <i>p</i><sub><b>C</b></sub>. And, conversely, for\nany position in <i>A</i><sub><b>C</b></sub>, we can find a corresponding sequence of <b>C</b>\npositions that lead to it. So, each position we check on <i>A</i><sub><b>C</b></sub> can cover up\nto <b>C</b> positions of <i>O</i>, and will cover exactly <b>C</b> positions if we make the right\nchoice. Since we need to cover all <b>K</b> positions of the original sequence, that means the\nimpossible cases are exactly those where <b>S</b>*<b>C</b> &lt; <b>K</b> &mdash; that is, where\ngetting <b>C</b> positions out of every one of our <b>S</b> tile choices is still not enough.\nFor the rest, we can assign a list of positions [1, 2, ..., <b>C</b>] to tile choice 1,\n[<b>C</b>+1, <b>C</b>+2, 2<b>C</b>] to tile choice 2, and so on until we get to <b>K</b>. If the\nlast tile choice has a list shorter than <b>C</b>, we can fill it up with copies of any integer\nbetween 1 and <b>K</b>. Now all we need to do is match each of these lists to a position in\n<i>A</i><sub><b>C</b></sub>, which we can do by following the descendant path (descendants of\nposition <i>p</i> are always positions (<i>p</i> - 1)*<b>K</b>+1 through\n(<i>p</i> - 1)*<b>K</b>+<b>K</b>). This simple Python code represents this idea:\n</p>\n<pre>\ndef Solve(k, c, s):\n  if c*s &gt; k:\n    return []  # returns an empty list for impossible cases\n  tiles = []\n  # the list for the last tile choice is filled with copies of k\n  # i is the first value of the list of the current tile choice\n  for i in xrange(1, k + 1, c):\n    p = 1\n    # j is the step in the current list [i, i+1, ..., i+C-1]\n    for j in xrange(c):\n      # the min fills the last tile choice's list with copies of k\n      p = (p - 1) * k + min(i + j, k)\n    tiles.append(p)\n  return tiles\n</pre>\n","id":"0000000000201bf1","statement":"<h3>Problem</h3>\n<p>\nLong ago, the Fractal civilization created artwork consisting of linear\nrows of tiles. They had two types of tile that they could use: gold\n(<code>G</code>) and lead (<code>L</code>).\n</p><p>\nEach piece of Fractal artwork is based on two parameters: an original sequence\nof <b>K</b> tiles, and a complexity <b>C</b>. For a given original\nsequence, the artwork with complexity 1 is just that original sequence,\nand the artwork with complexity <i>X</i>+1 consists of the artwork with\ncomplexity <i>X</i>, transformed as follows:\n<ul>\n<li>replace each <code>L</code> tile in the complexity <i>X</i> artwork with\nanother copy of the original sequence</li>\n<li>replace each <code>G</code> tile in the complexity <i>X</i> artwork with\n<b>K</b> <code>G</code> tiles</li>\n</ul>\n<p>\nFor example, for an original sequence of <code>LGL</code>, the pieces of\nartwork with complexity 1 through 3 are:\n</p>\n<ul>\n<li><b>C</b> = 1: <code>LGL</code> (which is just the original sequence)\n<li><b>C</b> = 2: <code>LGLGGGLGL</code>\n<li><b>C</b> = 3: <code>LGLGGGLGLGGGGGGGGGLGLGGGLGL</code>\n</ul>\n<p>\nHere's an illustration of how the artwork with complexity 2 is generated from\nthe artwork with complexity 1:\n</p><p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3oYthY0ksftsHKl3X86fqpL_5mbyExwdmvN-10U-_ka8bSiymDw4I2Z8i1zx7_xYxvAcrvJVQd/fractiles.png\"/>\n</p><p>\nYou have just discovered a piece of Fractal artwork, but the tiles are too\ndirty for you to tell what they are made of. Because you are an expert\narchaeologist familiar with the local Fractal culture, you know the values of\n<b>K</b> and <b>C</b> for the artwork, but you do not know the original\nsequence. Since gold is exciting, you would like to know whether there is at\nleast one <code>G</code> tile in the artwork. Your budget allows you to hire\n<b>S</b> graduate students, each of whom can clean one tile of your choice (out\nof the <b>K</b><sup><b>C</b></sup> tiles in the artwork) to see whether the\ntile is <code>G</code> or <code>L</code>.\n</p>\n<p>\nIs it possible for you to choose a set of no more than <b>S</b> specific tiles\nto clean, such that <i>no matter what</i> the original pattern was, you will be\nable to know for sure whether at least one <code>G</code> tile is present in\nthe artwork? If so, which tiles should you clean?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each consists of one line with three integers: <b>K</b>,\n<b>C</b>, and <b>S</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\neither <code>IMPOSSIBLE</code> if no set of tiles will answer your question, or\na list of between 1 and <b>S</b> positive integers, which are the positions of\nthe tiles that will answer your question. The tile positions are numbered from\n1 for the leftmost tile to <b>K</b><sup><b>C</b></sup> for the rightmost tile.\nYour chosen positions may be in any order, but they must all be different.\n</p>\n<p>\nIf there are multiple valid sets of tiles, you may output any of them. Remember that\nonce you submit a Small and it is accepted, you will not be able to download and submit another\nSmall input. See <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\">the FAQ</a> for a\nmore thorough explanation. <b>This reminder won't appear in problems in later rounds.</b>\n</p>\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>K</b> &le; 100.<br/>\n1 &le; <b>C</b> &le; 100.<br/>\n<b>K</b><sup><b>C</b></sup> &le; 10<sup>18</sup>.\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n<b>S</b> = <b>K</b>.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n1 &le; <b>S</b> &le; <b>K</b>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n2 3 2\n1 1 1\n2 1 1\n2 1 2\n3 2 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 1\nCase #3: IMPOSSIBLE\nCase #4: 1 2\nCase #5: 2 6\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nNote: for some of these sample cases, other valid solutions exist.\n</p><p>\nIn sample case #1, there are four possible original sequences: <code>GG</code>,\n<code>GL</code>, <code>LG</code>, and <code>LL</code>. They would produce the\nfollowing artwork, respectively:\n</p>\n<ul>\n<li>Original sequence <code>GG</code>: <code>GGGGGGGG</code>\n<li>Original sequence <code>GL</code>: <code>GGGGGGGL</code>\n<li>Original sequence <code>LG</code>: <code>LGGGGGGG</code>\n<li>Original sequence <code>LL</code>: <code>LLLLLLLL</code>\n</ul>\n<p>One valid solution is to just look at tile #2. If tile #2 turns out to be\n<code>G</code>, then you will know for sure the artwork contains at least one\n<code>G</code>. (You will not know whether the original sequence is\n<code>GG</code>, <code>GL</code>, or <code>LG</code>, but that doesn't matter.)\nIf tile #2 turns out to be <code>L</code>, then you will know that the original\nsequence must be <code>LL</code>, so there are no <code>G</code>s in the\nartwork. So <code>2</code> is a valid solution.\n</p><p>\nOn the other hand, it would not be valid to just look at tile #1. If it turns\nout to be <code>L</code>, you will only know that the original sequence could\nhave been either <code>LG</code> or <code>LL</code>. If the original sequence\nis <code>LG</code>, there is at least one <code>G</code> in the artwork, but if\nthe original sequence is <code>LL</code>, there are no <code>G</code>s. So\n<code>1</code> would not be a valid solution.\n</p><p>\nNote that <code>1 2</code> is also a valid solution, because tile #2 already\nprovides all the information you need. <code>1 2 3</code> is not a valid\nsolution, because it uses too many tiles.\n</p><p>\nIn sample case #2, the artwork must consist of only one tile: either\n<code>G</code> or <code>L</code>. Looking at that tile will trivially tell you\nwhether or not the artwork has a <code>G</code> in it.\n</p><p>\nIn sample case #3, which would not appear in the Small dataset, the artwork\nmust be either <code>GG</code>, <code>GL</code>, <code>LG</code>, or\n<code>LL</code>. You can only look at one tile, and neither of them on its own\nis enough to answer the question. If you see <code>L</code> for tile #1, you\nwill not know whether the artwork is <code>LG</code> or <code>LL</code>, so you\nwill not know whether any <code>G</code>s are present. If you see\n<code>L</code> for tile #2, you will not know whether the artwork is\n<code>GL</code> or <code>LL</code>, so you will not know whether any\n<code>G</code>s are present.\n</p><p>\nSample case #4 is like sample case #3, but with access to one more tile. Now\nyou can just look at the entire artwork.\n</p><p>\nIn sample case #5, there are eight possible original sequences, and they would\nproduce the following artwork:\n</p><p>\n<ul>\n<li>Original sequence <code>GGG</code>: <code>GGGGGGGGG</code></li>\n<li>Original sequence <code>GGL</code>: <code>GGGGGGGGL</code></li>\n<li>Original sequence <code>GLG</code>: <code>GGGGLGGGG</code></li>\n<li>Original sequence <code>GLL</code>: <code>GGGGLLGLL</code></li>\n<li>Original sequence <code>LGG</code>: <code>LGGGGGGGG</code></li>\n<li>Original sequence <code>LGL</code>: <code>LGLGGGLGL</code></li>\n<li>Original sequence <code>LLG</code>: <code>LLGLLGGGG</code></li>\n<li>Original sequence <code>LLL</code>: <code>LLLLLLLLL</code></li>\n</ul>\n<p>\nOne valid solution is to look at tiles #2 and #6. If they both turn out to\nbe <code>L</code>s, the artwork must be all <code>L</code>s. Otherwise, there\nmust at least one <code>G</code>. Note that <code>1 2</code> would not be a\nvalid solution, because even if those tiles both turn out to be <code>L</code>s,\nthat does not rule out an original sequence of <code>LLG</code>.\n<code>6 2</code> would be a valid solution, since the order of the positions\nin your solution does not matter.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Fractiles","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe most natural approach to this problem is to simulate the process: keep\ntrack of which digits Bleatrix has seen so far, and then keep generating and\nchecking the numbers she names until she has seen all of the digits 0-9. But\nare there other cases like <b>N</b> = 0 that go on forever or take an\nunacceptably long time?\n</p><p>\nOne way to answer this question for the purposes of the problem to just check\nall possible cases between 0 and 10<sup>6</sup> before downloading the Large\ndataset. With a well-written program on a reasonably fast machine, this should\ntake only a few seconds.\n</p><p>\nMore generally, it can be proven that for any <b>N</b> &gt; 0, the sheep\ndoesn't have to keep naming numbers for very long:\n</p>\n<ul>\n<li>Regarding the digit 0: The tenth number that Bleatrix names is 10 times\n<b>N</b>, and is therefore guaranteed to end in 0.</li>\n<li>Regarding digits 1-9: Consider the smallest power of 10 greater than\n<b>N</b>; call it <i>P</i>. Once the process reaches a number at least as large\nas <i>P</i>, then the leftmost digit will take on every possible value from 1-9\nas the number increases up to (or past) 9<i>P</i>. No digit can be skipped,\nbecause that would require the step between successive numbers (which equals\n<b>N</b>) to be larger than <i>P</i>... but we know that <b>N</b> is less than\n<i>P</i> because of how we chose <i>P</i>.</li>\n</ul>\n<p>\nSince, by definition of <i>P</i>, 10<b>N</b> &ge; <i>P</i>, we will reach a\nnumber larger than <i>P</i> after naming at most 10 numbers, and we will reach\na number greater than 9<i>P</i> after naming at most 90 numbers. So, after\nchecking for the special case of <b>N</b> = 0, we can run our simulation\nwithout fear of running forever, running for long enough to run out of time, or\noverflowing even a 32-bit integer. Within the limits of the Small and Large\ndatasets, the worst cases turn out to be 125 followed by any number of zeroes.\nIn those cases, Bleatrix will name 72 numbers before falling asleep.\n</p>\n","id":"0000000000201c8a","statement":"<h3>Problem</h3>\n<p>\nBleatrix Trotter the sheep has devised a strategy that helps her fall asleep\nfaster. First, she picks a number <b>N</b>. Then she starts naming <b>N</b>, 2\n&times; <b>N</b>, 3 &times; <b>N</b>, and so on. Whenever she names a number,\nshe thinks about all of the digits in that number. She keeps track of which\ndigits (0, 1, 2, 3, 4, 5, 6, 7, 8, and 9) she has seen at least once so far\nas part of any number she has named. Once she has seen each of the ten digits\nat least once, she will fall asleep.\n</p><p>\nBleatrix must start with <b>N</b> and must always name (<i>i</i> + 1) &times;\n<b>N</b> directly after <i>i</i> &times; <b>N</b>. For example, suppose that\nBleatrix picks <b>N</b> = 1692. She would count as follows:\n</p>\n<ul>\n<li><b>N</b> = 1692. Now she has seen the digits 1, 2, 6, and 9.</li>\n<li>2<b>N</b> = 3384. Now she has seen the digits 1, 2, 3, 4, 6, 8, and 9.</li>\n<li>3<b>N</b> = 5076. Now she has seen all ten digits, and falls asleep.</li>\n</ul>\n<p>\nWhat is the last number that she will name before falling asleep? If she will\ncount forever, print <code>INSOMNIA</code> instead.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each consists of one line with a single integer <b>N</b>,\nthe number Bleatrix has chosen.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe last number that Bleatrix will name before falling asleep, according to\nthe rules described in the statement.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n0 &le; <b>N</b> &le; 200.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n0 &le; <b>N</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n0\n1\n2\n11\n1692\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: INSOMNIA\nCase #2: 10\nCase #3: 90\nCase #4: 110\nCase #5: 5076\n\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn Case #1, since 2 &times; 0 = 0, 3 &times; 0 = 0, and so on, Bleatrix will never see any\ndigit other than 0, and so she will count forever and never fall asleep. Poor\nsheep!\n</p><p>\nIn Case #2, Bleatrix will name 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. The 0 will be\nthe last digit needed, and so she will fall asleep after 10.\n</p><p>\nIn Case #3, Bleatrix will name 2, 4, 6... and so on. She will not see the\ndigit 9 in any number until 90, at which point she will fall asleep. By that\npoint, she will have already seen the digits 0, 1, 2, 3, 4, 5, 6, 7, and 8,\nwhich will have appeared for the first time in the numbers 10, 10, 2, 30, 4,\n50, 6, 70, and 8, respectively.\n</p><p>\nIn Case #4, Bleatrix will name 11, 22, 33, 44, 55, 66, 77, 88, 99, 110 and then\nfall asleep.\n</p><p>\nCase #5 is the one described in the problem statement. Note that it would only\nshow up in the Large dataset, and not in the Small dataset.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":8}],"title":"Counting Sheep","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIn the small case we have a stack of at most 10 pancakes. The total number of\npossible different states we can get by performing any number of flips is thus\n2<sup>10</sup> = 1024. As this is a small number of states, we can solve the\nsmall test case by performing a breadth first search over this state space.\nFor <b>N</b> pancakes, this can be implemented to complete within\nO(<b>N</b> 2<sup><b>N</b></sup>) time.\n</p><p>\nThe large case requires a much more efficient solution. Imagine a large stack\nof pancakes, starting with a few happy side up, then a few blank side up, a few\nmore happy side up, and so on. Intuitively it seems like a good idea to avoid\nflipping between two pancakes facing the same direction and instead try and\nmake larger groups of pancakes facing the same direction. Define the \"grouped\nheight\" of a prefix of the stack of pancakes (possibly the entire stack) to be\nthe number of groups of contiguous pancakes facing the same direction. The goal\nstate has a grouped height of 1. We can consider how various flips affect the\ngrouped height of a stack of pancakes:\n</p>\n<ul>\n<li>If we flip a group of pancakes that has an even grouped height, then the\nstack's grouped height will be unchanged.</li>\n<li>If we flip a group of pancakes that has an odd grouped height, then the\nstack's grouped height will\n <ul>\n  <li>increase by 1 if we flip between two pancakes facing the same direction.</li>\n  <li>decrease by 1 if we flip between two pancakes facing opposite directions.</li>\n  <li>be unchanged if we flip the entire stack.</li>\n </ul>\n</li>\n</ul>\n<p>\nSince the above statements categorize all possible flips, a flip can reduce the\ngrouped height of a stack by at most 1. As the goal state has a grouped height\nof 1, a stack with grouped height of <i>H</i> requires at least <i>H</i>-1\nflips to reach the goal state. Considering simple cases, for example those in\nthe sample input, we can see that <i>H</i>-1 flips is not necessarily\nsufficient. A stack consisting only of blank side up pancakes has <i>H</i> = 1\nbut we need to flip the entire stack to make the pancakes happy side up. Given\na stack where the bottom pancake is blank side up, we need to flip the entire\nstack at least once as the bottom pancake is only flipped when we flip the\nentire stack. Flipping the entire stack does not affect the grouped height of\na stack so this gives us a stricter lower bound of either <i>H</i>-1 flips if\nthe bottom pancake is happy side up or <i>H</i> flips if the bottom pancake is\nblank side up.\n</p><p>\nFor a stack with <i>H</i> &gt; 1, we can always flip the topmost group of\npancakes facing the same direction to decrease the grouped height by 1. Thus\nthe stricter lower bound is a sufficient number of flips as the following\ngreedy strategy takes exactly that many moves: repeatedly flip the topmost\ngroup of pancakes facing in the same direction (reducing the grouped height by\n1 each flip) until the grouped height is 1 and then flip the entire stack once\nif needed.\n</p><p>\nThe problem only asks for the minimum number of flips and not which flips to\nmake. As argued above, this is 1 less than the grouped height if the bottom\npancake is happy side up and exactly the grouped height if the bottom pancake\nis blank side up. A sample implementation in Python is provided below, using\nthe fact that the grouped height is one more than the number of times the\nstring changes from <code>+</code> to <code>-</code> or vice versa.\n</p>\n<pre><code>\ndef minimumFlips(pancakes):\n  groupedHeight = 1 + pancakes.count('-+') + pancakes.count('+-')\n  if pancakes.endswith('-'):\n    return groupedHeight\n  else:\n    return groupedHeight - 1\n</code></pre>\n","id":"0000000000201d17","statement":"<h3>Problem</h3>\n<p>\nThe Infinite House of Pancakes has just introduced a new kind of pancake!\nIt has a happy face made of chocolate chips on one side (the \"happy side\"), and\nnothing on the other side (the \"blank side\").\n</p>\n<p>\nYou are the head waiter on duty, and the kitchen has just given you a stack of\npancakes to serve to a customer. Like any good pancake server, you have X-ray\npancake vision, and you can see whether each pancake in the stack has the happy\nside up or the blank side up. You think the customer will be happiest if every\npancake is happy side up when you serve them.\n</p>\n<p>\nYou know the following maneuver: carefully lift up some number of pancakes\n(possibly all of them) from the top of the stack, flip that entire group over,\nand then put the group back down on top of any pancakes that you did not lift\nup. When flipping a group of pancakes, you flip the entire group in one motion;\nyou do <i>not</i> individually flip each pancake. Formally: if we number the\npancakes 1, 2, ..., <i>N</i> from top to bottom, you choose the top <i>i</i>\npancakes to flip. Then, after the flip, the stack is <i>i</i>, <i>i</i>-1, ...,\n2, 1, <i>i</i>+1, <i>i</i>+2, ..., <i>N</i>. Pancakes 1, 2, ..., <i>i</i> now\nhave the opposite side up, whereas pancakes <i>i</i>+1, <i>i</i>+2, ...,\n<i>N</i> have the same side up that they had up before.\n</p>\n<p>\nFor example, let's denote the happy side as <code>+</code> and the blank side\nas <code>-</code>. Suppose that the stack, starting from the top, is\n<code>--+-</code>. One valid way to execute the maneuver would be to pick up\nthe top three, flip the entire group, and put them back down on the remaining\nfourth pancake (which would stay where it is and remain unchanged). The new\nstate of the stack would then be <code>-++-</code>. The other valid ways would\nbe to pick up and flip the top one, the top two, or all four. It would not be\nvalid to choose and flip the middle two or the bottom one, for example; you can\nonly take some number off the top.\n</p>\n<p>\nYou will not serve the customer until every pancake is happy side up, but you\ndon't want the pancakes to get cold, so you have to act fast! What is the\nsmallest number of times you will need to execute the maneuver to get all the\npancakes happy side up, if you make optimal choices?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\ntest cases follow. Each consists of one line with a string <b>S</b>, each\ncharacter of which is either <code>+</code> (which represents a pancake that is\ninitially happy side up) or <code>-</code> (which represents a pancake that is\ninitially blank side up). The string, when read left to right, represents the\nstack when viewed from top to bottom.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where\n<code>x</code> is the test case number (starting from 1) and <code>y</code> is\nthe minimum number of times you will need to execute the maneuver to get all\nthe pancakes happy side up.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\nEvery character in <b>S</b> is either <code>+</code> or <code>-</code>.\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n1 &le; length of <b>S</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n1 &le; length of <b>S</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n-\n-+\n+-\n+++\n--+-\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 1\nCase #3: 2\nCase #4: 0\nCase #5: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn Case #1, you only need to execute the maneuver once, flipping the first (and\nonly) pancake.\n</p>\n<p>\nIn Case #2, you only need to execute the maneuver once, flipping only the first\npancake.\n</p>\n<p>\nIn Case #3, you must execute the maneuver twice. One optimal solution is to\nflip only the first pancake, changing the stack to <code>--</code>, and then\nflip both pancakes, changing the stack to <code>++</code>. Notice that you\ncannot just flip the bottom pancake individually to get a one-move solution;\nevery time you execute the maneuver, you must select a stack starting from the\ntop.\n</p>\n<p>\nIn Case #4, all of the pancakes are already happy side up, so there is no need\nto do anything.\n</p>\n<p>\nIn Case #5, one valid solution is to first flip the entire stack of pancakes to\nget <code>+-++</code>, then flip the top pancake to get <code>--++</code>, then\nfinally flip the top two pancakes to get <code>++++</code>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Revenge of the Pancakes","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201bee","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2016"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
