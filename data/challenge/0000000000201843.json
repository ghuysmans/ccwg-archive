{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1492227000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000201843","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Round 1A is over, and it had a particularly tough C problem; only 124\n  contestants attempted the Large, and only 8 got it right! Believe it or\n  not, this was not the most brutally difficult Round 1 problem in Code Jam\n  history; that (dubious?)\n  honor still goes to Pseudominion\n  from Round 1A 2011.\n</p><p>\n  Fortunately, problems A and B (and the Small of Problem C) were far more\n  approachable. To advance, you needed to either get more than 56 points (e.g., by\n  solving A, B, and C-small), or get 56 points by solving A and B with a total\n  penalty time around two hours.  \n</p><p>\n  <i>Alphabet Cake</i> was a reminder that the GCJ staff is aware of forms of\n  cake other than pan\"cake\"s. It allowed various approaches, including a nifty\n  recursive one. <i>Ratatouille</i> was another food-related problem (we must\n  have been unusually hungry this year!), and it involved wrangling ratios in\n  recipes. Finally, <i>Play the Dragon</i> presented a game in which coming up\n  with the right strategy would get you the Small, but only very careful\n  implementation and attention to detail would slay the dreaded Large!\n</p><p>\n  Congratulations to our top 1,000 in this round, who advanced to Round 2,\n  and to Eryx, our winner, who finished with a commanding 40-minute lead over\n  the field! (pperm, xyz11, Nore, kmjp and mk.al13n also pulled off perfect scores.)\n  Even if you didn't advance, we still have Rounds 1B and 1C\n  remaining. As usual, we encourage you to take a look at the analyses to check out\n  our approaches and commentary.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Problem A (Alphabet Cake): Written by Pablo Heiber. Prepared by Jackson\n  Gatenby and Lalit Kundu.\n</p><p>\n  Problem B (Ratatouille): Written by Pablo Heiber. Prepared by Shane Carr.\n</p><p>\n  Problem C (Play the Dragon): Written by David Arthur, Steve Thomas, and Ian\n  Tullis. Prepared by John Dethridge.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Md Mahbubul\n  Hasan, Taman (Muhammed) Islam, Michael McMullen, Petr Mitrichev, Rohan\n  Mukkamala, Igor Naverniouk, Dong Xiao, and Josef Ziegler.\n</p>\n<p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Alphabet Cake: Ian Tullis</li>\n  <li>Ratatouille: Pablo Heiber and Ian Tullis</li>\n  <li>Play the Dragon: Ian Tullis</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1492218000000,"tasks":[{"analysis":"<h2>Play the Dragon: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  The Small limits are large enough to foil pure simulation of all possible\n  choices, so we need to have some insights before proceeding.\n</p>\n<ul>\n  <li>The dragon should cure only when it is forced to &mdash; that is, when\n    the knight's next attack would defeat it, and attacking or debuffing would\n    not prevent that. Otherwise, it is always better to do something else.</li>\n  <li>All buffs should come before all attacks, so that each of the dragon's\n    attacks gets the benefit of all of the buffs.</li>\n  <li>The number of buffs directly determines the number of attacks\n    needed.</li>\n  <li>All debuffs should come before all buffs/attacks, so that the total\n    amount of damage the dragon must withstand is minimized.</li>\n  <li>If the knight's first attack will defeat the dragon even if the dragon\n    attacks or debuffs in the first turn, the case is impossible.</li>\n  <li>If the dragon is forced to cure two turns in a row, then the case is\n    impossible, since that implies that the dragon will have to cure every\n    turn.</li>\n</ul>\n<p>\n  These observations add up to a strategy: spend some number D' of turns\n  debuffing, then some number B' of turns buffing, then some number A' of turns\n  attacking, and interleave cures only as needed to not be defeated. Since B'\n  determines A', we only need to consider (D', B') pairs. Since\n  <b>A<sub>k</sub></b> cannot exceed 100, there is no reason to ever do more\n  than 100 debuffs or 100 buffs; moreover, the worst-case scenario can't\n  possibly require more than a couple hundred turns (D' + B' + A'). We can\n  place much smaller upper bounds than those with a little more thought, but it\n  is already clear that direct simulation should be fast enough for the Small\n  dataset.\n</p><p>\n  So, we can proceed with translating the above strategy into code. We must\n  take care to prioritize actions in the right order. In particular, we must\n  avoid curing when we do not need to or failing to cure when we should. Once\n  that is written, we can simulate each possible (D', B') pair and find the\n  global minimum number of turns, or determine that the case is IMPOSSIBLE.\n</p>\n<h3>Large dataset</h3>\n<p>\n  We noted above that all debuffs should come before all buffs/attacks, and\n  that the number of buffs determines the number of attacks. In fact, the\n  buff/attack part of the problem is independent of the debuff part of the\n  problem. Changing the number of debuffs may change the number of cures, but\n  regardless of how many times we debuff, we have nothing to gain by using more\n  than the minimum number of buff + attack turns; that would just make us waste\n  more turns curing.\n</p><p>\n  We can find this minimum number of buff + attack turns as follows. First, we\n  suppose that we will buff 0 times, and we determine the total number of\n  attacks needed to defeat the knight. Then, we can repeatedly increase B' by\n  1 and calculate the number of attack turns A' required at that new level of\n  attack power. As soon as this causes the total to get <i>larger</i>, we can\n  stop (and take the previous total). It is safe to stop at that point because\n  the total number of turns is given by\n</p><p>\n  B' + ceil(<b>H<sub>k</sub></b> / (<b>A<sub>d</sub></b> + B' Ã— <b>B</b>))\n</p><p>\n  The B' part contributes a line with positive slope; the rest contributes a\n  decaying step function. If that step function were a smooth curve, there\n  would be one point at which the rate of decrease from the curve exactly\n  matched the rate of increase from the linear part, and the function would\n  take on our desired minimum there. Because of the discretization, there\n  may actually be multiple values of B' that yield the minimum number of B' +\n  A' turns, but it does not matter which one we choose; only the total matters.\n</p><p>\n  Finding the minimum B' + A' in this way takes O(sqrt(N)) time, where N is the\n  common upper limit for all of the parameters (10<sup>9</sup> for the Large).\n  This is because once we have raised B' to about sqrt(N), we can defeat the\n  knight in about sqrt(N) attack rounds, and there is no need to buff further.\n  It is also possible to solve this part of the problem using binary search or\n  ternary search, or by solving a quadratic equation.\n</p><p>\n  What about the number D' of debuffs? The key observation here is that we do\n  not need to consider every possible value of D'. For instance, suppose that\n  <b>H<sub>d</sub></b> is 100, <b>A<sub>k</sub></b> = 50, and <b>D</b> = 1.\n  Reducing <b>A<sub>k</sub></b> to 49 (which takes 1 turn of debuffing) is as\n  good as reducing <b>A<sub>k</sub></b> to 48 or 34; in all of these cases, the\n  dragon has to cure every other turn. However, reducing <b>A<sub>k</sub></b>\n  to 33 (which takes 17 turns of debuffing) means that the dragon only has to\n  cure on every third turn. We might as well only consider these threshold\n  values of D' = 0, 1, 17, 26, 31...; we can leave out the others. We can find\n  each of these values formulaically in constant time.\n</p><p>\n  Once we have these values, we do not even need to simulate them\n  independently. Note that a simulation with D' = 17 begins by looking like a\n  simulation with D' = 1, since we have to do one debuff before we do the other\n  sixteen. So we can perform a single simulation in which we keep track of\n  a number T of turns used so far, and repeat the following:\n</p>\n<ul>\n  <li>Pretend that we will do no more debuffing. Figure out how many additional\n    turns are needed to buff + attack while curing enough to survive. Compare\n    the total (T plus that number) to the best total we have seen so far.</li>\n  <li>Figure out how many turns are needed to increase the number of debuffs to\n    the next threshold value, while curing enough to survive. Add that number\n    to T.</li>\n</ul>\n<p>\n  It takes additional turns to debuff more, but that debuffing may \"pay for\n  itself\" by saving curing turns during the buff + attack phase. Our strategy\n  will find the right balance.\n</p><p>\n  Instead of actually simulating the turns, we can take advantage of the way we\n  have chosen threshold values of D': in the debuffing period between two of\n  our values of D', the frequency of curing remains constant. So we can\n  calculate the total number of debuff turns + cures via a formula, and we can\n  do the same for the number of cures in the buff + attack phase. With this\n  optimization, the complexity of this step is O(sqrt(N)); since we also took\n  O(sqrt(N)) time to find the optimal number of B' + A' turns, the algorithm is\n  O(sqrt(N)) overall.\n</p><p>\n  All that remains is to actually implement the above, which is perhaps even\n  harder than coming up with the algorithm; there are many opportunities to\n  make off-by-one errors! Although this is not generally the case in Code Jam,\n  in this particular problem, the limits do allow solutions with some but not\n  all of the above insights, and additional low-level optimizations, to pass\n  within the 8-minute window.\n</p>\n","id":"00000000002017f3","statement":"<h3>Problem</h3>\n<p>\n  You are a friendly dragon fighting to protect your lair from a greedy knight!\n  You have <b>H<sub>d</sub></b> health points and an attack power of\n  <b>A<sub>d</sub></b>, and the knight has <b>H<sub>k</sub></b> health points\n  and an attack power of <b>A<sub>k</sub></b>. If your health drops to 0 or\n  below at any point; you are knocked out and you instantly lose; if the\n  knight's health drops to 0 or below at any point, the knight is knocked out\n  and you win!\n</p><p>\n  You will battle the knight in a series of turns. On each turn, you go first,\n  and you can choose and execute any one of the following actions.\n<ul>\n  <li>Attack: Reduce the opponent's health by your own attack power.</li>\n  <li>Buff: Increase your attack power by <b>B</b> for the rest of the\n    battle.</li>\n  <li>Cure: Your health becomes <b>H<sub>d</sub></b>.</li>\n  <li>Debuff: Decrease the opponent's attack power by <b>D</b> for the rest of\n    the battle. If a Debuff would cause the opponent's attack power to become\n    less than 0, it instead sets it to 0.</li>\n</ul>\n<p>\n  Then, if the knight's health is greater than 0 following your action, the\n  knight will execute an Attack action. After that, the turn ends. (Note that\n  a turn in which you defeat the knight still counts as a turn even though\n  the knight does not get to act.)\n</p><p>\n  Note that buffs stack with each other; every buff adds an additional <b>B</b>\n  to your attack power. Similarly, debuffs stack with each other.\n</p>\n  You would like to defeat the knight as fast as possible (if it is possible)\n  so that you will not be late to help the villagers roast marshmallows at\n  tonight's festival. Can you determine the minimum number of turns in which\n  you can defeat the knight, or that it is <code>IMPOSSIBLE</code> to do so?\n</p>\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of one line with six integers\n  <b>H<sub>d</sub></b>,  <b>A<sub>d</sub></b>, <b>H<sub>k</sub></b>,\n  <b>A<sub>k</sub></b>, <b>B</b>, and <b>D</b>, as described above.\n</p>\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is either <code>IMPOSSIBLE</code> if it is not possible to defeat the knight,\n  or the minimum number of turns needed to defeat the knight.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n  1 &le; <b>H<sub>d</sub></b> &le; 100.<br/>\n  1 &le; <b>A<sub>d</sub></b> &le; 100.<br/>\n  1 &le; <b>H<sub>k</sub></b> &le; 100.<br/>\n  1 &le; <b>A<sub>k</sub></b> &le; 100.<br/>\n  0 &le; <b>B</b> &le; 100.<br/>\n  0 &le; <b>D</b> &le; 100.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 240 seconds.<br/>\n  1 &le; <b>H<sub>d</sub></b> &le; 10<sup>9</sup>.<br/>\n  1 &le; <b>A<sub>d</sub></b> &le; 10<sup>9</sup>.<br/>\n  1 &le; <b>H<sub>k</sub></b> &le; 10<sup>9</sup>.<br/>\n  1 &le; <b>A<sub>k</sub></b> &le; 10<sup>9</sup>.<br/>\n  0 &le; <b>B</b> &le; 10<sup>9</sup>.<br/>\n  0 &le; <b>D</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n11 5 16 5 0 0\n3 1 3 2 2 0\n3 1 3 2 1 0\n2 1 5 1 1 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 5\nCase #2: 2\nCase #3: IMPOSSIBLE\nCase #4: 5\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Case #1, you have 11 health and 5 attack, and the knight has 16 health\n  and 5 attack. One possible optimal sequence of actions is:\n  <ul>\n    <li>Turn 1: Attack, reducing the knight's health to 11. Then the knight\n      attacks and reduces your health to 6.\n    </li>\n    <li>Turn 2: Attack, reducing the knight's health to 6. Then the knight\n      attacks and reduces your health to 1.\n    </li>\n    <li>Turn 3: Cure, restoring your health to 11. Then the knight attacks and\n      reduces your health to 6. (If you had attacked instead this turn, the\n      knight's next attack would have caused you to lose.)\n    </li>\n    <li>Turn 4: Attack, reducing the knight's health to 1. Then the knight\n      attacks and reduces your health to 1.\n    </li>\n    <li>Turn 5: Attack, reducing the knight's health to -4. You instantly win\n      and the knight does not get another attack.\n    </li>\n  </ul>\n</p><p>\n  In Case #2, one possible optimal sequence of actions is:\n  <ul>\n    <li>Turn 1: Buff, increasing your attack power to 3. Then the knight\n      attacks and reduces your health to 1.\n    </li>\n    <li>Turn 2: Attack, reducing the knight's health to 0. You instantly win\n      and the knight does not get another attack.\n    </li>\n  </ul>\n</p><p>\n  In Case #3, the knight only needs two attacks to defeat you, and you cannot\n  do enough damage fast enough to defeat the knight. You can indefinitely\n  extend the combat by executing the Cure action after every attack, but it is\n  impossible to actually defeat the knight.\n</p><p>\n  In Case #4, one possible optimal sequence of actions is: Attack, Debuff,\n  Buff, Attack, Attack.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":19},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Play the Dragon","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Alphabet Cake: Analysis</h2>\n\n<h3>A brute force cell filling Small approach</h3>\n<p>\n  In the Small dataset, the cake can consist of at most 12 units. A viable\n  brute-force strategy is to try all ways of filling in every blank cell with\n  each letter already appearing on the cake. If <i>L</i> letters are already\n  present, then we have <i>L</i> possibilities for each of the remaining\n  12-<i>L</i> cells. Then, the number of combinations to try is\n  <i>L</i><sup>(12-<i>L</i>)</sup>, which is a lot less than 12<sup>12</sup>.\n  In this case, since <i>L</i> can range from 1 to 12, inclusive, the maximum\n  value that this can take is 5<sup>7</sup> = 78125</code>, which is a\n  pretty small number for a computer.\n</p><p>\n  One way to check a cake is to first make one pass through the cake, going\n  left-to-right, top-to-bottom, and find each letter's upper leftmost position,\n  lower rightmost position, and frequency. Then, for each letter, check that\n  the rectangle defined by the upper leftmost position and lower rightmost\n  position contains only that letter, and that its area equals the frequency\n  count.\n</p>\n<h3>A brute force rectangle-extending Small approach</h3>\n<p>\n  Another possible strategy is to start at a letter, draw a bounding box around\n  it that includes only <code>?</code>s, move on to another letter, and so on.\n  In the Small dataset, there are relatively few choices for how to draw these\n  bounding boxes. As long as you use other pre-existing letters to prune the\n  possible bounding boxes for each letter, and you carefully check for overlaps\n  and unused cells, an exhaustive search should be fast enough.\n</p><p>\n  There are non-exhaustive strategies similar to this that have the potential\n  to fail, though. Consider this algorithm: for each letter, start with a\n  1-by-1 bounding box containing only that letter. Stretch the box as far as\n  it will go to the top and bottom without hitting other letters, then stretch\n  the box as far as it will go to the left and right without hitting other\n  letters. Depending on the order in which you handle the letters, this can\n  fail. For example, consider this case:\n</p>\n<pre>\n  <code>\n    A?B\n    C??\n    ??D\n    ?EF\n  </code>\n</pre>\n<p>\n  If the algorithm proceeds in left-to-right, top-to-bottom order, it will\n  fill up the grid as follows, leaving an unfilled <code>?</code>:\n</p>\n<pre>\n  <code>\n    AAB\n    C?B\n    CDD\n    CEF\n  </code>\n</pre>\n<h3>A recursive Large approach</h3>\n<p>\n  Fittingly enough for a problem about cake, there is a simple\n  divide-and-conquer strategy for the Large dataset. If the cake has only one\n  letter on it, we can fill it up with that letter. Otherwise, we can make a\n  horizontal or vertical cut that divides the cake into two sub-cakes, such\n  that each part has at least one letter on it; this creates two more instances\n  of the same problem. It is always possible to do this if there are at least\n  two letters on the cake; one surefire way is to make a dividing cut that\n  includes the right border of the leftmost of a pair of letters, or, if they\n  are in the same column, the bottom border of the topmost of the pair.\n</p>\n<h3>A greedy Large approach</h3>\n<p>\n  There is a simple non-recursive approach as well. First, within each row, we\n  can extend each existing letter into all cells to the right of that letter,\n  until we reach another existing letter or the edge of the cake. Then, we can\n  extend the leftmost existing letter (if any) into all cells to the left of\n  that letter.\n</p><p>\n  At this point, any rows that had no existing letters are still empty. We can\n  make a pass through the grid from the second row to the bottom row, replacing\n  each empty row with the row above it. Then we can make one more pass from the\n  next-to-last row up to the top row, replacing each empty row with the row\n  below it.\n</p><p>\n  It is not difficult to prove that it is impossible for this strategy to\n  produce a non-rectangular region for a letter, to produce disjoint regions\n  for a letter, or to leave any cell unfilled.\n</p>\n","id":"0000000000201875","statement":"<h3>Problem</h3>\n<p>\n  You are catering a party for some children, and you are serving them a cake\n  in the shape of a grid with <b>R</b> rows and <b>C</b> columns. Your\n  assistant has started to decorate the cake by writing every child's initial\n  in icing on exactly one cell of the cake. Each cell contains at most one\n  initial, and since no two children share the same initial, no initial\n  appears more than once on the cake.\n</p><p>\n  Each child wants a single rectangular (grid-aligned) piece of cake that\n  has their initial and no other child's initial(s). Can you find a way to\n  assign every blank cell of the cake to one child, such that this goal is\n  accomplished? It is guaranteed that this is always possible. There is no\n  need to split the cake evenly among the children, and one or more of them may\n  even get a 1-by-1 piece; this will be a valuable life lesson about unfairness.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each begins with one line with two integers\n  <b>R</b> and <b>C</b>. Then, there are <b>R</b> more lines of <b>C</b>\n  characters each, representing the cake. Each character is either an\n  uppercase English letter (which means that your assistant has already added\n  that letter to that cell) or <code>?</code> (which means that that cell is\n  blank).\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x:</code> and\n  nothing else. Then output <b>R</b> more lines of <b>C</b> characters each.\n  Your output grid must be identical to the input grid, but with <i>every</i>\n  <code>?</code> replaced with an uppercase English letter, representing that\n  that cell appears in the slice for the child who has that initial. You may\n  not add letters that did not originally appear in the input. In your grid,\n  for each letter, the region formed by all the cells containing that letter\n  must be a single grid-aligned rectangle.\n</p><p>\n  If there are multiple possible answers, you may output any of them.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  There is at least one letter in the input grid.<br/>\n  No letter appears in more than one cell in the input grid.<br/>\n  It is guaranteed that at least one answer exists for each test case.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  1 &le; <b>R</b> &le; 12.<br/>\n  1 &le; <b>C</b> &le; 12.<br/>\n  <b>R</b> &times; <b>C</b> &le; 12.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>R</b> &le; 25.<br/>\n  1 &le; <b>C</b> &le; 25.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3 3\nG??\n?C?\n??J\n3 4\nCODE\n????\n?JAM\n2 2\nCA\nKE\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1:\nGGJ\nCCJ\nCCJ\nCase #2:\nCODE\nCOAE\nJJAM\nCase #3:\nCA\nKE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  The sample output displays one set of answers to the sample cases. Other\n  answers may be possible.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Alphabet Cake","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Ratatouille: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  The number of grams in a given package is not important in and of itself;\n  what is important is which multiples of the recipe that package could be used\n  in. If the base recipe requires 10 g of tomato, for instance, then a 201 g\n  package of tomatoes can be used to make 19, 20, 21, or 22 times the recipe,\n  but not any other multiple. So we can think of this package as the inclusive\n  range [19, 22].\n</p><p>\n  How can we find these ranges? Let Q be the amount in the package and R be the\n  amount of that ingredient required by the base recipe. Then any allowable\n  multiple m must satisfy both 0.9 &times; R &times; m &lt; Q and Q &lt; 1.1\n  &times; R &times; m. Simplifying and rearranging this, we get (10/11) &times;\n  (Q/R) &lt; m &lt; (10/9) &times; (Q/R); any integer value of m that satisfies\n  this inequality is part of the range, and we can find the lower and upper\n  bounds of this range in constant time. (Note that a range might not include\n  <i>any</i> integer values, e.g., for R = 10 and Q = 15.) It is possible to use\n  integer division here and avoid floating point numbers entirely.\n</p><p>\n  In the Small dataset, there can be at most two ingredients. If there is one\n  ingredient, the problem is very simple: each package with a non-empty range\n  (as described above) forms a kit, and each package with an empty range does\n  not.\n</p><p>\n  What if there are two ingredients? Then we need to pair up the packages into\n  kits, but we must be careful, since not any assignment will be optimal. For\n  example, suppose our recipe requires 5 g of A and 10 g of B, and we have the\n  following packages: 45 and 50 of A, and 110 and 111 of B. Converting these to\n  ranges, we get [9, 10] and [10, 11] for A, and [10, 12] and [11, 12] for B.\n  If we pair the [10, 11] package of A with the [10, 12] package of B, then we\n  will be left with a [9, 10] package of A and an [11, 12] package of B, and\n  those cannot be paired. However, we can make two kits by pairing the [9, 10]\n  package of A with the [10, 12] package of B, and the [10, 11] package of A\n  with the [11, 12] package of B.\n</p><p>\n  We could solve the problem via bipartite matching, but it is not needed.\n  Since there can be at most 8 packages of each ingredient in the Small, it is\n  possible to use brute force to try all 8! possible matchings and find the\n  largest number of kits that can be formed.\n</p>\n<h3>Large dataset</h3>\n<p>\n  The following greedy strategy works for the Large, for any number of\n  ingredients:\n</p>\n<ul>\n  <li>Keep making the smallest possible multiple of the recipe that we can.</li>\n  <li>Whenever we have a choice of packets, we choose one with the smallest\n    upper end of the range. Since we are always making the smallest multiple\n    we can, we do not care about the parts of the ranges up to and including\n    that multiple. We only care about how large the upper ends get. Since the\n    ranges are continuous, a range with a larger upper end is strictly more\n    flexible for future pairings than a range with a smaller upper end.</li>\n</ul>\n<p>\n  This strategy would not necessarily be optimal for arbitrary ranges, but it\n  is in this case thanks to the following property: if I<sub>1</sub> and\n  I<sub>2</sub> are the ranges of valid multipliers for the same ingredient,\n  and I<sub>1</sub> is included in I<sub>2</sub>, then I<sub>1</sub> and\n  I<sub>2</sub> have at least one endpoint in common. This is not hard to\n  prove: if I<sub>i</sub> comes from an original packet of size S<sub>i</sub>,\n  if S<sub>1</sub> &le; S<sub>2</sub>, then the lower bound of I<sub>1</sub>\n  must be no greater than the lower bound of I<sub>2</sub>. Otherwise,\n  S<sub>1</sub> &gt; S<sub>2</sub>, so the upper bound of I<sub>1</sub> must be\n  no less than the upper bound of I<sub>2</sub>. Let us call this property 0.\n</p><p>\n  We need some preliminary properties of our greedy algorithm before the main\n  proof:\n<ul>\n  <li><i>Property 1:</i> Whenever it chooses to discard a range, then there was\n    no valid kit remaining to use that range for. This follows directly by the\n    condition to discard ranges.</li>\n  <li><i>Property 2:</i> Whenever it chooses to use a set of ranges to form a\n    kit, and M is the lower bound of the intersection of all those ranges,\n    there is no other set of ranges left that could possibly make a kit with a\n    multiplier strictly less than M. This follows directly from the order in\n    which the ranges are considered.</li>\n</ul>\n<p>\n  Now we can combine all those properties and proceed by contradiction. Let\n  M<sub>1</sub>, M<sub>2</sub>, ..., M<sub>k</sub> be the smallest multipliers\n  of the kits produced by our greedy algorithm, in non-decreasing order. Let\n  N<sub>1</sub>, N<sub>2</sub>, ..., N<sub>k</sub>, N<sub>k+1</sub> be the\n  smallest multipliers of an assignment that produces one more kit, in\n  non-decreasing order.\n</p>\n<ul>\n  <li>Case A: Let i be the minimum i for which N<sub>i</sub> &lt;\n    M<sub>i</sub>. By property 2, that can only happen if there is no set of\n    ranges to make a kit with multiplier N<sub>i</sub>. That means the greedy\n    algorithm discarded such ranges or used them for some previous kit.\n    Property 1 prevents the discarding. Property 0 and the processing order\n    prevented the algorithm from using it before, because if a range R is\n    chosen at some point, all other remaining ranges for that ingredient have\n    an upper bound that is no less than R's, and therefore, such choice can't\n    prevent a future kit for being formed; all other ranges are, at that point,\n    at least as useful as R for larger multipliers.</li>\n  <li>Case B: There is no such i. Again, the greedy algorithm must have some\n    range missing not to be able to produce the kit with multiplier\n    N<sub>k+1</sub>. However, the same argument as in Case A using properties 1\n    and 0 shows that the wrong earlier decision that made that range not\n    available couldn't have happened.</li>\n</ul>\n<p>\n  We can implement this strategy with a separate list for each ingredient,\n  sorted first by nondecreasing lower end of range and then by nondecreasing\n  upper end of range. We keep looking at the set of earliest ranges of the\n  lists. If they all have an intersection, make them into a kit and remove\n  them. Otherwise, remove the least useful range (the one with the smallest\n  upper limit). We can speed this process up by using a priority queue, but\n  with <b>N</b> &times; <b>P</b> &le; 1000, such optimizations are not\n  necessary.\n</p>\n","id":"00000000002018fe","statement":"<h3>Problem</h3>\n<p>\n  You've discovered it: the ultimate recipe for ratatouille, the famous French\n  dish! You know which ingredients to use, and how many grams of each one to\n  use, in order to make one serving of ratatouille. But you believe that anyone\n  can cook, and so you want to share the recipe with the world... and make some\n  money in the process!\n</p><p>\n  You have ordered some ingredient packages that are easy to ship. Each package\n  contains some amount of one ingredient; different packages may have different\n  amounts even if they contain the same ingredient. For convenience, you\n  ordered the same number of packages of each ingredient.\n</p><p>\n  You would like to use these packages to form as many ratatouille <i>kits</i>\n  as possible to send to customers. A kit consists of <i>exactly one</i>\n  package of each ingredient, and a label with the integer number of servings\n  of ratatouille that the kit makes. Since you do not want to shortchange\n  customers or waste food, each package must contain between 90 and 110 percent\n  (inclusive) of the amount of that ingredient that is actually needed to make\n  the number of servings of ratatouille on the kit's label.\n</p><p>\n  For example, suppose that one serving of ratatouille takes 500 g of tomato\n  and 300 g of onion. Suppose that you have a 900 g package of tomato and a\n  660 g package of onion. You could form these into a kit that makes two\n  servings of ratatouille. To make two servings, 1000 g of tomato and 600 g of\n  onion are required. Since the 900 g of tomato you have is within [90, 110]%\n  of the 1000 g of tomato required, and the 660 g of onion you have is within\n  [90, 110]% of the 600 g of onion required, this is acceptable. However, you\n  could not say that the kit makes one or three servings of ratatouille, nor\n  could you say that it makes 1.999 servings (the number of servings must be\n  an integer).\n</p><p>\n  Note that there are some sets of packages that could never form a kit.\n  Continuing with our recipe above, if you have a 1500 g package of tomato and\n  an 809 g package of onion, for example, there is no amount of servings that\n  you can make. Three servings would take 1500 g of tomato and 900 g of onion,\n  and the amount of onion is not within the [90, 110]% range. No other integer\n  amount of servings works, either.\n</p><p>\n  You want to share your recipe with as many customers as possible, so you want\n  to produce the maximum number of valid kits. (Of course, each package can be\n  used in at most one kit.) What is the largest number of kits that you can\n  form? Note that you are <i>not</i> required to maximize the total number of\n  servings of ratatouille formed.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case consists of the following:\n</p>\n<ul>\n  <li>One line with two integers <b>N</b>: the number of ingredients, and\n    <b>P</b>, the number of packages of each ingredient.</li>\n  <li>One line with <b>N</b> integers <b>R<sub>i</sub></b>. The i-th of these\n    represents the number of grams of the i-th ingredient needed to make one\n    serving of ratatouille.</li>\n  <li><b>N</b> more lines of <b>P</b> integers each. The j-th value on the\n    i-th of these lines, <b>Q<sub>ij</sub></b>, represents the quantity, in\n    grams, in the j-th package of the i-th ingredient.</li>\n</ul>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the maximum number of kits you can produce, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>R<sub>i</sub></b> &le; 10<sup>6</sup>, for all i.<br/>\n  1 &le; <b>Q<sub>ij</sub></b> &le; 10<sup>6</sup>, for all i and j.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n  1 &le; <b>N</b> &le; 2.<br/>\n  1 &le; <b>P</b> &le; 8.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\nTime limit: 120 seconds.<br/>\n  1 &le; <b>N</b> &le; 50.<br/>\n  1 &le; <b>P</b> &le; 50.<br/>\n  <b>N</b> &times; <b>P</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">6\n2 1\n500 300\n900\n660\n2 1\n500 300\n1500\n809\n2 2\n50 100\n450 449\n1100 1101\n2 1\n500 300\n300\n500\n1 8\n10\n11 13 17 11 16 14 12 18\n3 3\n70 80 90\n1260 1500 700\n800 1440 1600\n1700 1620 900\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 0\nCase #3: 1\nCase #4: 0\nCase #5: 3\nCase #6: 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Note that the last sample case would not appear in the Small dataset.\n<p></p>\n  Sample cases #1 and #2 are the ones described in the problem statement.\n</p><p>\n  In sample case #3, you can form a kit out of the 450 g package of the first\n  ingredient and the 1100 g package of the second ingredient, and say that the\n  kit makes 10 servings of ratatouille. That number of servings requires 500 g\n  of the first ingredient; you have 450 g, which is 90% of 500 and within the\n  allowed limit. It requires 1000 g of the second ingredient; you have 1100 g,\n  which is 110% of 1000 and within the allowed limit.\n</p><p>\n  Once you form this kit, however, you cannot form the remaining packages into\n  a kit. 449 g of the first ingredient and 1101 g of the second ingredient\n  would not be able to form 10 (or any other number of) servings. In fact, the\n  (450 g, 1100 g) kit is the only kit that can be formed from these packages.\n</p><p>\n  In sample case #4, no kits can be formed. Note that the recipe requires\n  particular amounts of particular ingredients <i>in the given order</i>; the\n  ingredients are not interchangeable. This is fine French cuisine, after all!\n</p><p>\n  In sample case #5, the recipe has only one ingredient &mdash; how elegantly\n  simple! A single serving cannot use more than 11 g, and two servings cannot\n  use fewer than 18 g. It is possible to form three kits: two with an 11 g\n  package, and one with an 18 g package.\n</p><p>\n  In sample case #6, you can form three valid kits: (700 g, 800 g, 900 g),\n  which makes 10 servings, and (1500 g, 1600 g, 1700 g) and (1260 g, 1440 g,\n  1620 g), each of which makes 20 servings. Note that you could also say that\n  the (1260 g, 1440 g, 1620 g) kit makes 17, 18, or 19 servings, but it does\n  not matter how many servings a kit makes as long as the kit is valid.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Ratatouille","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000201843","type":1,"type__str":"SPECTATOR"},"title":"Round 1A 2017"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
