{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1586052000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000019fd27","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  This was Code Jam's first-ever five-problem Qualification Round! Our easiest\n  and hardest problems, <i>Vestigium</i> and <i>Indicium</i>, were both about\n  the <a href=\"https://en.wikipedia.org/wiki/Trace_(linear_algebra)\" target=\"_blank\">traces</a>\n  of <a href=\"https://en.wikipedia.org/wiki/Latin_square\" target=\"_blank\">Latin squares</a>\n  (and both of their names roughly mean \"trace\" in Latin). <i>Vestigium</i>\n  was an implementation problem; <i>Indicium</i> was more daunting, but could\n  be solved in various ways from case work to\n  <a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)#Matching_in_bipartite_graphs\" target=\"_blank\">bipartite matching</a>.\n  Of the middle three problems, <i>Nesting Depth</i> and\n  <i>Parenting Partnering Returns</i> were tractable options for scoring enough\n  points to advance, and <i>ESAb ATAd</i> was a difficult interactive problem\n  (a sequel to last year's\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/\" target=\"_blank\">Dat Bae</a>\n  problem) with a satisfying solution.\n</p><p>\n  Only 1 minute and 53 seconds into the round, <b>arknave</b> submitted the\n  first correct solution of Code Jam 2020! And it didn't even take an hour for\n  <b>xiaowuc1</b>, a legendarily fast Qual Round solver, to earn a perfect\n  score. <b>cki86201</b> and <b>Benq</b> followed with their own perfect scores\n  to claim second and third place, and <b>Golovanov399</b> and <b>Snuke</b>\n  rounded out the top 5 that managed a perfect score within the first 2 hours.\n  Despite the difficulty of the last two problems, 340 users earned a perfect\n  score!\n</p><p>\n  We had over 96000 registrants, 44434\n  (<a href=\"http://codingcompetitions.withgoogle.com/codejam/round/0000000000051705\" target=\"_blank\">22222 + 22212</a>)\n  of whom submitted at least one attempt, and 40697 of whom earned at least one\n  point. Over 30000 contestants qualified for the Round 1s by scoring 30 points\n  or more. All of these numbers are records for Code Jam! Just like last year,\n  we were happy to see submissions in each of our supported languages.\n</p><p>\n  Thank you for joining us for another Qual Round, and we'll see many of you\n  again in Round 1A in a week. (Remember that you can keep trying Round 1s\n  as long as you have not already advanced to Round 2.) If you did not make it\n  to Round 1 this time, we strongly encourage you to try again in 2021, since\n  these things take time and practice! In either case, one way to train is to\n  compete in\n  <a href=\"http://codingcompetitions.withgoogle.com/kickstart\" target=\"_blank\">Kick Start</a>\n  rounds throughout the year...\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Vestigium: Written by the Code Jam team. Prepared by Mohamed Yosri Ahmed.\n</p><p>\n  Nesting Depth: Written by Pablo Heiber. Prepared by Artem Iglikov.\n</p><p>\n  Parenting Partnering Returns: Written by Pablo Heiber and Ian Tullis.\n  Prepared by Jonathan Irvin Gunawan.\n</p><p>\n  ESAb ATAd: Written by Pablo Heiber. Prepared by Pi-Hsun Shih.\n</p><p>\n  Indicium: Written by Darcy Best and Ian Tullis. Prepared by Trung Thanh\n  Nguyen and Ian Tullis.\n</p><p>\n  Solutions and other problem preparation and review by Mohamed Yosri Ahmed,\n  Liang Bai, Darcy Best, Timothy Buzzelli, John Dethridge, Kevin Gu, Jonathan\n  Irvin Gunawan, Md Mahbubul Hasan, Andy Huang, Artem Iglikov, and Pi-Hsun\n  Shih.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Vestigium: Ian Tullis</li>\n  <li>Nesting Depth: Artem Iglikov</li>\n  <li>Parenting Partnering Returns: Jonathan Irvin Gunawan</li>\n  <li>ESAb ATAd: Ian Tullis</li>\n  <li>Indicium: Darcy Best</li>\n</ul>\n","registration_gives_participant":true,"result_status":30,"result_status__str":"FINALIZED","start_ms":1585954800000,"tasks":[{"analysis":"<p>\n  One simple way to check whether the values in a row or column are a\n  permutation of the values from 1 to <b>N</b> is to sort them and then step\n  through them, checking whether the sorted list starts at 1 and increases by 1\n  each time. Another option, which avoids the sort and takes time linear in\n  <b>N</b>, is to look at the values one by one and store each one in a hash\n  table-based data structure. If we ever find that a value is already in\n  the set, then that row or column contains a repeated value. Because there are\n  <b>N</b> values and the problem guarantees that they are integers between 1\n  and <b>N</b>, inclusive, the absence of duplicates implies that we have a\n  permutation as desired.\n</p><p>\n  Finding the trace is also straightforward &mdash; iterate through the rows\n  taking the i-th value from the i-th row, and add the values together.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1irWAo5ieANUvQK-6gzDDkDqSC1ZwV2m5DiuqyU8zPYjs-Ru4F9kVdyB8XvpZO6kPvXCZlDes/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"000000000020993c","statement":"<h3>Problem</h3>\n<p>\n  Vestigium means \"trace\" in Latin. In this problem we work with Latin squares\n  and matrix traces.\n</p><p>\n  The <i>trace</i> of a square matrix is the sum of the values on the main\n  diagonal (which runs from the upper left to the lower right).\n</p><p>\n  An <b>N</b>-by-<b>N</b> square matrix is a <i>Latin square</i> if each\n  cell contains one of <b>N</b> different values, and no value is repeated\n  within a row or a column. In this problem, we will deal only with \"natural\n  Latin squares\" in which the <b>N</b> values are the integers between 1 and\n  <b>N</b>.\n</p><p>\n  Given a matrix that contains only integers between 1 and <b>N</b>, we want to\n  compute its trace and check whether it is a natural Latin square. To give\n  some additional information, instead of simply telling us whether the matrix\n  is a natural Latin square or not, please compute the number of rows and the\n  number of columns that contain repeated values.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each starts with a line containing a single\n  integer <b>N</b>: the size of the matrix to explore. Then, <b>N</b> lines\n  follow. The i-th of these lines contains <b>N</b> integers\n  <b>M<sub>i,1</sub></b>, <b>M<sub>i,2</sub></b> ..., <b>M<sub>i,N</sub></b>.\n  <b>M<sub>i,j</sub></b> is the integer in the i-th row and j-th column of the\n  matrix.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: k r c</code>,\n  where <code>x</code> is the test case number (starting from 1),\n  <code>k</code> is the trace of the matrix, <code>r</code> is the number of\n  rows of the matrix that contain repeated elements, and <code>c</code> is the\n  number of columns of the matrix that contain repeated elements.\n</p>\n\n<h3>Limits</h3>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>N</b> &le; 100.<br/>\n  1 &le; <b>M<sub>i,j</sub></b> &le; <b>N</b>, for all i, j.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U03C3Hunxjk7rlSHn9i-DMfVuCilUkmMpE832yAnUmaj9SA_58W4hupgUo6PWnqLnTWJD7du_UxbAW9Cn_d3fsf2pUzoSCSUQ/vestigium_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n4\n1 2 3 4\n2 1 4 3\n3 4 1 2\n4 3 2 1\n4\n2 2 2 2\n2 3 2 3\n2 2 2 3\n2 2 2 2\n3\n2 1 3\n1 3 2\n1 2 3\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3mBT3nMIYR08AzVFplKaVv71B2EAP-RIdVKdLeIa9XglqioNxk4L-yTp5D98F55mM8-x8j6HkQQmxfwFo7MJ2DLSteVz46NCg/vestigium_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 4 0 0\nCase #2: 9 4 4\nCase #3: 8 0 2\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, the input is a natural Latin square, which means no row or\n  column has repeated elements. All four values in the main diagonal are 1, and\n  so the trace (their sum) is 4.\n</p><p>\n  In Sample Case #2, all rows and columns have repeated elements. Notice that\n  each row or column with repeated elements is counted only once regardless of\n  the number of elements that are repeated or how often they are repeated\n  within the row or column. In addition, notice that some integers in the range\n  1 through <b>N</b> may be absent from the input.\n</p><p>\n  In Sample Case #3, the leftmost and rightmost columns have repeated elements.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":7}],"title":"Vestigium","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  In Test Set 1, there are only 10 positions in the string. We can query for\n  each of them and then submit the complete string, without having to worry\n  about any quantum fluctuations (which would only happen if we submitted an\n  11th query).\n</p>\n<h3>Test Set 2</h3>\n<p>\n  Here is one of various ways to solve the second test set. We begin by\n  querying for the first ten positions in the real string, then create a\n  \"possibility set\" containing all 1024 20-character strings that begin with\n  those 10 characters. Then we update our \"possibility set\" to contain all\n  strings that could have arisen from those strings after the next quantum\n  fluctuation. The correct answer is in here somewhere &mdash; now we need to\n  narrow the set down!\n</p><p>\n  Before making each subsequent query, we first find the string index (between\n  1 and 20) at which the proportion of <code>0</code>s and <code>1</code>s\n  among the strings in our possibility set is most nearly even. Then we query\n  the real string at that index, and eliminate from the possibility set any\n  strings that are not consistent with that information. Whenever we can\n  indeed find a position with even proportions, we are guaranteed to cut the\n  size of the set in half, but if there is no such position, we may not be\n  able to eliminate that many possibilities. We can continue in this way,\n  remembering to expand the possibility set every time there is a quantum\n  fluctuation, until only one possibility remains, which must be the answer.\n</p><p>\n  It is not easy to prove that this strategy will converge upon an answer.\n  Intuitively, we can observe that a quantum fluctuation increases the size\n  of the possibility set by at most 4, and even if we somehow only cut the\n  possiblity set by 20% with each pruning, we would still easily beat that\n  factor-of-4 increase and make enough progress to finish within 150 queries.\n  Moreover, it would not be possible for the strings in the possibility set to\n  all be distinct while being so similar at <i>every</i> individual position\n  (recall that we always pick the position that will be <i>most</i> useful to\n  us in the worst case). Also, Test Set 2 is a Visible Verdict set, so we\n  might as well just submit our answer and see.\n</p>\n<h3>Test Set 3</h3>\n<p>\n  The above strategy will not work for 100-character strings, since the\n  possibility set would be astronomically huge. Fortunately, there is a much\n  simpler approach.\n</p><p>\n  Observe that if we can find two positions that are equidistant from the\n  center of the string and have the same value, we can use them to detect when\n  a quantum fluctuation has included a complementation (with or without a\n  reversal). Suppose, for example, that the two ends of the string are\n  <code>0</code> just before a quantum fluctuation. After the fluctuation, we\n  can check the first one. If it is <code>1</code>, then there was a\n  complementation; if not, there wasn't one. This is true regardless of\n  whether that quantum fluctuation included a reversal.\n</p><p>\n  Now suppose that we continue to check pairs of positions in this way, moving\n  inward one step at a time. After every quantum fluctuation, we must spend\n  one query to check for complementation so we can update our existing\n  knowledge about the string if there has been one. If every pair turns out to\n  be a \"same pair\" like the first pair, then we never needed to care about\n  reversals anyway (since the string is palindromic), and we are done.\n</p><p>\n  But what if, in the course of this, we find a \"different pair\"? Such pairs\n  are helpful in their own way! If we query the first position of a\n  \"different pair\" after a quantum fluctuation and we find that that bit has\n  changed, then we know that either a complementation or reversal has happened,\n  but not both.\n</p><p>\n  Once we have such a \"different pair\", we can use it in conjunction with the\n  \"same pair\", spending 2 out of every 10 queries to learn exactly what happened\n  in each quantum fluctuation. For example, if the first position of our\n  \"same pair\" stayed the same but the first position of our \"different pair\"\n  did not, we know that the quantum fluctuation included a reversal but no\n  complementation.\n</p><p>\n  In the above analysis, we assumed we would encounter a \"same pair\" first. If\n  the first pair is different, though, we can proceed until we encounter a\n  \"same pair\"; if we never encounter one, then we do not care about the\n  distinction between complementation and reversal, because the operations are\n  equivalent for that particular string. If we do encounter a \"same pair\",\n  though, then we can proceed as above.\n</p><p>\n  How many queries will we need in the worst case? We can use all of our first\n  10 to gather data, since whatever happened in the quantum fluctuation at the\n  start of the problem is unknowable and does not matter. After that, we may\n  need to use up to 2 out of every 10 queries to reorient ourselves before\n  spending the remaining 8 gathering data. So, to be sure we can find the\n  entire string, we will need 10 queries, plus 11 more sets of 10 queries in\n  which we learn 8 positions each time, (to get us to 98 positions known),\n  plus 2 more queries for a final reorientation, plus 2 more to get the last\n  two positions. That is a total of 124, which is well within the allowed\n  limit of 150.\n</p>\n<h3>Regarding the name...</h3>\n<p>\n  Last year, we had the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de\" target=\"_blank\">Dat Bae problem</a>\n  about deletions from a string in a database; the name was\n  <code>Data Base</code>, altered in a way that reflected the theme.\n  <code>ESAb ATAd</code> is similar, with case change serving as a rough\n  equivalent of complementation. (Imagine how much the Code Jam team has\n  enjoyed trying to type the name correctly each time!)\n</p>\n","id":"0000000000209a9e","statement":"<h3>Problem</h3>\n<p>\n  Last year, a research consortium\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/round/0000000000051705/00000000000881de\" target=\"_blank\">had some trouble</a>\n  with a distributed database system that sometimes lost pieces of the data.\n  You do not need to read or understand that problem in order to solve this\n  one!\n</p><p>\n  The consortium has decided that distributed systems are too complicated, so\n  they are storing <b>B</b> bits of important information in a\n  single array on one awesome machine. As an additional layer of security,\n  they have made it difficult to obtain the information quickly; the user must\n  query for a bit position between 1 and <b>B</b>, and then they receive that\n  bit of the stored array as a response.\n</p><p>\n  Unfortunately, this ultra-modern machine is subject to random quantum\n  fluctuations! Specifically, after every 1st, 11th, 21st, 31st... etc. query\n  is sent, <i>but before the response is given</i>, quantum fluctuation causes\n  exactly one of the following four effects, with equal probability:\n</p>\n<ul>\n  <li>25% of the time, the array is complemented: every <code>0</code> becomes\n    a <code>1</code>, and vice versa.</li>\n  <li>25% of the time, the array is reversed: the first bit swaps with the last\n    bit, the second bit swaps with the second-to-last bit, and so on.</li>\n  <li>25% of the time, both of the things above (complementation and reversal)\n    happen to the array. (Notice that the order in which they happen does not\n    matter.)</li>\n  <li>25% of the time, nothing happens to the array.</li>\n</ul>\n<p>\n  Moreover, there is no indication of what effect the quantum fluctuation\n  has had each time. The consortium is now concerned, and it has hired you\n  to get its precious data back, in whatever form it is in! Can you find\n  the entire array, such that your answer is accurate\n  <i>as of the time that you give it</i>? Answering does not count as a query,\n  so if you answer after your 30th query, for example, the array will be the\n  same as it was after your 21st through 30th queries.\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the\n  information in the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of our FAQ.\n</p><p>\n  Initially, your program should read a single line containing two integers\n  <b>T</b> and <b>B</b>: the number of test cases and the number of bits\n  in the array, respectively. Note that <b>B</b> is the same for every test\n  case.\n</p><p>\n  Then, you need to process <b>T</b> test cases. In each case, the judge begins\n  with a predetermined <b>B</b>-bit array; note that this array can vary from\n  test case to test case, and is not necessarily chosen at random. Then, you\n  may make up to 150 queries of the following form:\n</p>\n<ul>\n  <li>Your program outputs one line containing a single integer P between 1 and\n    <b>B</b>, inclusive, indicating which position in the array you wish to\n    look at.\n  </li><li>\n    If the number of queries you have made so far ends with a 1, the judge\n    chooses one of the four possibilities described above (complementation,\n    reversal, complementation + reversal, or nothing), uniformly at random and\n    independently of all other choices, and alters the stored array\n    accordingly. (Notice that this will happen on the very first query\n    you make.)\n  </li><li>\n    The judge responds with one line containing a single character\n    <code>0</code> or <code>1</code>, the value it currently has stored at bit\n    position P, or <code>N</code> if you provided a malformed line (e.g., an\n    invalid position).\n  </li>\n</ul>\n<p>\n  Then, after you have made as many of the 150 queries above as you want, you\n  must make one more exchange of the following form:\n</p>\n<ul>\n  <li>Your program outputs one line containing a string of <b>B</b> characters,\n    each of which is <code>0</code> or <code>1</code>, representing the bits\n    <i>currently</i> stored in the array (which will not necessarily match the\n    bits that were initially present!)\n  </li>\n  <li>\n    The judge responds with one line containing a single letter:\n    uppercase <code>Y</code> if your answer was correct, and uppercase\n    <code>N</code> if it was not (or you provided a malformed line).\n    If you receive <code>Y</code>, you should begin the next test case,\n    or stop sending input if there are no more test cases.\n  </li>\n</ul>\n<p>\n  After the judge sends <code>N</code> to your input stream, it will not send\n  any other output. If your program continues to wait for the judge after\n  receiving <code>N</code>, your program will time out, resulting in a Time\n  Limit Exceeded error. Notice that it is your responsibility to have your\n  program exit in time to receive a Wrong Answer judgment instead of a Time\n  Limit Exceeded error. As usual, if the memory limit is exceeded, or your\n  program gets a runtime error, you will receive the appropriate judgment.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 40 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  <b>B</b> = 10.<br/>\n</p>\n\n<h4>Test set 2 (Visible Verdict)</h4>\n<p>\n  <b>B</b> = 20.<br/>\n</p>\n\n<h4>Test set 3 (Hidden Verdict)</h4>\n<p>\n  <b>B</b> = 100.<br/>\n</p>\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our servers.\n  To test locally, you will need to run the tool in parallel with your code;\n  you can use our\n  <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\" target=\"_blank\">interactive runner</a>\n  for that. <b>The interactive runner was changed after the 2019 contest. Be sure to download the\n  latest version.</b> For more information, read the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p>\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3JLm8cdltEmu8M8HeJcQifp8wFi2d5iWdw_1Rz3ZFO6gpOaAkBj6umEd7vgML928QnAPACObbyXqLxIpgiSg/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n\n<p>\n  The following interaction corresponds to Test Set 1.\n</p>\n\n<pre>\n  t, b = readline_int_list()      // reads 100 into t and 10 into b.\n  // The judge starts with the predetermined array for this test case:\n  // 0001101111. (Note: the actual Test Set 1 will not necessarily\n  // use this array.)\n  printline 1 to stdout   // we ask about position 1.\n  flush stdout\n  // Since this is our 1st query, and 1 is 1 mod 10, the judge secretly and\n  // randomly chooses one of the four possible quantum fluctuation effects, as\n  // described above. It happens to choose complementation + reversal, so now\n  // the stored value is 0000100111.\n  r = readline_chr()      // reads 0.\n  printline 6 to stdout   // we ask about position 6.\n  flush stdout\n  // Since this is our 2nd query, and 2 is 2 mod 10, the judge does not choose\n  // a quantum fluctuation effect.\n  r = readline_chr()      // reads 0.\n  ...\n  // We have omitted the third through tenth queries in this example.\n  ...\n  printline 1 to stdout   // we decide to ask about position 1 again.\n  flush stdout\n  // Since this is our 11th query, and 11 is 1 mod 10, the judge secretly and\n  // randomly chooses a quantum fluctuation effect, and happens to get\n  // reversal, so now the stored value is 1110010000.\n  r = readline_chr()      // reads 1.\n  printline 1110110000 to stdout   // we try to answer. why?!?!\n  flush stdout\n  ok = readline_chr()     // reads N -- we have made a mistake!\n  exit                    // exits to avoid an ambiguous TLE error\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":1},{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":16}],"title":"ESAb ATAd","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  To solve Test Set 1, we can put an opening parenthesis before each group of <code>1</code>s and a\n  closing parenthesis after.\n</p>\n<p>\n  We can use the following trick to simplify the implementation: prepend and append one extra\n  <code>0</code> to <b>S</b>. Then the implementation is just replacing <code>01</code> with\n  <code>0(1</code> and <code>10</code> with <code>1)0</code>, which can be written in one line of\n  code in some programming languages. Don't forget to remove the extra <code>0</code>s from the\n  end of the resulting string!\n</p>\n<h3>Test Set 2</h3>\n<p>\n  For convenience, let's once again use the trick described above: prepend and append extra\n  <code>0</code>s to <b>S</b>, and then scan <b>S</b> from left to right.\n</p>\n<p>\n  Suppose we see some number A immediately followed by some larger number B and suppose all of the\n  previously inserted parentheses would leave A at the right nesting depth &mdash; that is,\n  there are exactly A unmatched opening parentheses preceding A, and no unmatched\n  closing parentheses. For B to be at nesting depth B we need to add at least B - A opening\n  parentheses. We can just do that and nothing else, to keep the final string length minimal.\n  Any additional opening parentheses we would add would need to be closed before B, which would\n  needlessly lengthen the string.\n  Similarly, if we see some number A immediately followed by some smaller number B, we can just\n  insert A - B closing parentheses. And in the case when A is equal to B, we don't need to add\n  anything.\n</p>\n<p>\n  We don't need any parentheses before the temporary <code>0</code>\n  in the beginning, or after the one in the end, so we can just drop them before printing the\n  result.\n<p>\n  Since we only add p parentheses when at least p are needed, the resulting string is of minimum\n  length.\n</p>\n<h3>An inefficient but fun solution</h3>\n<p>\n  The problem can be solved using only string replacements. First, replace each\n  digit D with D <code>(</code>s, then the digit itself, then D\n  <code>)</code>s. Then eliminate all instances of <code>)(</code>, collapsing\n  the string each time, until there are no more to remove.\n</p><p>\n  Here's a Python3 implementation:\n</p>\n<pre>\nfor C in range(int(input())):\n  rawstr = ''.join([int(x) * '(' + x + ')' * int(x) for x in str(input())])\n  for _ in range(9):\n    rawstr = rawstr.replace(')(', '')\n  print(\"Case #{}: {}\".format(C+1, rawstr))\n</pre>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U15T82o4Xqt3MbpcecSwvygDehTPGXggZ2HMvdP2uH-DKBA5KKjm6Orx6wdZklubm_BfOGH1OQ/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"0000000000209a9f","statement":"<h3>Problem</h3>\n<p>\n  tl;dr: Given a string of digits <b>S</b>, insert a minimum number of opening\n  and closing parentheses into it such that the resulting string is balanced and\n  each digit d is inside exactly d pairs of matching parentheses.\n</p><p>\n  Let the <i>nesting</i> of two parentheses within a string be the substring\n  that occurs strictly between them. An opening parenthesis and a closing\n  parenthesis that is further to its right are said to <i>match</i> if their\n  nesting is empty, or if every parenthesis in their nesting matches with\n  another parenthesis in their nesting. The <i>nesting depth</i> of a position\n  p is the number of pairs of matching parentheses m such that p is included in\n  the nesting of m.\n</p><p>\n  For example, in the following strings, all digits match their nesting\n  depth: <code>0((2)1)</code>, <code>(((3))1(2))</code>, <code>((((4))))</code>,\n  <code>((2))((2))(1)</code>. The first three strings have minimum length among\n  those that have the same digits in the same order, but the last one does not\n  since <code>((22)1)</code> also has the digits <code>221</code> and is\n  shorter.\n</p><p>\n  Given a string of digits <b>S</b>, find another string S',\n  comprised of parentheses and digits, such that:\n  <ul>\n    <li>all parentheses in S' match some other parenthesis,</li>\n    <li>removing any and all parentheses from S' results in <b>S</b>,</li>\n    <li>each digit in S' is equal to its nesting depth, and</li>\n    <li>S' is of minimum length.</li>\n  </ul>\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> lines follow. Each line represents a test case and contains only the\n  string <b>S</b>.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the string S' defined above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; length of <b>S</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  Each character in <b>S</b> is either <code>0</code> or <code>1</code>.<br/>\n</p>\n\n<h4>Test set 2 (Visible Verdict)</h4>\n<p>\n  Each character in <b>S</b> is a decimal digit between <code>0</code> and\n  <code>9</code>, inclusive.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2NT90a-VIOcVQjPV93pslpy5PomWhWv8Djf1q9mHbEaCISiSyCdjcG3rawKIB1vrVdkGsoe2eigOMRhRLg53JtsVcF9MN3u157pJ8/nesting_depth_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n0000\n101\n111000\n1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0_R8a3BOtdSPhI9jWKUST1RVysbF3cYt40dmTC2RlZVSY_a3PcHNLsbHzUgB1KFGMeWqfxoAOd3TCg3NhkZb4vHzB97UCep0u7qsyI/nesting_depth_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 0000\nCase #2: (1)0(1)\nCase #3: (111)000\nCase #4: (1)\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  The strings <code>()0000()</code>, <code>(1)0(((()))1)</code> and\n  <code>(1)(11)000</code> are not valid solutions to Sample Cases #1, #2 and\n  #3, respectively, only because they are not of minimum length. In addition,\n  <code>1)(</code> and <code>)(1</code> are not valid solutions to Sample Case\n  #4 because they contain unmatched parentheses and the nesting depth is 0\n  at the position where there is a 1.\n</p><p>\n  You can create sample inputs that are valid only for Test Set 2 by removing\n  the parentheses from the example strings mentioned in the problem statement.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":11}],"title":"Nesting Depth","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  There are a few different options for solving test set 1. Since there are only 44\n  possible cases, one option is to generate all answers by hand or via a program\n  that is run locally, then submit a program that dispenses those. Another\n  approach is to notice that\n  there are not many different Latin squares for <b>N</b> &le; 5 (see the number of Latin\n  squares <a href=\"https://oeis.org/A002860\" target=\"_blank\">here</a>), and check them all.\n  To generate all Latin squares,\n  we can recursively fill in the cells one by one. For each cell, we try all <b>N</b>\n  possible values. For each one, we ensure that it does not conflict with any\n  cells in the same row or same column. Since there are at most 161280 Latin squares\n  to consider, this is quite quick.\n</p>\n<h3>Test Set 2</h3>\n<p>\n  Unfortunately, once <b>N</b> gets even slightly large, there are way too many Latin\n  squares to generate them all (for <b>N</b> = 11, for example, there are\n  776966836171770144107444346734230682311065600000 different Latin squares).\n</p><p>\n  There are many creative ways to solve this test set. The\n  <a href=\"https://groups.google.com/forum/#!forum/google-code\" target=\"_blank\">Code Jam forum</a>\n  is a good place to share and discuss different solutions!\n  For example, we can directly create Latin squares with the appropriate trace\n  by modifying structured Latin squares (for example, by modifying\n  <a href=\"https://en.wikipedia.org/wiki/Circulant_matrix#Definition\" target=\"_blank\">circulant Latin squares</a>).\n  Below, we discuss an easy-to-implement idea which is a little tricky to come up with and uses\n  a graph algorithm in the middle!\n</p><p>\n  First, we start by dealing with the impossible cases. If <b>K</b> = <b>N</b>+1, then the only\n  possible diagonals have exactly one <code>2</code> and <b>N</b>-1 <code>1</code>s. However, if\n  <b>N</b>-1 of the diagonal\n  elements are <code>1</code>, then the only location for the <code>1</code> in the remaining\n  row must be on\n  the diagonal, so we cannot make a sum of <b>N</b>+1. Similarly, we cannot make a sum\n  of <b>N</b><sup>2</sup>-1 since the only possible diagonal is one <code>N-1</code>\n  and <b>N</b>-1 <code>N</code>s.\n</p><p>\n  We will now show a construction which works for every other case (with 2 additional small cases that don't work, see below).\n  One of the main insights needed is that all possible sums are achievable\n  using a diagonal with almost all values the same. In particular, we may assume\n  that at least <b>N</b>-2 values are the same: AAAA ... AABC\n  for some A, B, C (not necessarily all different).\n</p><p>\n  For example, if <b>N</b> = 10 and <b>K</b> = 20, we can choose A = 2, B = 2, and C = 2. If <b>N</b> = 10\n  and <b>K</b> = 55, we can choose A = 6, B = 4, and C = 3. We already showed above that\n  A = B if and only if A = C. We leave it as an exercise to show that all values for\n  <b>K</b> between <b>N</b> and <b>N</b><sup>2</sup> are possible with these constraints. (Note: you have\n  to be a little careful with <b>N</b> = 3. If B = C, then A = B = C for a similar reason; so with\n  <b>N</b> = 3, neither <b>K</b> = 5 nor <b>K</b> = 7 will have solutions).\n  To find the appropriate values of A, B, and C, we can brute force all possible triples\n  and check whether the chosen diagonal will work.\n</p><p>\n  Now that we know what the diagonal looks like, how do we actually find a Latin\n  square that has this diagonal? To do that, we will fill in the unfilled cells\n  row by row. We will use\n  <a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)\" target=\"_blank\">bipartite matching</a>\n  to find a valid row. In one bipartition,\n  we have <b>N</b> vertices for the <b>N</b> cells in that row. In the other bipartition, we have\n  <b>N</b> vertices for the <b>N</b> numbers that can be placed into the cell. Make an edge between\n  the cell vertex on the diagonal and the number vertex that was decided on. For\n  every other cell, make an edge\n  between a cell vertex and a number vertex if that number can be put into that\n  cell without breaking the Latin square properties.\n</p><p>\n  We can greedily pick any perfect matching for each row <i>starting with the rows with B and\n  C on their diagonal</i>.\n  Once we have filled in these two rows, we can use\n  <a href=\"https://en.wikipedia.org/wiki/Hall%27s_marriage_theorem\" target=\"_blank\">Hall's Marriage Theorem</a>\n  to show that we will never run into any issues (so long as the conditions\n  above about A, B, C are met).\n</p>\n<h3>Hall's Theorem</h3>\n<p>\n  This section is dedicated to proving the above claim that Hall's theorem holds. We will\n  assume in this section that the reader is comfortable with Hall's theorem.\n  A one sentence high-level reminder of Hall's theorem: <i>All subsets of one bipartition\n  have a neighborhood that is at least as large as the original subset if and only\n  if the graph has a perfect matching.</i>\n</p><p>\n  For the explanation here, we will make the top two rows with B and C on their diagonal\n  as the top two rows. We'll assume that these two rows are already filled in (and leave the\n  proof you can do this to the reader). The important part is that the top-left 2 &times; 2\n  submatrix is <code>CA</code>/<code>AB</code>. Now imagine that we have filled in\n  <b>N</b>-k rows (and have k mostly empty rows). Consider this example with <b>N</b> = 8\n  and k = 3.\n  (<code>?</code> means filled in, but it doesn't matter with what and <code>_</code>\n  means not filled in yet):\n</p><div style=\"padding-left:2em\"><pre>\nCA??????\nAB??????\n??A?????\n???A????\n????A???\n_____A__\n______A_\n_______A\n</pre></div><p>\n  For each of the <b>N</b>-1 non-<code>A</code>\n  \"cell vertices\", the <b>N</b>-k vertices on the left\n  of the diagonal have a degree of k and the k-1 vertices on the right of the diagonal\n  have a degree of k-1 (because the number <code>A</code> is also restricted).\n  For each of the <b>N</b>-1 non-<code>A</code> \"number vertices\", each number originally had\n  degree <b>N</b> and we have removed at least <b>N</b>-k of those edges since the number\n  appeared once in the top <b>N</b>-k rows. Thus, the maximum degree of the \"number vertices\"\n  is k.\n</p><p>\n  We will ignore the \"cell vertex\" and the \"number vertex\" corresponding to the forced diagonal\n  entry since that will be forced in our matching (and leaving it out makes our math below\n  easier).\n</p><p>\n  Let X be a subset of \"cell vertices\". Let m = |X|. We must show that |N(X)| &ge; m in order\n  to utilize Hall's theorem (where N(X) is the set of \"number vertices\" that are adjacent\n  to at least one vertex in X). We have 2 separate cases:\n</p><div style=\"padding-left:2em\">\n  <p>\n    <b>Case 1:</b> m &le; k-1.\n  </p><p>\n    Since the degree of each vertex in X is at least k-1, the number of edges leaving X\n    is at least m &times; (k-1). Consider the \"number vertices\" that these edges are\n    absorbed into. Since the maximum degree of \"number vertices\" is k, there are at\n    least (m &times; (k-1))/k \"number vertices\" that absorb these edges. That is,\n    |N(X)| &ge; (m &times; (k-1))/k = m-m/k.\n    Since m &le; k-1, we have that m/k &lt; 1. So |N(X)| &gt; m-1. Since |N(X)| is an integer,\n    we have |N(X)| &ge; m as desired.\n  </p><p>\n    <b>Case 2:</b> m &ge; k.\n  </p><p>\n    Consider the edges leaving X. At most k-1 of them have degree k-1, and the remaining have\n    degree k. Thus, the number of edges leaving X is at least\n    (k-1) &times; (k-1) + (m-(k-1)) &times; k.\n    Since the maximum degree of \"number vertices\" is k, there are at\n    least ((k-1) &times; (k-1) + (m-(k-1)) &times; k)/k \"number vertices\" that absorb these\n    edges. That is, |N(X)| &ge; ((k-1) &times; (k-1) + (m-(k-1)) &times; k)/k = m - (1 - 1/k).\n    Since 1 - 1/k &lt; 1, we have |N(X)| &gt; m-1. Since |N(X)| is an integer,\n    we have |N(X)| &ge; m as desired.\n  </p>\n</div>\n<p>\n  Thus, in all cases, the conditions for Hall's theorem are satisfied, so there exists a\n  perfect matching and we can iteratively complete the Latin square.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2x3SQ8ZkIgjKosdY9E8k-qF7mErkajf6SO4l4YeGnpqa8HK-l_o0aqphttkQ_Z3rDicCIn4vY/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"0000000000209aa0","statement":"<h3>Problem</h3>\n<p>\n  Indicium means \"trace\" in Latin. In this problem we work with Latin squares and\n  matrix traces.\n</p><p>\n  A <i>Latin square</i> is an <b>N</b>-by-<b>N</b> square matrix in which each\n  cell contains one of <b>N</b> different values, such that no value is\n  repeated within a row or a column. In this problem, we will deal only with\n  \"natural Latin squares\" in which the <b>N</b> values are the integers between\n  1 and <b>N</b>.\n</p><p>\n  The <i>trace</i> of a square matrix is the sum of the values on the main\n  diagonal (which runs from the upper left to the lower right).\n</p><p>\n  Given values <b>N</b> and <b>K</b>, produce any <b>N</b>-by-<b>N</b> \"natural\n  Latin square\" with trace <b>K</b>, or say it is impossible. For example, here\n  are two possible answers for <b>N</b> = 3, <b>K</b> = 6. In each case, the\n  values that contribute to the trace are underlined.\n</p><p>\n<code>\n  <u>2</u> 1 3&nbsp;&nbsp;&nbsp;<u>3</u> 1 2<br/>\n  3 <u>2</u> 1&nbsp;&nbsp;&nbsp;1 <u>2</u> 3<br/>\n  1 3 <u>2</u>&nbsp;&nbsp;&nbsp;2 3 <u>1</u><br/>\n</code>\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of one line containing two integers\n  <b>N</b> and <b>K</b>: the desired size of the matrix and the desired trace.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is <code>IMPOSSIBLE</code> if there is no answer for the given parameters or\n  <code>POSSIBLE</code> otherwise. In the latter case, output <b>N</b> more\n  lines of <b>N</b> integers each, representing a valid \"natural Latin square\"\n  with a trace of <b>K</b>, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  <b>N</b> &le; <b>K</b> &le; <b>N</b><sup>2</sup>.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  <b>T</b> = 44.<br/>\n  2 &le; <b>N</b> &le; 5.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>N</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1mApWTE0zBXNvwcHwDye4_VzESnguyH5S5QiS9Bh3MPUyRYmvVzYW6xmUQ1nOHD1dklxMpQqW9woptJK-lN_fspeiwa12H/indicium_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n3 6\n2 3\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0iaCHZnB39FS9N6Iy9JzM6OAVw5-_GVDyF2XkJVhE4qMn_ioSEqEJ2q4LV-AxdQjesIAqMG4VTzP_AP6mlnohDYNrKSMsIeA/indicium_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: POSSIBLE\n2 1 3\n3 2 1\n1 3 2\nCase #2: IMPOSSIBLE\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Sample Case #1 is the one described in the problem statement.\n</p><p>\n  Sample Case #2 has no answer. The only possible 2-by-2\n  \"natural Latin squares\" are as follows:\n</p>\n<code>\n  1 2&nbsp;&nbsp;&nbsp;2 1<br/>\n  2 1&nbsp;&nbsp;&nbsp;1 2<br/>\n</code>\n<p>\n  These have traces of 2 and 4, respectively. There is no way to get a trace\n  of 3.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Indicium","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  We can solve this test set by naively trying every possible subset of activities to be covered by\n  Jamie and assign the rest of the activities to be covered by Cameron. For each subset of\n  activities, we can check whether a pair of activities overlap for each pair of activities.\n  An activity with start time s<sub>1</sub> and end time t<sub>1</sub> overlaps with another\n  activity with start time s<sub>2</sub> and end time t<sub>2</sub> if the time intersection is\n  not empty (i.e., max(s<sub>1</sub>, s<sub>2</sub>) &lt; min(t<sub>1</sub>, t<sub>2</sub>)).\n</p><p>\n  The running time of this solution is O(2<sup><b>N</b></sup> &times; <b>N</b><sup>2</sup>), which\n  is fast enough to solve Test Set 1.\n</p>\n<h3>Test Set 2</h3>\n<p>\n  We can solve this test set by greedily assigning the activities in increasing order of start time.\n  For each activity (in increasing order of start time), we can check whether Jamie or Cameron can\n  be assigned to cover the activity and assign the activity to whomever can be assigned to (or\n  arbitrarily if both partners can be assigned). The check can be done by iterating all activities\n  that have been previously assigned to Jamie and Cameron.\n</p><p>\n  The greedy assignment is correct because the only way that the assignment fails is when there is a\n  time that is covered by three activities. In such a case, there is indeed no valid assignment.\n  When deciding who to assign an activity with start time s, only activities with start times no\n  later than s have been assigned. Therefore, if both Jamie and Cameron have some activity assigned\n  with end time later than s, it means that there are three activities that use the time between s\n  and s + 1, and therefore, there is no possible assignment. If an assignment is possible, there\n  cannot be any set of three activities that pairwise overlap, so by the contrapositive of the the\n  previous argument, we will be able to assign the activity to at least one of Jamie or Cameron at\n  every step.\n</p><p>\n  The running time of this solution is O(<b>N</b><sup>2</sup>), which is fast enough to solve this\n  test set. To optimize the solution to O(<b>N</b> log <b>N</b>) time, we can efficiently check\n  whether an activity can be assigned to Jamie or Cameron by keeping track of the end time of the\n  last activity assigned to each partner and comparing this to the start time of the new activity.\n  In this case, only O(<b>N</b>) extra time is needed after sorting the activities by their start\n  time.\n</p>\n<h4>\n  Graph approach\n</h4>\n<p>\n  Another possible approach to solve this test set is to construct a\n  <a href=\"https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)\">graph</a> with <b>N</b>\n  nodes, each representing one activity. We add an edge connecting a pair of nodes if the pair of\n  activities represented by the nodes overlap (see Test Set 1 section for details on how to check if\n  two intervals overlap). This graph is commonly known as an\n  <a href=\"https://en.wikipedia.org/wiki/Interval_graph\">interval graph</a>.\n</p><p>\n  Therefore, the problem is equivalent to <a href=\"https://en.wikipedia.org/wiki/Bipartite_graph\">\n  finding a partition of nodes C and J such that every edge connects a node in C and a node in\n  J</a>, as we can assign all activities represented by nodes in C to Cameron and all activities\n  represented by nodes in J to Jamie. The running time of the algorithm to find the partition (or\n  report if one does not exist) is linear on the size of the graph. The graph has <b>N</b> nodes and\n  O(<b>N</b><sup>2</sup>) edges, which means the solution requires O(<b>N</b><sup>2</sup>) time to\n  build the graph and O(<b>N</b><sup>2</sup>) time to run the partition algorithm, so also\n  O(<b>N</b><sup>2</sup>) time overall.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1J2It45cwgUfjEbt9mj-e8bGuYC-tdgN0a7O01GGRmPU7UG3RzgcZ-pRX94jutCW2elyWI1Mo/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"000000000020bdf9","statement":"<h3>Problem</h3>\n<p>\nCameron and Jamie's kid is almost 3 years old! However, even though the child is more independent\nnow, scheduling kid activities and domestic necessities is still a challenge for the couple.\n</p><p>\nCameron and Jamie have a list of <b>N</b> activities to take care of during the day. Each activity\nhappens during a specified interval during the day. They need to assign each activity to one\nof them, so that neither of them is responsible for two activities that overlap.\nAn activity that ends at time t is not considered to overlap with another activity that\nstarts at time t.\n</p><p>\nFor example, suppose that Jamie and Cameron need to cover 3 activities: one running\nfrom 18:00 to 20:00, another from 19:00 to 21:00 and another from 22:00 to 23:00.\nOne possibility would be for Jamie to cover the activity running from 19:00 to 21:00,\nwith Cameron covering the other two. Another valid schedule would be for Cameron to\ncover the activity from 18:00 to 20:00 and Jamie to cover the other two. Notice\nthat the first two activities overlap in the time between 19:00 and 20:00, so it is\nimpossible to assign both of those activities to the same partner.\n</p><p>\nGiven the starting and ending times of each activity, find any schedule that does not require\nthe same person to cover overlapping activities, or say that it is impossible.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\nEach test case starts with a line containing a single integer <b>N</b>, the number of activities\nto assign. Then, <b>N</b> more lines follow. The i-th of these lines (counting starting from 1)\ncontains two integers <b>S<sub>i</sub></b> and <b>E<sub>i</sub></b>.\nThe i-th activity starts exactly <b>S<sub>i</sub></b> minutes after\nmidnight and ends exactly <b>E<sub>i</sub></b> minutes after midnight.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where <code>x</code> is\nthe test case number (starting from 1) and <code>y</code> is <code>IMPOSSIBLE</code> if there\nis no valid schedule according to the above rules, or a string of exactly <b>N</b> characters\notherwise. The i-th character in <code>y</code> must be <code>C</code> if the i-th activity\nis assigned to Cameron in your proposed schedule, and <code>J</code> if it is assigned to\nJamie.\n</p><p>\n  If there are multiple solutions, you may output any one of them. (See\n  \"What if a test case has multiple correct solutions?\" in the Competing\n  section of the\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#competing\">FAQ</a>. This\n  information about multiple solutions will not be explicitly stated in the\n  remainder of the 2020 contest.)\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &le; <b>S<sub>i</sub></b> &lt; <b>E<sub>i</sub></b> &le; 24 &times; 60.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n2 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Test set 2 (Visible Verdict)</h4>\n<p>\n2 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1JNlRjVshh43fbQIKKQDNvsiggvn7oN-LmrqWHDaRmIACm-YZFhZQRj24_i31CICJi3n3g_gydFO8ghllZlacFy1gdiu2dHySFtxGE0yaEJvQ65RpDIxKxAgI/parenting_partnering_returns_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n3\n360 480\n420 540\n600 660\n3\n0 1440\n1 3\n2 4\n5\n99 150\n1 100\n100 301\n2 5\n150 250\n2\n0 720\n720 1440\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2XLhY7zEJ29qACQOYXOctxZPh3AbWzHu-h5hy_Q-i3J9a2q0FKJE0qG_ocjgSvEIgJGBgIzJ4GpVNbUg45AO_YDjG5efHTDD63eTc3WFwmuIkqHdTQl2-5VxZo/parenting_partnering_returns_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: CJC\nCase #2: IMPOSSIBLE\nCase #3: JCCJJ\nCase #4: CC\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Sample Case #1 is the one described in the problem statement. As mentioned above, there are other\n  valid solutions, like <code>JCJ</code> and <code>JCC</code>.\n</p><p>\n  In Sample Case #2, all three activities overlap with each other. Assigning them all would mean\n  someone would end up with at least two overlapping activities, so there is no valid schedule.\n</p><p>\n  In Sample Case #3, notice that Cameron ends an activity and starts another one at minute 100.\n</p><p>\n  In Sample Case #4, any schedule would be valid. Specifically, it is OK for one partner to do\n  all activities.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":7},{"type":1,"type__str":"VISIBLE","value":12}],"title":"Parenting Partnering Returns","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000019fd27","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2020"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
