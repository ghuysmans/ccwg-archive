{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1430591400000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000433551","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nRound 1B was considerably tougher than Round 1A, with no clear “easy” Large input.\nCounter Culture is solvable using a fairly simple algorithm, but it’s not trivial to get the details right, and 31% of attempts on the Large input failed.\nNoisy Neighbors is an ad hoc problem that requires some clever insight to see the correct strategy, and there's a corner case that is easy to overlook.\nHiking Deer was very challenging for a Round 1 problem -- its second Small input was worth more than each of the other two problems’ Large inputs! Its Large, which set a daunting bar of up to 500000 hikers per test case, was designed to weed out all but the very fastest solutions; only 88 contestants dared to attempt it, of which 52 got it right.\n\n<p>\n5619 contestants downloaded at least one input, and at the end of the day, 60.5% of the contestants solved at least one Small or Large input. To advance, it was generally necessary to solve at least three inputs, including at least one Large. Only 30 people (including our defending world champion) got a perfect score. \n</p>\n\n<p>\nWe hope everybody enjoyed the round! Congratulations to the Top 1000 who have now made it to Round 2.\n</p>\n\n<hr>\n\n<p>\nCast\n</p>\n<p>\nProblem A. <i>Counter Culture</i> written and prepared by Ian Tullis.\n</p>\n<p>\nProblem B. <i>Noisy Neighbors</i> written by Ian Tullis.  Prepared by Ahmed Aly.\n</p>\n<p>\nProblem C. <i>Hiking Deer</i> written by Ian Tullis.  Prepared by Yiming Li.\n</p>\n\n<p>\nSolutions and other problem preparation by Ahmed Aly, Artur Satayev, Calvin Li, Carlos Guía Vera, David Spies, Felix Halim, Ian Tullis, Igor Naverniouk, Ilham Kurnia, Jackson Gatenby, John Dethridge, Jonathan Paulson, Onufry Wojtaszczyk, Tsung-Hsien Lee, and Yiming Li.\n</p>\n\n<p>\nContest analysis written by John Dethridge, Artur Satayev, Felix Halim, David Spies, and Ian Tullis.\n</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1430582400000,"tasks":[{"analysis":"<h2>Small number of tenants, N &lt;= ceil(R * C / 2)</h2>\n\n<p>\nFor N &lt;= ceil(R * C / 2), we can put the tenants in a checkerboard pattern inside the R x C apartment complex and get the minimum possible unhappiness score of zero. See the following examples:\n</p>\n\n<pre>\n .X.X     .X.X.     X.X.X\n X.X.     X.X.X     .X.X.\n .X.X     .X.X.     X.X.X\n X.X.     X.X.X     .X.X.\n                    X.X.X\n\n4 x 4     4 x 5     5 x 5\n</pre>\n\n<p>\nThe left figure shows a 4 x 4 complex where we can place up to 8 tenants to apartments marked by ‘X’ and get zero unhappiness score (an empty apartment is marked by ‘.’). Observe that no two occupied apartments share a wall. Similarly for the middle figure, we can place up to 10 tenants and get zero unhappiness score.\n</p>\n\n<p>\nWith either R or C even (the left and middle figures), exactly half of the apartments can be rented. However, when both R and C are odd, two checkerboard patterns are possible. We should pick the checkerboard pattern with larger size. So for the right figure, we pick the checkerboard that has 13 ‘X’ marks, instead of the other checkerboard with only 12 ‘X’ marks.\n</p>\n\n<h2>Large number of tenants, N &gt; ceil(R * C / 2)</h2>\n\n<p>\nFor N &gt; ceil(R * C / 2), some level of unhappiness will be present, since we must place at least one pair of tenants next to each other.\nInstead of starting with an empty building and adding tenants, it is easier to solve this case by starting with a building completely filled with tenants, and then removing K = R*C - N of them.\nWe now need to determine which K tenants to remove in order to decrease the unhappiness score by as much as possible.\n</p>\n\n<p>\nLet’s first solve the smaller cases where R = 1 or C = 1. For those cases, we can always remove up to K tenants in such a way that each removal decreases the unhappiness score by 2, which is the maximum possible, and thus is optimal. To show this, look at the two possible examples below where C is even and C is odd:\n</p>\n\n<pre>\n  .X.X..     .X.X.X.\neven C=6     odd C=7\n</pre>\n\n<p>\nFor even C, K is at most C / 2 - 1 since N &gt; ceil(R * C / 2). Thus for even C, it is always possible to remove tenants using the pattern shown on the left figure (marked by ‘X’) to guarantee that each removal decreases the unhappiness score by 2 (i.e., the maximum possible decrease).\n</p>\n\n<p>\nFor odd C, K is at most (C - 1) / 2. In this case, it is always possible to remove tenants using the pattern shown on the right figure (marked by ‘X’) to guarantee that each removal decreases the unhappiness score by 2 (i.e., the maximum possible decrease).\n</p>\n\n<p>\nTo get some idea for solving a general case where R and C are at least 2, let’s observe the four buildings below with the checkerboard pattern. The cells marked by a number represent the apartments where the tenants may be removed. The numbers represent the amount of unhappiness each tenant is contributing to the building, or equivalently, the decrease in unhappiness that will occur if those tenants were removed:\n</p>\n\n<pre>\n .3.2     .3.3.     2.3.2     .3.3.\n 3.4.     3.4.3     .4.4.     3.4.3\n .4.3     .4.4.     3.4.3     .4.4.\n 2.3.     2.3.2     .4.4.     3.4.3\n                    2.3.2     .3.3.\n\n4 x 4     4 x 5     5 x 5     5 x 5\n</pre>\n\n<p>\nWe can devise an optimal K-tenant-removal strategy (i.e., remove K tenants such that the total unhappiness score is minimal) as follows:\n</p>\n\n<ul>\n<li>\nFor K &lt;= (R - 2) * (C - 2) / 2, we can always remove K tenants from the inner building (at the positions marked by ‘4’ in the figures) where each tenant removal decreases the unhappiness score by 4, which is the maximum decrease we can get, and thus it is optimal.\n</li>\n\n<li>\nFor K &gt; (R - 2) * (C - 2) / 2, after removing all the tenants at positions marked by ‘4’, we start removing more tenants at the sides of the building marked by ‘3’ (each tenant removal at these positions decreases the unhappiness score by 3). If all tenants at the sides of the building have been removed but we still need to remove more tenants (i.e., the total number of removed tenants has not reached K yet), remove more tenants at the corners of the building marked by ‘2’ (each tenant removal at these positions decreases the unhappiness score by 2). It is guaranteed that K tenants can be removed by now, since K is at most R * C / 2.\n</li>\n</ul>\n\n<p>\nNote that for odd R and odd C, there are two possible checkerboard patterns. Both of them must be considered, and we pick the one that yields the minimum unhappiness score.\n</p>\n\n<h3>Why does this strategy work?</h3>\n\n<p>\nEach removal can reduce unhappiness by at most 4. Below is a 5 x 5 building where the number in each apartment cell is the amount of unhappiness score reduction if the tenant at that cell location is removed:\n<pre>\n23332\n34443\n34443\n34443\n23332\n</pre>\n\n<p>\nWe can place at most ceil((R-2) * (C-2) / 2) 4s, so we cannot do better than to place this many 4s, and for the remainder place 3s.  So we can put an upper bound U on the amount of unhappiness reduction we can achieve &mdash; U &lt;= 4 * K for K &lt;= ceil((R-2) * (C-2) / 2), and U &lt;= 3 * K + ceil((R-2) * (C-2) / 2) otherwise.\n</p>\n\n<p>\nConsider the removal strategy using this checkerboard pattern (let's call this <i>pattern1</i>):\n</p>\n\n<pre>\n2.3.2\n.4.4.\n3.4.3\n.4.4.\n2.3.2\n</pre>\n\n<p>\nThis achieves U exactly when K &lt;= floor(R * C / 2) - 3 for R and C odd, and K &lt;= floor(R * C / 2) - 2 when one of R and C are even, so this strategy is optimal for these cases.\n</p>\n\n<p>\nFor the remaining cases, this strategy achieves either U-1 and U-2, because we need to place some 2s.  Since this strategy uses the maximal number of 4s, and the maximal number of 3s possible when using the maximal number of 4s, the only possible way to improve upon it would be to use 1 fewer 4 in order to use more 3s.\n</p>\n\n<p>\nIt is indeed possible to do this to improve the case K = floor(R * C / 2) - 1 from 4 total unhappiness to 3 total unhappiness, using the other checkerboard pattern (let’s call this <i>pattern2</i>):\n</p>\n\n<pre>\n.3.3.\n3.4.3\n.4.4.\n3.4.3\n.3.3.\n</pre>\n\n<p>\nThat is, if we were to use the checkerboard <i>pattern1</i>, removing K = 11 tenants reduces the unhappiness score by 5*4 + 4*3 + 2*2 = 36. On the other hand, <i>pattern2</i> reduces the unhappiness score by 4*4 + 7*3 = 37, by using 1 fewer 4s and more 3s.\n</p>\n\n<p>\nOn the other hand, <i>pattern1</i> is optimal is when K = 5, for example. In this case, <i>pattern1</i> reduces the unhappiness score more than <i>pattern2</i> since <i>pattern1</i> has 5 of 4s while <i>pattern2</i> only has 4 of 4s and would need to remove another 1 of 3s.\n</p>\n\n<p>\nSample implementation in C++:\n</p>\n\n<pre>\n#include &lt;cassert&gt;\n#include &lt;cstdio&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nint T, R, C, N;\n\nint remove_tenants(int &amp;K, int max_remove, int remove_cost) {\n  int removed = min(K, max_remove);\n  K -= removed;\n  return removed * remove_cost;\n}\n\nint get_score(int all, int corners, int inners) {\n  int sides = all - corners - inners;\n  int K = R * C - N;\n  int unhappiness = R * C * 2 - R - C;\n  unhappiness -= remove_tenants(K,  inners, 4);\n  unhappiness -= remove_tenants(K,   sides, 3);\n  unhappiness -= remove_tenants(K, corners, 2);\n  assert(K == 0);\n  return unhappiness;\n}\n\nint min_unhappines() {\n  // Guaranteed zero unhappiness.\n  if (N &lt;= (R * C + 1) / 2) return 0;\n\n  if (R == 1) {\n    int K = R * C - N;\n    int unhappiness = C - 1;\n    int remove_cost = 2;\n    return unhappiness - K * remove_cost;\n  }\n\n  if (R % 2 == 1 &amp;&amp; C % 2 == 1) {\n    // 2.3.2\n    // .4.4.\n    // 3.4.3\n    // .4.4.\n    // 2.3.2\n    int pattern1 = get_score(\n      (R * C + 1) / 2,  // Max #tenants that can be removed.\n      4,  // #tenants at the corners of the building.\n      ((R-2) * (C-2) + 1) / 2  // #tenants at inner building.\n    );\n\n    // .3.3.\n    // 3.4.3\n    // .4.4.\n    // 3.4.3\n    // .3.3.\n    int pattern2 = get_score(\n      (R * C) / 2,  // Max #tenants that can be removed.\n      0,  // #tenants at the corners of the building.\n      ((R-2) * (C-2)) / 2  // #tenants at inner building.\n    );\n\n    return min(pattern1, pattern2);\n  }\n\n  // .3.2      2.3.      2.3.2\n  // 3.4.  or  .4.3  or  .4.4.\n  // .4.3      3.4.      3.4.3\n  // 2.3.      .3.2      .3.3.\n  return get_score(\n    (R * C + 1) / 2,  // Max #tenants that can be removed.\n    2,  // #tenants at the corners of the building.\n    ((R-2) * (C-2) + 1) / 2  // #tenants at inner building.\n  );\n}\n\nint main() {\n  scanf(\"%d\", &amp;T);\n  for (int TC = 1; TC &lt;= T; TC++) {\n    scanf(\"%d %d %d\", &amp;R, &amp;C, &amp;N);\n    if (R &gt; C) swap(R, C);\n    printf(\"Case #%d: %d\\n\", TC, min_unhappines());\n  }\n}\n</pre>\n","id":"0000000000433516","statement":"<h3>Problem</h3>\n<p>\nYou are a landlord who owns a building that is an <b>R</b> x <b>C</b> grid of apartments; each apartment is a unit square cell with four walls. You want to rent out <b>N</b> of these apartments to tenants, with exactly one tenant per apartment, and leave the others empty. Unfortunately, all of your potential tenants are noisy, so whenever any two occupied apartments share a wall (and not just a corner), this will add one point of <i>unhappiness</i> to the building. For example, a 2x2 building in which every apartment is occupied has four walls that are shared by neighboring tenants, and so the building's unhappiness score is 4.<br>\n<br>\nIf you place your <b>N</b> tenants optimally, what is the minimum unhappiness value for your building?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> lines follow; each contains three space-separated integers: <b>R</b>, <b>C</b>, and <b>N</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum possible unhappiness for the building.<br>\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 1000.<br/>\n0 &le; <b>N</b> &le; <b>R*C</b>.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>R*C</b> &le; 16.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>R*C</b> &le; 10000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n2 3 6\n4 1 2\n3 3 8\n5 2 0\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 7\nCase #2: 0\nCase #3: 8\nCase #4: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn Case #1, every room is occupied by a tenant and all seven internal walls have tenants on either side.<br>\n<br>\nIn Case #2, there are various ways to place the two tenants so that they do not share a wall. One is illustrated below.<br>\n<br>\nIn Case #3, the optimal strategy is to place the eight tenants in a ring, leaving the middle apartment unoccupied.<br>\n<br>\nHere are illustrations of sample cases 1-3. Each red wall adds a point of unhappiness.<br>\n<br>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2ezudFZzPl5Rgtj6gpkWpEhFCxxU9ge6-nBSO05bUQM96sVEY_1Fw0mowVABXIa9DAzU-_zMLh/neighbors.png\"><br>\n<br>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Noisy Neighbors","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nSome programming contest problems have their origins in everyday life. This year, the Qualification Round's \"Standing Ovation\" was written during a concert, and Round 1A's \"Haircut\" was written while waiting in a long line for a sandwich at Google's Go Cafe. You may not be surprised to learn that this problem was inspired by a circular hike on a day with an unusually large number of hikers on the trail!\n</p>\n\n<p>\nLet H be the total number of hikers.  One important observation is that the answer can't be larger than H, since no matter what the hikers' initial positions and speeds are, Herbert can just go around so fast that no hiker gets a chance to move very far, so he encounters each of them once.\n</p>\n\n<p>\nAnother key observation is that allowing Herbert to wait or vary his speed makes no difference to the answer.  If we know the time he arrives at the end, we can put a lower bound on the answer based on the number of hikers he must have overtaken and the number of times hikers must have overtaken him. This lower bound is exactly the answer we get by having Herbert move at a constant speed, so no strategy of waiting or changing speed can improve on it.\n</p>\n\n<p>\nSo now, we will find a finish time that minimizes the number of encounters.\n</p>\n\n<p>\nConsider the case of a single hiker.  As the trail is circular and the hiker walks endlessly, the hiker repeatedly reaches Herbert’s starting point.  Call the time at which Herbert finishes his hike X, and the times when the hiker reaches Herbert’s starting point T1, T2, T3, etc. \n</p>\n\n<ul>\n<li>If X &lt;= T1, then there is one encounter with the hiker as Herbert passes.</li>\n<li>If T1 &lt; X &lt; T2, then there are no encounters with the hiker.</li>\n<li>If T2 &lt;= X &lt; T3, then the hiker passes Herbert once.</li>\n<li>If T3 &lt;= X &lt; T4, then the hiker passes Herbert twice.</li>\n<li>etc.</li>\n</ul>\n\n<p>\nSo as we increase Herbert's finish time, there are multiple \"events\" where the number of encounters changes.  It decreases by 1 for the first event, then it increases by 1 for each event after that.\n</p>\n\n<p>\nNow when we have multiple hikers, there is a series of events for each of them that can increase or decrease the total number of encounters.\n</p>\n\n<p>\nThere will never be a reason for Herbert to take so long that we see more than H events for a single hiker, because then the number of encounters with that single hiker will be at least H.  So a solution that will work for the small datasets is to make a sorted list of the first H events for all of the hikers, and then find the optimal number of encounters in this way:\n<p>\n\n<ul>\n<li>Initialize the number of encounters to H.</li>\n<li>For each event, in order of time, subtract 1 from the number of encounters if it is the first event for the hiker, otherwise add 1.</li>\n</ul>\n\n<p>\nThe answer is the minimum number of encounters for any time.\n</p>\n\n<p>\nFor the large dataset, we need a more efficient solution.  Note that there are only H events that subtract 1 from the number of encounters, and the rest add 1.  So once we have processed 2H events, we will never find a time with fewer than H encounters, so we can stop searching.\n</p>\n\n<p>\nWe still need to avoid storing H^2 events.  To do this, we can maintain a priority queue of events.  We initialize the queue with one event for each hiker -- the event for that hiker's T1.  Whenever we process an event, we replace that event on the queue with the next event for that hiker.  In this way we only need O(H) memory, and O(H log H) time.\n</p>\n\n<p>\nOne subtlety to note is that if multiple hikers reach Herbert’s starting point at the same time, we must process the events that add an encounter (those for a hiker's T2, T3, etc.) before the events that subtract an encounter (those for a hiker's T1) since the number of encounters only really decreases once Herbert's finish time is <i>larger</i> than T1.\n</p>\n\n<p>\n52 people successfully solved the large input for this problem during the contest.  See, for example, Belonogov's solution, which you can download from the scoreboard.\n</p>\n","id":"0000000000433739","statement":"<h3>Problem</h3>\n<p>\nHerbert Hooves the deer is going for a hike: one clockwise loop around his favorite circular trail, starting at degree zero. Herbert has perfect control over his speed, which can be <i>any</i> nonnegative value (not necessarily an integer) at any time -- he can change his speed instantaneously whenever he wants. When Herbert reaches his starting point again, the hike is over.<br>\n<br>\nThe trail is also used by human hikers, who also walk clockwise around the trail. Each hiker has a starting point and moves at her own constant speed. Humans continue to walk around and around the trail forever.<br>\n<br>\nHerbert is a skittish deer who is afraid of people. He does not like to have encounters with hikers. An encounter occurs whenever Herbert and a hiker are in exactly the same place at the same time. You should consider Herbert and the hikers to be points on the circumference of a circle.<br>\n<br>\nHerbert can have multiple separate encounters with the same hiker.<br>\n<br>\nIf more than one hiker is encountered at the same instant, all of them count as separate encounters.<br>\n<br>\nAny encounter at the exact instant that Herbert finishes his hike still counts as an encounter.<br>\n<br>\nIf Herbert were to have an encounter with a hiker and then change his speed to exactly match that hiker's speed and follow along, he would have infinitely many encounters! Of course, he must never do this.<br>\n<br>\nEncounters do not change the hikers' behavior, and nothing happens when hikers encounter each other.<br>\n<br>\nHerbert knows the starting position and speed of each hiker. What is the minimum number of encounters with hikers that he can possibly have?\n</p>\n\n<h3>Solving this problem</h3>\n<p>\nUsually, Google Code Jam problems have 1 Small input and 1 Large input. This problem has 2 Small inputs and 1 Large input. You must solve the first Small input before you can attempt the second Small input; as usual, you will be able to retry the Small inputs (with a time penalty). Once you have solved both Small inputs, you will be able to download the Large input; as usual, you will get only one chance at the Large input.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each begins with one line with an integer <b>N</b>, and is followed by <b>N</b> lines, each of which represents a <i>group</i> of hikers starting at the same position on the trail. The <b>i</b>th of these lines has three space-separated integers: a starting position <b>D<sub>i</sub></b> (representing <b>D<sub>i</sub></b>/360ths of the way around the trail from the deer's starting point), the number <b>H<sub>i</sub></b> of hikers in the group, and <b>M<sub>i</sub></b>, the amount of time (in minutes) it takes for the fastest hiker in that group to make each complete revolution around the circle. The other hikers in that group each complete a revolution in <b>M<sub>i</sub></b>+1, <b>M<sub>i</sub></b>+2, ..., <b>M<sub>i</sub></b>+<b>H<sub>i</sub></b>-1 minutes. For example, the line<br>\n<br>\n<code>180 3 4</code><br>\n<br>\nwould mean that three hikers begin halfway around the trail from the deer's starting point, and that they take 4, 5, and 6 minutes, respectively, to complete each full revolution around the trail.<br>\n<br>\nHerbert always starts at position 0 (0/360ths of the way around the circle), and no group of hikers does. Multiple groups of hikers may begin in the same place, but no two hikers will both begin in the same place and have the same speed.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of encounters with hikers that the deer can have.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>D<sub>i</sub></b> &le; 359.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>H<sub>i</sub></b>.<br/>\n1 &le; <b>M<sub>i</sub></b> &le; 10<sup>9</sup>. (Note that this only puts a cap on the time required for the <i>fastest</i> hiker in each group to complete a revolution.  Slower hikers in the group will take longer.)<br/>\n</p>\n\n<h4>Small dataset 1</h4>\n<p>\nTime limit: 240 seconds.<br/>\nThe total number of hikers in each test case will not exceed 2.<br/>\n</p>\n\n<h4>Small dataset 2</h4>\n<p>\nTime limit: 240 seconds.<br/>\nThe total number of hikers in each test case will not exceed 10.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\nThe total number of hikers in each test case will not exceed 500000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\n1 1 12\n359 1 12\n2 1 12\n358 1 12\n2\n180 1 100000\n180 1 1\n1\n180 2 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 1\nCase #3: 0\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn Case #1, the hikers all happen to be moving at the same speed, and one way for Herbert to avoid encountering any of them is to move exactly as fast as they do.<br>\n<br>\nIn Case #2, the second hiker is moving much faster than the first, and if Herbert goes slowly enough to avoid overtaking the first hiker, he will have multiple encounters with the speedy second hiker. One optimal strategy for Herbert is to go exactly as fast as the second hiker, encountering the first hiker once and never encountering the second hiker at all.<br>\n<br>\nIn Case #3, the two hikers start in the same place, but one is twice as fast as the other. One optimal strategy is for Herbert to immediately catch up to the slower hiker without overtaking him, follow just behind him until he passes the deer's starting position, and then finish quickly before the faster hiker can catch Herbert.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":13},{"type":1,"type__str":"VISIBLE","value":16},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Hiking Deer","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nFor the small dataset, it suffices to use a breadth-first search to find the minimum number of moves required to generate all numbers from 1 to 10<sup>6</sup>.  You will never want to construct a number larger than 10<sup>6</sup> and later flip it to get a smaller number, so you only need to consider 10<sup>6</sup> states.\n</p>\n\n<p>\nFor the large dataset, the following solution works. The key ideas are:\n<ul>\n<li>You should first build the numbers 10, 100, 1000, ... until you get a power of 10 with the same number of digits as N, and then build N.</li>\n<li>You should make at most one flip while the number is at a given number of digits.</li>\n</ul>\n</p>\n\n<p>\nOur algorithm works in two parts.\n</p>\n\n<h3>\nPart 1: Get to the right number of digits as fast as possible.\n</h3>\n\n<p>\nTo get from a 1 followed by X 0s to a 1 followed by X+1 0s: first count until the right half of the number is filled with 9s. (When the length is odd, make the left half shorter than the right half.) Then flip, then count until the number is all 9s. Then add 1.  (To get from 1 to 10, obviously we don't need to flip.)\n</p>\n\n<h3>\nPart 2: Either count directly to the answer, or do some counting, flip, and then do some more counting, whichever is faster.\n</h3>\n\n<p>\nOnce we're at the right number of digits, we use a similar algorithm to produce N: count until the right half looks like the left half of N in reverse, then flip, then count up to the target. For example, to get from 100000 to 123456:\n<ul>\n<li>count to 100321</li>\n<li>flip to get 123001</li>\n<li>count to 123456.</li>\n</ul>\n</p>\n\n<p>\nIf the left half is just a 1 followed by 0s, we can skip the first two steps and just count to N.\n</p>\n\n<p>\nWhen the right half of N is all zeroes the above method doesn't work, because after we flip, the right half ends with 1.  Instead, we make the right half look like the left half of N-1, flip, then count up to N.  For example, to get from 100000 to 300000:\n<ul>\n<li>count to 100992</li>\n<li>flip to get 299001</li>\n<li>count to 300000.</li>\n</ul>\n</p>\n\n<p>\nHowever, as before, if the left half of N-1 is a 1 followed by 0s, we can skip the first two steps.  For example, to get from 100000 to 101000, it's best to count up directly.\n</p>\n\n<p>Why do we need to do at most one flip? The goal of the flip is to allow us to reach the left half of the number as quickly as possible. Raising the right half to the desired value is better done by directly counting the number up. In other words, there is no added value in doing multiple flips.</p>\n\n<p>\nSample implementation in C++:\n</p>\n\n<pre>\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nlong long p10[10];  // p10[i] == 10^i\n\nbool is_1_followed_by_0s(string S) {\n  reverse(S.begin(), S.end());\n  return atoi(S.c_str()) == 1;\n}\n\nint solve(long long N) {\n  if (N &lt; 10) return N;  // Trivial case.\n\n  char X[20]; sprintf(X, \"%lld\", N);\n  string S = X;\n  int M = S.length();  // Number of digits of N.\n\n  // Starts from 1.\n  int ans = 1;\n\n  // Part 1: from 1, get to the M digits as fast as possible.\n  for (int d = 1; d &lt; M; d++) {\n    // For digits = 7, it starts from 7 digits:    1000000\n    ans += p10[(d + 1) / 2] - 1; // Count up 9999: 1009999\n    if (d &gt; 1) ans++;            // Flip once:     9999001\n    ans += p10[d / 2] - 1;       // Count up 999: 10000000\n  }\n\n\n  // Part 2:\n\n  // Split N into two halves. For example N = \"1234567\"\n  string L = S.substr(0, M / 2);  // L = \"123\"\n  string R = S.substr(M / 2);     // R = \"4567\"\n\n  // Handles the case where the right half is all zeroes.\n  if (atoi(R.c_str()) == 0) return solve(N - 1) + 1;\n\n  // Special case: Count directly to the answer.\n  if (is_1_followed_by_0s(L))\n    return ans + atoi(R.c_str());\n\n  // Count until the right half looks like the left half of N\n  // in reverse. In this case, count from 1000000 to 1000321.\n  reverse(L.begin(), L.end());\n  ans += atoi(L.c_str());\n\n  // Flip 1000321 to 1230001.\n  ans++;\n\n  // Count up 4566 to the target from 1230001 to 1234567.\n  ans += atoi(R.c_str()) - 1;\n  return ans;\n}\n\nint main() {\n  p10[0] = 1;\n  for (int i = 1; i &lt; 10; i++)\n    p10[i] = p10[i - 1] * 10;\n\n  long long T, N;\n  scanf(\"%lld\", &amp;T);\n  for (int TC = 1; TC &lt;= T; TC++) {\n    scanf(\"%lld\", &amp;N);\n    printf(\"Case #%d: %d\\n\", TC, solve(N));\n  }\n}\n</pre>","id":"0000000000433a0f","statement":"<h3>Problem</h3>\n<p>\nIn the Counting Poetry Slam, a performer takes the microphone, chooses a number <b>N</b>, and counts aloud from 1 to <b>N</b>. That is, she starts by saying 1, and then repeatedly says the number that is 1 greater than the previous number she said, stopping after she has said <b>N</b>.<br>\n<br>\nIt's your turn to perform, but you find this process tedious, and you want to add a twist to speed it up: sometimes, instead of adding 1 to the previous number, you might reverse the digits of the number (removing any leading zeroes that this creates). For example, after saying \"16\", you could next say either \"17\" or \"61\"; after saying \"2300\", you could next say either \"2301\" or \"32\". You may reverse as many times as you want (or not at all) within a performance.<br>\n<br>\nThe first number you say must be 1; what is the fewest number of numbers you will need to say in order to reach the number <b>N</b>? 1 and <b>N</b> count toward this total. If you say the same number multiple times, each of those times counts separately.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> lines follow. Each has one integer <b>N</b>, the number you must reach.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of numbers you need to say.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 240 seconds.<br/>\n1 &le; <b>N</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 480 seconds.<br/>\n1 &le; <b>N</b> &le; 10<sup>14</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1\n19\n23\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 19\nCase #3: 15\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn Case #2, flipping does not help and the optimal strategy is to just count up to 19.<br>\n<br>\nIn Case #3, the optimal strategy is to count up to 12, flip to 21, and then continue counting up to 23. That is, the numbers you will say are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 21, 22, 23.\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":11},{"type":2,"type__str":"HIDDEN","value":14}],"title":"Counter Culture","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000433551","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2015"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
