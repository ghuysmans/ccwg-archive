{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1591461000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000019ff7e","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Our first problem in Round 3, <i>Naming Compromise</i>, could be solved by\n  finding the right way to extract information from a well-known algorithm. If\n  you've been looking for a way to name a baby, and you don't mind potentially\n  ending up with a very strange string of letters, our method might be right\n  for you! The next problem, <i>Thermometers</i>, represented a big step up in\n  difficulty, but it was tractable once you wrapped your head around the\n  circular island presented in the problem.\n</p><p>\n  The remaining two problems, <i>Pen Testing</i> and <i>Recalculating</i>,\n  were different beasts entirely! Even a very seasoned competitive programmer\n  might take hours to solve just one of them. Both were worth the same amount,\n  so many contestants probably surmised that either one (plus the first two\n  problems) could potentially serve as a pathway to the World Finals. It was a\n  choice between creative and perhaps risky experimentation in Pen Testing, and\n  finding the right setup and data structures for a tricky geometric situation\n  in Recalculating.\n</p><p>\n  As we expected, we got many solves of Naming Compromise early on, and solutions\n  to Thermometers trickled in slowly but steadily. A few contestants picked off\n  earlier test sets of Pen Testing and Recalculating. At the 1:34 mark,\n  <b>saketh.are</b> became the first contestant to fully solve Pen Testing.\n  Not long after that, at 1:45, <b>Dlougach</b> submitted the first full solution\n  to Recalculating. Everything had been solved at least once, and the race was on\n  to cobble together enough points to make the top 25!\n</p><p>\n  <b>Benq</b> leapt to 70 points at 2:04, but our defending\n  champion <b>Gennady.Korotkevich</b> sent a burst of submissions just\n  a few minutes later, and reached an even more impressive total of 85.\n  Surpassing that would have required solving the full set, and <b>Gennady.Korotkevich</b>\n  did indeed take first in the end, followed\n  by <b>Benq</b>, <b>ecnerwala</b>, <b>peehs_moorhsum</b>, and <b>gs12117</b>\n  (taking 5th with a last-minute submission!) There were various ways to advance,\n  but it took more than the first two problems. Our contestants' overall performance\n  was even stronger than we had predicted &mdash; you find new ways to impress us\n  every year!\n</p><p>\n  In two months, our finalists will face off in our first-ever Virtual World\n  Finals! We will confirm the results soon and will reach out to finalists with\n  more info. Whether or not you advanced, you'll still be able to\n  show off your Code Jam 2020 shirt to all your friends around the world. In the\n  meantime, there's a\n  <a href=\"http://codingcompetitions.withgoogle.com/kickstart\" target=\"_blank\">Kick Start</a>\n  round to satisfy your appetite for problems.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Naming Compromise: Written by Pablo Heiber. Prepared by Artem Iglikov and\n    Jonathan Irvin Gunawan.\n</p><p>\n  Thermometers: Written by Pablo Heiber. Prepared by Artem Iglikov.\n</p><p>\n  Pen Testing: Written by Ian Tullis. Prepared by Petr Mitrichev.\n</p><p>\n  Recalculating: Written by Timothy Buzzelli and Pablo Heiber.\n    Prepared by Timothy Buzzelli, John Dethridge and Pablo Heiber.\n</p><p>\n  Solutions, problem preparation and review, analysis contributions, and\n    countless drawings of overlapping squares by Liang Bai,\n    Darcy Best, Timothy Buzzelli, Chen-hao Chang, Yilun Chong, John Dethridge,\n    Kevin Gu, Jonathan Irvin Gunawan, Md Mahbubul Hasan, Pablo Heiber,\n    Yui Hosaka, Andy Huang, Artem Iglikov, Nafis Sadique, Pi-Hsun Shih,\n    Sudarsan Srinivasan, and Ian Tullis.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Naming Compromise: Pablo Heiber.</li>\n  <li>Thermometers: Artem Iglikov and Pablo Heiber.</li>\n  <li>Pen Testing: Petr Mitrichev.</li>\n  <li>Recalculating: Pablo Heiber.</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1591452000000,"tasks":[{"analysis":"<h3>Test Set 1</h3>\n<p>\n  In Test Set 1, the limits are small enough that we might be tempted to just try lots of possible\n  outputs and keep the best one. However, since there is no a priori limit on the output\n  length, and we can use any of the English alphabet letters in the output, we need to think a\n  little bit first. In addition, we have to actually implement the calculation of\n  <a href=\"https://en.wikipedia.org/wiki/Levenshtein_distance\" target=\"_blank\">edit distance</a>,\n  which we can learn about via various online resources, including that Wikipedia link.\n</p><p>\n  The distance between two strings of length up to 6 is at most 6, since we could just replace\n  every character in the longer string (or an arbitrary one, if they are of the same length) to\n  match the other string, and delete any excess. Moreover, the distance between two strings is\n  never less than the absolute difference in length between them, because we would need to add\n  at least that many characters to the shorter string (if one is indeed shorter) just to make it as\n  long as the other string. It follows that the output should never be longer than 12 characters.\n</p><p>\n  In addition, if the output N contains a letter\n  that is not present in either of the input strings, exchanging that letter in N for a letter\n  contained in one of the inputs cannot increase either distance, which can be proven by induction\n  by inspecting the recursive definition of edit distance. Therefore, we can limit our search\n  to strings of length up to 12 over the alphabet {<code>X</code>, <code>Y</code>, <code>Z</code>}.\n  There are less than a million candidates, and calculating the edit distance for such short\n  strings is really efficient, so this is fast enough to solve Test Set 1.\n</p><p>\n  It is possible to prove tighter limits on the output, and this can drastically reduce the\n  number of candidates and make the solution even faster. We leave the details to the reader, but\n  consider whether we ever really need an answer longer than 6 letters. If we have\n  <code>ABCDFG</code> and <code>ACDEFG</code>, for example, then instead of compromising on the\n  seven-letter <code>ABCDEFG</code> by adding <code>E</code> to the first name and <code>B</code>\n  to the second name, we could just as easily delete <code>B</code> from the first name and\n  <code>E</code> from the second name, compromising on the shorter <code>ACDFG</code> instead.\n</p>\n<h3>Test Set 2</h3>\n<p>\n  For Test Set 2 we need to use some additional insights. The most important one is noticing\n  that edit distance is actually a distance, and has typical properties of distances like\n  being <a href=\"https://en.wikipedia.org/wiki/Reflexive_relation\" target=\"_blank\">reflexive</a>\n  and satisfying\n  the <a href=\"https://en.wikipedia.org/wiki/Triangle_inequality\" target=\"_blank\">\n  triangle inequality</a>.\n  Let e(s, t) denote the edit distance between two strings s and t. For an output N, we want\n  e(<b>C</b>, N) + e(<b>J</b>, N) = e(<b>C</b>, N) + e(N, <b>J</b>) to be minimal.\n  By the triangle inequality, e(<b>C</b>, <b>J</b>) is a lower bound on this quantity, and an\n  achievable one. For example, we can set N equal to <b>C</b> since e(<b>C</b>, <b>C</b>) = 0.\n</p><p>\n  By the reasoning above, we need to find an N such that\n  e(<b>C</b>, N) + e(N, <b>J</b>) = e(<b>C</b>, <b>J</b>)\n  and |e(<b>C</b>, N) - e(N, <b>J</b>)| is as small as possible. Luckily, the definition\n  of edit distance hints at a way of doing that. If the edit distance between <b>C</b> and <b>J</b>\n  is d, it means that there is a path of d valid operations on <b>C</b> that results in it turning\n  into <b>J</b>. Formally, there are d - 1 intermediate strings\n  S<sub>1</sub>, S<sub>2</sub>, ..., S<sub>d - 1</sub> such that e(<b>C</b>, S<sub>i</sub>) = i\n  and e(S<sub>i</sub>, <b>J</b>) = d - i. Therefore, it suffices to pick S<sub>d / 2</sub>. If d\n  is odd, both rounding up and down work, since for both possibilities,\n  |e(<b>C</b>, N) - e(N, <b>J</b>)| = 1.\n</p><p>\n  To find S<sub>1</sub>, S<sub>2</sub>, ..., S<sub>d - 1</sub>, we can use a common technique\n  to reconstruct the path that achieves an optimal result as found via\n  <a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\" target=\"_blank\">\n    dynamic programming</a> (DP).\n</p><p>\n  For example, let <b>C</b><sub>a</sub> be the prefix of length a of <b>C</b>\n  and <b>J</b><sub>b</sub> be the prefix of length b of <b>J</b>. The usual\n  algorithm to compute edit distance is based on a recursive definition of\n  a function f(a, b) that returns e(<b>C</b><sub>a</sub>, <b>J</b><sub>b</sub>) (see the\n  link from the previous section for details). Similarly, we can define g(a, b, k)\n  as a fuction that returns e(<b>C</b><sub>a</sub>, <b>J</b><sub>b</sub>) and also\n  a string S such that e(<b>C</b><sub>a</sub>, S) = k and\n  e(<b>J</b><sub>b</sub>, S) = e(<b>C</b><sub>a</sub>, <b>J</b><sub>b</sub>) - k.\n  The new function g can be defined with a similar recursion as f, and then memoized for\n  efficiency. The details are left as an exercise for the reader.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2L3_XvyhcdtC3Y1j6sU1llBw-UI49xOGDkELoI1ee-Vo5LzTd7M6A6w1qdUVyoiSCXQCWeQKM/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000003774db","statement":"<h3>Problem</h3>\n<p>\n  Cameron and Jamie are about to welcome a second baby into their lives. They are\n  already good at working together as parents, but right now they are\n  disagreeing about one crucial thing! Cameron wants to name the baby one name\n  (the string <b>C</b>), whereas Jamie wants to name the baby something else\n  (the string <b>J</b>).\n</p><p>\n  You want to help them find a <i>compromise name</i> that is as close as possible\n  to what each of them wants. You think you can do this using the notion of\n  <i>edit distance</i>. The edit distance between two strings S<sub>1</sub> and\n  S<sub>2</sub> is the minimum number of operations required to transform\n  S<sub>1</sub> into S<sub>2</sub>, where the allowed operations are as follows:\n</p>\n<ul>\n  <li>Insert one character anywhere in the string.</li>\n  <li>Delete one character from anywhere in the string.</li>\n  <li>Change one character in the string to any other character.</li>\n</ul>\n<p>\n  For example, the edit distance between <code>CAMERON</code> and\n  <code>JAMIE</code> is 5. One way to accomplish the transformation in 5 steps\n  is the following: <code>CAMERON</code> to <code>JAMERON</code> (change) to\n  <code>JAMIERON</code> (insert) to <code>JAMIEON</code> (delete) to\n  <code>JAMIEN</code> (delete) to <code>JAMIE</code> (delete).\n  Any transformation from <code>CAMERON</code> into <code>JAMIE</code>\n  requires at least this many operations.\n</p><p>\n  To make the compromise name N as close as possible to the original desires\n  of the parents, you want N to be a non-empty string\n  such that the sum of the edit distances between <b>C</b> and N and\n  between <b>J</b> and N is as small as possible.\n  Out of all those choices for N, to make sure the compromise is fair,\n  you must choose an N such that the\n  difference between those two edit distances is also as small as possible.\n  Please find a compromise name for Cameron and Jamie.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each case consists of a single line with two\n  strings <b>C</b> and <b>J</b>: the names that Cameron and Jamie have\n  proposed for the baby, respectively. Each of these names is made up of\n  uppercase English alphabet letters.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is a name that meets the requirements mentioned in the statement. Note that\n  <code>y</code> must contain only uppercase English letters.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  <b>C</b> &ne; <b>J</b>.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  1 &le; length of <b>C</b> &le; 6.<br/>\n  1 &le; length of <b>J</b> &le; 6.<br/>\n  The i-th letter of <b>C</b> is an uppercase <code>X</code>, <code>Y</code>, or <code>Z</code>,\n    for all i.<br/>\n  The i-th letter of <b>J</b> is an uppercase <code>X</code>, <code>Y</code>, or <code>Z</code>,\n    for all i.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  1 &le; length of <b>C</b> &le; 60.<br/>\n  1 &le; length of <b>J</b> &le; 60.<br/>\n  The i-th letter of <b>C</b> is an uppercase English alphabet letter, for all i.<br/>\n  The i-th letter of <b>J</b> is an uppercase English alphabet letter, for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3kPyMWq8H45-WQeA7xM5Dvqj2YzRQjhv6K0Xip7Q1y8Y9EnS7-l5t6094F_EAE9E2-Pi8SD10ESDRgoSZ20jn3bgmKkgdL8MfUz6nHh9DI/naming_compromise_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\nXYZZY ZZYZX\nY Z\nYYXXYZ ZYYXXY\nXZXZXZ YZ\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2XGaFkA4AUepsrsXGN7k0urUUw5jaoIWvh3WUsD6tvXNNnq-01Ym4r2GWETdBBgFzSKVFMAqAojKs4CvO2wmiJhpSQZZAnBiQP5cq7qrupew/naming_compromise_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: ZZY\nCase #2: Z\nCase #3: ZYYXXYZ\nCase #4: ZYZX\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<p>\n  The above cases meet the limits for Test Set 1. Another sample case that does not meet those\n  limits appears at the end of this section.\n</p><p>\n  In Sample Case #1, the edit distance from <code>XYZZY</code> to\n  <code>ZZY</code> is 2 (delete the first two letters), and the edit distance\n  from <code>ZZYZX</code> to <code>ZZY</code> is 2 (delete the last two\n  letters). <code>XZZX</code> and <code>ZYYZY</code> would also work.\n  No possible name has a sum of edit distances that is less than 4.\n</p><p>\n  <code>ZY</code>, for example, has the same edit distance to <b>C</b> as to\n  <b>J</b> (3, in each case). However the sum of those distances would be 6, which is not\n  minimal, so it would not be an acceptable answer.\n</p><p>\n  <code>XZZY</code> is also unacceptable. Its edit distances to <b>C</b> and <b>J</b>,\n  respectively, are 1 and 3. The sum of those edit distances is minimal, but the difference\n  between the two (|1-3| = 2) is not minimal, since we have shown that it is possible to\n  achieve a difference of 0.\n</p><p>\n  In Sample Case #2, <code>Y</code> and <code>Z</code> are the only acceptable answers.\n</p><p>\n  In Sample Case #3, notice that input length restrictions do not apply to the\n  output, so the shown answer is acceptable in either test set.\n  Another possible answer is <code>YYXXY</code>.\n</p><p>\n  In Sample Case #4, the edit distance between <code>XZXZXZ</code> and <code>ZYZX</code>\n  is 3, and the edit distance between <code>YZ</code> and <code>ZYZX</code> is 2.\n  The sum of those edit distances is 5, and their difference is 1; these values are\n  optimal for this case.\n</p><p>\n  The following additional case could not appear in Test Set 1, but could appear in Test Set 2.\n</p>\n<pre>\n1\nGCJ ABC\n</pre>\n<p>\n  <code>Case #1: GC</code> is one of the possible correct outputs.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":8}],"title":"Naming Compromise","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>A quarter pi helps the math go down</h3>\n<p>\nAs can be seen in the pictures in the statement, lines dividing distinguishable and\nnon-distinguishable areas are always 45 degree diagonals.\nThe reason is that the distinguishability can only\nchange when the retrievability of some repair center changes, and those only change when\ncrossing diagonals because of the sum in the L<sub>1</sub> distance definition. Since\nhorizontals and verticals are much easier to deal with than diagonals, we can rotate the\nwhole problem by &pi;/4 = 45 degrees.\nIf we do that directly (for example, by multiplying all points by the corresponding\n<a href=\"https://en.wikipedia.org/wiki/Rotation_matrix\" target=\"_blank\">rotation matrix</a>)\nwe will find ourselves\ndealing with points at non-integer coordinates, which has problems in itself. Notice that rotating\nis equivalent to <a href=\"https://en.wikipedia.org/wiki/Vector_projection\" target=\"_blank\">\n  projecting</a> into\nnew axes of coordinates. In this case, the directions of those\nnew axes are the rows of the rotation matrix, or (2<sup>-2</sup>, 2<sup>-2</sup>) and\n(2<sup>-2</sup>, -2<sup>-2</sup>). The vectors (1, 1) and (1, -1) have the same directions but\ndo not have length 1. We can still project onto them and end up with a rotated and re-scaled\nversion of the input. Luckily, neither rotation nor re-scaling affects the ultimate result. So,\na convenient transformation is to map each point (x, y) in the input to (x+y, x-y). Notice that\nin this rotated and scaled world, L<sub>1</sub> distance changes to\n<a href=\"https://en.wikipedia.org/wiki/L-infinity\" target=\"_blank\">L<sub>&infin;</sub></a>\ndistance, which is\njust a fancy way of saying that those diagonals turn into horizontals and verticals that are\nexactly <b>D</b> meters away from the point in question. Although we will not explicitly mention\nit, this transformation is applied as the first step of all solutions presented here.\n</p>\n<h3>Test Set 1</h3>\n<p>\nWe can write a solution for Test Set 1 by examining a few cases and finding a formula for\neach one. The set of points from which a repair center can be seen is an axis-aligned\nsquare of side 2<b>D</b> with the repair center at its center. Let us call that the <i>r-square</i>\nof the point.\n</p><p>\nThere are 3 possible situations:\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1P7AJtgV-nqxSrlV6BO-wOJ5DWgynXQkNu4dI009HbQVDNhH7MQkz4hriZuBXulHqTnk2Ivl0/ts1_cases.png\"/>\n</p>\n<ul>\n<li>I: The r-squares do not intersect.</li>\n<li>II: The r-squares intersect and the repair centers are outside\neach other's r-squares.</li>\n<li>III: The repair centers are inside each other's r-squares.</li>\n</ul>\n<p>\nSituation I is the easiest to handle, because the answer is always 0, as Sample Case #2\nillustrates.\n</p><p>\nSituation II is illustrated by Sample Case #1. As suggested in the statement,\nwe can find the red area as 3 times the area of the intersection of both r-squares (notice that\nthe intersection is not necessarily a square) and the blue area as the sum\nof both r-squares, 2&times;(2<b>D</b>)<sup>2</sup>, minus the area of the intersection.\n</p><p>\nIn Situation III, the total area in which Principia could be deployed can be calculated\nin the same way as before. The distinguishable area, however, is slightly different. It can be\nsimpler to calculate the non-distinguishable area (highlighted below), which consists of four\ncopies of the same region, and then complement the result.\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2ZC-e7YJf0Jiey-_6kqXBGSC_lzDvUzz0-zqvKJ-jmZtVUghPVSe1d-xgmEl2FXBQINvjCb6zXSuTV/ts1_hard_case.png\"/>\n</p>\n<h3>Test Set 2</h3>\n<p>\nRecall that Info(p) is the set of relative locations of repair centers that can be retrieved\nfrom a point p. Notice that when two points p and p' are very close, Info(p) and Info(p') will\nlook similar.\nIf the repair centers that can be retrieved from both are the same (which is true most of the time\nfor points that are close to each other), then Info(p') is equal to Info(p) shifted by the shift\nbetween p and p'. However, if at least one repair center is retrieved from one of these points\nand not from the other, that is not true. In particular, Info(p) and Info(p') could be\nsets of different numbers of points.\n</p><p>\nFirst we deal with the changes in which repair centers can be retrieved by splitting the\ninteresting area into parts. Within each part, the set of repair centers that can be retrieved\nis constant. Consider all the horizontal lines\ny=X+<b>D</b> and y=X-<b>D</b> for each x-coordinate X of a point in the input, and all vertical\nlines x=Y+<b>D</b> and x=Y-<b>D</b> for each y-coordinate Y of a point in the input. The points\nthat are not surrounded by 4 of these lines (for example, the points above the highest horizontal\nline) are too far from all of the repair centers to be able to retrieve any of them, so we can\ndisregard them for the rest of the analysis.\nThese up to 4<b>N</b> lines divide the remaining points into up to\n4<b>N</b><sup>2</sup> - 4<b>N</b> - 1 rectangular regions. Since all sides of all r-squares\nfully overlap with these lines, the set of repair centers that are retrievable from any point\nstrictly within one of those regions is the same. The set of repair centers that can be retrieved\nfrom points on the lines might be different from those retrieved from any of its adjacent\nregions. However, since the area of each line is 0, the probability of Principia being\ndeployed there is 0, so we simply ignore them and work with points strictly within regions.\nFor each region R, we calculate the total area A(R) of distinguishable points in the region\nand the total area B(R) of points where Principia can be deployed. The answer is then\nthe sum of A(R) over all regions divided by the sum of B(R) over all regions.\n</p><p>\nFix a current region C.\nGoing back to the first paragraph, Info(p) and Info(p') are shifts of each other for all p and p'\nfrom the same region. Calculating B(C) is easiest: it is either the area of C if Info(p) is\nnon-empty for any point p in the region, and 0 otherwise. To calculate A(C),\nwe can use an analysis generalizing our reasoning in Test Set 1. We need to find other regions\nR where Info(q) is a shift of Info(p) for a point q in R. In Test Set 1, this happened for the\nregions where one repair center can be seen, because the sets of a single point are always shifts\nof each other. We can check whether Info(p) and Info(q) are shifts of each other and find\nthe appropriate shift if they are. First we check that they have the same number of points,\nand then we sort the points in\nan order that is invariant by shift (for example, sorting by x-coordinate\nand breaking ties by y-coordinate). In this way, we can fix the shift as the one between the first\npoint of Info(p) and the first point of Info(q). Finally, we check that that shift works for all\npairs of i-th points. If true, we can shift R by the found amount to obtain R', and the\nintersection between R' and C is a rectangle in which the points are non-distinguishable.\nIf we do that over all regions R, the union of all those intersections is exactly the area\nof non-distinguishable points in C, and we can subtract it from the area of C to obtain B(C).\nThere are many algorithms (with different levels of efficiency) to find the area of the union\nof rectangles aligned with the axes. Given the low limits of Test Set 2, it suffices to use\na technique like the above, in which we extend the rectangle sides to lines and divide\ninto regions, checking each region individually.\n</p><p>\nFor each region C, the algorithm needs\nto find Info(p) for a point p in C, which takes time O(<b>N</b>), then iterate over all other\nO(<b>N</b><sup>2</sup>) regions R and find Info(q) for a point there, check\nInfo(q) against Info(p) for a shift, and possibly produce an intersection.\nThat takes O(<b>N</b>) time per R, or O(<b>N</b><sup>3</sup>) overall for the fixed C.\nThen, we need to take the union of up to O(<b>N</b><sup>2</sup>) rectangles, which, with the\nsimple algorithm above, can take between O(<b>N</b><sup>4</sup>) and O(<b>N</b><sup>6</sup>)\ntime, depending on implementation details. This means the overall time, summing over all possible C,\ncan be up to O(<b>N</b><sup>8</sup>). Most implementations should be OK in most languages though.\nAs we will see, there are many optimizations needed for Test Set 3, and even just doing the\nsimplest of them would be enough to pass Test Set 2. Alternatively, there is a known algorithm\nto find the area of the union of K rectangles in O(K log K) time, and multiple references to\nit can be found online. Using it off the shelf would yield an overall time complexity of\nO(<b>N</b><sup>4</sup> log <b>N</b>), which is small enough to handle much larger limits\nthan Test Set 2's.\n</p>\n<h3>Test Set 3</h3>\n<p>\nTo solve Test Set 3, we have a lot of optimization to do. The first step is to avoid calculating\nInfo for each region more than once. That alone does not change the ultimate time complexity\nof the algorithm from the previous section, but it is a necessary step for all optimizations that\nfollow.\n</p><p>\nWe divide the work into two phases. In the first phase, we group all regions that have equivalent\nInfo sets. For each region C, we calculate S := Info(p) for an arbitrary point p in C as before,\ndiscard it if S is empty. Otherwise, we sort S, and then shift both C and the sorted result by\nthe first point such that the shifted S' has the origin as its first point.\nIn this way, S' is a normalized pattern for C, and two regions with Info sets that are\nshifts of each other end up with the same S. After doing this, we can accumulate all shifted\nregions for each S that appears, and process them together.\n</p><p>\nNotice that we can sort the input points at the\nvery beginning and then always process them in order such that every calculated S is already\nsorted, to avoid an extra log <b>N</b> factor in the time complexity.\nA rough implementation of this\nphase takes O(<b>N</b><sup>3</sup>) time if we use a dictionary over a hash table to aggregate\nall regions for each set S. We optimize this further below.\n</p><p>\nFor the second phase, we have to process the set of shifted regions for each shifted S'. Since the\nregions are already shifted in a normalized way, we can process them all together. That is,\ninstead of calculating A(C) for each individual C, we calculate A(S') := the sum of\nA(C) over all C in S'.\n</p><p>\nThe picture below shows an example of the input we need to process for a fixed S'. There are\nmultiple rectangular regions that have been shifted, so some may overlap now. We need\nthe area of the part where no intersections happen (highlighted in the picture).\nIf we do this by extending sides and processing each resulting region individually,\nwe end up with an algorithm that takes between O(K<sup>2</sup>) and O(K<sup>3</sup>) time again,\nwhere K is the number of rectangles. However, the sum of the number of rectangles over all S' is\nO(<b>N</b><sup>2</sup>), because each original region appears in at most one group. Therefore,\nthe overall cost of the second phase implemented like this over all S' would be between\nO(<b>N</b><sup>4</sup>) and O(<b>N</b><sup>6</sup>).\n</p><p align=\"center\">\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U251ctPUX0CTX29AbDb1eygfmb0zunW48s5TcB2to0olMM3hegqeKfM4xGt9K6XZSCt2mPk2FcXNSeOCPo/shifted_regions.png\"/>\n</p><p>\nWe now have an algorithm with a first phase that takes O(<b>N</b><sup>3</sup>) time and a second\nphase that takes between O(<b>N</b><sup>4</sup>) and O(<b>N</b><sup>6</sup>) time overall. We need\nto optimize further.\n</p><p>\nFor the first phase, if we want to keep O(<b>N</b><sup>2</sup>) regions and go significantly below\nO(<b>N</b><sup>3</sup>), we need to make the processing of each region not require a full pass\nover the input points. Consider a fixed row of regions between the same two horizontal lines.\nNotice that each repair center can be retrieved from a contiguous set of those regions, and they\nbecome both retrievable and non-retrievable in sorted order of x-coordinate. Therefore,\nwe can maintain the list of points that represent S in amortized constant time\nby simply pushing repair centers that become retrievable to the back of the list and\npopping repair centers that become non-retrievable from the front. This technique is sometimes\ncalled \"chasing pointers\".\n</p><p>\nUnfortunately, this is not enough, as we need to shift each S by a different amount, and shifting\nS requires time linear in the size of S. It is entirely possible for S to contain a significant\npercentage of points for a significant percentage of regions.\nWe can do better by using a\n<a href=\"https://en.wikipedia.org/wiki/Rolling_hash\" target=\"_blank\">rolling hash</a>\nof S. That would get us a hash of each S without any additional complexity. Unfortunately,\nwe cannot shift the resulting hash. The last trick is, instead of hashing the actual points, hash\nthe shift between each point and the last considered (adding a virtual initial point with any\nvalue). Those internal shifts are invariant to our overall shift of S, and since the first point\nof S' is always the origin, we can simply remove that one from the hash. The result is something\nthat uniquely (up to hash collisions) represents the shifted S'.\nThis change optimizes the first phase to run in O(<b>N</b><sup>2</sup>) time.\n</p><p>\nTo optimize the second phase &mdash; specifically the calculation of the values A(C) &mdash;\nwe can use an algorithm similar to the one mentioned at the\nend of the previous section to calculate the union of the area of all rectangles. Consider a\n<a href=\"https://en.wikipedia.org/wiki/Sweep_line_algorithm\" target=\"_blank\">\n  sweep line algorithm</a>\nthat processes the start and end of each rectangle in order of x-coordinate. We can maintain\na data structure that knows, for each y-coordinate, how many rectangles overlap the sweep line\nat coordinate y. We need to be able to insert a new interval of y-coordinates each time\na rectangle starts, remove one each time a rectangle ends, and query the total length\nof y-coordinate covered by exactly one rectangle.\nMultiplying that by the difference in x-coordinate between stops of the sweep line,\nwe can calculate how much area to add to A(S') at each stop of the sweep line.\n</p><p>\nWe can use a\n<a href=\"https://cp-algorithms.com/data_structures/segment_tree.html\" target=\"_blank\">segment tree</a>\nto efficiently represent that. At each node of the segment tree we need to record:\n<ul>\n<li>(1) How many rectangles processed\nso far fully cover the interval represented by the node and do not fully cover its parent.</li>\n<li>(2) The total length covered by 1 or more rectangles within the interval represented by\n  the node.</li>\n<li>(3) The total length covered by 2 or more rectangles within the interval represented by\nthe node.</li>\n</ul>\n(1) and (2) are exactly what need to be recorded for the algorithm to calculate just\nthe area of the union of the rectangles. When inserting an interval I at a node representing\ninterval J, if I and J do not overlap, we do nothing. If J is contained in I, we simply increment\n(1) and do nothing recursively. For any other case, we insert recursively into the node's children.\nRemoval is similar: since in our use case removing J means that we previously\ninserted J, we are guaranteed that in the case where J is contained in I, (1) is positive,\nand we just decrement it. After inserting or removing as above, we recompute values (2) and (3).\nThat recomputation can be done in constant time based on (1) and the (2) and (3) values of\nthe children, if any, with a case analysis on whether (1) is 0, 1, or 2 or more. The details\nare left as an exercise to the reader. The total length covered by\nexactly 1 rectangle is exactly the value (2)-(3) on the root of the tree.\n</p><p>\nSince each insertion and removal requires going through at most O(log <b>K</b>) nodes, and the\nqueries are resolved in constant time, using this sweep line algorithm with the described segment\ntree structure results in an algorithm that processes a set of K rectangles for the second phase\nin O(K log K) time. This results in O(<b>N</b><sup>2</sup> log <b>N</b>) time overall for the\nphase (and the algorithm), since, as we argued before, the sum of all K over all S' is\nO(<b>N</b><sup>2</sup>).\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2SIE9zIsUxarktZlQzisutfeRMDl0w1rKwNVTSVwrU2eyleWhDypY-U5gQm6EV2jIlRqp_Z-Y/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000003775e9","statement":"<h3>Problem</h3>\n<p>\nYou are working for the Driverless Direct Delivery Drone Directions Design Division of\nApricot Rules LLC. The company is about to take its first drone \"Principia\" to market.\nYou are tasked with designing backup systems for Principia, in case it\nloses access to its primary geolocation systems (like GPS), but it still needs a way to get\ndirections. Principia is designed for use on a flat region; formally, the region is a Cartesian\nplane in which the coordinates are in meters. One or more points on this plane are\n<i>drone repair centers</i>. No two drone repair centers are at the same location.\n</p><p>\nPrincipia has a system that can retrieve the relative locations of drone repair centers\nthat are within an L<sub>1</sub> distance (which is also known as\n<a href=\"https://en.wikipedia.org/wiki/Taxicab_geometry\" target=\"_blank\">Manhattan distance</a>)\nof at most <b>D</b> meters of its location. The information retrieved is a set of repair center\nlocations relative to Principia's current location. For example: \"there is a repair center 4 meters\nnorth and 3.5 meters west, and another one 2.5 meters east\". Notice that the information does\nnot identify repair centers; it gives their locations relative to Principia.\n</p><p>\nYou quickly realized that there may be points on the\nmap where this information may not be enough for Principia to uniquely determine its current\nlocation. This is because there might be two (or more) different points from which the\ninformation looks the same. Points with this property are called <i>non-distinguishable</i>, while\nall other points are called <i>distinguishable</i>.\n</p><p>\nFormally, the information retrieved by Principia when located at point (x, y)\nis Info(x, y) := the set of all points (z - x, w - y), where (z, w) is the location\nof a repair center and |z - x| + |w - y| &le; <b>D</b>. Here\n|z - x| and |w - y| denote the absolute values of z - x and w - y, respectively.\nA point (x<sub>1</sub>, y<sub>1</sub>) is non-distinguishable if and only if\nthere exists another point (x<sub>2</sub>, y<sub>2</sub>) such that\nInfo(x<sub>1</sub>, y<sub>1</sub>) = Info(x<sub>2</sub>, y<sub>2</sub>).\n</p><p>\nFor example, suppose <b>D</b>=4 and there are repair centers at points (0, 0) and (5, 0).\nThe point (0, 0) is non-distinguishable because Info(0, 0)={(0, 0)}=Info(5, 0).\nThis means that point (5, 0) is also non-distinguishable. On the other hand,\nInfo(3.5, 0.1)={(-3.5, -0.1), (1.5, -0.1)} is not equal to the information from any other point,\nwhich means that point (3.5, 0.1) is distinguishable. The following picture illustrates the\nregions of distinguishable points (in red) and non-distinguishable points (in blue):\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3jKQZkgTLJUt2K0g8zkCEmq_x1sQA8pyeQ5sfLHNFI3LS98MHl5fR9KnSuQ90iGnQhTrxyxA/sample_1.png\" style=\"width: 500px; height: auto;\" />\n</p><p>\nPrincipia is deployed to a point that is chosen uniformly at random from the set of all points\nthat are within <b>D</b> meters (using L<sub>1</sub> distance) of at least one repair center\n&mdash; that is, the set of all points (x, y) such that Info(x, y) is non-empty.\nThe probability of that choice belonging to a given continuous set of points S is\nproportional to the number of square meters of S's area.\nIn the example above, each red square has an area of 4.5 square meters, while each blue section\nhas an area of 23 square meters. Therefore, the probability of Principia being deployed within\neach red square is 4.5/(3&times;4.5 + 2&times;23) and the probability of it being deployed\nwithin each blue section is 23/(3&times;4.5 + 2&times;23). Since the border between adjacent\ndifferently-colored sections has area equal to 0, the probability of Principia being\ndeployed exactly on the border is exactly 0.\n</p><p>\nGiven the locations of all repair centers, what is the probability that the point to which\nPrincipia is deployed is distinguishable?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\nEach test case starts with a line containing two integers <b>N</b> and <b>D</b> representing\n(respectively) the number of repair centers and the maximum L<sub>1</sub> distance from which\nPrincipia can retrieve information from a repair center, as described above. Then, <b>N</b> lines\nfollow. The i-th of these contains two integers <b>X<sub>i</sub></b> and <b>Y<sub>i</sub></b>\nrepresenting the coordinates of the i-th repair center. The unit of measurement for\nall coordinates and <b>D</b> is meters.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y z</code>, where <code>x</code> is\nthe test case number (starting from 1) and <code>y</code> and <code>z</code> are non-negative\nintegers. The fraction <code>y</code>/<code>z</code> must represent\nthe probability of Principia being at a distinguishable location,\nif one is chosen uniformly at random from all locations that are\nwithin <b>D</b> meters of at least one repair center (using L<sub>1</sub> distance).\nIf there are multiple acceptable values for <code>y</code> and <code>z</code>, choose\nthe one such that <code>z</code> is minimized.\n</p><p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>D</b> &le; 10<sup>7</sup>.<br/>\n-10<sup>9</sup> &le; <b>X<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n-10<sup>9</sup> &le; <b>Y<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n(X<sub>i</sub>, Y<sub>i</sub>) &ne; (X<sub>j</sub>, Y<sub>j</sub>) for all i &ne; j.\n  (No two repair centers share the same location.)<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\nTime limit: 20 seconds.<br/>\n<b>N</b> = 2.<br/>\n</p>\n\n<h4>Test Set 2 (Visible Verdict)</h4>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Test Set 3 (Visible Verdict)</h4>\n<p>\nTime limit: 120 seconds.<br/>\nFor 6 cases, <b>N</b> = 1687.<br/>\nFor <b>T</b>-6 cases, 2 &le; <b>N</b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3ga9oJG5hNnOWVqtiw4-39I76iKjZF4U7an7R1eNo5cfoiUDNeUxuO1UtyDBc1VddUGnxgKwvxS8BUFtxPJ-hPo9xAADjX668MQG8/recalculating_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n2 4\n0 0\n5 0\n2 1\n0 0\n5 0\n2 4\n0 0\n4 4\n2 4\n0 0\n5 1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U34UdfyIAIPcVtFYlpmJtCSPO1kh9itwjMXRw3kfjnB7R7y_BZ43YOKzyqWiA52UD6i5AA3v4VS8xJxzr9MTUm9vTxEG160uB88xymb/recalculating_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 27 119\nCase #2: 0 1\nCase #3: 0 1\nCase #4: 1 5\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<p>\n  The above cases meet the limits for Test Set 1. Another sample case that does not meet those\n  limits appears at the end of this section.\n</p><p>\n  Sample Case #1 is described and depicted in the statement.\n</p><p>\n  The points in the middle red region are all distinguishable points because they are the only\n  points that retrieve information from both repair centers, and each point in that region\n  retrieves a distinct set of information.\n</p><p>\n  The points in the left and right red region each receive information from only one repair center,\n  but that information is always unique, so these are all distinguishable points. For example, if\n  Principia knows it is 3 meters east of a repair center, it can be sure it is not 3 meters east of\n  the repair center at (0, 0), because then it would have retrieved information from both repair\n  centers. So it must be 3 meters east of the repair center at (5, 0).\n</p><p>\n  The points in the blue regions are all non-distinguishable points. Choose any point in one of\n  those regions, and consider the information that Principia would get from that point.\n  It contains only the one repair center in range. But, there is a corresponding point in\n  the other blue region from which Principia would get exactly the same information.\n</p><p>\n  As explained above, the probability of Principia being deployed to one of the red sections\n  is 4.5/59.5, so the total probability of it being deployed to any of them is 3&times;4.5/59.5 = 27/119.\n</p><p>\n  The following picture illustrates Sample Case #2. There is no way to retrieve information from\n  more than one repair center, so every point close enough to one of them is non-distinguishable;\n  the same information is retrieved from an equivalent point near the other one.\n  Remember that <code>z</code> (the denominator) must be minimal, so <code>0 1</code> is\n  the only acceptable answer.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U361_tcRZPHfLLZgVZjRJXR22G1R5v2Q13nt5EJM-91fAN1Hokt3-MYn4nWrRpZbrU8yQojHw/sample_2.png\" style=\"width: 500px; height: auto;\" />\n</p><p>\n  The following picture illustrates Sample Case #3. Notice that the border between the two blue\n  squares consists of distinguishable points. However, since its area is 0, the probability\n  of Principia being deployed there is 0. All other points where Principia can be deployed\n  are non-distinguishable.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U11SAiPRwfywgNvqIQvanCGA1m_Xpb_NLHs6VZta_r5xJU9w0Mqwrm-6UzlKYSJf0PQ7UbRUg/sample_3.png\" style=\"width: 300px; height: auto;\" />\n</p><p>\n  The following picture illustrates Sample Case #4.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U13VcCRHHeVy7Q302BYvK6Q1YoBLTiMwfDOcOezAh_09PQk9hVLsfzmyogGLElwSkO9oezrMg/sample_4.png\" style=\"width: 300px; height: auto;\" />\n</p><p>\n  The following picture illustrates the additional case.\n</p><p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3LbvBHJcVbLQywmNnVQrpxTUX8rVgUtRX5yCzwbA0bp4AjWnThCU4sZQpmWSzzNCcNwvedCw/sample_5.png\" style=\"width: 300px; height: auto;\" />\n</p><p>\n  The following additional case could not appear in Test Set 1, but could appear in any of the\n  other test sets.\n</p>\n<pre>\n1\n3 4\n0 0\n1 1\n2 3\n</pre>\n<p>\n  The correct output is <code>Case #1: 101 109</code>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":6},{"type":1,"type__str":"VISIBLE","value":11},{"type":1,"type__str":"VISIBLE","value":15}],"title":"Recalculating","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>How to approach this problem?</h3>\n<p>\n  At first sight, it might seem impossible to achieve the number of correct guesses required in\n  this problem. If we just pick two pens at random without writing anything, the probability of\n  success will be 46.666...%. And whenever we write anything, the amount of remaining ink only\n  decreases, seemingly just making the goal harder to achieve.\n  And yet we are asked to succeed in 63.6% of test cases in Test Set 3. How can we start\n  moving in that direction?\n</p>\n<p>\n  Broadly speaking, there are three different avenues. The first avenue is solving this problem in\n  one's head or on paper, in the same way most algorithmic problems are solved: by trying to come\n  up with smaller sub-problems that can be solved, then trying to generalize the solutions to those\n  sub-problems to the entire problem.\n</p>\n<p>\n  The second avenue is more experimental: given that the\n  local testing tool covers the entire problem (i.e., there is no hidden input to it), we can\n  start trying our ideas using the local testing tool. This way we can quickly identify the more\n  promising ones, and also fine-tune them to achieve optimal performance. Note that one could also\n  edit the local testing tool to make it more convenient for experimentation; for example, one\n  could modify the interaction format so that only one test case is judged at a time.\n</p>\n<p>\n  The third avenue starts with implementing a dynamic programming solution that can be viewed as\n  the exhaustive search with memoization: in each test case, our state is entirely determined by how\n  much ink have we spent\n  in each pen, and by which pens are known to have no ink left. Our transitions correspond to the\n  basic operation available: trying to spend one unit of ink from a pen. Moreover, we can collapse\n  the states that differ only by a permutation of pens into one, since they will have the same\n  probability of success in an optimal strategy. Finally, we need to be able to compute the\n  probability of success whenever we decide to stop writing and pick two pens; we can do this\n  by considering all permutations, or by using some combinatorics (which is a bit faster).\n  This approach is hopelessly slow for <b>N</b>=15. However, we can run it for smaller values of\n  <b>N</b> and then use it as inspiration: we can print out sequences of interactions that happen\n  for various input permutations, and then generalize what happens into an algorithm that will\n  work for higher values of <b>N</b>.\n</p>\n<h3>Test Set 1</h3>\n<p>\n  How can we find a small sub-problem in which writing actually helps\n  improve the probability of success? Suppose we have only three pens, with 1, 9 and 10 units of ink\n  remaining. If we just pick two pens at random, we will have two pens with at least 15 units of ink\n  between them only with probability 1/3: 9+10&ge;15, but 1+9&lt;15 and 1+10&lt;15. However, if\n  we first write 2 units of ink with each pen, we will know which pen had 1 unit of ink since\n  we will fail to write 2 units with it, and will therefore know that the other two pens have 7 and\n  8 units of ink remaining, so we can pick them and succeed with probability 1!\n</p>\n<p>\n  How can we generalize this approach to the original problem? We can pick a number K and write\n  K units of ink with each pen. Then, we will know the identities of pens 0, 1, ..., K-1 so\n  that we can avoid taking them to the South Pole. However, the other pens will have 0, 1, ...,\n  <b>N</b>-K units of ink remaining, which seems to be strictly worse than the initial state.\n  But we can include a small optimization: we can stop writing as soon as we find all pens from\n  the set 0, 1, ..., K-1. For example, if the two last pens both have at least K units\n  initially, we will stop before we reach them, so by the time we identify all pens from\n  the set 0, 1, ..., K-1 and stop writing, we will not have touched those two pens at all.\n  Therefore we will know that they both have some amount of ink from the set K, K+1,\n  ..., <b>N</b>, and picking them gives us a much higher probability of success.\n  Of course, this will\n  not always be the case, and sometimes we will have only one or zero untouched pens. In this case\n  we should pick the untouched pen if we have it, and add a random pen from those that have written\n  K units successfully.\n</p>\n<p>\n  By running this strategy against the local testing tool with various values of K,\n  we can learn that it succeeds in about 56.5% of all cases when K=3, and is good enough to pass\n  Test Set 1. We will call this strategy <i>fixed-K</i>.\n</p>\n<p>\n  There are certainly many other approaches that pass Test Set 1 &mdash; for example, less accurate\n  implementations of the solutions for Test Set 2 and Test Set 3 mentioned below.\n</p>\n<h3>Test Set 2</h3>\n<p>\n  How do we make further improvements? Our current approach suffers from two inefficiencies.\n  The first inefficiency has to do with the fact that we keep writing K units of ink with\n  each pen even if we have already found the pen which had K-1 units of ink initially. Since\n  we are now searching for 0, 1, ..., K-2, it suffices to write only K-1 units of ink\n  with each subsequent pen at this point. More generally, if X is the most full pen\n  from the set 0, 1, ..., K-1 that we have not yet identified, we only need to write\n  X+1 units of ink with the next pen. Having identified all pens from the set 0, 1, ..., K-1,\n  we stop writing and take the two pens not from this set that have written the least units to the\n  South Pole. We will call this improvement <i>careful writing</i>.\n</p>\n<p>\n  It turns out that careful writing with K=4 increases our chances substantially to 61.9%,\n  enough to pass Test Set 2!\n</p>\n<p>\n  The second inefficiency is that out of the pens that are determined to have at least K units, we\n  take two to the South Pole, but the rest are useless. For example, we never end up taking any\n  pen except the last K+2 pens to the South Pole! Therefore we could start by writing with the first\n  <b>N</b>-K-2 pens until they are used up and have exactly the same success rate. We can improve\n  the success rate if we use the information that we get from those pens to make potentially better\n  decisions!\n</p>\n<p>\n  More specifically, we can do the\n  following: initially, write with the first pen until it is used up (and therefore we know how\n  much ink was in it). Then, write with the second pen until it is used up, and so on. In this\n  manner, we will always know exactly which pens are remaining. At some point we should decide to\n  stop gathering information and switch to the fixed-K strategy. The information we gathered can\n  be used to pick the optimal value of K, which is potentially different in different branches.\n</p>\n<p>\n  This gives rise to a dynamic programming approach with 2<sup><b>N</b></sup> states: a state is\n  defined by the set of pens remaining after we have used up some pens.\n  For each state we consider either writing with the next pen until it is used up, or trying\n  the fixed-K strategy with each value of K. Note that we only need to run the dynamic programming\n  once before the interaction starts, and then we can use its results to solve all test cases.\n</p>\n<p>\n  We will call this improvement to the fixed-K strategy <i>pen exploration</i>.\n  It turns out that pen exploration allows us to succeed in about 62.7% of all cases, which is also\n  enough to pass Test Set 2. We expect that there are many additional ways to pass it.\n</p>\n<h3>Test Set 3</h3>\n<p>\n  What about Test Set 3? You might have guessed it: we can actually combine careful writing\n  and pen exploration! This yields a solution that succeeds in about 63.7% of all cases, which is\n  close to the boundary of Test Set 3, so while it might not pass from the first attempt\n  because of bad luck, it will definitely pass after a few attempts.\n</p>\n<p>\n  This is not the only way to solve Test Set 3, though. If we take a closer look at the\n  careful writing solution, we can notice that we can achieve exactly the same outcome using a\n  bottom-up approach instead of a left-to-right approach. More specifically, we start by writing\n  one unit of ink using each pen in the order from left to right, until we find a pen that cannot\n  write; we can conclude that it is the pen that started with 0 units of ink. Then, we can go from\n  left to right again and make sure that each subsequent pen has written two units of ink (which\n  will entail writing one more unit of ink from pens that have already written one, or writing two\n  units of ink for pens that were untouched in the last round), until we find the pen that had 1\n  unit of ink in the beginning. We continue in the same manner until we have found pens 0, 1, ...,\n  K-1, just as before. The amount written with each pen at this point will be exactly the same as\n  the amount written with each pen in the original careful writing approach.\n</p>\n<p>\n  However, this formulation allows us to improve this approach: we no longer need to pick K\n  in advance! We can instead make a decision after finding each pen X: either we continue\n  by searching for the pen X+1 in the above manner, or we stop and return the two pens\n  that have written the least so far. We will call this improvement <i>early stopping</i>. In order\n  to make the decision of whether to continue or to return, we can either implement some heuristics,\n  or actually compute the probability of success using a dynamic programming approach where\n  the state is the amount written by each pen at the time we have found pens 0, 1, ..., X.\n  This dynamic programming has just 32301 states for <b>N</b>=15, so it can be computed quickly.\n</p>\n<p>\n  Careful writing with early stopping works in about 64.2% of all cases if one makes the optimal\n  decisions computed by the aforementioned dynamic programming, allowing one to pass\n  Test Set 3 with a more comfortable margin. Once again, we expect that there are many additional\n  approaches available for Test Set 3.\n</p>\n<h3>Ultimate solution</h3>\n<p>\n  All three improvements&nbsp;&mdash; careful writing, pen exploration and early\n  stopping&nbsp;&mdash; can be combined in one solution. It is a dynamic programming solution in\n  which the state is once again the amount written with each pen, and we consider three options for\n  every state:<br/>\n  1. Write with the leftmost remaining (=not known to be used up) pen until it is used up.<br/>\n  2. Write with all pens from left to right to find the smallest remaining pen.<br/>\n  3. Return the two rightmost pens that have not been used up yet.<br/>\n</p>\n<p>\n  Note that computing the probability of success for the third option is easy in this solution,\n  as each of the remaining pens can be at any of the available positions.\n  This means that any pair of\n  remaining pens is equally likely to appear as the two pens we are taking to the South Pole.\n  This means, in turn, that if the pens we are taking to the South Pole have written\n  X and Y units, then the probability of success is simply the number of pairs of remaining pens\n  with initial amounts A and B such that A+B>=<b>N</b>+X+Y, divided by the total number of pairs of\n  remaining pens.\n</p>\n<p>\n  This dynamic programming has 1343425 states for <b>N</b>=15; therefore, it can run in time even in\n  PyPy if implemented carefully. Its probability of success is around 64.4%, which is more than\n  enough for Test Set 3.\n</p>\n<p>\n  Moreover, we have compared the probability of success for this approach with the optimal one\n  (computed by the aforementioned exhaustive search with memoization, after\n  <i>a lot</i> of waiting), and it turns out that\n  for all <b>N</b>&le;15 this solution is in fact optimal. Therefore, we suspect that it is optimal\n  for higher values of <b>N</b> as well. We do not have a proof of this fact, but we would be very\n  interested to hear it if you have one! Of course, neither this solution nor its proof are\n  necessary to pass all test sets in this problem.\n</p>\n<h3>Constraints and judge</h3>\n<p>\n  Finally, let us share some considerations that went into preparing the constraints and the judge\n  for this problem. Given its random nature, the fraction of successfully solved test cases will\n  vary for every solution. More specifically, thanks to the\n  <a href=\"https://en.wikipedia.org/wiki/Central_limit_theorem\" target=\"_blank\">\n    Central Limit Theorem</a> we know\n  that for a solution with probability of success P that is run on <b>T</b> test cases,\n  the fraction of successfully solved test cases will be approximately normally distributed with\n  mean P\n  and standard deviation sqrt(P&times;(1-P)/<b>T</b>). In Test Sets 1 and 2\n  the standard deviation is therefore around 0.35%, and in Test Set 3 it is around 0.15%.\n</p>\n<p>\n  Considering\n  <a href=\"https://en.wikipedia.org/wiki/68%E2%80%9395%E2%80%9399.7_rule\" target=\"_blank\">\n    the probabilities</a>\n  that a sample from a normal distribution deviates from its mean by a certain multiple of its\n  standard deviation, we can see that for practical purposes we can expect to never land more than,\n  say, five standard deviations away from the mean. This creates a window of about &plusmn;1.75% in\n  Test sets 1 and 2, and a window of about &plusmn;0.75% in Test Set 3 such that whenever a solution\n  is outside this window, it will always pass or always fail, but within this window the outcome\n  depends on luck to some degree.\n</p>\n<p>\n  This luck window is inevitable and its size almost does not depend on the\n  required success rate, only on the number <b>T</b> of test cases.\n  Therefore it is impossible to completely\n  avoid the situation when the success rate of a solution falls into the luck window, and therefore\n  one might need to submit the same solution multiple times to get it accepted, with the number of\n  required attempts depending on luck.\n  Increasing the number <b>T</b> reduces the luck window, but increasing it\n  too much requires the solutions to be extremely efficient and can rule out some approaches.\n  Therefore, we decided that the best tradeoff lies around <b>T</b>=20000 for Test Sets 1 and\n  2, allowing less efficient approaches to still pass there. For Test Set 3, we felt the best\n  tradeoff lies around <b>T</b>=100000 to better separate the solutions that are optimal or close to\n  optimal from the rest and to reduce the luck window, while still not pushing the time limit to\n  impractical amounts.\n</p>\n<p>\n  We have picked the required success rates in the following manner:<br/>\n  - For Test Set 1, we picked it such that the fixed-K strategy is outside the luck window and\n    always passes.<br/>\n  - For Test Set 2, we picked it such that both careful writing and pen exploration are outside\n    the luck window and always pass.<br/>\n  - For Test Set 3, we picked it such that the ultimate solution with all three improvements\n    is outside the luck window and always passes, but solutions with careful writing and one of\n    early stopping or pen exploration are within the luck window and therefore might require\n    multiple submissions, but not too many. Lowering the threshold further in this test set\n    would bring pen exploration without careful writing within the luck window. More generally,\n  there is a continuum of solutions here if one uses inexact heuristics instead of exact\n  dynamic programming to make the early stopping decision, and some of those solutions\n  would inevitably land in the luck window.<br/>\n</p>\n<p>\n  Another peculiar property of this problem is that the judge is not deterministic, whereas\n  typically in interactive problems, the randomness in each test set is fixed in advance, and\n  submitting the same deterministic code always leads to the same outcome.\n  This is necessary to avoid approaches in which one first uses a few submissions to learn some\n  information about the test sets, for example by making the solution fail with Wrong Answer or\n  Runtime Error or Time Limit or Memory Limit, to pass two bits of infomation back.\n  This information can then be used to achieve a higher probability of success.\n</p>\n<p>\n  In order to see how this small amount of information can help significantly, consider a solution\n  that has a probability of success that is five standard deviations smaller than the required one.\n  Using the simple \"submit the same code again\" approach, one would need more than 3 million\n  attempts on average to get it accepted, which is clearly not practical. However, we can do the\n  following instead: we can submit a solution that just writes with all pens until they are used up,\n  therefore gaining full knowledge of the test set. Then, it runs the suboptimal solution\n  several million times with different random seeds, which by the above argument will find a random\n  seed where the suboptimal solution in fact achieves the required success rate. Now the solution\n  just needs to communicate back 20-30 bits comprising this random seed, which even at the two\n  bits per submission rate requires just 10-15 submissions, which can be made within the space of a\n  round. Finally, one could just submit the suboptimal solution with this random seed hardcoded,\n  and pass.\n</p>\n<p>\n  We hope that this provides some insight into why this problem is designed the way it is, and\n  we are sorry that some potential remained for contestants to be negatively impacted by the luck\n  window or by the judge's non-determinism.\n</p>\n","id":"0000000000377630","statement":"<h3>Problem</h3>\n<p>\nYou have <b>N</b> ballpoint pens. You know that each has a distinct integer number of units of\nink between 0 and <b>N</b>-1, but the pens are given to you in random order, and therefore you do\nnot know which pen is which.\n</p>\n<p>\nYou are about to go on a trip to the South Pole (where there are no pens), and your luggage only has\nroom for two pens, but you know you will need to do a lot of important postcard writing. Specifically,\nthe two pens you choose must have a total of at least <b>N</b> ink units.\n</p>\n<p>\nYour only way to get information about the pens is to choose one and try writing something with it.\nYou will either succeed, in which case the pen will now have one unit of ink less (and is now\npossibly empty), or fail, which means that the pen already had no ink left. You can repeat this\nmultiple times, with the same pen or different pens.\n</p>\n<p>\nEventually, you must select the two pens to take on your trip, and you succeed if the total amount\nof ink remaining in those two pens is at least <b>N</b> units.\n<p>\nYou will be given <b>T</b> test cases, and you must succeed in at least <b>C</b> of them. Note that\nall test sets in this problem are Visible.\n</p>\n\n<h3>Input and output</h3>\n<p>\n  This is an interactive problem. You should make sure you have read the\n  information in the Interactive Problems section of our\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq#interactive-problems\" target=\"_blank\">FAQ</a>.\n</p>\n<p>\n  Initially, your program should read a single line containing three integers\n  <b>T</b>, <b>N</b>, and <b>C</b>: the number of test\n  cases, the number of pens, and the minimum number of test cases you must succeed in.\n  (Note that the value of <b>N</b> is the same for all test sets,\n  and is provided as input only for convenience; see the Limits section for\n  more details.)\n</p><p>\n  Then, your program needs to process all <b>T</b> test cases at the same time (this is done to\n  reduce the number of roundtrips between your solution and the judging program). The interaction\n  is organized into rounds.\n</p>\n<p>\n  At the beginning of each round, your program must print one line containing <b>T</b> integers:\n  the <b>i</b>-th integer is the number of the pen you want to try writing with in the\n  <b>i</b>-th test case, or 0 if you do not want to write with any pen in this test case in this\n  round. The pens are numbered from 1 to <b>N</b>.\n</p>\n<p>\n  Be aware that flushing the output buffer after each one of these integers, instead of\n  only once after printing all <b>T</b>, could cause a Time Limit Exceeded error because of the\n  time consumed by the flushing itself.\n</p>\n<p>\n  The judge responds with one line containing <b>T</b> integers: the <b>i</b>-th integer is the\n  amount of ink spent in the <b>i</b>-th test case in this round. It will be equal to 1\n  if the writing in the <b>i</b>-th test case was successful. Otherwise, it will be\n  equal to 0, which could mean that you tried to write in the <b>i</b>-th test case but\n  the pen you chose had no ink left, or that you did not try to write in the <b>i</b>-th\n  test case at all.\n</p>\n<p>\n  You may participate in at most <b>N</b>&times;(<b>N</b>+1)/2 rounds. Note that this is enough to\n  be confident that all pens are empty.\n</p>\n<p>\n  When your program is ready to submit an answer for all test cases, it must print a line containing\n  the number 0 <b>T</b> times. This line is not counted towards the limit on the number of rounds,\n  and the judge will not send a response.\n</p>\n<p>\n  Then, your program must print another line with 2&times;<b>T</b> integers: the\n  (2&times;<b>i</b>-1)-th and the (2&times;<b>i</b>)-th integers in this line are the distinct\n  numbers of the pens that you take to the South Pole in the <b>i</b>-th test case.\n  The judge will not send a response, and your program must then terminate with no error.\n</p>\n<p>\n  If the judge receives unexpected output from\n  your program at any moment, the judge will print a single\n  number -1 and not print any further output. If your program continues to wait for the judge after\n  receiving a -1, your program will time out, resulting in a Time Limit\n  Exceeded error. Notice that it is your responsibility to have your program\n  exit in time to receive a Wrong Answer judgment instead of a Time Limit\n  Exceeded error. As usual, if the memory limit is exceeded, or your program\n  gets a runtime error, you will receive the appropriate judgment.\n</p>\n<p>\n  You can assume that the pens are given to you in random order. These orders are chosen\n  uniformly at random and independently for each test case and for each submission. <i>Therefore\n  even if you submit exactly the same code twice the judge will use different random orders</i>.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 90 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  <b>N</b> = 15.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  <b>T</b> = 20000.<br/>\n  <b>C</b> = 10900 (<b>C</b>=0.545&times;<b>T</b>).<br/>\n</p>\n\n<h4>Test Set 2 (Visible Verdict)</h4>\n<p>\n  <b>T</b> = 20000.<br/>\n  <b>C</b> = 12000 (<b>C</b>=0.6&times;<b>T</b>).<br/>\n</p>\n\n<h4>Test Set 3 (Visible Verdict)</h4>\n<p>\n  <b>T</b> = 100000.<br/>\n  <b>C</b> = 63600 (<b>C</b>=0.636&times;<b>T</b>).<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0OzmatdMHB0eRib1ZMD8El3ELuw98_E86zp-AWmFgjQEwX7FyoUre-w17mtl4dcT8NqFtc2DSjAV0zpxs43w/local_testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n\n<h3>Sample Interaction</h3>\n<p>\n  The following interaction does not correspond to any of the three test sets, as its values of\n  <b>T</b> and <b>N</b> are too small. It merely serves to demonstrate the protocol.\n</p>\n\n<div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input to your program</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Output of your program</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n    <pre class=\"io-content\">2 5 1<br/><br/>1 0<br/><br/>0 1<br/><br/>0 1<br/><br/><br/></pre>\n  </td>\n  <td>\n    <pre class=\"io-content\"><br/>4 5<br/><br/>4 3<br/><br/>0 2<br/><br/>0 0<br/>3 4 3 4<br/></pre>\n  </td></tr></tbody></table>\n</div>\n\n<p>\n  Here is the same interaction, explained:\n</p>\n\n<pre>\n  // The following reads 2 into t, 5 into n and 1 into c.\n  t, n, c = readline_int_list()\n  // The judge secretly picks the number of units for each pen:\n  // in test case 1: 2 0 4 1 3\n  // in test case 2: 1 3 2 4 0\n  // We write with the 4-th pen in test case 1, and with the 5-th pen in test case 2.\n  printline 4 5 to stdout\n  flush stdout\n  // Reads 1 0, as the 4-th pen in test case 1 still had ink left,\n  // but the 5-th pen in test case 2 did not.\n  a1, a2 = readline_int_list()\n  // We write with the 4-th pen in test case 1 again, and with the 3-rd pen in test case 2.\n  printline 4 3 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We only write in test case 2 this time, with the 2-nd pen.\n  printline 0 2 to stdout\n  flush stdout\n  // Reads 0 1.\n  a1, a2 = readline_int_list()\n  // We decide we are ready to answer.\n  printline 0 0 to stdout\n  flush stdout\n  // We take the 3-rd and the 4-th pens to the South Pole in both test cases.\n  printline 3 4 3 4 to stdout\n  flush stdout\n  // In test case 1, the remaining amounts in the 3-rd and the 4-th pens are 4 and 0, and 4+0&lt;5,\n  // so we did not succeed.\n  // In test case 2, the remaining amounts in the 3-rd and the 4-th pens are 1 and 4, and 1+4&ge;5,\n  // so we succeeded.\n  // We have succeeded in 1 out of 2 test cases, which is good enough since c=1.\n  exit\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":6},{"type":1,"type__str":"VISIBLE","value":11},{"type":1,"type__str":"VISIBLE","value":15}],"title":"Pen Testing","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<h3>\n  Test Set 1\n</h3>\n<p>\n  First of all, notice that <b>X<sub>i</sub></b> splits the circle into a sequence of segments, so\n  that throughout each segment, the temperature of all the points is the same. Let's say that the\n  i-th segment is the segment which starts at <b>X<sub>i</sub></b> and goes clockwise. We will use\n  d<sub>i</sub> as the length of the i-th segment. Also note that per the problem statement, there\n  are no adjacent segments with the same temperature, so we can safely ignore the actual\n  temperatures <b>T<sub>i</sub></b>.\n</p>\n<p>\n  We can make the following observations:\n</p>\n<ul>\n  <li>\n    We never need more than two thermometers on each segment, as a thermometer put in between two\n    others on the same segment will not cover any points which are not already covered by the\n    original two.\n  </li>\n  <li>\n    In an optimal answer, we should never have two adjacent segments with 2 thermometers each. If\n    we have two adjacent segments with 2 thermometers in each, we can simply \"push\" the middle 2\n    thermometers outwards until at least one of them runs into the other thermometer in their\n    segment, which reduces the total number of thermometers by at least one.\n  </li>\n  <li>\n    The adjacent thermometers on different adjacent segments need to be equidistant from the common\n    point of those segments. Otherwise, the temperature of some points between these thermometers\n    will be incorrect.\n  </li>\n  <li>\n    The thermometers in an optimal answer can always be put in integer or half-integer positions.\n    If we have an answer in which that is not the case, we can \"push\" the thermometers until they\n    reach integer or half-integer positions.\n  </li>\n</ul>\n<p>\n  Given these observations, and the low limits in Test Set 1, we can iterate through all possible\n  configurations and choose the one that gives the best answer.\n</p>\n<h3>\n  Test Set 2\n</h3>\n<p>\n  Note that if we know the position of a thermometer on segment A that is closest to an adjacent\n  segment B, we can calculate the anticipated position of a thermometer on B. To do so, we need\n  to \"mirror\" the known position over the common point of the segments. If the mirrored position\n  doesn't belong to the segment B, then it is not possible for segment A to have the closest\n  thermometer at this position.\n</p>\n<p>\n  First, let's assume that the answer is greater than <b>N</b>. We can apply the following greedy\n  strategy to find the optimal answer (we will show below that it actually works).\n</p>\n<p>\n  Let's start with some segment A and assume that this is the only segment. We can put a thermometer\n  at any point of A (except the endpoints, per the problem statement) and it will cover the whole\n  segment. So the <i>interval</i> of valid positions on A is the whole segment. Now, let's consider\n  an adjacent segment B and see how we can put the thermometers on both segments, so that only two\n  thermometers are used. We can mirror the interval of valid positions in A over the common point\n  of these segments. The interval of valid positions in B is the intersection of the mirrored\n  segment and B. We will refer to this operation as <i>propagation</i>.\n</p>\n<p>\n  We can continue propagating this interval through as many segments as possible and stop if the\n  propagated interval would be empty. If we propagate the last interval back to A through all the\n  intermediate segments, this will give us valid positions for the thermometers to cover all these\n  segments with one thermometer per segment.\n</p>\n<p>\n  As we cannot propagate the current interval anymore, we can define a new interval of valid\n  positions on the current segment, taking into account the old one, effectively putting two\n  thermometers on this segment, and repeat the process again. Once we reach segment A, we should\n  verify that the last interval begins before the first interval ends, so that we could put two\n  thermometers on segment A.\n</p>\n<p>\n  The answer will be <b>N</b> (as we have to put at least one thermometer on each segment) plus the\n  number of times we had to start with the new interval, effectively putting two thermometers on\n  the corresponding segment. We can try all segments as the starting one and choose the best\n  answer. Again, the proof that this always works is given below.\n</p>\n<p>\n  Now let's see how to handle the case of the answer being equal to <b>N</b>, when we put exactly\n  one thermometer on each segment. If we assume that z<sub>i</sub> is the position of a thermometer\n  on segment i, measured from the segment's beginning (point <b>X<sub>i</sub></b>), then, we can\n  calculate the other positions as follows:\n</p>\n<p>\n  z<sub>2</sub> = d<sub>1</sub> - z<sub>1</sub>\n</p>\n<p>\n  z<sub>3</sub> = d<sub>2</sub> - z<sub>2</sub> = d<sub>2</sub> - d<sub>1</sub> - z<sub>1</sub>\n</p>\n<p>\n  ...\n</p>\n<p>\n  z<sub><b>N</b></sub> = d<sub><b>N</b>-1</sub> - z<sub><b>N</b>-1</sub> = d<sub><b>N</b>-1</sub> -\n  d<sub><b>N</b>-2</sub> + d<sub><b>N</b>-3</sub> - ... +/- z<sub>1</sub>\n</p>\n<p>\n  z<sub>1</sub> = d<sub><b>N</b></sub> - z<sub><b>N</b></sub> = d<sub><b>N</b></sub> -\n  d<sub><b>N</b>-1</sub> + d<sub><b>N</b>-2</sub> - d<sub><b>N</b>-3</sub> + ... +/- z<sub>1</sub>\n</p>\n<p>\n  These equations give us a quick test for whether the answer could be <b>N</b>.\n</p>\n<p>\n  In case <b>N</b> is even:\n</p>\n<p>\n  z<sub>1</sub> = d<sub><b>N</b></sub> - d<sub><b>N</b>-1</sub> + d<sub><b>N</b>-2</sub> -\n  d<sub><b>N</b>-3</sub> + ... - d<sub>1</sub> + z<sub>1</sub>, or, subtracting z<sub>1</sub> from\n  both sides:\n</p>\n<p>\n  0 = d<sub><b>N</b></sub> - d<sub><b>N</b>-1</sub> + d<sub><b>N</b>-2</sub> -\n  d<sub><b>N</b>-3</sub> + ... - d<sub>1</sub>\n</p>\n<p>\n  As long as the above holds, any z<sub>1</sub> will satisfy the equation. The caveat here is that\n  some of the z<sub>i</sub>s may not be inside of the corresponding segments. So we need to verify\n  that we can do the same propagation as we did earlier, and reach the first segment without adding\n  the second thermometer on any segment. If we can do so, then the answer is <b>N</b>.\n</p>\n<p>\n  In case <b>N</b> is odd:\n</p>\n<p>\n  z<sub>1</sub> = d<sub><b>N</b></sub> - d<sub><b>N</b>-1</sub> + d<sub><b>N</b>-2</sub> -\n  d<sub><b>N</b>-3</sub> + ... + d<sub>1</sub> - z<sub>1</sub>, or, adding z<sub>1</sub> to both\n  sides:\n</p>\n<p>\n  2z<sub>1</sub> = d<sub><b>N</b></sub> - d<sub><b>N</b>-1</sub> + d<sub><b>N</b>-2</sub> -\n  d<sub><b>N</b>-3</sub> + ... + d<sub>1</sub>\n</p>\n<p>\n  In this case, there is exactly one value for z<sub>1</sub>. As in the previous case, we need to\n  verify that this value produces a valid set of positions, and we can do this by propagating\n  z<sub>1</sub> through all the segments. If we can do so, then the answer is <b>N</b>.\n</p>\n<p>\n  Propagating an interval through all segments is O(<b>N</b>), and we do this at most once to check\n  <b>N</b> as an answer, and do this <b>N</b> times if the answer is not <b>N</b>. This gives us\n  O(<b>N</b><sup>2</sup>) running time.\n</p>\n<p>\n  <b>Proof of greedy solution</b>\n</p>\n<p>\n  Here is an image which roughly describes the steps in the proof below:\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1qxZxtX_vfI7ca_RnzgCNNRPwYqtN-Fn61r71mUD-L16op2fMn6kBDDOxDPewJdwK44age9bk3fig/proof.svg\" />\n</p>\n<p>\n  We will concentrate on the case when the answer is greater than <b>N</b>, since for the case of\n  <b>N</b> the solution is constructive.\n</p>\n<p>\n  Let's define a few additional terms.\n</p>\n<p>\n  A <i>chain</i> is a sequence of adjacent segments, where there is some placement of thermometers\n  such that each segment can be covered by one thermometer, except for the first and the last\n  ones, each of which requires two thermometers. Note that it is possible that a chain covers the\n  whole circle, starting in some segment, wrapping around the whole circle, and ending at the same\n  segment.\n</p>\n<p>\n  A <i>maximum chain</i> is a chain that cannot be extended clockwise by adding the next segment\n  because it is not possible to place the thermometers (as per the definition of a chain) to cover\n  such a chain.\n</p>\n<p>\n  Two chains are <i>consecutive</i> if the last segment of one chain is the first segment of the\n  other chain. Note that on the common segment, we will have to use two thermometers.\n</p>\n<p>\n  A <i>valid sequence of chains</i> is a sequence of consecutive chains containing all the given\n  segments.\n</p>\n<p>\n  Note that any valid positioning of the thermometers is a valid sequence of chains, and the number\n  of thermometers there is <b>N</b> plus the number of chains. The optimal answer is achieved in\n  the positioning requiring the smallest number of chains.\n</p>\n<p>\n  <i>Lemma 1.</i> If we have a valid sequence of chains and the first chain is not a <i>maximum\n  chain</i>, we can take some segments from the next chain(s) and attach them to this one until it\n  becomes maximum, while keeping the sequence valid and not increasing the total number of chains.\n</p>\n<div style=\"padding-left:2em\">\n  <p>\n    <u>Proof</u>\n  </p>\n  <p>\n    Let's add a few more terms to our vocabulary.\n  </p>\n  <p>\n    The <i>position of a thermometer</i> on the i-th segment is the distance between the\n    thermometer and <b>X<sub>i</sub></b>.\n  </p>\n  <p>\n    A <i>chain flexibility interval</i> is a set of valid thermometer positions on a segment of a\n    chain, which can be correctly propagated through the whole chain. Note that it is always a\n    subsegment (maybe of length 0) of a segment.\n  </p>\n  <p>\n    The <i>first and last flexibility interval of a chain</i> are the instances of the chain\n    flexibility interval on the first and last segment of the chain accordingly.\n  </p>\n  <p>\n    We can now redefine a valid sequence of chains as a sequence of consecutive chains, containing\n    all the segments, such that on every segment connecting two chains, if (x<sub>last</sub>,\n    y<sub>last</sub>) and (x<sub>first</sub>, y<sub>first</sub>) are the last and first\n    flexibility intervals of these chains, then x<sub>last</sub> &le; y<sub>first</sub>.\n  </p>\n  <p>\n    Now let's consider the first and second chains in some configuration:\n  </p>\n  <ul>\n    <li>\n      a, b and c are the lengths of the first, second and the third segments (if any) of the second\n      chain. Note that a is also the last segment of the first chain.\n    </li>\n    <li>\n      (x<sub>1</sub>, y<sub>1</sub>) - last flexibility interval of the first chain (on segment a).\n    </li>\n    <li>\n      (x<sub>2</sub>, y<sub>2</sub>) - first flexibility interval of the second chain (also on\n      segment a).\n    </li>\n  </ul>\n  <p>\n    For clarity:\n  </p>\n  <ul>\n    <li>\n      x<sub>1</sub> &le; y<sub>2</sub> by the definition of a valid sequence of chains.\n    </li>\n    <li>\n      (a - y<sub>2</sub>, a - x<sub>2</sub>) - second flexibility interval of the second chain (on\n      segment b).\n    </li>\n  </ul>\n  <p>\n    Let's connect segment b to the first chain. Then:\n  </p>\n  <ul>\n    <li>\n      The last flexibility interval of the first chain will be mirrored to segment b and becomes (a\n      - y1, min(b, a - x1)).\n    </li>\n    <li>\n      The second flexibility interval of the second chain will become the first one, and in the\n      worst case will be (a - y2, a - x2) (in other cases it will grow and will contain this\n      interval fully).\n    </li>\n  </ul>\n  <p>\n    First, let's consider the case where the initial flexibility intervals of the chains are\n    intersecting (x<sub>2</sub> &le; y<sub>2</sub>). In this case the new configuration is valid,\n    as a - y<sub>1</sub> &le; a - x<sub>2</sub>, so we can go on to try the next segment if\n    possible.\n  </p>\n  <p>\n    Otherwise, if the original flexibility intervals were not intersecting (x<sub>2</sub> &gt;\n    y<sub>1</sub>), then the new configuration is not valid. Again, the new flexibility intervals\n    will be (a - y<sub>2</sub>, a - x<sub>2</sub>) and (a - y<sub>1</sub>, min(b, a -\n    x<sub>1</sub>)), they will not intersect, and the first flexibility interval of the second\n    chain will come before the last flexibility interval of the first chain (this is why the\n    configuration is invalid).\n  </p>\n  <p>\n    However, we can notice that because (a - y<sub>2</sub>, a - x<sub>2</sub>) belongs to the second\n    chain, it could be successfully propagated to the next segment (c) by definition. But, because\n    (a - y<sub>1</sub>, min(b, a - x<sub>1</sub>)) is even closer to the segment border, we must be\n    able to propagate it as well. This means that we can also attach the next segment to the\n    first chain:\n  </p>\n  <ul>\n    <li>\n      The first flexibility interval of the second chain becomes (b - (a - x<sub>2</sub>), b - (a -\n      y<sub>2</sub>))\n    </li>\n    <li>\n      The last flexibility interval of the first chain will be (b - min(b, a - x<sub>1</sub>),\n      min(c, b - (a - y<sub>1</sub>)))\n    </li>\n  </ul>\n  <p>\n    Now the configuration is valid, because b - min(b, a - x<sub>1</sub>) &le; b - (a -\n    y<sub>2</sub>), and x<sub>1</sub> &le; y<sub>2</sub> by definition.\n  </p>\n  <p>\n    What if we don't have a second segment to attach? Then we won't be able to attach the first\n    one either, since the flexibility intervals were not intersecting, and the flexibility interval\n    of a single segment is the whole segment.\n  </p>\n</div>\n<p>\n  <i>Lemma 2.</i> An optimal answer can always be achieved with a sequence of maximum chains and one\n  potentially non-maximum chain.\n</p>\n<div style=\"padding-left:2em\">\n  <p>\n    <u>Proof</u>\n  </p>\n  <p>\n    Let's consider the first chain of an optimal answer. Let's attach segments from the next chain\n    while we can (we are allowed to do so by Lemma 1). Repeat with the next chain, and so on.\n    When we reach the last chain, leave it alone. Now all the chains except for the last one are\n    maximum, and the last one can be either maximum or not.\n  </p>\n</div>\n<p>\n  The solution described above is building all possible sequences mentioned in Lemma 2, and by that\n  lemma, some of them will be optimal.\n</p>\n<p>\n  Note that our proof has not dealt with small chains properly&mdash;that is, chains of length 1, 2\n  and 3 may not work properly in the proof above, but they are easy to deal with independently as\n  special cases.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0k_JaCYPWwg6kRwv-vHJmNY5wpPgEyLZY0qrpblMbxE67zLDrW2YsgFDcbHDTNiWoYHj0BAgE/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"000000000037776b","statement":"<h3>Problem</h3>\n<p>\n  You are part of a team of researchers investigating the climate along the\n  coast of an island. The island's coast is modeled as a circle with a\n  circumference of <b>K</b> kilometers. There is a lighthouse on the coast\n  which occupies a single point on the circle's circumference. Each point on\n  the coast is mapped to a real number in the range [0, <b>K</b>); formally,\n  point x is the point on the coast that is x kilometers away from the\n  lighthouse when walking clockwise along the coast. For example, if\n  <b>K</b> = 5, point 0 is the point where the lighthouse is, point 1.5 is the\n  point that is 1.5 kilometers away from the lighthouse in the clockwise direction,\n  and point 2.5 is the point that is located at the diametrical opposite of the\n  lighthouse.\n</p><p>\n  You are in charge of studying coastal temperatures. Another team installed a\n  coastal temperature measuring system that works as follows: a number of\n  thermometers were deployed at specific points to measure the temperature at\n  those points. No two thermometers were placed at the same point. In that\n  team's model, points without thermometers are assumed to have the same\n  temperature as the one measured by the closest thermometer. For points that\n  are equidistant from two thermometers, the thermometer in the clockwise\n  direction is used (the first one you would encounter if walking clockwise\n  from the point).\n</p><p>\n  Unfortunately, you do not know how many thermometers the system used or\n  where they were placed, but you do have access to the system's temperature\n  data. It is given as two lists\n  of <b>N</b> values each <b>X<sub>1</sub></b>, <b>X<sub>2</sub></b>, ...,\n  <b>X<sub>N</sub></b> and <b>T<sub>1</sub></b>, <b>T<sub>2</sub></b>, ...,\n  <b>T<sub>N</sub></b>, representing that each point x where\n  <b>X<sub>i</sub></b> &le; x &lt; <b>X<sub>i+1</sub></b> is assigned\n  temperature <b>T<sub>i</sub></b>, for each 1 &le; i &lt; <b>N</b>, and each\n  point x where 0 &le; x &lt; <b>X<sub>1</sub></b> or\n  <b>X<sub>N</sub></b> &le; x &lt; <b>K</b> is assigned temperature\n  <b>T<sub>N</sub></b>. The points are enumerated in the clockwise direction,\n  so <b>X<sub>i</sub></b> &lt; <b>X<sub>i+1</sub></b>, for all i.\n</p><p>\n  You want to determine the smallest number of thermometers\n  that, when placed in some set of locations, could have produced the observed\n  data.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow; each consists of three lines. The first line of a\n  test case contains two integers <b>K</b> and <b>N</b>: the circumference\n  of the island and the size of the lists representing the temperature data.\n  The second line\n  contains <b>N</b> integers <b>X<sub>1</sub></b>, <b>X<sub>2</sub></b>, ...,\n  <b>X<sub>N</sub></b>. The third line contains <b>N</b> integers\n  <b>T<sub>1</sub></b>, <b>T<sub>2</sub></b>, ..., <b>T<sub>N</sub></b>. The\n  way in which the integers in the second and third line represent the\n  temperatures is explained above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is the minimum number of thermometers that could have produced the observed\n  input data, as described above.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>N</b> &le; min(100, <b>K</b>). <br/>\n  0 &le; <b>X<sub>1</sub></b>. <br/>\n  <b>X<sub>i</sub></b> &lt; <b>X<sub>i+1</sub></b>, for all i. <br/>\n  <b>X<sub>N</sub></b> &lt; <b>K</b>. <br/>\n  184 &le; <b>T<sub>i</sub></b> &le; 330, for all i. <br/>\n  <b>T<sub>i</sub></b> &ne; <b>T<sub>i+1</sub></b>, for all i. <br/>\n  <b>T<sub>1</sub></b> &ne; <b>T<sub>N</sub></b>. <br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  2 &le; <b>K</b> &le; 10.\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  2 &le; <b>K</b> &le; 10<sup>9</sup>.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3qWrIND8J8qMGhaiYPuGx8JHswdmoeSbg9BzNvheLnE6bL_icm1XgG9nG5iG-s3HW1j4nhxf8eXyVAW3_NocyleuK_8PBDp3aiOg/thermometers_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n2 2\n0 1\n184 330\n3 2\n0 1\n184 330\n10 3\n1 5 9\n184 200 330\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2BDK5CC_0vPgZ3CjEpnL2x8iQ71tjFCSQfAyTtETvC_rP3h9RFZnbC2z7in25DG86hds1kFwMeARU0D_-Q8NR_XabpNI3USMez9IM/thermometers_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 2\nCase #2: 3\nCase #3: 3\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, at least 2 thermometers are needed because there are two\n  different temperatures measured. It is possible to produce the data using\n  exactly 2 thermometers, with one thermometer (measuring 184) at point 0.5 and\n  another (measuring 330) at point 1.5. Note that point 0 and point 1 are\n  equidistant from both thermometers, so the thermometer in the clockwise\n  direction is used. The temperature measured at point 0 comes from the\n  thermometer at point 0.5 and the temperature measured at point 1 comes from\n  the thermometer at point 1.5.\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0-4chdBQiuYzKl9UWH-NXAw5PMOFRJ1KwuKd2Y3dbZ-MpROlJzVBce-BSiFT-ev57mDLEi9xHEb_m8tTlvrC3Xiw/sample_case_1.svg\"/>\n</p>\n<p>\n  The data from Sample Case #2 could not be produced with just 2 thermometers.\n  It could be produced with 3 thermometers if they were placed at point 0.2,\n  point 1.8, and point 2.8, measuring 184, 330 and 330, respectively. There are\n  other ways to place 3 thermometers that would also yield the input data.\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2yiuTxFYuqVVfruYF8gpLsdNOGq0qGO7UZ3v1izW1NP4oZmXRqrKAmEX9UL6VLOY0SPDjPL_MA6M_Nn7MbiAMSUQ/sample_case_2.svg\"/>\n</p>\n<p>\n  In Sample Case #3, one way to produce the data with 3 thermometers is to\n  place them at point 0, point 2 and point 8, measuring 330, 184 and 200,\n  respectively.\n</p>\n<p style=\"text-align:center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0qZHOyX7WanVOI_0rc7tfWRQEjlJzlTwwaSF2Z3zqPfPDPQgZdhmMpjW6n3-O0EBmA57jWenyryny28CnuzSoV2Q/sample_case_3.svg\"/>\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Thermometers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000019ff7e","type":1,"type__str":"SPECTATOR"},"title":"Round 3 2020"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
