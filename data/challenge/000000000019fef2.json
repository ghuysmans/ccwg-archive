{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1587321000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000019fef2","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  This year, Round 1B jumped right into the <i>Expogo</i> problem, which had a\n  pleasing deterministic solution. <i>Blindfolded Bullseye</i> was interactive\n  and involved geometry; arriving at a correct algorithm probably required\n  drawing some pictures and experimenting bravely! The card-shuffling\n  <i>Join the Ranks</i> had a constructive solution, but one that wasn't easy\n  to find, and a brute-force approach was too slow even for Test Set 1 without\n  an insight.\n</p><p>\n  This was a more time-consuming set of problems than Round 1A's set, and we\n  didn't see our first perfect score until about an hour into the round.\n  <b>jiry_2</b> was in the lead for much of the first hour, and was the first\n  to solve every problem, but <b>mnbmvar</b> swooped in with a penalty time of\n  1:04:30, and <b>jiry_2</b>'s penalty time ended up being slightly larger, at\n  1:07:08. <b>isaf27</b> came in third with 1:08:38, and then\n  <b>Marcin.Smulewicz</b> and <b>duality</b> were not far behind in fourth and\n  fifth. By the end of the contest, there were almost 90 perfect scores.\n</p><p>\n  Once again, we had a five-digit number of contestants on the scoreboard.\n  Tentatively, the advancement cutoff is 34 points plus a small enough\n  penalty time. It wasn't quite enough to solve just Expogo! We saw quite a\n  few pickups of the first Blindfolded Bullseye set; the first Join the Ranks\n  set, on the other hand, was tougher to snag.\n</p><p>\n  Round 1C is two weeks from now, so you will have some extra time to\n  <a href=\"https://codingcompetitions.withgoogle.com/codejam/archive\" target=\"_blank\">practice</a>\n  if that round will be your last chance to advance. Good luck, and next time\n  you play darts, remember to flush your buffer between throws!\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Expogo: Written by Ian Tullis. Prepared by John Dethridge.\n</p><p>\n  Blindfolded Bullseye: Written and prepared by Pablo Heiber.\n</p><p>\n  Join the Ranks: Written by Shik Chen and Pi-Hsun Shih. Prepared by Kevin Gu\n  and Jonathan Irvin Gunawan.\n</p><p>\n  Solutions and other problem preparation and review by Liang Bai, Darcy Best,\n  Timothy Buzzelli, John Dethridge, Kevin Gu, Jonathan Irvin Gunawan, Md\n  Mahbubul Hasan, Andy Huang, Nafis Sadique, Pi-Hsun Shih, Kevin Tran, and Max\n  Ward.\n</p><p>\n  Analysis authors:\n</p>\n<ul>\n  <li>Expogo: Ian Tullis.</li>\n  <li>Blindfolded Bullseye: Pablo Heiber.</li>\n  <li>Join the Ranks: Pablo Beltran.</li>\n</ul>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1587312000000,"tasks":[{"analysis":"<h3>Test Set 1</h3>\n<p>\n  Test Set 1 is small enough to solve by hand. We can speed this up with a\n  couple of observations:\n</p>\n<ul>\n  <li>We can notice that every position with an even (X + Y) (apart from the\n    origin) &mdash; hereafter an \"even\" position &mdash; seems to be\n    unreachable. We can prove to ourselves that this is true: our initial X and\n    Y coordinates of (0, 0) are both even, but only the first of our possible\n    jumps (the 1-unit one) is of an odd length, and all jumps after that are of\n    even lengths. So there is no way to reach any other \"even\" position\n    starting from the origin, no matter how much jumping we do.</li>\n  <li>We can find that all \"odd\" positions, on the other hand, can be reached\n    using no more than 3 moves.</li>\n  <li>To speed up solving the \"odd\" positions, we can take advantage of\n    symmetry, as suggested in the explanation for Sample Case #2. For example,\n    if we learn that <code>EEN</code> is a solution for (3, 4), then we also\n    know that <code>WWS</code> is a solution for (-3, -4), and <code>EES</code>\n    is a solution for (3, -4), and so on. Because of all the horizontal,\n    vertical, and diagonal symmetry, there are really only six fundamentally\n    different cases!</li>\n  <li>We can check that our solutions are optimally short by using an argument\n    like the one in the explanation for Sample Case #1. Any position with a\n    Manhattan distance (that is, |<b>X</b>| + |<b>Y</b>|) of 1 cannot be reached\n    in fewer than one jump; positions with Manhattan distances up to 3 and 7\n    require at least two or three jumps, respectively. If our solution lengths\n    match these lower bounds &mdash; and they probably do unless we have jumped\n    in an unusually indirect way &mdash; then they are valid.</li>\n</ul>\n<h3>Test Set 2</h3>\n<p>\n  Based on the observations above, we may think to try a\n  <a href=\"http://en.wikipedia.org/wiki/Breadth-first_search\" target=\"_blank\">breadth-first search</a>\n  of all possible jumping paths, and continue until every \"odd\" (X, Y) position\n  (with -100 &le; X &le; 100 and -100 &le; Y &le; 100) has been reached. It\n  turns out that each such position is reachable in no more than 8 moves. We\n  know that these solutions are optimally short because of the breadth-first\n  nature of the search.\n</p>\n<h3>Test Set 3</h3>\n<p>\n  Suppose that (<b>X</b>, <b>Y</b>) = (7, 10). In what direction should we\n  make our initial 1-unit jump? As we saw above, we need our final X coordinate\n  to be odd, but it is currently even, and we have only one chance to go from\n  even to odd. Moving north or south will make our Y coordinate odd, but then\n  we will never have another chance to make that even and the X coordinate odd.\n  So we should either move west or east. For now, let's guess that we will go\n  west; we will revisit the other possibility later.\n</p><p>\n  That jump will take us to (-1, 0), and we will next need to make a 2-unit\n  jump. Notice that we can make this look identical to the original problem setup,\n  if we make two changes:\n</p>\n<ol>\n  <li>Shift (-1, 0) to be the new (0, 0). Then the goal becomes (8, 10)\n    rather than (7, 10).</li>\n  <li>Transform the scale of the problem such that a 2-unit jump (to a\n    \"neighboring\" cell) becomes the new 1-unit jump. Then the goal becomes\n    (4, 5) instead of (8, 10).</li>\n</ol>\n<p>\n  With this in mind, let's revisit our original decision to jump to the west.\n  If we had jumped east instead, we would have ended up at (1, 0), and if we\n  had changed the problem in the same way we did above, our new goal would have\n  been (3, 5). But that would be an \"even\" position (after rescaling), which\n  cannot be reached! So we had no choice after all; we had to move west to be\n  able to eventually reach the goal. It's a good thing we were so lucky!\n</p><p>\n  So now the problem has \"reset\", and we are at (0, 0) and trying to get to\n  (4, 5). In what direction should we make our \"first\" jump? Now we know we\n  must move vertically, since 5 is odd and we will only have \"one chance\" to\n  go from even to odd. If we jump north, the next rescaling will have a target\n  of (2, 2), but if we jump south, the target will be (2, 3), which is the\n  \"odd\" position that we want. From there, we should jump south to change the\n  target to (1, 2), then east to change the target to (0, 1). At that point,\n  we have a choice between jumping north and reaching the goal, and jumping\n  south (which could still allow us to reach the goal after some further moves,\n  e.g. one more to the south and then one more to the north). But the problem\n  requires that we choose the shortest solution, so we should jump right to\n  the goal! Therefore, the answer in this case is <code>WSSEN</code>.\n</p><p>\n  Notice that this method is deterministic: we always have only one choice out\n  of the four possible directions. We can rule out two of them because they\n  will not make the correct coordinate odd. Of the other two, the new goal\n  states they would leave us with must differ only in one of the coordinates\n  and only by exactly 1 unit, and therefore one must be an \"odd\" position and\n  the other must be an \"even\" position. It is possible that that \"even\"\n  position is the goal, in which case we should jump there, but otherwise, we\n  must choose the \"odd\" position.\n</p><p>\n  The above analysis also shows that the only time we have a choice is when\n  one of those options is to jump directly to the goal, in which case we\n  obviously should. So we can be confident that our method produces the\n  shortest possible solution. (We also know that that solution is unique,\n  since if we were to choose to not jump directly to the goal when we had that\n  option, we would only end up with a longer solution.)\n</p><p>\n  Our method has a running time which is logarithmic in the magnitudes of the\n  coordinates, so it will solve this test set blazingly fast!\n</p>\n\n<h3>A Code Jam callback!</h3>\n<p>\n  This problem is a riff on the Pogo problem from Round 1C in 2013. If you were\n  familiar with that problem, the analysis might have helped a bit with this\n  one... but, like a well-designed pogo stick, Expogo is not <i>too</i>\n  difficult to get a handle on anyway.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3TWlJTotUtN5FRuVTnjw3ZcpQOiD2Qf5stMV3dwr_tvmi7rY2ugMPh9PWzzHLK2zzh6LDEryE/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000002d5b62","statement":"<h3>Problem</h3>\n<p>\n  You have just received the best gift ever: an Expogo stick. You can stand on\n  it and use it to make increasingly large jumps.\n</p><p>\n  You are currently standing on point (0, 0) in your infinite two-dimensional\n  backyard, and you are trying to reach a goal point (<b>X</b>, <b>Y</b>), with\n  integer coordinates, in as few jumps as possible. You must land exactly on\n  the goal point; it is not sufficient to pass over it on a jump.\n</p><p>\n  Each time you use your Expogo stick to jump, you pick a cardinal direction:\n  north, south, east, or west. The i-th jump with your Expogo stick moves you\n  2<sup>(i-1)</sup> units in the chosen direction, so your first jump takes you\n  1 unit, your second jump takes you 2 units, your third jump takes you 4 units,\n  and so on.\n</p><p>\n  Given a goal point (<b>X</b>, <b>Y</b>), determine whether it is possible to\n  get there, and if so, demonstrate how to do it using as few jumps as\n  possible.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of a single line with two integers\n  <b>X</b> and <b>Y</b>: the coordinates of the goal point.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is <code>IMPOSSIBLE</code> if the goal point cannot be reached. Otherwise,\n  <code>y</code> must be a string of one or more characters, each of which is\n  either <code>N</code> (north), <code>S</code> (south), <code>E</code> (east),\n  or <code>W</code> (west), representing the directions of the jumps that you\n  will make, in order. This sequence of jumps must reach the goal point at the\n  end of the final jump, and it must be as short as possible.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  (<b>X</b>, <b>Y</b>) &ne; (0, 0).<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 80.<br/>\n  -4 &le; <b>X</b> &le; 4.<br/>\n  -4 &le; <b>Y</b> &le; 4.<br/>\n</p>\n\n<h4>Test set 2 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  -100 &le; <b>X</b> &le; 100.<br/>\n  -100 &le; <b>Y</b> &le; 100.<br/>\n</p>\n\n<h4>Test set 3 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  -10<sup>9</sup> &le; <b>X</b> &le; 10<sup>9</sup>.<br/>\n  -10<sup>9</sup> &le; <b>Y</b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0sVW7Ooh_AwDV15_WSPPL9OlmYNCRFpxoL5iJpLyQsJ7zZU6z6nqfUIXZnFLdU4OnLskST-UZTBkDvCmgCfLaYj0NUNQ/expogo_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n2 3\n-2 -3\n3 0\n-1 1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3pJI0aS9oAHC4Wo63w8CexGRiWgK6JNL930uAhj9qp66GoCK9R_Kr0OO6KqPehN9MRE4G7qJEe69JN7-CtK1KdRWTfNiI/expogo_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: SEN\nCase #2: NWS\nCase #3: EE\nCase #4: IMPOSSIBLE\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, you can jump south from (0, 0) to (0, -1), then jump east\n  to (2, -1), then jump north to (2, 3).\n</p><p>\n  We can be sure there is not a more efficient solution (two moves or fewer)\n  because at least 2 + 3 = 5 units of distance are needed to reach the goal\n  point, but the first two jumps combined only give us 3 units of distance.\n</p><p>\n  Notice that Sample Case #2 is like Sample Case #1 but reflected across both\n  axes, and so the answer comes from reflecting all directions in Sample Case\n  #1's answer.\n</p><p>\n  In Sample Case #3, notice that <code>EWE</code> would not be a valid answer,\n  even though it reaches the target, because there is a way to get there using\n  fewer jumps.\n</p><p>\n  We leave it to you to determine why it is impossible to reach the target in\n  Sample Case #4.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":8},{"type":1,"type__str":"VISIBLE","value":16}],"title":"Expogo","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\nIn Test Set 1 the radius is both really large and known in advance. The fact that it is large gives\nus a major restriction: plugging in the value for R in the limits for X and Y shows that the hidden\ncenter is restricted to a square with side length 10 nanometers, centered on the origin. That means\nthat there are only 11<sup>2</sup> = 121 possible positions for the center! We can simply try\nthrowing a dart at each of them, stopping as soon as we are told that we have hit the\n<code>CENTER</code>.\n</p>\n<h3>Test Set 2</h3>\n<p>\nIn Test Set 2 the radius is also large and known, but small enough that\nthe square of candidate center points has side 101 nanometers. This means that there are 10201\npossible centers, which is a lot more than the number of darts we get. We need to restrict that\nfurther.\n</p><p>\nWe can use the fact that we know the exact radius to reduce this number.\nEvery dart we throw can give us a clue. If a dart thrown at point p hits, that means the\nthe distance between p and the center c is no more than R. If a dart thrown at point q misses,\nthat means that the distance between q and c is more than R. If we find two points p and q that are\nclose to each other, the points that are no more than R away from p but more than R away\nfrom q form a narrow crescent-shaped region of width equal to the distance between p and q.\nIntersecting that with the original square of possibilities from the first paragraph can give us a\nsmall enough range for c that we can just throw a dart at each possibility without running out of\ndarts.\n</p><p>\nWe can find points p and q that are close to each other by finding the edge of the dartboard. Since\nthe dartboard is so large, the edge has to be close to the edge of the wall. If we inspect points\n(x, 0) for the possible values of x, most points are guaranteed to be inside the dartboard: any\npoint (x, 0) with -10<sup>9</sup> + 101 &le; x &le; 10<sup>9</sup> - 101 is no more than R away from\nall possible centers, and is thus guaranteed to be inside the circle. Therefore, we can try all\npossible x on any one side of that guaranteed interval to find a hit point and a miss point that are\n1 nanometer away from each other. Since there are only 101 points on each side that are not\nguaranteed to be in the circle &mdash; for example [-10<sup>9</sup>, -10<sup>9</sup> + 100] &mdash;\nthis requires at most 101 darts.\n</p><p>\nAfter finding those points, we know that the center has to be inside a narrow crescent-shaped band\nof width 1. Intersecting that with the 101-by-101 square of candidates leaves at most 202\ncandidates, since there can't be more than 2 candidates that share an x value. Moreover,\nfor most x values, the rounding ensures that there are less than 2, so the 199 darts we\nhave left are enough to cover all candidates.\n</p><p>\nNotice that no complicated geometry is involved to find the candidates; the square is small enough\nto iterate over all points within it and check the distances to our hit and miss points to see if\nthey are candidates or not.\n</p>\n<h3>Test Set 3</h3>\n<p>\nFor Test Set 3, we can take a more typical geometric approach. To find the center of a circle,\nwe can find 3 points on the edge of the circle, and then calculate a center from those. This\nhas an issue: we only have nanometer precision, which means we would typically find points near the\nedge of the circle, but not exactly in it. The error that this introduces in our calculations\ncould be significant. We can overcome this by bounding the error and then checking not only\nour calculated center, but also other nearby points too. The math to calculate the center,\nand most importantly, to bound the error of it, can be hard and time consuming, but it\nis doable. In addition, you can wing it by not bounding the error and instead starting to throw\nat your calculated center and then spiral around it on nearby points until you find the actual\ncenter. This requires a leap of faith that you won't run out of tries, but it's a reasonable\nassumption. Fortunately, there is a simpler related approach that is more clearly correct,\nthat we describe below. Of course, we still need to solve the problem of finding \"almost-edge\"\npoints of the circle, which we also need for our simpler approach.\n</p><p>\nTo find a point in the edge, we can't use the approach in Test Set 1, because if the dartboard's\nradius is not very large, those points could be really far away from the wall's edge. A different\nway of doing it is via a\n<a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\" target=\"_blank\">binary search</a>.\nSay we know that point (x<sub>0</sub>, y<sub>0</sub>) is within the dartboard. Then,\nwe know that for all x in the range [-10<sup>9</sup>, x<sub>0</sub>]\nthe points (x, y<sub>0</sub>) are grouped such that there is a (possibly empty) interval having\nall misses, and then an interval having all hits. The same holds (in reverse) for\n[x<sub>0</sub>, 10<sup>9</sup>]. Analogously, points (x<sub>0</sub>, y) for y in\n[-10<sup>9</sup>, y<sub>0</sub>] or [y<sub>0</sub>, 10<sup>9</sup>] are grouped by hits/misses.\nThen, for each of those ranges, we can do a binary search to find the switching point &mdash;\nthat is, a point in the edge of the circle. This is exactly what we did in Test Set 2, except\nwe fixed x<sub>0</sub> = 0, because the radius is so large that some points\nlike (0, 0) are guaranteed to be inside the dartboard, and the range is small enough that we\ncan scan it entirely instead of using binary search.\n</p><p>\nThe searches above get us leftmost and rightmost points inside the dartboard for a given\ny-coordinate y<sub>0</sub>, and topmost and bottommost points for a given x-coordinate\nx<sub>0</sub>. Notice that the dartboard is symmetric with respect to the horizontal and vertical\nlines that go through its center. Therefore, the leftmost and rightmost points inside the dartboard\nin any fixed y-coordinate mirror each other, and the x-coordinate of the center is the midpoint\nbetween their x-coordinates. Similarly, we can find the y-coordinate of the center\nas the midpoint between the y-coordinates of the topmost and bottommost points inside the\ndartboard at any fixed x-coordinate.\n</p><p>\nThe remaining task is to find a single point inside the dartboard. Since the area of the dartboard\nmakes up a significant percentage of the wall area (at least &pi; / 16), we could do this by\nthrowing darts at random until we hit one point (the probability of hitting could be slightly less\nthan &pi; / 16 because we consider only points with integer nanometer coordinates, but the\ndifference is negligible). This has an overwhelmingly high chance of hitting in 100 throws or fewer\nfor all cases. However, there is a deterministic way that also works, which is to divide\nthe wall into squares of side <b>A</b>. If the center of the dartboard is inside a square, it is\nguaranteed that at least one of the corners of that square is inside the dartboard. Therefore, we\ncan simply try all those corners (there are only 25, and it is even possible to restrict it\nfurther), and we will find a hit point.\n</p><p>\nSo, we need a fixed small number of darts (up to 100, depending on our method of choice)\nto find a point inside the dartboard, and each binary search\nneeds at most 31 = ceil(log<sub>2</sub> (2 &times; 10<sup>9</sup> + 1)). That is at most\n4 &times; 31 + 100, which is a lot less than the 300 limit. In the first version, you need one fewer\nbinary search &mdash; 3 edge points are enough to find a unique center &mdash; so after finding\nthe center with error, you could have 150 darts left to explore its vicinity. Notice that if your\ninitial point is actually one of the points (X - R, Y), (X + R, Y), (X, Y - R) or (X, Y + R),\nyou would end up with two points instead of three and be unable to find the center. If we use the\nrandom procedure to find (x<sub>0</sub>, y<sub>0</sub>), the probability of this happening is\nnegligible. Otherwise, we can detect the case and know that the two found points are opposite\neach other, so the center is their middle point.\n</p>\n","id":"00000000002d5b63","statement":"<h3>Problem</h3>\n<p>\n  Gary has a large square wall that is exactly 2 &times; 10<sup>9</sup> nanometers tall and\n  2 &times; 10<sup>9</sup> nanometers wide.\n  Gary has a dartboard placed on the wall. The dartboard is circular and its radius is\n  between <b>A</b> and <b>B</b> nanometers, inclusive.\n  The dartboard is fully contained within the wall, but it may touch its edges.\n  The center of the dartboard is an integer number of nanometers from each edge of the wall.\n</p><p>\n  Gary invited his friend Mika over to play an interesting game. Gary blindfolds Mika and\n  challenges her to throw a dart at the center of the dartboard. To help her, whenever Mika\n  throws a dart at the wall, Gary will tell her whether the dart hit the dartboard.\n</p><p>\n  Mika does not know where on the wall the dartboard is, but since Mika is very skilled at darts,\n  she can throw darts with nanometer precision. That is, she can aim and hit exactly any point that\n  is an integer number of nanometers away from each edge of the wall. Immediately after throwing\n  each dart, Gary tells her whether she hit the center of the dartboard, some other part of it, or\n  missed it completely and hit the bare wall.\n</p><p>\n  Can you help Mika hit the center of the dartboard, without throwing more than 300 darts?\n</p>\n\n<h3>Input and Output</h3>\n<p>\n  Initially, your program should read a single line containing three integers <b>T</b>,\n  <b>A</b> and <b>B</b>, indicating the number of test cases and the inclusive minimum and maximum\n  values for the dartboard's radius, in nanometers, respectively. (Notice that <b>A</b> and\n  <b>B</b> are the same for every test case within a test set.) Then, you need to process <b>T</b>\n  test cases.\n</p><p>\n  We represent the points that darts can be aimed at as pairs (x, y), where x and y are\n  integers between -10<sup>9</sup> and 10<sup>9</sup>, inclusive. The pair (x, y) is\n  the point that is x + 10<sup>9</sup> nanometers away from the left edge of the wall and\n  y + 10<sup>9</sup> nanometers away from the bottom edge of the wall. Point (0, 0) is therefore\n  at the exact center of the wall.\n</p><p>\n  For each test case, there is a secretly chosen radius R for the dartboard, and a\n  secretly chosen center of the dartboard (X, Y).\n  R, X, and Y are integers chosen for each test case by the judges in a designed\n  (not random) way, within the limits. For each test case you need to process up to 300 exchanges\n  with the judge. Your program represents Mika and the judge program represents Gary.\n  Each exchange consists of Mika (your program) choosing where to throw a dart and Gary\n  (the judging program) giving information about that position.\n</p><p>\n  The i-th exchange consists of your program first outputting a single line containing two integers\n  X<sub>i</sub> and Y<sub>i</sub>, both between -10<sup>9</sup> and 10<sup>9</sup>, inclusive,\n  and the judge responding with a single line containing either:\n</p>\n<ul>\n  <li><code>CENTER</code> if X<sub>i</sub> = X and Y<sub>i</sub> = Y</li>\n  <li><code>HIT</code> if 0 &lt;\n        (X - X<sub>i</sub>)<sup>2</sup> + (Y - Y<sub>i</sub>)<sup>2</sup> &le; R<sup>2</sup></li>\n  <li><code>MISS</code> in all other cases.</li>\n</ul>\n<p>\n  After sending <code>CENTER</code>, the judge will start waiting for the first\n  exchange of the next test case, if there is any.\n</p><p>\n  If you output a line that is incorrectly formatted or with an out of bounds value,\n  the judge will respond with a single line containing <code>WRONG</code>.\n  If 300 exchanges occur (including 300 responses from the judge) without you receiving\n  <code>CENTER</code>, or if you ever receive <code>WRONG</code>, the judge will finish all\n  communication, wait for your own program to also finish, and give a Wrong Answer verdict.\n  After sending the <b>T</b>-th <code>CENTER</code>, on the other hand, the judge will finish all\n  communication, wait for your own program to finish, and give a Correct verdict.\n  If, while waiting for your program to finish, time or memory limits are exceeded,\n  the corresponding verdict will be assigned instead. (Note that verdicts are not messages\n  sent to your program.)\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 20.<br/>\n  <b>A</b> &le; R &le; <b>B</b>.<br/>\n  -10<sup>9</sup> + R &le; X &le; 10<sup>9</sup> - R.<br/>\n  -10<sup>9</sup> + R &le; Y &le; 10<sup>9</sup> - R.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  <b>A</b> = <b>B</b> = 10<sup>9</sup> - 5.<br/>\n</p>\n\n<h4>Test set 2 (Visible Verdict)</h4>\n<p>\n  <b>A</b> = <b>B</b> = 10<sup>9</sup> - 50.<br/>\n</p>\n\n<h4>Test set 3 (Hidden Verdict)</h4>\n<p>\n  <b>A</b> = 10<sup>9</sup> / 2.<br/>\n  <b>B</b> = 10<sup>9</sup>.<br/>\n</p>\n\n\n<h3>Testing Tool</h3>\n<p>\n  You can use this testing tool to test locally or on our platform. To test\n  locally, you will need to run the tool in parallel with your code; you can\n  use our <a href=\"https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py\">interactive runner</a>\n  for that. For more information, read the instructions in comments in that\n  file, and also check out the\n  <a href=\"/codejam/faq#interactive-problems\" target=\"_blank\">Interactive Problems section</a>\n  of the FAQ.\n</p><p>\n  Instructions for the testing tool are included in comments within the tool.\n  We encourage you to add your own test cases. Please be advised that although\n  the testing tool is intended to simulate the judging system, it is <b>NOT</b>\n  the real judging system and might behave differently. If your code passes the\n  testing tool but fails the real judge, please check the\n  <a href=\"/codejam/faq#coding\" target=\"_blank\">Coding section</a>\n  of the FAQ to make sure that you are using the same compiler as us.\n</p><p>\n<a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3kUw_lKjUnV_5YLPSEeDFzPcLjscwaS2xR2TNBBhjHFnhAgGtySXF32rWU5sXH8D3QyZ2NWRY1Iw/testing_tool.py?dl=1\" download=\"testing_tool.py\">Download testing tool</a>\n</p>\n<p>\n  <b>The interactive runner was changed after the 2020 Qualification Round.\n  Be sure to download the latest version.</b>\n</p>\n<h3>Sample Interaction</h3>\n\n<p>\n  The following sample interaction uses the limits of Test Set 1.\n</p>\n\n<pre>\n  // The following reads 20 into t and 999999995 into a and b.\n  t, a, b = readline_int_list()\n  // The judge secretly picks R = 999999995 (it had no choice) and X = -1,\n  // Y = 3 (it did have a choice here). (Note: the actual Test Set 1 will\n  // not necessarily use the values in this example.)\n  // We try to throw at the upper left corner of the wall, and the dartboard\n  // does not overlap with that point.\n  printline -1000000000 1000000000 to stdout\n  flush stdout\n  r = readline_string()  // reads MISS.\n  // We try to throw at the center of the wall. That does hit the dartboard,\n  // but not the center.\n  printline 0 0 to stdout\n  flush stdout\n  r = readline_string()  // reads HIT.\n  // We make a super lucky choice and throw at the center of the dartboard.\n  printline -1 3 to stdout\n  flush stdout\n  r = readline_string()  // reads CENTER.\n  // The judge begins the next test case. It secretly picks R = 999999995\n  // and X = 5, Y = 5.\n  // We accidentally throw a dart out of the allowed range.\n  printline -1234567890 1234567890 to stdout\n  flush stdout\n  r = readline_string()  // reads WRONG.\n  exit  // exits to avoid an ambiguous TLE error.\n</pre>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":3},{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":19}],"title":"Blindfolded Bullseye","trial_input_type":2,"trial_input_type__str":"JUDGE_CODE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\n  Test set 1 contains the 12 possible inputs allowed by the limits. We can try to solve the problem\n  via a\n  <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\" target=\"_blank\">breadth-first search</a> (BFS),\n  on the graph of states, where a state is the current arrangement of cards in the deck. Notice,\n  however, that cases with 14 total cards would yield an enormous graph and make the solution run\n  too slowly &mdash; probably even too slowly for us to run the code locally to precompute answers\n  that we can then hardcode!\n</p><p>\n  However, one observation will help us: since the success condition does not involve the suits of\n  the cards at all, we can ignore them and work only with the ranks. That dramatically cuts down\n  the number of possible states, by going from\n  (<b>R</b> &times; <b>S</b>)! to (<b>R</b> &times; <b>S</b>)! / ((<b>S</b>!)<sup><b>R</b></sup>).\n  This allows a BFS to finish fast enough for this test set. We can also use this observation while\n  solving the next test set...\n</p>\n<h3>Test Set 2</h3>\n<p>\n  For test set 2, the worst case (<b>R</b>=40, <b>S</b>=40) has around 1.8 x 10<sup>2517</sup>\n  unique orderings. This means that the brute force solution will not work.\n</p><p>\n  Our first important observation is that the reordering operation can decrease the\n  number of adjacent cards of different ranks by at most two. In the starting configuration\n  there are (<b>R</b> &times; <b>S</b>)-1 adjacent cards of different ranks. In the ending\n  configuration there are <b>R</b>-1 adjacent cards of different ranks. So to get from\n  (<b>R</b> &times; <b>S</b>)-1 to <b>R</b>-1 we need at least\n  ceil((<b>R</b> &times; <b>S</b> - <b>R</b>) / 2) operations.\n</p><p>\n  Now that we know ceil((<b>R</b> &times; <b>S</b> - <b>R</b>) / 2) is a lower bound on the answer,\n  if we can come up with a method that is guaranteed to use no more than\n  ceil((<b>R</b> &times; <b>S</b> - <b>R</b>) / 2) steps, then it will always produce a valid\n  answer.\n</p><p>\n  Now we will outline a way to sort the cards using exactly that many operations. The invariant we\n  maintain is that at all times, for the ranks X and Y of any two consecutive cards, either Y = X,\n  or Y = (X + 1) mod <b>R</b>. This is of course true for the initial ordering of the deck.\n</p><p>\n  We repeatedly perform the following operation, as long as the number of adjacent pairs of cards\n  of the same rank is less than <b>R</b> - 1 and the operation would not pick up the bottom card of\n  the deck: find the largest block of consecutive cards from the top that contains exactly 2\n  different ranks to use as pile A. By the invariant, this will be one or more cards with rank X,\n  followed by one or more cards with rank (X+1) mod <b>R</b>. Then, starting from the first card\n  from the top that is not on pile A, take as pile B the largest block of consecutive cards that\n  does not contain any cards of rank X, plus all consecutive cards of rank X that immediately\n  follow that block. Notice that at least one such card of rank X must exist; otherwise, by the\n  invariant, the number of adjacent pairs of cards of different ranks would already be <b>R</b>-1.\n</p><p>\n  We can show that this operation reduces the number of adjacent cards of different ranks by 2 every\n  time it does not pick up the bottom card of the deck. To show this, notice that the bottom of pile\n  B is a card of rank X and the first card left over in the deck is, by the invariant,\n  (X + 1) mod <b>R</b>. That means that the new adjacent pairs are two cards of rank X\n  (the bottom of pile B and the top of pile A) and two cards of rank (X + 1) mod <b>R</b>\n  (the bottom of pile A and the top of the leftover deck). The broken adjacent pairs are &mdash;\n  by definition of piles A and B &mdash; both of cards of different rank. Therefore, the number of\n  adjacent pairs of cards of different rank decreases by 2 with this operation.\n</p><p>\n  Suppose that performing the operation would pick up the bottom card of the deck. That means that\n  all cards of rank X are in two contiguous blocks at the top and bottom of the deck before the\n  operation is performed. In addition, since this is the first time the bottom card of the deck is\n  picked up for an operation, X = <b>R</b>. Because of the invariant, that requires every other rank\n  to be in a single contiguous block. In this ordering, there are exactly <b>R</b> adjacent pairs of\n  cards with different ranks. Instead of the operation above, we finish by making pile A consist of\n  the largest block of consecutive cards of rank <b>R</b>, starting at the top, and pile B be the\n  rest of the deck. After performing the operation, <b>R</b> - 1 pairs of adjacent cards of\n  different ranks remain (by a similar argument as before, ignoring the broken and created pairs\n  that involved the leftover deck, since there is none leftover) and the final card of the deck is\n  still <b>R</b>.\n</p><p>\n  After performing the repeated operation floor((<b>R</b> &times; <b>S</b> - <b>R</b>) / 2)\n  times, the number of adjacent pairs of cards of the same rank decreases to <b>R</b> - 1 if\n  <b>R</b> &times; <b>S</b> - <b>R</b> is even or <b>R</b> if it's odd. Notice that the number\n  remains greater than <b>R</b> before each such operation, so we would never have picked up the\n  bottom card of the deck. In the even case, the number of adjacent pairs of cards of the same rank\n  is now minimum and we never picked up the bottom card of the deck, so we are at exactly the target\n  ordering. In the odd case, we arrive at the case in which we do pick up the bottom card of the\n  deck with our last operation, but as argued above, that operation also leaves the deck in the\n  target order.\n</p>\n\n\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1P2pw6y0s-_MGVXc2MgI4V6SRwvkTUPGV4WofZ__sbUaQMWJJBi3NeIklp0AB25l7Wn5KSA1s/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000002d5b64","statement":"<h3>Problem</h3>\n<p>\n  You recently acquired a new deck of cards. Each card displays a rank, which\n  is an integer between 1 and <b>R</b>, and a suit, which is an integer between\n  1 and <b>S</b>. For each combination of a rank and a suit, there is exactly\n  one card that displays it, meaning that the deck has <b>R</b> &times;\n  <b>S</b> cards in total. We will denote a card with rank r and suit s as\n  (r, s).\n</p><p>\n  Being brand new, the deck is sorted from top to bottom by suit in increasing\n  order, with ties being broken by ranks in increasing order. That is, (1, 1)\n  comes first, then (2, 1), ..., (<b>R</b>, 1), then (1, 2), (2, 2), ...,\n  (<b>R</b>, 2), and so on up to (<b>R</b>, <b>S</b>). For example, with\n  <b>R</b> = 4 ranks and <b>S</b> = 2 suits, the initial ordering would be:\n  (1, 1), (2, 1), (3, 1), (4, 1), (1, 2), (2, 2), (3, 2), (4, 2).\n</p><p>\n  You want to reorder the deck to be sorted by rank. That is, you want to put\n  all the cards of the same rank together, and have the ranks be in increasing\n  order. You do not care, however, about the order of the suits within each\n  rank. For example, with <b>R</b> = 4 and <b>S</b> = 2, one of the various\n  possible valid new orderings would be: (1, 2), (1, 1), (2, 1), (2, 2), (3, 1),\n  (3, 2), (4, 2), (4, 1).\n</p><p>\n  You have been learning how to cook, so you want to reorder the deck without\n  putting your spatulas down. You decided to sort the deck using only the\n  following multi-part operation:\n<ul>\n  <li>First, take one or more cards from the top of the deck, and set that\n    selection aside as pile A.</li>\n  <li>Next, take one or more cards from the new top of the deck, and set that\n    selection aside as pile B.</li>\n  <li>Finally, put pile A on top of the deck, and then put pile B on top of\n    the new deck.\n</ul>\n<p>\n  Notice that the operation exchanges the pile A part of the deck and the pile\n  B part of the deck, without affecting any other cards deeper in the deck (if\n  there are any).\n</p><p>\n  Continuing with our <b>R</b> = 4, <b>S</b> = 2 example, if your first move is\n  to choose 3 cards from the top for pile A and 2 cards for pile B, then these\n  are the cards you get:<br/>\n  A: (1, 1), (2, 1), (3, 1),<br/>\n  B: (4, 1), (1, 2), and<br/>\n  Remainder of deck: (2, 2), (3, 2), (4, 2).<br/>\n  After putting A on the deck and then B on top of that, the new deck is\n  ordered like this:<br/>\n  (4, 1), (1, 2), (1, 1), (2, 1), (3, 1), (2, 2), (3, 2), (4, 2).\n</p><p>\n  Given <b>R</b> and <b>S</b>, find a sequence of operations that reorders the\n  deck to be sorted by rank, as described above, and uses the minimum possible\n  number of operations to do so.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> lines follow. Each of these lines describes a single test case with\n  two integers <b>R</b> and <b>S</b>, the number of ranks and suits in the\n  deck, respectively.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1) and\n  <code>y</code> is the minimum number of operations needed to reorder the deck\n  as explained above. Then, print <code>y</code> more lines containing\n  <code>a<sub>i</sub> b<sub>i</sub></code>, meaning that in the i-th operation\n  in a sequence of moves that reorders the deck, you take\n  <code>a<sub>i</sub></code> cards first to form pile A and then\n  <code>b<sub>i</sub></code> cards after that to form pile B.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Memory limit: 1GB.<br/>\n</p>\n\n<h4>Test set 1 (Visible Verdict)</h4>\n<p>\n  Time limit: 30 seconds.<br/>\n  <b>T</b> = 12.<br/>\n  2 &le; <b>R</b> &le; 5.<br/>\n  2 &le; <b>S</b> &le; 7.<br/>\n  <b>R</b> &times; <b>S</b> &le; 14.<br/>\n</p>\n\n<h4>Test set 2 (Hidden Verdict)</h4>\n<p>\n  Time limit: 60 seconds.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>R</b> &le; 40.<br/>\n  2 &le; <b>S</b> &le; 40.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0sSltwGlod7lULkiQVFS3Z4oP-KPb_q4kSrCYPvyZsQvK7OjfpPQn9mnDfY-f_i_LF0tyuP94DsRvtGZ9ztkjNOoHcjroiE6DY8pyS/join_the_ranks_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n2 2\n3 2\n2 3\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1BnzBpH_fK1U9CO80zeUzBSKD8Aksf5xSWI7c4v81PdUkAYpHKw0gxBgsPcOynhYfvlGU2DKokEcrL86ZY5Ai5wMU1Sx8gFU9hynr4dA/join_the_ranks_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 1\n2 1\nCase #2: 2\n3 2\n2 1\nCase #3: 2\n2 3\n2 2\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, the initial order is\n  <nobr>(1, 1), (2, 1), (1, 2), (2, 2).</nobr> After swapping\n  <nobr>A = (1, 1), (2, 1)</nobr> and <nobr>B = (1, 2)</nobr> the deck is left\n  as <nobr>(1, 2), (1, 1), (2, 1), (2, 2)</nobr>, which is sorted by rank as\n  needed. Notice that the suits are in different orders within each rank, which\n  is allowed.\n</p><p>\n  In Sample Case #2, the initial order is\n  <nobr>(1, 1), (2, 1), (3, 1), (1, 2), (2, 2), (3, 2).</nobr>\n  After swapping <nobr>A = (1, 1), (2, 1), (3, 1)</nobr> and\n  <nobr>B = (1, 2), (2, 2)</nobr> the deck is left as\n  <nobr>(1, 2), (2, 2), (1, 1), (2, 1), (3, 1), (3, 2).</nobr>\n  In a second move, we can do <nobr>A = (1, 2), (2, 2)</nobr> and\n  <nobr>B = (1, 1)</nobr> to get\n  <nobr>(1, 1), (1, 2), (2, 2), (2, 1), (3, 1), (3, 2).</nobr>\n</p><p>\n  In Sample Case #3, another valid solution is <code>a<sub>1</sub></code> = 4,\n  <code>b<sub>1</sub></code> = 1 first, and then <code>a<sub>2</sub></code> = 3\n  and <code>b<sub>2</sub></code> = 1.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":14},{"type":2,"type__str":"HIDDEN","value":23}],"title":"Join the Ranks","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000019fef2","type":1,"type__str":"SPECTATOR"},"title":"Round 1B 2020"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
