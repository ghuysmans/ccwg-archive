{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1596906000000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000019ff31","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\r\n  We know the Code Jam 2020 World Finals were a different experience, but the\r\n  problems themselves were as challenging as usual! The first one,\r\n  <i>Pack the Slopes</i>, was worth fewer points and could be solved with the\r\n  right applications of some evergreen techniques. The other four were all\r\n  worth the same (larger) amount of points, so contestants had to make tactical\r\n  decisions based on their own strengths and preferences. Would they try the\r\n  insight-based <i>Adjacent and Consecutive</i>, the implementation-heavy\r\n  <i>Hexacoin Jam</i>, the tricky geometric <i>Musical Cords</i>, or the\r\n  elegantly satisfying graph-based <i>Replace All</i>? Also, which Test Set\r\n  1s were the lowest-hanging fruit?\r\n</p><p>\r\n  Only 13 minutes in, <b>Benq</b> submitted the first correct full solution,\r\n  which was for Pack the Slopes. After that, it took another hour for one of the\r\n  other problems to be solved (Replace All, by <b>ecnerwala</b> and then\r\n  <b>yutaka1999</b>). <b>ecnerwala</b> was the first to break the 100 point\r\n  barrier, around two and a half hours into the contest, and <b>ksun48</b>\r\n  reached the same point total about 15 minutes later.\r\n</p><p>\r\n  The top of the board was quiet for a while, but then at 3:11,\r\n  <b>Gennady.Korotkevich</b> made several submissions and leapt to 173 points,\r\n  lacking only the second test set of Musical Cords. The other contestants\r\n  didn't know the true results, of course, and there was a chance that someone\r\n  could have overtaken him... but nobody did, and he became our seven-time\r\n  Code Jam champion! What an impressive streak &mdash; our hats are off to\r\n  you. In second, third, and fourth, all with 131 points, were <b>ksun48</b>\r\n  (3:30:36), <b>ecnerwala</b> (3:55:58), and <b>scottwu</b> (4:13:58) &mdash;\r\n  also excellent performances!\r\n</p><p>\r\n  We hope that Code Jam 2020 provided you with the usual joy of solving\r\n  algorithmic problems, and we especially appreciate your participation this\r\n  time around. We look forward to welcoming everyone back again in 2021, and\r\n  until then, you can keep your skills sharp on our platform with\r\n  <a href=\"http://codingcompetitions.withgoogle.com/kickstart\" target=\"_blank\">Kick Start</a>.\r\n  All of us on the team hope that you and your loved ones are safe and healthy.\r\n</p>\r\n<hr>\r\n<p>\r\n  <b>Cast</b>\r\n</p><p>\r\n  Pack the Slopes: Written by Max Ward. Prepared by Darcy Best and Max Ward.\r\n</p><p>\r\n  Adjacent and Consecutive: Written by Pablo Heiber. Prepared by Mohamed Yosri\r\n    Ahmed, Timothy Buzzelli, and Jonathan Irvin Gunawan.\r\n</p><p>\r\n  Hexacoin Jam: Written by Darcy Best. Prepared by Mohamed Yosri\r\n    Ahmed and Pablo Heiber.\r\n</p><p>\r\n  Musical Cords: Written by Max Ward. Prepared by the üê± Peppurr Fan Squad üê±:\r\n    Darcy Best, Timothy Buzzelli, and Max Ward.\r\n</p><p>\r\n  Replace All: Written by Pablo Heiber. Prepared by John Dethridge.\r\n</p><p>\r\n  Solutions and other problem preparation and review by\r\n  Mohamed Yosri Ahmed, Sadia Atique, Liang Bai, Tomi Belan, Darcy Best,\r\n  Timothy Buzzelli, Chun-Sung Ferng, Jonathan Irvin Gunawan, Md Mahbubul Hasan,\r\n  Pablo Heiber, Ikumi Hide, Yui Hosaka, Artem Iglikov, Gabriel-Robert Inelus,\r\n  ChanMin Kim, Petr Mitrichev, Kimiyuki Onaka, Archie Pusaka, Nafis Sadique,\r\n  Pi-Hsun Shih, Ian Tullis, Max Ward, and Marten Wiman.\r\n</p><p>\r\n  Analysis authors:\r\n</p>\r\n<ul>\r\n  <li>Pack the Slopes: Max Ward.</li>\r\n  <li>Adjacent and Consecutive: Pablo Heiber.</li>\r\n  <li>Hexacoin Jam: Pablo Heiber.</li>\r\n  <li>Musical Cords: Max Ward.</li>\r\n  <li>Replace All: Pablo Heiber.</li>\r\n</ul>\r\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1596891600000,"tasks":[{"analysis":"<p>\nThe first thing we can notice is that since we replace every occurrence of a character, and at\nthe end we count unique characters, we can regard the input <b>S</b> as a set. That is, multiple\noccurrences of the same character can be ignored, and the order of the characters is\nunimportant. We write \"x &rarr; y\" to represent the replacement of a character x by a character y.\nHere, and in the rest of the analysis, we use both lowercase and uppercase letters to represent\nvariables, not actual letters that can happen in the input.\n</p><p>\nTo simplify the explanations, we can represent the list of replacements as a\n<a href=\"https://en.wikipedia.org/wiki/Directed_graph\" target=\"_blank\">directed graph</a> G where nodes\nrepresent characters, and there is an edge from x to y if and only if\nthere exists a replacement x &rarr; y in the input. Notice that each\n<a href=\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)\" target=\"_blank\">weakly connected component</a>\nof G defines a problem that can be solved independently, and combining the results corresponds to\nadding up the number of distinct characters that can occur in the final text from each group.\nIn particular, notice that a character c that does not appear in any replacement forms a\nsingle-node connected component, and the result for each such character is\neither 1 if c is in <b>S</b>, and 0 otherwise.\n</p><p>\nLet us define <i>diversity</i> as the number of unique characters in a text. Diversity\nof the last text is exactly what we are trying to maximize.\nIf both x and y are in U, the diversity after performing x &rarr; y on U is 1 less than before.\nOn the other hand, if at least one of x and y is not in U, then the diversity before and\nafter performing x &rarr; y is the same.\nThat is, the replacement can either cause a diversity loss of 1,\nor not cause any loss. We can then work on minimizing the diversity loss, and the final\nanswer will be the original diversity minus the loss.\n</p>\n<h3>Test Set 1</h3>\n<p>\nIn Test Set 1 the in-degree of each node of G is limited to at most 1. This restricts\nthe types of weakly connected components the graph can have. If there is a node in the\ncomponent with in-degree equal to 0, then the component is a\n<a href=\"https://en.wikipedia.org/wiki/Tree_(graph_theory)\" target=\"_blank\">directed tree</a> and the node with\nin-degree equal to 0 is the root. If all nodes in the component have in-degree equal to 1, then\nthere is a cycle (which we could find by starting at any node and following edges backwards\nuntil we see a node for the second time). Each node in the cycle only has its incoming edge\ncoming from another node in the cycle, but it can have edges pointing out to non-cycle nodes.\nThis means each cycle-node can be the root of a directed tree. These are the connected components\nof <a href=\"https://en.wikipedia.org/wiki/Pseudoforest\" target=\"_blank\">pseudoforests</a>.\n</p><p>\nWe can break down this test set by component type.\nLet's consider the simplest possible tree first: a\nsimple path c<sub>1</sub> &rarr; c<sub>2</sub> &rarr; ... &rarr;  c<sub>k</sub>. If both\nc<sub>k-1</sub> and c<sub>k</sub> are in the initial text <b>S</b>, then we cannot perform\nc<sub>k-1</sub> &rarr; c<sub>k</sub> without losing diversity.\nNo other replacement in the text can make c<sub>k-1</sub> or c<sub>k</sub> disappear from\nthe text, so they will both be present until c<sub>k-1</sub> &rarr; c<sub>k</sub>\nis performed for the first time. In addition, after\nwe perform c<sub>i-1</sub> &rarr; c<sub>i</sub> for any i, we can immediately perform\nc<sub>i-2</sub> &rarr; c<sub>i-1</sub> without loss of diversity, since c<sub>i-1</sub>\nwill definitely not be in the text then. Therefore, performing every replacement in the path\nin reverse order works optimally.\n</p><p>\nWith some care, we can extend this to any tree. Consider a leaf node y that is maximally far from\nthe root. The replacement x &rarr; y that goes into it is in a similar position as the last\nreplacement in a path, but there could be other replacements that remove x from the text\nbefore performing x &rarr; y, which would prevent x &rarr; y from causing diversity loss.\nSince y is maximally far from the root, however, all other replacements\nthat can help also lead to leaf nodes. If x and the right side of all replacements that\ngo out of x are in <b>S</b>, there is no way to avoid losing diversity. However, only the first\none we perform will cause diversity loss, whereas all the others can be done when x\nis no longer in the text, preventing further loss. We can generalize this by noticing that we\ncan \"push\" characters down the tree without loss of diversity as long as there is at least one\ndescendant node that is not in the current text. This is done by considering the path\nfrom a node x to the descendant that is not in the text y, and processing the path between x\nand y as described earlier.\n</p><p>\nFrom the previous paragraph, we can see that any edge x &rarr; y that does not go into a leaf\nnode can be used without diversity loss. Even if there are no descendants of x in the tree that\nare not in the initial text <b>S</b>, we can process some unsalvageable leaf node first, and\nthen we will have room to save x &rarr; y. Any edge z &rarr; w that goes into leaf nodes may be\nsalvageable as well, as long as z has other descendants. Putting it all together, we can process\nthe nodes in reverse <a href=\"https://en.wikipedia.org/wiki/Topological_sorting\" target=\"_blank\">topological\norder</a>. At the time when we process a node x, if there is any descendant of x that is not\nin the current text, then we can push x down and then process all of x's outgoing edges without\nany diversity loss. If we process a node x and its subtree consists only of nodes representing\nletters currently in the text, that means that we will lose 1 diversity with the first\nedge going out of x that we process (it doesn't matter which one we process first),\nbut that loss is unpreventable.\n</p><p>\nTo handle cycles, consider first a component that is just a simple cycle. If there is at least\none node representing a character x not in <b>S</b>, then we can process it similarly to paths,\nwithout diversity loss: we replace y &rarr; x, then z &rarr; y, etc, effectively shifting which\ncharacters appear on the text, but keeping diversity constant. If all characters in the cycle\nare in <b>S</b>, then the first replacement we perform will definitely lose diversity, and after\nthat we can prevent diversity loss by using the character that disappeared as x in the process\nfrom the first case.\n</p><p>\nIf a component is a cycle with one or more trees hanging from it, we can first process each tree\nindependently. Then, each of those trees will have at least one node representing a character\nnot in the current text: either there was such a node from the start, or it was created as\npart of processing the tree.\nSo, we can push down the root of one of those trees (which is a node in the cycle) without\nlosing diversity. Then, there will be at least one node in the cycle whose represented character\nis not in the text, so we can process it without diversity loss.\n</p>\n<h3>Test Set 2</h3>\n<p>\nIn Test Set 2, the graph G can be anything, so we cannot do a component type case analysis like\nwe did for Test Set 1. However, we can still make use of the idea of processing paths and\npushing characters to avoid diversity loss following our first replacement.\n</p><p>\nWe tackle this by morphing the problem into equivalent problems.\nWe start with the problem of finding an order of the edges of G that uses\neach edge at least once while minimizing steps in which we cause diversity loss.\n</p><p>\nFirst, notice that once we perform x &rarr; y, we can immediately perform any other x &rarr; z\nwithout diversity loss. So, if we have a procedure that uses at least one replacement of the\nform x &rarr; y\nfor each x for which there is at least one, then we can insert the remaining replacements\nwithout altering the result. That is, instead of considering having to use every edge\nat least once, we can simply find a way to use every node that has out-degree at least 1.\nFurthermore, any replacement x &rarr; y such that x is not in <b>S</b> can be performed at\nthe beginning without changing anything, so we do not need to worry about using them.\nNotice that we are only removing the requirement of using particular edges, not the\npossibility. Therefore, we can make the requirements even less strict:\nnow we only need to use every node with out-degree at least 1 that represents\na character present in <b>S</b>.\n</p><p>\nNow that we have a problem in which we want to cover nodes, and we know from our work in\nTest Set 1 that we can process simple subgraphs like paths and cycles in a way that limits\ndiversity loss, we can define a generalized version of the\n<a href=\"https://en.wikipedia.org/wiki/Path_cover\" target=\"_blank\">minimum path cover</a> problem that is\nequivalent.\n</p><p>\nGiven a list of paths L, let us define the <i>weight</i> of L\nas the number of paths in L minus the number of characters c not in <b>S</b> such\nthat at least one path in L ends with c. That is, for each character c not in <b>S</b>,\nwe can include just one path ending in c in L without adding to its weight.\nLet us say that a list of paths L <i>covers</i> G if every node in G with out-degree at least 1\nthat represents a character in <b>S</b> is present in some path in L in a place other than at\nthe end. That is, at least one edge going out of the node was used in a path in L.\nWe claim that the minimum weight of a cover of G is equal to the minimum number\nof steps that cause diversity loss in the relaxed problem.\n</p><p>\nTo prove the equivalency, we first prove that if we have a valid solution to the problem that\ncauses D diversity loss, we can find a cover that has weight at most D. Afterwards we prove\nthat if we have a cover with weight D, we can find a solution to the problem that causes a\ndiversity loss of at most D.\n</p><p>\nLet r<sub>1</sub>, r<sub>2</sub>, ..., r<sub>n</sub> be an ordered list of replacements\nthat satisfies the relaxed conditions of the problems and has D steps that cause\ndiversity loss. We build a list of paths L iteratively, starting with the empty\nlist. When considering replacement r<sub>i</sub> = x &rarr; y:\n<ol>\n<li>If the text before and after r<sub>i</sub> are the same, we do not change L.</li>\n<li>If there is a path starting with y in L, we append x at the start of it.</li>\n<li>Otherwise, we add r<sub>i</sub> as a new path in L.</li>\n</ol>\n</p><p>\nNotice that the first time we perform a replacement x &rarr; y where x is a node that we need\nto cover, we cannot be in case 1: the xs that were originally in <b>S</b> have not been\nreplaced yet, so r<sub>i</sub> will replace them and change the text. Cases 2 and 3\nadd x as a non-final part of a path. Further processing can only append things to the start of\nthe path, so x will remain a non-final member of it. This proves that L is a cover.\n</p><p>\nNow, suppose step r<sub>i</sub> = x &rarr; y falls into case 3 and\nadds a path to L that increases its weight. Because we are not in case 1, x is in the\ntext at the time we begin to perform r<sub>i</sub>. Since we are in case 3, there wasn't\na path in L starting with y. That means that for any previous replacement of the form\ny &rarr; z that erased ys from the text, there was another replacement of the form\nw &rarr; y that that reintroduced y and caused it to no longer be a starting element of the path\nin L in which y &rarr; z was added.\nMoreover, since we are assuming this step increases L's weight, either\ny was in <b>S</b> or there is a path in L ending with v &rarr; y, which introduced y\ninto the text. In either case, y is in the text before performing r<sub>i</sub>, meaning that\nr<sub>i</sub> causes diversity loss. Since every step that adds weight to L is\na step that causes diversity loss, the weight of L is at most D.\n</p><p>\nNow let us prove that given a cover L of weight D, we can find a solution to the problem\nwith diversity loss D. For that, we need to process paths in a manner that is not as simple as\nthe one we used for Test Set 1. The way in which we process paths in Test Set 1 could only\nresult in diversity loss on the first replacement made, but it also produced other\nchanges in the text. Those changes could hurt us now that we have to process multiple\npaths within the same connected component.\n</p><p>\nTo process a path P, we consider the status of the text U right before we start.\nWe call a node <i>strictly internal</i> to a path if it is a node in the path that is neither the\nfirst nor the last node in the path.\nWe split P into ordered subpaths\nP<sub>1</sub>, P<sub>2</sub>, ..., P<sub>n</sub> such that the last node of P<sub>i</sub>\nis the same as the first node of P<sub>i+1</sub> (the edges in the subpaths are a partition\nof the edges in P). We split in such a way that a strictly internal node of P is also a\nstrictly internal node of the P<sub>i</sub> where it lands if and only if the character it\nrepresents is in U. Then, we process the subpaths in reverse order\nP<sub>n</sub>, then P<sub>n-1</sub>, ..., then P<sub>1</sub>. Within a subpath,\nwe perform the replacements in the path's order (unlike in Test Set 1).\nSince the intermediate characters within a subpath do not appear in S, performing all the\nreplacements of a subpath that starts with x and ends with y\nhas the net effect of replacing x by y. In the case of P<sub>1</sub>, if x is\nnot in U, then there is no effect. After processing subpath P<sub>i+1</sub> that starts with\nx<sub>i+1</sub>, x<sub>i+1</sub> is not in U, and after processing subpath P<sub>i</sub>,\nx<sub>i</sub> is not in U and x<sub>i+1</sub> is restored. The net effect is that\nprocessing the path in this way effectively replaces the first character of the path that is in\nU by the last character of the path, and doesn't change any other character.\n</p><p>\nLet L' be a sublist of L consisting of exactly one path that ends in c for each character c not in\n<b>S</b>. L - L' contains exactly D paths. We process the paths in L' first, and then\nthe ones in L - L'. When we process a path in L', we change the text by introducing\na new character to it. However, that character is not in the original <b>S</b>, and it is always\na new one, so those changes cause no diversity loss. When processing all other paths, since the\nnet effect is that of a single replacement, we can cause at most 1 diversity loss each time,\nwhich means at most D diversity loss overall.\n</p><p>\nNotice that if we have a path that touches a\nnode x that represents a character in <b>S</b>, we can replace that node in the path with\na cycle that starts and ends at x and visits its entire\n<a href=\"https://en.wikipedia.org/wiki/Strongly_connected_component\" target=\"_blank\">strongly connected\ncomponent</a>. A replacement like this one on a path\nin a list does not change its weight. Therefore, we can relax the condition to require covering\njust one node of out-degree at least 1 and with a represented character in <b>S</b> per\nstrongly connected component.\n</p><p>\nWe can turn this into a\n<a href=\"https://en.wikipedia.org/wiki/Maximum_cardinality_matching\" target=\"_blank\">maximum matching</a> problem\non a <a href=\"https://en.wikipedia.org/wiki/Bipartite_graph\" target=\"_blank\">bipartite graph</a>\nsimilarly to how we solve the minimum path cover problem in\n<a href=\"https://en.wikipedia.org/wiki/Directed_acyclic_graph\" target=\"_blank\">directed acyclic graphs</a>.\nConsider a matching M between the set of strongly connected components C (restricted to nodes\nrepresenting characters in <b>S</b>) that need to be covered, and the set D equal\nto C and all remaining nodes representing characters not in <b>S</b>.\nAn element c from C can be matched to an element d from D if there is a non-empty path from c to d\n(it cannot be matched with itself). This matching represents a \"next\" relationship assignment,\nand unmatched elements represent \"ending\" nodes in paths.\nMore formally, let f(c) be the function that maps a member of C to the member of D that corresponds\nto the same strongly connected component.\nWe can create a cover with weight exactly the size of the\nunmatched elements from C by creating a path that adds weight for each unmatched element from C,\nand adding paths that do not add weight for each element in D - C.\n</p><p>\nFor each unmatched element c from C, add it to a new path, then append to its left its matched\nelement M(f(c)), then M(f(M(f(c)))), etc. Then, for each matched element c in D - C,\nwhich are the characters not in <b>S</b>, do the same.\nThis yields a set of paths that touches every element of C,\nand the ending elements are either unmatched elements from C or characters not in <b>S</b> which\ndo not add weight. Notice that some unmatched elements could yield single node paths, which are\npaths not really considered above. However, since such a path always counts toward the weight,\nwe can append any replacement to its end to make it not empty without increasing the weight.\n</p><p>\nTherefore, the size of the unmatched elements from C in a maximum matching of the defined\nrelation, which we can calculate efficiently by\n<a href=\"https://en.wikipedia.org/wiki/Maximum_cardinality_matching#Algorithms_for_bipartite_graphs\" target=\"_blank\">\nadapting a maximum flow algorithm</a> like\n<a href=\"https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm\" target=\"_blank\">Ford-Fulkerson</a>, is\nequal to the minimum weight of a cover, which is what we needed to calculate.\n</p><p>\nDespite the long proofs, the algorithm is relatively straightforward to implement. The graph\ncan be built in time linear in the size of the input,\nwhile the strongly connected components and their transitive\nclosure, which are required to build the relation for the matching, can be found in quadratic\ntime in the size of the alphabet A\n(the relation itself can have size quadratic in A, so it cannot be done faster).\nThe maximum matching itself takes time cubic in A, because it needs to find up to\nA augmenting paths, each of which can take up to O(A<sup>2</sup>) time (linear in the size of\nthe relation graph). This leads to an overall complexity of O(A<sup>3</sup>), which is fast enough\nfor the small alphabet size of this problem. Moreover, we could use something simpler and\ntechnically slower for the strongly connected components and their transitive closure like\n<a href=\"https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\" target=\"_blank\">Floyd-Warshall</a>,\nsimplifying the algorithm without affecting the overall running time.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U20BxcKpkRe2VuWRKMkF1pejmntqJKj0Sb0rabWn0s7VkCN9agjzUsbarQtLqVEAS4ylg5NSX4/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000003b4bc4","statement":"<h3>Problem</h3>\n<p>\nBanana Rocks Inc is coming up with a revolutionary technology to perform the common edit operation\n\"replace all\". Their implementation replaces every occurrence of a character\nwithin a given text with another character. (If the character does not appear in the text, then\nthe operation occurs but has no effect.)\n</p><p>\nFor example, if the starting text is\n<code>CODEJAMWORLDFINALS</code> and an operation is performed to replace <code>A</code> with\n<code>O</code>, the new text would be <code>CODEJOMWORLDFINOLS</code>. If another operation\nis performed on that result to replace <code>O</code> with <code>Y</code>, the final text\nwould be <code>CYDEJYMWYRLDFINYLS</code>.\n</p><p>\nUnfortunately, the implementation is incomplete, so it can only perform replacements from\na specific list of <b>N</b> pairs of characters. Also, even if a replacement of a specific\ncharacter c<sub>1</sub> with another character c<sub>2</sub> is implemented, the reverse\nreplacement of c<sub>2</sub> with c<sub>1</sub> may or may not be implemented.\n</p><p>\nYou want to try all the implemented replacements. You are given some initial string <b>S</b>\nto use as the initial text. You can perform any number of replacements in sequential order:\nthe first replacement is performed on <b>S</b>, and the (i+1)-th replacement is performed\non the result of performing the i-th replacement. The only requirement is that each\nimplemented replacement is performed at least once during this process. There is no upper limit\non how many times you may perform each replacement.\n</p><p>\nThe allowed characters are decimal digits and uppercase and lowercase English alphabet\nletters. In this problem, uppercase and lowercase versions of the same letter are treated\nas distinct characters.\n</p><p>\nWhat is the maximum number of unique characters that can appear in a text that is\nthe result of the last replacement performed?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow.\nEach test case consists of two lines. The first line contains a string <b>S</b>\nand an integer <b>N</b>: the initial text and the number of implemented replacements.\nThe second line contains <b>N</b> two-character strings <b>R<sub>1</sub></b>, <b>R<sub>2</sub></b>, ..., <b>R<sub>N</sub></b>, representing\nthe implemented replacements. <b>A<sub>i</sub></b> and <b>B<sub>i</sub></b> are the first and second characters of <b>R<sub>i</sub></b>, respectively.\nThe i-th implemented replacement corresponds to replacing all occurrences of <b>A<sub>i</sub></b> with <b>B<sub>i</sub></b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing <code>Case #x: y</code>, where <code>x</code>\nis the test case number (starting from 1) and <code>y</code> is the maximum number of\nunique characters that can appear in a text that is the result of performing all implemented\nreplacements to <b>S</b> one or more times each, in some order.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 60 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n2 &le; length of <b>S</b> &le; 1000, for all i.<br/>\nEach character of <b>S</b> is an uppercase or lowercase English alphabet letter or\n  a decimal digit.<br/>\n<b>A<sub>i</sub></b> is an uppercase or lowercase English alphabet letter or\n  a decimal digit, for all i.<br/>\n<b>B<sub>i</sub></b> is an uppercase or lowercase English alphabet letter or\n  a decimal digit, for all i.<br/>\n<b>A<sub>i</sub></b> &ne; <b>B<sub>i</sub></b>, for all i.<br/>\n(<b>A<sub>i</sub></b>, <b>B<sub>i</sub></b>) &ne; (<b>A<sub>j</sub></b>, <b>B<sub>j</sub></b>), for all i &ne; j. (Each replacement is unique.)<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n2 &le; <b>N</b> &le; 62.<br/>\n<b>B<sub>i</sub></b> &ne; <b>B<sub>j</sub></b>, for all i &ne; j.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n2 &le; <b>N</b> &le; 62 &times; 61.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3T-hOXXSn_jmxJhh59Of9zMkSJ-p8-CNJ7b5t7oCxS-n1SSAKgedQ5silQGYEdVMkXCjhKeJUZznJapow_iE6kas443tL96NfJ/replace_all_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\nCODEJAMWORLDFINALS 2\nAO OY\nxyz 3\nxy zx yz\nCJ 4\n20 2O HC KS\nAB 2\nAb bA\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1mYCE_n7BUG84CFTJy1T_SuzLMep_YbLLGPV9XrNBaaRg6N2b0BZfhc4fZCtJ3poRKvRnP4Iyjikn8UglkCAiHb7PgvlgOQD5D6Q/replace_all_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 14\nCase #2: 2\nCase #3: 2\nCase #4: 2\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  The above cases meet the limits for Test Set 1. Another sample case that does not meet those\n  limits appears at the end of this section.\n</p><p>\n  Sample Case #1 is the one in the statement. Notice that if we perform the replacements in the\n  order mentioned in the statement, we get 13 different characters in the final text. If we perform\n  them both once in the other order, however, we can get <code>CYDEJOMWYRLDFINOLS</code>, which\n  has 14 different characters.\n</p><p>\n  In Sample Case #2, one way to get 2 different characters in the final text is to perform\n  the replacements in the order given from left to right, once each.\n</p><p>\n  In Sample Case #3, none of the replacements affect the text at all, so it does not matter\n  how we apply them. We will always be left with the original two letters.\n  Notice that replacements can contain characters not appearing in the initial text, and\n  the initial text can contain characters not appearing in the implemented replacements.\n</p><p>\n  In Sample Case #4, remember that uppercase <code>B</code> is not the same character as\n  lowercase <code>b</code>.\n</p><p>\n  The following additional case could not appear in Test Set 1, but could appear in Test Set 2.\n</p>\n\n<pre>\n1\n1234 5\n12 2X X3 31 X2\n</pre>\n<p>\n  The correct output is <code>Case #1: 4</code>.\n</p>\n<p>\n  In this additional sample case, one possibility is to perform the replacements in the\n  following order: <code>X3 2X X2 2X 12 31</code>. This process goes through the\n  following strings, starting with <b>S</b>: <code>1234 1234 1X34 1234 1X34 2X34 2X14</code>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":27}],"title":"Replace All","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe main task in this problem is to count how many ways there are to pick a permutation and\na pair of numbers from the list such that their (possibly truncated) sum falls within the given\ninterval. This is the numerator of a fraction representing the desired probability.\nThe number of total picks (our denominator) is simply\n16! &times; <b>N</b> &times; (<b>N</b> - 1) / 2. Then, we can use a known algorithm (like dividing\nnumerator and denominator by the\n<a href=\"https://en.wikipedia.org/wiki/Greatest_common_divisor\" target=\"_blank\">greatest common divisor</a>)\nto reduce the fraction to the desired form. In the rest of the analysis, we focus only on\ncalculating the non-reduced numerator.\n</p><p>\nOne common denominator among all solutions for all test sets is that the actual values of the\ndigits in the list do not matter. Once we fix a pair of numbers X and Y from the list,\nonly the \"digit structure\" of the pair (X, Y) matters. The digit structure of a pair of numbers\nis a unique way to see their coupling as digits. We define it as the lexicographically\nsmallest pair (P[X], P[Y]) across all possible digit permutations P, where P[X] is the result of\nreplacing each digit of X with the value assigned to it by P. Notice that digit structures have\nlength 2<b>D</b>.\n</p><p>\nThe total number of digit structures grows rapidly when <b>D</b> increases, but depends only\non <b>D</b>, which has small limits. The total number is 15 for <b>D</b>=2, 203 for <b>D</b>=3,\n4140 for <b>D</b>=4, and 115975 for <b>D</b>=5.\n</p>\n<h3>Test Set 1</h3>\n<p>\nIn Test Set 1, the number of different digit structures is really small. In addition, for a\nfixed structure, we only care about the values assigned by the chosen permutation\nto up to 2<b>D</b> digits. For each digit structure with d unique digits,\nwe can compute the value of the truncated sum for a valid assignment of those d digits,\nnoting that there are (16 - d)! ways to generate each assignment.\n</p><p>\nThe number of valid assignments can be somewhat large at 16! / 10! or about 6 million for 6\ndifferent digits, but there is only one digit structure within Test Set 1 that has that many\ndifferent digits. There are a handful that have 5, for which there are around half a million\nassignments each, and most structures have 4 or fewer different digits, which have fewer than 50\nthousand different assignments each. Moreover, this computation only depends on <b>D</b>\nand not on the rest of the input, so we have to do it only once for each possible structure\nfor <b>D</b>=2 and <b>D</b>=3.\n</p><p>\nGiven the precomputation above, we can iterate over the pairs of integers from the list, compute\ntheir digit structures, and use two\n<a href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\" target=\"_blank\">binary searches</a>\nto see how many of the numbers in the list are in range. Then, we compute the number of different\ndigits in the structure d and multiply the total by (16 - d)!, which gives us the\nnumber of sums in range that can be produced for the given pair. Summing that result over\nall possible pairs gives us the answer we need.\n</p>\n<h3>Test Set 2</h3>\n<p>\nThe precomputation above can be slow in Test Set 2. Not only do we have 4140 additional digit\nstructures to process, but most importantly, a few of those have 7 and 8 unique digits. Each\nadditional digit means an order of magnitude extra possible assignments. There are several ways\nto handle this, and we need only a few of the tricks below to make it work.\n</p><p>\nThe first issue is that the lists we need to store are now too long to fit in memory. Since there\nare only up to 16<sup>4</sup> different results, many of those results would be repeated, so\nwe can compress them based on those repetitions. This is still tough to pull off, so the best\nthing to do is to just not store the full list. We know we only care about how many items\non the list are in range for up to <b>T</b> different ranges. So, we can read all cases before\nstarting the computation, split the full range of sum results at every <b>A</b> and <b>B</b>\nthat we read into up to 2<b>T</b>+1 minimal ranges,\nand then compress together all numbers that are within the same range. This definitely fits\nin memory.\n</p><p>\nWe can also choose to not memoize between different test cases, and treat them one at a time.\nIf we do that, we have a fixed <b>A</b> and <b>B</b>, so there is no need for lists, just a counter.\nWe can either treat each pair of numbers individually as well (speeding up the process of\nassignments &mdash; see below) or try to memoize digit structures if any are repeated within\nthe same test case. It is possible that almost every pair has a different digit structure,\nof course, but there are few digit structures with the maximum number of unique digits.\nThis means the memoization reduces the total runtime in what was our previously worst case,\nand the new worst case (all different structures) is not as bad because many of those structures\nwill have fewer different digits.\n</p><p>\nWe can reduce the number of digit structures further by realizing that digit structures like\n(011, 022) and (012, 021) are equivalent, in the sense that for any assignment, their sum is\nthe same: both are 11 &times; (P[2] + P[3]) + 100 &times; P[0], where 11 and 100 are in base 16.\nThis only works in conjunction with some form of memoization.\n</p><p>\nOnce we have either a range [<b>A</b>, <b>B</b>] or a small list of ranges fixed at the moment\nof processing the assignments, we can use it to do some pruning. Suppose we assign values to\nthe digits in most significant positions first. When we have done a partial assignment, we can\ncompute or estimate a range of possible values that the sum may have when we finish. As\nmore highly significant digits get assigned, that range shrinks. If that range is completely\ninside our target range (or one of our target ranges) we can stop and know that all further\nassignments work, counting them using a simple multiplication. If the range is completely\noutside of the target range (or all target ranges),\nwe can also stop and count nothing further.\n</p><p>\nAs mentioned above, we need only some of the optimizations above to manage to pass Test Set 2.\nOf course, the more of them we find and implement, the more confident we can be about the speed\nof our solution.\n</p>\n<h3>Test Set 3</h3>\n<p>\nTo simplify the problem, we can use a common technique when dealing with counting numbers\nin closed intervals [A, B]. We write a function f(U) that only calculates the value for\nclosed intervals [0, U-1]. Then, the result for an interval [A, B] is f(B + 1) - f(A).\nIn this case, we can use this to take care of the overflow as well, by simply ignoring the overflow\nand counting the number of hits in the interval [A, B] plus the number of hits in the interval\n[16<sup><b>D</b></sup> + A, 16<sup><b>D</b></sup> + B], which are the only possible sums whose\ntruncation would yield a result in [A, B]. After we write our function f, this translates to\na result of f(B + 1) + f(16<sup><b>D</b></sup> + B + 1) - f(A) - f(16<sup><b>D</b></sup> + A).\nWe focus now on calculating f(U), that is, the number of picks of a permutation and a pair\nof numbers that yield a (non-truncated) sum of strictly less than U.\n</p><p>\nBoth the number of possible values a sum can have and the possible number of pairs are small\n(for computers). We can use an asymmetric \"meet in the middle\" approach to take advantage of both\nthose facts. We do this in a similar way as what we did for Test Set 1 and possibly for Test Set\n2, by keeping a count on each digit structure, and then iterating over the pairs of numbers from\nthe list to see how much we have to use each of those counts.\n</p><p>\nFirst, let's consider all the ways to add up to something less than U. Let us fix the first number\nto have a value of x, so the second number can have any value less than U-x.\nA number y is less than U-x if and only if it has a smaller digit than U-x at the first\nposition at which they differ. We can represent this set of ys by saying they are all the ys\nthat start with the first i digits of U-x, then continue with a digit d smaller than the\n(i+1)-th digit of U-x, and any remaining digits can be any digit.\n</p><p>\nFor example, if U=2345 and x=1122, then U-x=1223 and y can be of the form 0***, 10**, 11**,\n120*, 121*, 1220, 1221, 1222, where * represents any digit.\n</p><p>\nFor each pair of an x and a prefix for y, we can represent all the pairs of numbers from the list\nthat match by matching that with a digit structure that allows for *s at the end.\nIn this way, a pair of numbers from the list X and Y can be\nmapped to x and y by a permutation if they have the same digit structure, disregarding the actual\ndigit values. To represent this, we normalize the digit structure as we did before:\nno digit appears for the first time before another smaller digit. Therefore, a structure\nlike x=1122 and y=10** is represented as x=0011 and y=02**. As before, the number of permutations\nthat can match a pair of numbers to this digit structure is (16 - d)!, where d is the number\nof unique digits that appear in the structure.\n</p><p>\nNotice that different values of x can yield the same structure. For example,\nx=1133 yields U-x=1212, and for y=10** the structure is the same as for x=1122 and y=10**.\n</p><p>\nFor each digit structure of 2<b>D</b> total digits that have between 0 and <b>D</b>-1 asterisks at\nthe right end, we count the number of permutations that make its parts add up to something less\nthan U.\n</p><p>\nWe now process the pairs of numbers from the list. For each pair, we build its normalized digit\nstructure as before, and add the count for that digit structure to our running total. We also\nadd the count of the structures that result in replacing up to <b>D</b>-1 rightmost digits with *s.\n</p><p>\nWe can express the complexity of this algorithm in terms of the base B, the number of digits\nof each number <b>D</b>, and <b>N</b>, the size of the list of numbers.\nThe first stage iterates through up to O(B<sup><b>D</b></sup>) possible values for x, and for each\none, considers up to O(B&times;<b>D</b>) digit structures for y. If factorials up to B are\nprecomputed, and we store the results in a hash table or an array with a clever hashing for\ndigit structures that keeps hashes unique and small, this requires only constant time per pair, so\nO(B<sup><b>D</b>+1</sup>&times;<b>D</b>) time overall.\nThe second stage requires processing up to O(<b>D</b>) digit structures per pair, so it takes\nO(<b>N</b><sup>2</sup>&times;<b>D</b>) time in total. The sum of both stages gives us the overall\ntime to compute f, which is\nO(B<sup><b>D</b>+1</sup>&times;<b>D</b> + <b>N</b><sup>2</sup>&times;<b>D</b>).\nSince we need only a constant number of calls to f, that is also the overall time complexity of\nour algorithm.\n</p><p>\nAnother solution is to to use all of our Test Set 2 tricks in an efficient way. Consider\nespecially the last one: when considering the pair of i-th most significant digits, only the pairs\nwhose sum is close to either that value at <b>A</b> or that value at <b>B</b> produce a range\nof possible sums for the pair that is neither fully inside [<b>A</b>, <b>B</b>] nor\nfully outside of it. That means that for the i-th digits, there are only a linear number\nof pairs of digits that can be assigned at that position that would make the process not stop\nimmediately, instead of a quadratic number.\nThis shrinks the number of assignments to approximately the square root of its previous value,\nbehaving more as exponential on <b>D</b> than as an exponential on 2<b>D</b>.\nThis gives us a time complexity comparable to that of\nthe other solution presented above. While the overall time complexity is still\nhigher, these two solutions can perform pretty similarly for the limits we have:\nthe bound on the number\nof assignments is actually smaller than B<sup><b>D</b></sup> because it behaves more like\nB! / (B - <b>D</b>)!. Those savings, plus those from not needing extra <b>D</b> terms, make up for\nthe fact that the backtracking solution's time complexity has a term with behavior\nsimilar to B<sup><b>D</b></sup> and a term with behavior similar to <b>N</b><sup>2</sup>\nmultiplied together instead of added.\n</p><p>\nNotice that the basic insights of both solutions are closely related.\nThe pruning provides such a large speedup for the same reason that we can use the\n\"meet in the middle\" approach based on digit structures.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1dDMfS8x4WC6YFtv9Y6JruB9JbcEip3kia1vOKJmQ_TtewkEwmkufGt0R-b_NhLNDOtLFppyE/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000003b4bc5","statement":"<h3>Problem</h3>\n<p>\n  The Code Jam team's first cryptocurrency, jamcoins, never caught on. This year,\n  we are trying again with <i>hexacoins</i>, which are named for their\n  use of base 16. To \"mine\" a <b>D</b>-digit hexacoin, one has to work with\n  integers using exactly <b>D</b> base 16 digits, including leading zeroes\n  if needed. Each value represents an integer between 0 and 16<sup><b>D</b></sup> - 1,\n  inclusive. Base 16 digits are represented by the numbers 0 through 9 and\n  the uppercase letters A through F, as usual. For example, F2B, 0C8 and 000 are valid values when <b>D</b>=3,\n  corresponding to the base 10 values 3883, 200 and 0. On the other\n  hand, 1234, DF, C0DE and JAM are not valid values when <b>D</b>=3.\n</p><p>\n  When performing addition of <b>D</b>-digit base 16 values, any overflow\n  digits are dropped. That is, the addition is performed modulo\n  16<sup><b>D</b></sup>. For example, F2B + 0C8 = FF3 (4083 in base 10) and F2B + F2B = E56 (3670 in base 10,\n  because the sum's result is 7766, and taking modulo 16<sup>3</sup>\n  yields 3670).\n</p><p>\n  To \"mine\" a <b>D</b>-digit hexacoin, a computer must perform the following\n  steps:\n</p>\n<ol>\n  <li>Choose a list <b>L</b> of <b>N</b> <b>D</b>-digit\n    base 16 values <b>L<sub>1</sub></b>, <b>L<sub>2</sub></b>,\n    ..., <b>L<sub>N</sub></b>.</li>\n  <li>Choose a target range of <b>D</b>-digit base 16\n    values: the numbers from <b>S</b> to <b>E</b>, inclusive.</li>\n  <li>Choose a permutation P of the base 16 digits 0 through F,\n    uniformly at random from among all 16! such permutations.</li>\n  <li>Apply P to all digits of all numbers in the list, creating a new list L'\n    consisting of <b>N</b> <b>D</b>-digit base 16 values. Formally,\n    the j-th digit of the i-th element of L' is the result of applying P\n    to the j-th digit of the i-th element of <b>L</b>.</li>\n  <li>Choose a pair of elements from L' without\n    replacement, uniformly at random from among all such possible choices,\n    and independently of the choice of permutation.</li>\n  <li>Calculate the sum (dropping overflow digits) of the two chosen elements.</li>\n</ol>\n<p>\nIf the sum calculated in the last step is between <b>S</b> and <b>E</b>, inclusive,\nthen a hexacoin has been found! For example, suppose that:\n</p>\n<ul>\n  <li><b>L</b> = [134, 000, FFB, 000, AA9].</li>\n  <li><b>S</b> = 85C and <b>E</b> = EDF.</li>\n  <li>The computer happens to choose P = (0 &rarr; 4, 1 &rarr; A, 2 &rarr; 2, 3 &rarr; 8,\n    4 &rarr; 9, 5 &rarr; B, 6 &rarr; C, 7 &rarr; 7, 8 &rarr; F, 9 &rarr; 1, A &rarr; 0,\n    B &rarr; 3, C &rarr; 5, D &rarr; 6, E &rarr; E, F &rarr; D).\n</ul>\n<p>\n  Then, when P is applied to <b>L</b>, the resulting L' is\n  [A89, 444, DD3, 444, 001]. Notice that P is not applied to <b>S</b> and <b>E</b>.\n</p><p>\n  There are (5 &times; 4) / 2 = 10 pairs of values to choose, and each pair\n  has a probability of 1/10 of being chosen. The only sums that fall within the\n  range are A89 + DD3 = 85C, 444 + 444 = 888, A89 + 001 = A8A, DD3 + 001 = DD4,\n  and A89 + 444 = ECD (twice).\n</p><p>\n  The first two steps are already computed and you know the list <b>L</b> and\n  the range [<b>S</b>, <b>E</b>] that were chosen. What is the probability that\n  a hexacoin is found after the rest of the process is performed?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case consists of three lines.\n  The first line contains two integers <b>N</b> and <b>D</b>: the size\n  of the given list and the number of digits to work with,\n  respectively. The second line contains two <b>D</b>-digit base 16 numbers\n  <b>S</b> and <b>E</b>: the inclusive lower and upper bounds of the target range,\n  respectively. Then there is one more line containing <b>N</b> <b>D</b>-digit\n  base 16 numbers <b>L<sub>1</sub></b>, <b>L<sub>2</sub></b>, ...,\n  <b>L<sub>N</sub></b>, representing the values in the list.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y z</code>,\n  where <code>x</code> is the test case number (starting from 1) and\n  <code>y</code> and <code>z</code> are non-negative integers, such that the\n  fraction <code>y</code>/<code>z</code> represents the probability of\n  finding a hexacoin, under the conditions described above. All of\n  <code>x</code>, <code>y</code>, and <code>z</code> must be in base 10. If there\n  are multiple acceptable values for <code>y</code> and <code>z</code>, choose\n  the ones such that <code>z</code> is minimized.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 90 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  2 &le; <b>N</b> &le; 450.<br/>\n  <b>S</b> contains exactly <b>D</b> characters.<br/>\n  Each character of <b>S</b> is a base 16 digit.<br/>\n  <b>E</b> contains exactly <b>D</b> characters.<br/>\n  Each character of <b>E</b> is a base 16 digit.<br/>\n  <b>S</b> &le; <b>E</b>.<br/>\n  <b>L<sub>i</sub></b> contains exactly <b>D</b> characters, for all i.<br/>\n  Each character of <b>L<sub>i</sub></b> is a base 16 digit, for all i.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>D</b> &le; 3.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>D</b> &le; 4.<br/>\n</p>\n\n<h4>Test Set 3 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 10.<br/>\n  2 &le; <b>D</b> &le; 5.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2x7anyTgq2Q-RN09oFJeJFtRQzGRobh9V-XlohyZ9DGGFhdtgIXQXDI7v_mcR9-BwwrScPV29Azp5sJ-ldo9BvWp2eTJ_9_fLfrQ/hexacoin_jam_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">4\n2 2\n10 10\n00 FF\n2 2\n10 11\n00 FF\n4 3\nFFF FFF\n230 A10 010 F70\n4 3\nAFF FFF\n230 A10 010 F70\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1aFHtCJsOvS17JjFD--iowLaQWqot-nah_6OiRmmdSAds0tTYWkswJOoYJzKrkaPZeumDHCdAw-wu-l4fWX5xkWwiASZdMpvq1jYU/hexacoin_jam_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 7 120\nCase #2: 1 15\nCase #3: 0 1\nCase #4: 2731 8736\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, the target range is just a single value 10. Since the result\n  ends with 0, the sum of the values assigned to both last digits 0 and F\n  must end in 0 as well. Since P[0] and P[F] are different values, their sum cannot\n  be exactly 0. Therefore, P[0] + P[F] must be 10 (in base 16). There are 7 pairs\n  of different digits that accomplish that. P[0] and P[F] cannot both be 8.\n  All 7 pairs lead to an overall sum of 10 (after dropping an overflow 1).\n  Therefore, there are 14 assignments of different digits to 0 and F that lead to a\n  hexacoin. There are 16 &times; 15 possible assignments to those digits, so the result is\n  14/240 = 7/120.\n</p><p>\n  In Sample Case #2, we need to add the probability of the result being exactly 11\n  to the result of Sample Case #1.\n  The only way that happens is if 0 and F are assigned to\n  0 and 1, in either order. That has a probability of 2/240=1/120, leading to a total\n  of 7/120 + 1/120 = 8/120 = 1/15.\n</p><p>\n  In Sample Case #3, notice that regardless of which permutation and pair of numbers\n  the computer chooses from the list, we will add two numbers that end in the same digit.\n  That produces an even result, even after taking it modulo 16<sup>3</sup>. Since the only\n  value in range is odd, we have no hope of mining a hexacoin in this case. Notice that\n  <code>0 2</code> is an invalid representation of the answer because <code>z</code>\n  would not be minimum.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":10},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Hexacoin Jam","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n\n<p>\nA translation of the problem statement is that we wish to find the\n<a href=\"https://en.wikipedia.org/wiki/Minimum-cost_flow_problem\" target=\"_blank\">minimum cost</a>\n<a href=\"https://en.wikipedia.org/wiki/Maximum_flow_problem\" target=\"_blank\">maximum flow</a>\non a <a href=\"https://en.wikipedia.org/wiki/Tree_(graph_theory)\" target=\"_blank\">directed tree</a>.\nThe rest points can be represented by\nnodes, and the ski slopes can be represented by edges. A commonly used algorithm\nto solve minimum cost maximum flow problems is\n<a href=\"https://cp-algorithms.com/graph/min_cost_flow.html\" target=\"_blank\">\nsuccessive shortest paths</a>.\nIn the case of our directed tree, a simplified successive shortest paths\napproach can be applied.\n</p>\n\n<p>\nObserve that we can add skiers greedily. Of all the nodes that can be\nreached from the top of the mountain (the root of the tree), we should always\nsend a skier to a node with a minimum cost path using only edges that still have\ncapacity remaining. Since we are working with a tree, there is only one path\nfrom the root to each node. With this in mind, we can find\nthe path costs to all the nodes using any\n<a href=\"https://en.wikipedia.org/wiki/Tree_traversal\" target=\"_blank\">tree traversal</a>\nfrom the root while calculating the cost to each node as the cost\nof its parent (which we calculated first) plus the cost of the edge connecting them.\nThen, we can sort the nodes by their path cost in ascending order. We should always\nuse the first node in the list that still has some capacity along its path.\n</p>\n\n<p>\nLet us maintain the number of skiers sent through each edge. We can work\nthrough our sorted list of nodes in order. We check if the current node in the list still has\nsome capacity by checking the edges in the path, and\neither update the capacities if we can push another skier, or\nmove on to the next node in the list if we cannot. Doing this for a single\nskier takes O(<b>N</b>) time. We know we will keep using the same path until\nsome edge reaches capacity, so we can compute the minimum capacity left in the\npath with a linear pass over it, and simulate sending that many skiers at once.\nEach such a step takes O(<b>N</b>) time overall, and since we have to try up\nto O(<b>N</b>) possible destinations, the overall algorithm takes\nO(<b>N</b><sup>2</sup>) time, which is efficient enough to solve Test Set 1.\n</p>\n\n<h3>Test Set 2</h3>\n\n<p>\nFor the large input, we need to do more. We can use a\n<a href=\"https://cp-algorithms.com/graph/hld.html\" target=\"_blank\">heavy light decomposition</a>\nof the tree to manage the remaining capacities of the edges in the tree. The\ndecomposition will need to support updates and queries on paths from the root to\nan internal node. The updates involve subtracting an amount from the capacity\nof each edge. The queries involve finding the minimum capacity of all the edges\non a path.\n</p>\n\n<p>\nA heavy light decomposition breaks a tree up into a collection of disjoint\npaths such that the number of decomposition paths from any node to the root\nis at most O(log <b>N</b>). If we keep a\n<a href=\"https://cp-algorithms.com/data_structures/segment_tree.html\" target=\"_blank\">segment tree</a>\nfor each decomposition path, then\nwe can support both the query and update operations in O(log<sup>2</sup> <b>N</b>).\nNote that the segment tree we use must support lazy range updates. This improves the running\ntime of each step of the algorithm for Test Set 2 to take only O(log<sup>2</sup> <b>N</b>) time\ninstead of O(<b>N</b>) time. This makes the algorithm run in\nO(<b>N</b> log<sup>2</sup> <b>N</b>) time in total, which is sufficient to solve the Test Set 2.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U05qqSALOOiXSfs1WGebqC7IfTqr_4J0hmChEt3yY-O1rM6mcjYE3zUd01l4r0eW13nD8E2M1E/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000003b4f31","statement":"<h3>Problem</h3>\n<p>\n  You are trying to organize a group of skiers. The skiers are taking a trip to a\n  large mountain, which has been rented for the day.\n</p><p>\n  There are <b>N</b> rest points numbered from 1 to <b>N</b> on the mountain,\n  and they are connected by <b>N</b>-1 slopes. Each slope starts at some rest\n  point and goes directly to another rest point, with no intermediate slopes\n  or rest points. A slope can be traversed in only one direction.\n</p><p>\n  Each skier starts at the summit rest point and traverses a slope to reach\n  another rest point. From there, the skier can traverse another slope to reach\n  another rest point, and so on. Once a skier reaches their destination rest point,\n  they stop skiing for the day and head to the ski lodge for hot cocoa.\n  The destination rest point cannot be the summit rest point.\n  However, notice that a skier's destination rest point can be the start of zero or more\n  slopes; that is, a skier does not necessarily have to keep using available\n  slopes until there are none available:\n  they can always walk carefully down the rest of the mountain!\n  For all rest points, there is exactly one sequence of slopes that a skier can\n  use to reach it from the summit rest point.\n</p><p>\n  Each slope can accommodate only a certain total number of skiers in a day, after\n  which the snow gets too choppy to ski. In addition, the ski resort can\n  charge or reward each skier for each slope that they ski on.\n  Each slope may have a different price, and each skier must pay the price\n  for each slope they ski on. A slope's price can be positive, zero, or even\n  negative; a negative price represents a bounty awarded for testing that\n  slope. As the organizer, you pay all the slope prices and collect all\n  the bounties on behalf of your group of skiers.\n  Notice that if multiple skiers use the same slope, you pay that slope's\n  price or collect the slope's bounty multiple times.\n  The sum of all costs you pay minus the sum of all bounties you collect\n  is the total expense for the trip. The expense can be positive, zero,\n  or negative. A negative expense means that you actually made money on the trip!\n</p><p>\n  As the organizer, you want to figure out the maximum number of skiers that\n  you can put on the mountain. Also, you would like to figure out the minimum\n  possible expense for a trip with that maximum number of skiers.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. The first line of a test case contains a single\n  integer <b>N</b>: the number of rest points on the mountain.\n</p><p>\n  Each of the final <b>N</b>-1 lines of a test case describes a slope via four integers\n  <b>U<sub>i</sub></b>, <b>V<sub>i</sub></b>, <b>S<sub>i</sub></b>, and\n  <b>C<sub>i</sub></b>. These are the slope's starting rest point, the slope's\n  ending rest point, the maximum number of skiers the slope can accommodate,\n  and the slope's price per skier, respectively.\n</p>\n<p>\n  The summit rest point where the skiers start from is always numbered 1.\n</p>\n\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y z</code>,\n  where <code>x</code> is the test case number (starting from 1),\n  <code>y</code> is the maximum number of skiers, and <code>z</code> is the\n  minimum expense for having <code>y</code> skiers\n  ski at least one slope each.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 30 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>U<sub>i</sub></b> &le; <b>N</b>, for all i.<br/>\n  2 &le; <b>V<sub>i</sub></b> &le; <b>N</b>, for all i. (No\n    slope can end at the summit rest point.)<br/>\n  <b>U<sub>i</sub></b> &ne; <b>V<sub>i</sub></b>, for all i.<br/>\n  1 &le; <b>S<sub>i</sub></b> &le; 10<sup>5</sup>, for all i.<br/>\n  -10<sup>5</sup> &le; <b>C<sub>i</sub></b> &le; 10<sup>5</sup>, for all i.<br/>\n  There is exactly one sequence of slopes that a skier can\n  use to reach rest point r from the summit rest point, for all r.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  1 &le; <b>T</b> &le; 100.<br/>\n  2 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  <b>T</b> = 17.<br/>\n  2 &le; <b>N</b> &le; 10<sup>5</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0yNCWLGAXiTDz9L5hswQlpVa2uOAUnQ-gklouRiRyVp-5NM8dj3f7Gsh7TGXiE0IH3gH6xi2vO4Qe33-YNMmjIDZkT2-xpN6n_EVKVYQ/pack_the_slopes_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n4\n1 2 2 5\n1 3 2 5\n3 4 1 -2\n7\n4 7 2 2\n1 3 5 5\n1 4 2 -1\n3 2 3 -2\n3 5 2 -1\n3 6 2 2\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3fNf4UBRCJv4qIHNEkPhDlCfMEwvsKiIyU7gGQHl6m_vijj5wBGAGzItAp2D5f-8K69IwBovkOz-w-A7tVaPouFsjFJnvlpweBr_aDw4M/pack_the_slopes_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 4 18\nCase #2: 7 15\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  In Sample Case #1, we can send one skier to rest point 4, one skier to rest\n  point 3, and two skiers to rest point 2.\n</p><p>\n  In Sample Case #2, we can send three skiers to rest point 2, two skiers to\n  rest point 5, and two skiers to rest point 4.\n</p><p>\n  Notice that the first slope listed in a test case does not need to start at\n  the summit rest point, and that slopes can have\n  <b>U<sub>i</sub></b> &gt; <b>V<sub>i</sub></b>.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":22}],"title":"Pack the Slopes","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test Set 1</h3>\n<p>\nIn this problem, we are given a circle, a collection of points around the perimeter of the circle,\n  and the attachment values for each of those points (<b>L<sub>i</sub></b>).\n  We want  the top <b>K</b> pairs of points that maximizes the Euclidean distance between the\n  points plus their\n  attachment values. For Test Set 1, we know that the point values are picked randomly. We will need\n  to use this property somehow. We also know that <b>K</b>=1, so we are looking for the top pair of\n  points.\n</p><p>\n  Imagine considering the points around the circle in the clockwise order. Let us say that we are\n  at a point p. Also, without loss of generality, let us only consider points that are at most 180\n  degrees clockwise from p. That is, we only consider half of the circle starting at p. If we find\n  the maximum pairing (maximum distance plus attachment values) for every possible p,\n  the maximum over all of those pairs will be the answer. This is because considering each point,\n  (and points that are up to 180 degrees clockwise from it) will consider every possible\n  pair of points at least once.\n</p>\n\n<p>\n  So, we are considering all points p in the clockwise order around the circle and trying to find\n  the maximum pairing for each of these. If we consider the possible other points we could pair\n  with p in the counterclockwise order starting from the location 180 degrees clockwise of p (the\n  \"other side\" of the circle from p), then we can observe some useful properties. Once we have\n  considered some pairing point x, then some further counterclockwise point y will be closer to p.\n  Thus, for y to be the maximum pairing, its attachment value must be greater than x's attachment\n  value. So, we only need to consider points that increase in their attachment values.\n</p>\n\n<p>\n  We know that the attachment values are randomly selected.\n  In a sequence of <b>N</b> integers randomly selected from a uniform range,\n  we expect the running maximum to change only\n  log <b>N</b> times. To see why, observe that first element has a 1/1\n  chance of being the new maximum,\n  the second element has a 1/2 chance, the third element has a 1/3 chance, and so on. This is the\n  <a href=\"https://en.wikipedia.org/wiki/Harmonic_series_(mathematics)\" target=\"_blank\">harmonic series</a>.\n  The sum of its first <b>N</b> terms is bounded by O(log <b>N</b>).\n  Thus, we expect to see only O(log <b>N</b>) changes of\n  maximum. This means the explained solution has\n  an expected time complexity of O(<b>N</b> log <b>N</b>),\n  which should be fast enough to pass. The worst case among all possible inputs takes\n  O(<b>N<sup>2</sup></b>) time. However, as we showed, this is extremely unlikely\n  with random attachment values.\n</p>\n\n<p>\n  Now, when we are considering a point x, we need an efficient way to find the\n  first point in the counterclockwise order from x whose\n  attachment value is greater than x. This is actually equivalent to a known problem: the\n  next greater element problem.\n  The twist is that our values are on a circle, so we have wraparound. One way to deal with this\n  is to make an array of attachment values, append it to itself, and then apply a fast algorithm\n  for the next greater element problem to the resulting array.\n</p>\n\n<p>\n  There are other approaches that also take O(<b>N</b><sup>2</sup>) time in the worst case, because\n  they might compare a high percentage of all pairs, but use other clever speedups like\n  jumping to the next greater value, to have a high chance to cut the number of comparisons\n  way down.\n</p>\n\n<h3>Test Set 2</h3>\n<p>\n  The attachment values of points are not randomly generated in this test set, so we will need to\n  find a different approach. Also, <b>K</b>=10, so we also need to find more than one pair\n  of points. Instead of trying to find the top <b>K</b> pairs directly, we can find the best\n  pairing for each point, and extend this solution to find the top <b>K</b> pairs overall. Let's\n  first figure out how to find the best pairing for each point, then explain how to extend it to\n  find the top <b>K</b> pairs.\n</p><p>\n  We start by finding, for each input point P, which other input point\n  Q is its best pairing. That is, we find for which other input point Q the function\n  L<sub>P</sub> + L<sub>Q</sub> + distance(P, Q) is maximized.\n</p><p>\n  Now consider points P not necessarily in the input.\n  We define a value function V<sub>P</sub>(Q) = distance(P, Q) + L<sub>Q</sub>. Notice that\n  if P is a point in the input, V<sub>P</sub>(Q) + L<sub>P</sub> is the amount of\n  cord required to connect P and Q.\n</p><p>\n  Let us approach the problem visually. Imagine moving P around the circle\n  in the clockwise order and computing the value function V<sub>P</sub>(Q) for all the input\n  points Q that are up to 180 degrees clockwise of P.\n  As we move P, how does the distance function to some other point change?\n</p><p>\n  The Euclidean distance part of the distance function is equivalent to computing the length of a\n  circular chord. That is, V<sub>P</sub>(Q)=2&times;<b>R</b>&times;sin(angle(P, Q)/2)+L<sub>Q</sub>.\n  Notice here than the angle function is in the clockwise direction, and it's always less than\n  or equal to 180 degrees. Consider how this function changes when P changes. That is,\n  consider the function W<sub>Q</sub>(P)=V<sub>P</sub>(Q). As the domain for V<sub>P</sub>\n  is the Qs that are up to 180 degrees in the clockwise direction, the domain for W<sub>Q</sub>\n  is the Ps that are up to 180 degrees in the counterclockwise direction.\n</p><p>\n  For each Q, W<sub>Q</sub> has a constant term\n  L<sub>Q</sub>, and then a term that looks like half a sine wave. Notice that the graph\n  of the function is the same for any Q, but translated:\n  the change in angle(P, Q) translates it horizontally, and the change in L<sub>Q</sub> translates\n  it vertically.\n  An example of how these graphs might look follows.\n  Each black curve corresponds to W<sub>Q</sub> for a different point Q.\n</p>\n<p align=\"center\">\n  <img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3ppGSLKQlycdoGATyQVTIpOy2K4eDAUwkj4BGFNCuxHy7R4gEDvarBOvLBJRcyHRMqffZudZw/sinegraph.png\" style=\"width: 500px; height: auto;\" />\n</p>\n<p>\n  Because all of the distance functions have the same shape, we can see that W<sub>Q</sub>\n  has maximum values compared to all other W functions for a continuous range of points P.\n  So, can we efficiently compute these ranges for each point? If so, we can use\n  these ranges to find the maximum for each possible point by finding which maximum's range it\n  falls into.\n</p><p>\n  We can analyze this graph by sweeping across it from left to right&mdash;that is,\n  increasingly along the x-axis. Since the x-axis represents points on a circle, it may be easier\n  to visualize if we instead represent each point by its angle with respect to the positive half\n  of the x-axis, as usual.\n  For a fixed angle A, let us consider only the curves whose domain includes at least one point\n  in the range [0, A] and call that set C<sub>A</sub>.\n  As we consider increasing values for A, at some point\n  we consider a curve for the first time, with domain [A, B]. The curve is definitely\n  maximum among all curves in C<sub>A</sub> at B, because it is the only curve at that point.\n  So, the range for which it is the maximum must end there.\n  Since we know there is only one such range, we can binary search to find the beginning of the\n  range.\n</p><p>\n  We keep a sorted list of non-overlapping ranges as we go, and add new ranges to the end.\n  Note that we may need to pop off some ranges from the end of the list if we find a new range\n  that covers them completely, or shorten them if the new range covers them only partially.\n  There can be zero or more left-most ranges where the new curve is fully under the maximum curve\n  in that range, zero or more right-most ranges where the new curve is fully over the maximum curve\n  in that range, and zero or exactly one range where the new curve and the curve from the range\n  cross. We\n  <a href=\"https://en.wikipedia.org/wiki/Bisection_method\" target=\"_blank\">binary search</a>\n  within the range for the exact crossing point.\n</p><p>\n  One issue we still need to deal with is that the graph is actually cyclic. It represents the\n  distance function to points as we go around a circle. So, the distance\n  functions we plot can \"wrap around\". We can deal with this via a method similar to what we used in\n  Test Set 1: append a copy of the input to itself, and go around the input twice.\n</p><p>\n  The final list of ranges can be used to get the maximum pairing for each point on the circle.\n  For each input point P, we find the Q for which W<sub>Q</sub> is the maximum at P.\n  Since we only need to check input points P, we can restrict the\n  domains of all functions and intervals discussed so far to input points\n  without affecting the correctness.\n  This allows us to binary search over an array of O(<b>N</b>) values as opposed to\n  over a range of real numbers.\n</p><p>\n  The time complexity of constructing the list of ranges is therefore O(<b>N</b> log <b>N</b>).\n  Then, we go through the list iterating over the list of possible Ps for each Q. While a\n  particular Q can have a long range, overall, we iterate over each input P at most once (or twice\n  for the duplicated input). This makes the final step take linear time.\n</p><p>\n  An O(<b>N</b>) algorithm for the above problem does exist.\n  This is left as an exercise for the reader.\n</p><p>\n  We have a way to find the best pairing for each point. How do we extend this solution to find the\n  top <b>K</b> unordered pairings? It is possible that a pair in the top <b>K</b> is not in our list of\n  best pairings for each point. However, we can still use our list. Consider sorting the list by\n  the Euclidean distance plus attachment values of the pair in descending order. The first entry\n  in the list will definitely be the top pair overall. The second top pair will either be the next\n  entry in our list, or it will be paired with one of the points in our top pair. We can look\n  at all pairings involving the points in our top pair, and now we know the second best pair. We\n  can repeat this process to find the top <b>K</b>. In each step, the pair we choose is either the\n  next best pair in our\n  list that we haven't seen,\n  or it is a pairing with a point in the previous pairs in our list. In each of these <b>K</b>\n  steps, we take O(<b>N</b>) time. Sorting our list initially takes O(<b>N</b> log <b>N</b>) time,\n  so our algorithm requires O(<b>N</b> log <b>N</b> + <b>N</b> &times; <b>K</b>) time overall,\n  which is fast enough to pass.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2NR6E9c9GKCTEYYz-tZPAV9-EoI4emAwpA5tb6PE5XfNuYqfujeQiSY4fvpfrG6jR78yc1M-c/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000003b532b","statement":"<h3>Problem</h3>\n<p>\n  Lauren is trying to play the most beautiful notes possible using a harp. The\n  harp is a circle with a radius of <b>R</b> centimeters.\n  To play a note, a cord must be attached to the harp\n  in a way that connects two different <i>attachment points</i> on the\n  perimeter of the circle. Lauren then plucks this cord to play a note.\n</p>\n<p>\n  There are <b>N</b> attachment points on the perimeter of the circular harp at\n  which a cord can be attached. The i-th such attachment point\n  is at a location that is <b>D<sub>i</sub></b> nanodegrees (a nanodegree is 10<sup>-9</sup>\n  degrees) clockwise around the perimeter of the circular harp, starting from the rightmost\n  point on the perimeter.\n</p>\n<p>\n  Not all attachment points use the same technology to properly fix the cords onto them.\n  The i-th attachment point requires L<sub>i</sub> centimeters of cord to be used for attaching.\n  A cord fixed between two different attachment points i and j needs to be exactly\n  L<sub>i</sub> + L<sub>j</sub> + distance(i, j) centimeters long. By\n  distance(i, j) we mean the length of the geometric\n  <a href=\"https://en.wikipedia.org/wiki/Chord_(geometry)\" target=\"_blank\">chord</a>\n  connecting the i-th and j-th attachment points, that is, the Euclidean distance between\n  the two points.\n</p>\n<p>\n  Lauren thinks that notes sound better when they come from longer cords. What are the\n  <b>K</b> longest cords that can be used with Lauren's harp?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. The first line of a test case contains three integers: <b>N</b>,\n  <b>R</b> and <b>K</b>: the number of attachment points,\n  the radius of the circular harp in centimeters, and\n  the number of lengths of cords that Lauren is interested in knowing.\n</p>\n<p>\n  The next <b>N</b> lines describe the attachment points. The i-th of these lines contains\n  two integers,\n  <b>D<sub>i</sub></b> and <b>L<sub>i</sub></b>, which describe the position (in number of\n  nanodegrees clockwise from the rightmost point of the harp) and length of cord in\n  centimeters needed at the i-th attachment point.\n</p>\n\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y<sub>1</sub> y<sub>2</sub>\n  ... y<sub><b>K</b></sub></code>, where\n  <code>x</code> is the test case number (starting from 1), and <code>y<sub>n</sub></code> is the\n  n-th value in the list of lengths of all <b>N</b>&times;(<b>N</b>-1)/2 cords\n  that can be used in Lauren's harp, sorted in non-increasing order.\n</p>\n<p>\nEach <code>y<sub>n</sub></code> will be considered correct if it is within an absolute or\nrelative error of 10<sup>-9</sup> of the correct answer. See the\n<a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an\nexplanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 120 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  <b>N</b> = 150000 in at most 10 cases.<br/>\n  5 &le; <b>N</b> &le; 10<sup>4</sup> in all cases with <b>N</b> &ne; 150000.<br/>\n  1 &le; <b>R</b> &le; 10<sup>9</sup>.<br/>\n  0 &le; <b>D<sub>1</sub></b>.<br/>\n  <b>D<sub>i</sub></b> &lt; <b>D<sub>i+1</sub></b>, for all i.<br/>\n  <b>D<sub>N</sub></b> &lt; 360 &times; 10<sup>9</sup>.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  <b>L<sub>i</sub></b> is chosen independently and uniformly at random between 1 and\n  10<sup>9</sup>, inclusive, for each i.<br>\n  <b>K</b> = 1.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  1 &le; <b>L<sub>i</sub></b> &le; 10<sup>9</sup>, for all i.<br/>\n  (There is no guarantee as to how each L<sub>i</sub> is generated.)\n  <br/>\n  <b>K</b> = 10.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2KuUwsw3sHkwXmc5F1fbF7dQVadS9rok4xKhw2Mp0XYKNpy4rioU9lP02WZEDj08tbeJygY5AsSGrlbt0mm1XUi2GYlucv9wZIpvI/musical_cords_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">2\n5 2 1\n0 3\n1234567890 3\n3154510113 3\n180000000000 3\n359999999999 3\n5 10 1\n90000000000 8\n180000000000 7\n260000000000 9\n260000000001 1\n260000000002 1\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2DBZlKHawNnIJMSMJIrnf8iWLcJihJhO6_S-AOJ-x4a0NynhrfKYudPOQ6UQAS99B-K-oVnl8Ty-mSRCgVoaTHnoIpHXT2TX7pzTmh/musical_cords_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 10.0000000000\nCase #2: 36.9238939618\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n<p>\n  The above cases meet the limits for Test Set 1. Another sample case that does not meet those\n  limits appears at the end of this section.\n</p><p>\n  Note: the <b>L<sub>i</sub></b> values in these sample cases for Test Set 1 were chosen\n  for ease of understanding and were not randomly generated. Your solution will be run against\n  these sample cases and must pass them.\n</p><p>\n  In Sample Case #1, all of the attachment points have the same value, so we should\n  pick the pair connected by the longest chord, which in this case is a horizontal\n  diameter of the circle that has a length of 4 centimeters. So the total length needed is\n  4 + 3 + 3 = 10 centimeters.\n</p><p>\n  In Sample Case #2, the fourth and fifth points are extremely close to the third\n  point, but have much smaller <b>L</b> values. We can effectively rule them\n  out and focus on the possible connections among the first three points,\n  as follows:\n  <ul>\n    <li>first and second points: length 10&radic;2 + 8 + 7: &asymp;29.142136.</li>\n    <li>first and third points: length &asymp;19.923894 + 8 + 9: &asymp;36.923894.</li>\n    <li>second and third points: length &asymp;12.855726 + 7 + 9: &asymp;28.855726.</li>\n  </ul>\n<p>\n  Using the first and third points gives us the greatest total length.\n</p><p>\n  The following additional case could not appear in Test Set 1, but could appear in Test\n  Set 2.\n</p>\n<pre>\n1\n6 1 10\n0 10\n15000000000 1\n30000000000 1\n45000000000 1\n60000000000 1\n75000000000 1\n</pre>\n<p>\n  The correct output is <code>Case #1: 12.2175228580 12.0000000000 11.7653668647 11.5176380902 11.2610523844 3.0000000000 2.7653668647 2.7653668647 2.5176380902 2.5176380902</code>\n</p>\n<p>\n  Notice that there are three possible pairs of points tied for producing the 9th longest cord. Also, it is\n  fine if lines connecting different pairs of points intersect, since Lauren will only be playing one note\n  at a time.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":27}],"title":"Musical Cords","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nAs is the case in many problems about games, this problem revolves around evaluating\na given state of the game and deciding whether it is winning or losing.\nThe problem defines mistakes as transitions from winning to losing states, so once\nwe have determined the type of each state, we can easily count up the mistakes.\n</p>\n<h3>Test Set 1</h3>\n<p>\nIn all <a href=\"https://en.wikipedia.org/wiki/Zero-sum_game\" target=\"_blank\">zero-sum</a>\nfinite two person games\nwith no ties, the basic framework to decide whether a state is winning is the same. Let us call\na state <i>A-winning</i> (or equivalently, <i>B-losing</i>) if player A can ensure a win from it,\nor <i>B-winning</i>/<i>A-losing</i> otherwise.\nFor a given state, if the game is over, check the winning condition. Otherwise, if it is\nplayer X's turn, try every possible play. If any of them leads to an X-winning state,\nthen the current state is also X-winning. Otherwise, the current state is X-losing.\nWe can implement this as a recursive function, but given that there can be\nO(<b>N</b><sup>2</sup>) possible plays on any given turn, this will only work\nquickly enough for small values of <b>N</b>.\n</p><p>\nWe can see immediately that there can be a lot of repeated work in that recursive evaluation.\nFor example, consider a state S and another state S' such that S' is the result of making\nP plays on S. Since there are P! ways to make those plays, state S' potentially\nneeds to be evaluated P! times to evaluate S once. Memoizing the function or turning it into a\n<a href=\"https://en.wikipedia.org/wiki/Dynamic_programming\" target=\"_blank\">dynamic programming</a>\nimplementation would thus save a lot of recursive calls.\n</p><p>\nIn addition, there are many states that can be evaluated without the need for a recursive call.\nSome simple cases include states in which there already are two adjacent and consecutive tiles\nplaced (the \"already won\" condition for player A).\nWe can prune the recursive calls tree by simply returning those states as A-winning.\nWe can prune it further: if there is a play that creates such a pair during A's turn\n(the \"can win immediately\" condition), we just do that instead of trying all possible plays\nfor A. We can also restrict B to only try plays that do not leave a known A-winning condition.\nThere are ways to prune the tree further, some of which we explore in the Test Set 2\nsection below.\n</p><p>\nWe can pass Test Set 1 either with a combination of simple pruning and memoization/dynamic\nprogramming, or a lot of pruning.\n</p>\n<h3>Test Set 2</h3>\n<p>\nThe number of possible states in Test Set 2 is just too big to even fit in memory, even after\ncareful pruning. However, pruning enough can help us find sets of equivalent states, that is,\ngroups of states that we can prove have the same winner. By doing that, we can dramatically\nreduce the number of memoized states.\n</p><p>\nConsider only A's turns first. We have already mentioned the \"already won\" and\n\"can win immediately\" conditions above. On top of those, we can notice that if\nthere is some set of three unplayed tiles available with three consecutive numbers,\nand there is some block of three consecutive cells available, A\ncan win by playing the middle number in the middle cell (we call this the \"can win in 2 moves\"\ncondition). Whatever B plays next, A's following turn will fulfill either the\n\"already won\" condition or the \"can win immediately\" condition.\n</p><p>\nThe conditions above allow us to find some states which are\ndefinitely A-winning. Notice that in any other state where it is A's turn, it's impossible for any\nof the already-placed tiles to end the game as part of an adjacent and consecutive pair.\nTherefore, they could be replaced by \"unavailable\" cells without a specific number on them.\nSo, the remaining cells can be represented as\nthe multiset of sizes of the groups of consecutive cells that are left; call it L<sub>C</sub>.\nThe exact locations of those groups on the board are not relevant to the final outcome.\nSince each tile can only form\nadjacent and consecutive pairs with other leftover tiles, we can similarly represent the remaining\ntiles with a multiset of lengths of consecutive runs of tiles; call it L<sub>T</sub>. For example,\nthe state\n<pre>\n7 2 6 _ _ 3 _ 4 _ _ 5\n</pre>\n<p>\nhas the leftover tiles 1, 8, 9, 10, 11, so its leftover cells can be represented by\nthe multiset L<sub>C</sub> = {1, 2, 2} and its leftover tiles by the multiset L<sub>T</sub> = {1, 4}.\n</p><p>\nIn addition, since the \"can win in 2 moves\" condition has already been checked, we know that at\nleast one of L<sub>C</sub> and L<sub>T</sub> does not contain any integer greater than or equal to 3.\nTo simplify the algorithm, notice that the game in which we swap tile numbers and cell\nnumbers is equivalent (because the winning condition is symmetric). Therefore, states with\nL<sub>C</sub> and L<sub>T</sub> swapped are equivalent. We can therefore assume it is always\nL<sub>C</sub> that has only integers 1 and 2.\n</p><p>\nAfter this compression, the number of states is dramatically reduced. Notice that because\nwe know that there are no three consecutive leftover numbers, at least <b>N</b>/3 numbers have been\nplayed already. That means that the sum of the integers in both L<sub>C</sub> and L<sub>T</sub>\n(which is the same for both multisets) is at most 2&times;<b>N</b>/3. Therefore, the total number of\npossible multisets L<sub>T</sub> under those conditions is bounded by the sum of partitions(K)\nfor every K between 0 and 2&times;<b>N</b>/3, which is partitions(2&times;<b>N</b>/3+1).\nGiven such an L<sub>T</sub>\nmultiset, the number of possible multisets L<sub>C</sub> of only 1s and 2s such that the\nsum of L<sub>C</sub> and L<sub>T</sub> is the same is bounded by\n<b>N</b>/3 (which is the maximum number of 2s). So, the number of states is no greater than\n(<b>N</b>/3)&times;partitions(2&times;<b>N</b>/3+1), which is a fairly small number for the given\nlimits for <b>N</b>. Moreover, we need only one memoization or dynamic programming table for all\ntest cases.\n</p><p>\nThere are multiple sufficiently fast ways to implement the second player's turns\n(which are the slowest ones), and there are further restrictions that can be placed on\nplays to optimize our strategy even more. Some of those options result in an algorithm\nwhose complexity makes it clear that it runs within the time limit. Some other options have a\ntheoretical complexity that is either too large or hard to estimate tightly enough to be\nconvinced it's fast enough. Fortunately, it's possible to compute the recursive function\nfor all possible states without reading any data,\nand be sure that it runs in time before submitting.\n</p>\n<h3>The Test Set 3 that wasn't</h3>\n<p>\nWe considered having a third test set for this problem requiring a polynomial solution.\nWe progressively found solutions taking O(<b>N</b><sup>3</sup>) time, O(<b>N</b><sup>2</sup>)\ntime and even one requiring only O(<b>N</b> log <b>N</b>) time. We ultimately decided against\nadding the test set because the possibility of solving it by guessing the right theorem without\nproof was a significant concern. The benefit of the extra challenge without making\ncontestants have to read a full extra statement is of course a significant benefit, but\nit was dampened by our estimation that the likelihood of it being solved legitimately was small.\nIf we had made it worth a small number of points, it would not have been worth the relative\neffort to solve it. If we had made it worth a lot, though, that would have diminished the\nvalue of the work needed for our favorite part of the problem, which is solving Test Set 2.\n</p><p>\nIf you are up to try an extra challenge without spoilers, stop here. If you want\nsome hints on how those solutions go, read ahead!\n</p><p>\nThe first theorem further compresses the states considered in the Test Set 2 solution\non A's turns. Consider a state that is not under the \"already won\", \"can win immediately\" or\n\"can win in 2 moves\" conditions represented by some multisets L<sub>C</sub> and L<sub>T</sub>,\nwhere only L<sub>T</sub> can contain integers greater than 2. That state\nis A-winning if and only if the state represented by multisets L<sub>C</sub> and L'<sub>T</sub>\nis A-winning, where L'<sub>T</sub> is obtained from L<sub>T</sub> by replacing each integer X in\nL<sub>T</sub> with floor(X / 2) copies of a 2 and a 1 if X is odd.\nThis reduces the number of states of the\ndynamic programming to O(<b>N</b><sup>3</sup>), and we can process each of those states in\nconstant time because there is only a bounded number of effectively different plays to make.\n</p><p>\nIf we pursue that line of reasoning further, we can find that we can check A-winningness with\na small number of cases. Let\nL<sub>Ci</sub> be the number of times i is in L<sub>C</sub>, and L<sub>Ti</sub> be the number of\ntimes i is in L<sub>T</sub>. Because we already assumed that L<sub>C</sub> had no integers greater\nthan 2, L<sub>Ci</sub> = 0 for all i &ge; 3. Let\nK = L<sub>C1</sub>+2&times;L<sub>C2</sub> = sum of i&times;L<sub>Ti</sub> over all i\nbe the number of turns left and\nZ = (L<sub>T2</sub>+L<sub>T3</sub>) + 2&times;(L<sub>T4</sub>+L<sub>T5</sub>) +\n    3&times;(L<sub>T6</sub>+L<sub>T7</sub>) + ...\nbe the number of times 2 appears in L'<sub>T</sub> as described in the previous paragraph. Then, the\nsecond theorem we can prove is that:\n<ul>\n  <li>If K = 2, then the state is A-winning if and only if L<sub>C2</sub> = L<sub>T2</sub> = 1.</li>\n  <li>If K &gt; 2, then the state is A-winning if and only if K is odd and\n      2&times;(L<sub>C2</sub>+Z) &gt; K.</li>\n</ul>\n<p>\nFrom the need to avoid the \"already won\", \"can win immediately\" and \"can win in 2 moves\"\nconditions, it is possible to reduce the number of plays on B's turn to a set of a bounded number of\noptions that always contains a winning move if there is one. This, together with the fact that\nthe conditions above can be checked in constant time, yields an algorithm that decides for\nany state whether it is winning or losing in O(<b>N</b>) time, making the overall process\nof a test case take O(<b>N</b><sup>2</sup>) time. With some technical effort, we can\nrepresent the board in a way that we can update and use in O(log <b>N</b>) time to check\nall the necessary conditions, yielding an algorithm that requires only O(<b>N</b> log <b>N</b>)\ntime to process a full test case.\n</p><p>\nThe proofs for the theorems on the paragraphs above are left as an exercise to the reader. As a\nhint, it is easier to prove the second more general theorem, which is already nicely framed,\nand then obtain the first theorem as a corollary.\n</p>\n\n\n  <div class=\"test-data-download-wrapper\">\n    <div class=\"test-data-download-header\">\n      <div class=\"test-data-download-header-text\">Test Data</div>\n      <div class=\"test-data-download-header-download-button\">\n        <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U38PpVB4Kprfe00FV-mL_kYhw8OIMXRtEERLAUa1ePa4jSXmms-fsSr-UJmeuOsq9eAYICBxpk/test_data.zip?dl=1\" target=\"_blank\">\n          <i class=\"material-icons grey\">save_alt</i>\n        </a>\n      </div>\n    </div>\n    <div class=\"test-data-download-content\">\n      <div class=\"test-data-download-warning\">\n        <span class=\"material-icons\" style=\"color: grey; vertical-align: middle;\">info</span>\n        <span style=\"vertical-align: middle;\">We recommend that you practice debugging solutions without looking at the test data.</span>\n      </div>\n    </div>\n  </div>\n\n\n","id":"00000000003b53ce","statement":"<h3>Problem</h3>\n<p>\n  Two players, A and B, are playing a game. The game uses <b>N</b> tiles\n  numbered 1 through <b>N</b>, and a board consisting of a single horizontal row\n  of <b>N</b> empty cells.\n</p><p>\n  Players alternate turns, with Player A going first. On a turn, a player picks an unused tile\n  and an empty cell and places the tile in the cell. At the end of the game, Player A wins if\n  there are two tiles with consecutive numbers in adjacent cells (regardless of who put them\n  there). Otherwise, Player B wins. For example, final boards of 1 2 3 4 and 4 1 3 2 are examples\n  of wins for Player A, and a final board of 3 1 4 2 is an example of a win for Player B.\n  (Notice that consecutive numbers may appear in either order.)\n</p><p>\n  You just watched two players play a game, but you could not understand their strategy. They\n  may not have played rationally! You decide to compare their moves against an optimal strategy.\n</p><p>\n  A <i>winning state</i> is a state of the game from which the player whose turn it is can\n  guarantee a win if they play optimally, regardless of what the opponent does. A <i>mistake</i>\n  is a move made while in a winning state that results in the opponent having a winning state on\n  their next turn. (Notice that it is not possible to make a mistake on the last turn of the game,\n  since if the last turn begins with a winning state for that player, it must be because that\n  player's only move results in a win.)\n</p><p>\n  Given the <b>N</b> moves, count the number of mistakes made by each player.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases\n  follow. Each case begins with one line containing an integer <b>N</b>: the number of tiles in\n  the game (which is also the number of turns, and the number of cells on the board).\n</p><p>\n  Then, <b>N</b> more lines follow. The i-th of these (counting starting from 1) has two integers\n  <b>M<sub>i</sub></b> and <b>C<sub>i</sub></b>. Respectively, these represent the tile chosen on\n  the i-th turn, and the index of the cell (counting from 1 at the left end to <b>N</b> at the\n  right end) where that tile is placed.\n</p><p>\n  Note that it is Player A's turn whenever i is odd, and Player B's turn whenever i is even.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: a b</code>, where <code>x</code>\n  is the test case number (starting from 1), <code>a</code> is the total number of mistakes made by\n  Player A, and <code>b</code> is the total number of mistakes made by Player B.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 40 seconds per test set.<br/>\n  Memory limit: 1GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>M<sub>i</sub></b> &le; <b>N</b>, for all i.<br/>\n  <b>M<sub>i</sub></b> &ne; <b>M<sub>j</sub></b>, for all i &ne; j.<br/>\n  1 &le; <b>C<sub>i</sub></b> &le; <b>N</b>, for all i.<br/>\n  <b>C<sub>i</sub></b> &ne; <b>C<sub>j</sub></b>, for all i &ne; j.<br/>\n</p>\n\n<h4>Test Set 1 (Visible Verdict)</h4>\n<p>\n  4 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Test Set 2 (Hidden Verdict)</h4>\n<p>\n  4 &le; <b>N</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper-new\">\n    <div class=\"sampleio-wrapper\">\n      <div class=\"sample-input\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Input</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2J-7kcQ3gH3zk2gdohie7CxVpLPeCrUZ9RmrQRURVuXq37aR4AeUB1eh5WwBP8qJDW6HrO247UBglIY7BnpColYYJq3mzT-0-tr6lz_wyQb3tsJSf2pQ/adjacent_and_consecutive_sample_ts1_input.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_input_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_input_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_input_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_input_0\">3\n6\n2 2\n3 5\n4 3\n6 6\n1 4\n5 1\n4\n4 1\n1 3\n3 4\n2 2\n4\n3 1\n2 2\n4 3\n1 4\n</pre>\n        </div>\n      </div>\n      <div class=\"sample-output\">\n        <div class=\"sample-header\">\n          <div class=\"sample-header-text\">Sample Output</div>\n          <div class=\"sample-header-download-button\">\n            <a href=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0rmIEXe0Jv3WjJ65MG1iobTJsv7Acm3JoBGE3jb5iDrjricvx9WBNOSGJsnI5jpQYV82zW7SKnD9sqey6LG1YGpUtYBbwa-NY-3sbw8vBE7QFdkV_870E/adjacent_and_consecutive_sample_ts1_output.txt?dl=1\" target=\"_blank\" aria-label=\"Download\">\n              <i class=\"material-icons grey\">save_alt</i>\n            </a>\n          </div>\n          <div class=\"sample-header-copy-button\" onclick=\"\n              const copyText = document.getElementById('sample_output_0').textContent;\n              const textArea = document.createElement('textarea');\n              textArea.textContent = copyText;\n              textArea.style.position = 'absolute';\n              textArea.style.left = '-100%';\n              document.body.append(textArea);\n              textArea.select();\n              document.execCommand('copy');\n              textArea.remove();\n              const copyPopup = document.getElementById('sample_output_copy_popup_0');\n              copyPopup.classList.add('sample-header-copy-popup-shown');\n              setTimeout(function(){ copyPopup.classList.remove('sample-header-copy-popup-shown'); }, 2000);\n          \" aria-label=\"Copy to clipboard\">\n            <i class=\"material-icons grey\">content_copy</i>\n            <span class=\"sample-header-copy-popup\" id=\"sample_output_copy_popup_0\">\n              Copied!\n            </span>\n          </div>\n        </div>\n        <div class=\"sample-content\">\n          <pre class=\"sample-content-text\" id=\"sample_output_0\">Case #1: 2 1\nCase #2: 0 0\nCase #3: 0 0\n</pre>\n        </div>\n      </div>\n    </div>\n  </div>\n\n\n<p>\n  Notice that any game always begins in a winning state for Player A. For example, Player A can\n  play tile 2 in cell 2 (i.e. the second cell from the left). No matter what Player B does on their\n  turn, at least one of tiles 1 and 3 will be unused, and at least one of cells 1 and 3 will be\n  empty. Then Player A can play one of those tiles in one of those cells, and this secures a win\n  for Player A regardless of what happens in the rest of the game.\n</p><p>\n  In Sample Case #1, the game plays out as follows:\n</p>\n<ul>\n  <li>_ _ _ _ _ _. This is a winning state for Player A, as explained above.</li>\n  <li>Turn 1: Player A plays tile 2 in cell 2.</li>\n  <li>_ 2 _ _ _ _. This is not a winning state for Player B, as explained above; Player B cannot\n    guarantee a win, regardless of their remaining choices in the game.</li>\n  <li>Turn 2: Player B plays tile 3 in cell 5.</li>\n  <li>_ 2 _ _ 3 _. This is a winning state for Player A; for example, they could play tile 1 in\n    cell 3.</li>\n  <li>Turn 3: Player A plays tile 4 in cell 3.</li>\n  <li>_ 2 4 _ 3 _. This is a winning state for Player B; for example, they could play tile 5 in\n    cell 1, and then they would be guaranteed to win no matter what Player A did. So Player A's last\n    move was a mistake!</li>\n  <li>Turn 4: Player B plays tile 6 in cell 6.</li>\n  <li>_ 2 4 _ 3 6. This is a winning state for Player A, since Player A could play tile 1 in\n    cell 1. So Player B's last move was a mistake!</li>\n  <li>Turn 5: Player A plays tile 1 in cell 4.</li>\n  <li>_ 2 4 1 3 6. This is a winning state for Player B, so Player A's last move was a mistake!</li>\n  <li>Turn 6: Player B plays tile 5 in cell 1.</li>\n  <li>5 2 4 1 3 6. The game is over, and Player B has won.</li>\n</ul>\n<p>\n  In total, Player A made 2 mistakes and Player B made 1 mistake.\n</p><p>\n  In Sample Case #2, although some of the moves may look risky, neither player made a mistake as\n  defined in this problem. Player A never gave up a winning state to Player B, and Player B had no\n  opportunity to make a mistake because they were never in a winning state.\n</p><p>\n  In Sample Case #3, notice that even though the outcome of the game is determined after the\n  second move (since that move creates a pair of adjacent and consecutive tiles), all tiles must\n  be placed in each game. Moreover, although the second move assures Player A's victory, it is not\n  a mistake for Player B because Player B was not in a winning state at the time.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":0},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":32}],"title":"Adjacent and Consecutive","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000019ff31","type":1,"type__str":"SPECTATOR"},"title":"Virtual World Finals 2020"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
