{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1491703200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"00000000002017f7","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n  Our 2017 Qualification Round saw a record number of registrants (almost\n  64,000 &mdash; we may need to upgrade our unsigned short variable if this\n  keeps up!) Difficulty-wise, the round was somewhere between the legendarily\n  tough 2015 and the milder 2016. Over 25,000 contestants solved at least one\n  dataset, and about 500 managed perfect scores! xiaowuc1 continued a now five-year\n  streak of submitting the first correct dataset, and didn't even need two minutes\n  this time! y0105w49 was the first to submit every dataset correctly, but with\n  one four-minute penalty; FatalEagle swooped in shortly afterward, with no\n  penalties, to snatch first place.\n</p><p>\n  <i>Oversized Pancake Flipper</i> was this year's obligatory pancake-themed\n  problem. (We don't know how much longer this tradition will go on; we may\n  need some help from the Infinite House of Pancake Problem Ideas!)\n  <i>Tidy Numbers</i> had a tougher Large that required some attention to\n  edge cases. Perhaps because of its more tempting point value, more contestants\n  attempted it than A, though the numbers of contestants getting A-Large and\n  B-Large right were very similar.\n  <i>Bathroom Stalls</i> was a three-dataset problem that rewarded\n  various levels of optimization; its two Smalls were useful insurance for solvers\n  who weren't quite sure about their A-Large or B-Large answers. <i>Fashion Show</i>\n  presented an unusual story that disguised a chess piece problem that could be\n  simplified with one cool insight. Even its Small was quite tough, only garnering\n  around 1000 solves.\n</p><p>\n  Over 18,000 contestants advanced to the Round 1s by earning 25 points or more. If\n  you advanced, we hope to see you in under a week for Round 1A! Regardless of\n  how you fared, we hope you had a great time with the problems. Check out the\n  analyses for the problems for various interesting observations and alternate\n  solution methods.\n</p>\n<hr>\n<p>\n  <b>Cast</b>\n</p><p>\n  Problem A (Oversized Pancake Flipper): Written by Pablo Heiber. Prepared by\n  Ian Tullis.\n</p><p>\n  Problem B (Tidy Numbers): Written and prepared by Pablo Heiber.\n</p><p>\n  Problem C (Bathroom Stalls): Written and prepared by Pablo Heiber.\n</p><p>\n  Problem D (Fashion Show): Written by Ian Tullis. Prepared by Ahmed Aly and\n  Yerzhan Utkelbayev.\n</p><p>\n  Solutions and other problem preparation and review by Hossein Bateni,\n  Shane Carr, John Dethridge, Jackson Gatenby, Md Mahbubul Hasan, Alex Irpan,\n  Nathan Pinsker, Mihai-Emilian Scortaru, Steve Thomas, and Erick Wong.\n</p>\n<p>\n  Analysis authors:\n</p>\n<ul>\n<li>Oversized Pancake Flipper: Ian Tullis</li>\n<li>Tidy Numbers: Pablo Heiber, Ian Tullis, and Josef Ziegler</li>\n<li>Bathroom Stalls: Pablo Heiber</li>\n<li>Fashion Show: Steve Thomas and Ian Tullis</li>\n</ul>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1491606000000,"tasks":[{"analysis":"<h2>Fashion Show: Analysis</h2>\n<h3>What's really going on here?</h3>\n<p>\n  The somewhat strange scenario presented in this problem disguises a classic\n  type of chess problem in which pieces must be placed so that they do not\n  attack each other. The\n  <a href=\"https://en.wikipedia.org/wiki/Eight_queens_puzzle\">eight queens puzzle</a>\n  is one well-known example. Our problem is more complicated, and it involves\n  three types of piece. Let's restate the rules about how the models can\n  interact in more chess-like terms:\n</p>\n<ul>\n  <li>The <code>+</code> models are bishops. Two bishops may not occupy the\n    same diagonal.</li>\n  <li>The <code>x</code> models are rooks. Two rooks may not occupy the same\n    row or column.</li>\n  <li>The <code>o</code> pieces are queens. Two queens may not occupy the same\n    row, column, or diagonal. Moreover, a queen and a bishop may not occupy the\n    same diagonal; a queen and a rook may not occupy the same row or column.\n  </li>\n</ul>\n<p>\n  Observe that our problem does not accord with typical chess rules about\n  \"attacks\". For example, in our problem, it is fine for a rook and a bishop to\n  share the same row or column. Also, unlike in chess, a piece between two\n  pieces does not prevent them from \"attacking\" each other. For example, we do\n  not allow two bishops to share the same diagonal even if there is a rook\n  between them.\n</p>\n<h3>Decomposing the problem</h3>\n<p>\n  How will we deal with this variety of pieces? The critical insight is that\n  the rook and bishop parts of the problem are independent; we can solve them\n  separately, placing as many new pieces in each subproblem as possible, and\n  then merge the answers together. A queen is just a rook plus a bishop; we can\n  add each pre-placed queen into the rook subproblems as a rook and into the\n  bishop subproblem as a bishop. Then, once the subproblems are solved, we can\n  turn any cell that is occupied in both subproblem solutions back into a\n  queen.\n</p><p>\n  This strategy is guaranteed not to violate any rules. A rook subproblem\n  solution will never have two rooks in the same row or column, and a bishop\n  subproblem solution will never have two bishops on the same diagonal. Merging\n  the two subproblems' solutions may generate new queens, but it is impossible\n  for them to violate any rules, since that would imply a rule violation in one\n  of the subproblems. For example, we do not need to worry that we will end up\n  with a queen and a bishop on the same diagonal, since that would only be\n  possible if our bishop solution had two bishops on the same diagonal.\n</p><p>\n  Moreover, as long as we place as many rooks as possible in the rook\n  subproblem, and as many bishops as possible in the bishop subproblem, we are\n  guaranteed the maximum possible amount of style points for our test case.\n  Since queens are worth 2 points, merging a rook and a bishop into a queen has\n  no effect on our score.\n</p><p>\n  Let's walk through an example. This case:\n</p>\n<code>\n  +..<br>\n  +.o<br>\n  x..<br>\n</code>\n<p>\n  can be decomposed into rook and bishop problems:\n</p>\n<code>\n  ... +..<br>\n  ..x +.+<br>\n  x.. ...<br>\n</code>\n<p>\n  which can be solved independently:\n</p>\n<code>\n  .x. +..<br>\n  ..x +.+<br>\n  x.. +..<br>\n</code>\n<p>\n  and then merged back together. Note that we have replaced the former\n  <code>x</code> model from the lower left corner with an <code>o</code> model.\n</p>\n<code>\n  +x.<br>\n  +.o<br>\n  o..<br>\n</code>\n<h3>Solving the subproblems</h3>\n<p>\n  Now all we need are strategies for the subproblems themselves. The rook\n  problem is straightforward. Each rook removes exactly one row and column from\n  further consideration, so any greedy placement strategy that does not violate\n  the rules will place exactly <b>N</b> rooks.\n</p><p>\n  The bishop subproblem is more challenging. We can approach it differently in\n  the Small and Large datasets.\n</p>\n<h4>Bishops: Small dataset</h4>\n<p>\n  In the Small dataset, any pre-placed pieces are all in the top row. Observe\n  that bishops in the same row or column cannot possibly \"threaten\" each other,\n  and so we can safely add a bishop to any top row cell that does not already\n  have one. So, if we can come up with a general solution pattern in which the\n  top row is always completely filled with bishops, then we can solve any Small\n  test case, because we can safely turn any pre-placed arrangement into a row\n  packed with bishops.\n</p><p>\n  Once the top row is filled with bishops, where else on the board should we\n  put them? The bottom row is farthest away from the constraints imposed by\n  the top row, and we can try putting a bishop in every bottom-row cell except\n  for the cells on either end (which are \"threatened\" by the bishops at the two\n  ends of the top row). These bishops do not threaten each other or any top row\n  bishops, so this arrangement is valid, and we have a total of 2<b>N</b>-2\n  bishops. No additional bishops can be added after that, though. Have we\n  really placed as many as possible?\n</p><p>\n  At this point, we can experiment and convince ourselves that this solution\n  is probably optimal. We can also take a leap of faith; for a Small dataset in\n  a Qualification Round, there is little incentive not to submit the solution\n  and see if it is correct. Or, we can come up with a proof. An <b>N</b> by\n  <b>N</b> board has 4<b>N</b>-2 different diagonals. Moreover, the parallel\n  diagonals of length 1 in opposite corner cells can never both be used\n  simultaneously, so there are really only 4<b>N</b>-4 simultaneously usable\n  diagonals. Since placing a bishop uses up two diagonals, 2<b>N</b>-2 is an\n  upper bound on the number of bishops we can place. So, our method is optimal!\n</p><p>\n  We must still take care, though, to handle a pre-placed rook/queen correctly\n  if one is present, and to merge the rook and bishop solutions appropriately,\n  creating queens when necessary. We must also be careful with the 1 by 1\n  board, which has no bottom row distinct from its top row.\n</p><p>\n  It is possible to come up with the same construction without realizing that\n  the problem can be decomposed into rooks and bishops; it is just more\n  difficult to justify the optimality of the construction in that case!\n</p>\n<h4>Bishops: Large dataset</h4>\n<p>\n  One helpful observation is that, just as in a chess game, the \"white cell\"\n  bishops (in our problem, cells for which <b>R<sub>i</sub></b> +\n  <b>C<sub>i</sub></b> is even) are completely independent of the \"black cell\"\n  bishops (cells for which that sum is odd). So we can consider these as\n  sub-sub-problems.\n</p><p>\n  You can use a\n  <a href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)#Bipartite_matching\">bipartite matching algorithm</a>\n  to place the bishops optimally. There is, however, a greedy strategy; unlike\n  in the rook subproblem, however, not just any greedy strategy will work!\n</p><p>\n  Let's consider an 8 x 8 board with no pre-placed bishops. We'll look at just\n  the \"black\" cells of the board, and tilt the board 45 degrees clockwise.\n  (Here, <code>.</code>s represent black cells. The <code>@</code>s do not\n  represent cells &mdash; they are just there to orient the image.)\n</p>\n<code>\n  @@@..@@@<br>\n  @@....@@<br>\n  @......@<br>\n  ........<br>\n  @......@<br>\n  @@....@@<br>\n  @@@..@@@<br>\n</code>\n<p>\n  This new board has an important property: any row is a subset of all rows\n  with more black cells than it. For example, the four black cells in the\n  second row are also present in every row with at least four black cells.\n  This property holds regardless of the value of <b>N</b>, or whether we look\n  at \"white\" or \"black\" cells. It even holds as we add bishops! Adding a bishop\n  wipes out one entire row and one entire column &mdash; notice that we have\n  made this more like the rook problem &mdash; and since the remaining rows\n  have all lost the same column, the aforementioned property is unchanged.\n</p><p>\n  The property suggests a greedy strategy: first, sort the rows by the number\n  of available cells. Then, pick a \"smallest\" row (one with a minimal number of\n  available cells), place a bishop in any column in that row, and wipe out that\n  row and column. This strategy is guaranteed to place an optimally large\n  number of bishops. Suppose that we choose a column C in the smallest row R,\n  and another column C' in some other row R', such that C' is also in R. Then C\n  must also be in R', since all columns in the smallest row are in every other\n  row. We can therefore swap them over, and it is equally valid to choose C' in\n  row R and C in row R'.\n</p><p>\n  One tempting (but incorrect) greedy strategy is to go left to right, top to\n  bottom, and greedily place bishops in all legal places. Here is an example of\n  a board for which that fails.\n</p>\n<code>\n  .@@@@<br>\n  ....@<br>\n  ...@@<br>\n  ..@@@<br>\n  .@@@@<br>\n</code>\n<p>\n  The incorrect greedy strategy will only place three bishops, as follows:\n</p>\n<code>\n  +@@@@<br>\n  .+..@<br>\n  ..+@@<br>\n  ..@@@<br>\n  .@@@@<br>\n</code>\n<p>\n  whereas the correct strategy will place four (here is one optimal placement):\n</p>\n<code>\n  .@@@@<br>\n  ...+@<br>\n  ..+@@<br>\n  .+@@@<br>\n  +@@@@<br>\n</code>\n<p>\n  Notice that although we can always place <b>N</b> rooks, the number of\n  bishops we are able to place depends on the pre-placed bishops. This explains\n  why different test cases with the same value of <b>N</b> might have\n  different maximum scores.\n</p>\n","id":"00000000002017f8","statement":"<h3>Problem</h3>\n<p>\n  You are about to host a fashion show to show off three new styles of clothing.\n  The show will be held on a stage which is in the most fashionable of all\n  shapes: an <b>N</b>-by-<b>N</b> grid of cells.\n</p><p>\n  Each cell in the grid can be empty (which we represent with a <code>.</code>\n  character) or can contain one fashion model. The models come in three types,\n  depending on the clothing style they are wearing: <code>+</code>,\n  <code>x</code>, and the super-trendy <code>o</code>. A cell with a\n  <code>+</code> or <code>x</code> model in it adds 1 <i>style point</i> to the\n  show. A cell with an <code>o</code> model in it adds 2 style points. Empty\n  cells add no style points.\n</p><p>\n  To achieve the maximum artistic effect, there are rules on how models can be\n  placed relative to each other.\n</p>\n<ul>\n  <li>Whenever any two models share a row or column, at least one of the two\n    must be a <code>+</code>.</li>\n  <li>Whenever any two models share a diagonal of the grid, at least one of\n    the two must be an <code>x</code>.</li>\n</ul>\n<p>\n  Formally, a model located in row i<sub>0</sub> and column j<sub>0</sub> and a\n  model located in row i<sub>1</sub> and column j<sub>1</sub> share a row if\n  and only if i<sub>0</sub> = i<sub>1</sub>, they share a column if and only if\n  j<sub>0</sub> = j<sub>1</sub>, and they share a diagonal if and only if\n  i<sub>0</sub> + j<sub>0</sub> = i<sub>1</sub> + j<sub>1</sub> or\n  i<sub>0</sub> - j<sub>0</sub> = i<sub>1</sub> - j<sub>1</sub>.\n</p><p>\n  For example, the following grid is not legal:\n</p>\n<code>\n  ...<br>\n  x+o<br>\n  .+.<br>\n</code>\n<p>\n  The middle row has a pair of models (<code>x</code> and <code>o</code>) that\n  does not include a <code>+</code>. The diagonal starting at the\n  <code>+</code> in the bottom row and running up to the <code>o</code> in\n  the middle row has two models, and neither of them is an <code>x</code>.\n</p><p>\n  However, the following grid is legal. No row, column, or diagonal violates\n  the rules.\n</p>\n<code>\n  +.x<br>\n  +x+<br>\n  o..<br>\n</code>\n<p>\n  Your artistic advisor has already placed <b>M</b> models in certain\n  cells, following these rules. You are free to place any number (including\n  zero) of additional models of whichever types you like. You may not remove\n  existing models, but you may upgrade as many existing <code>+</code> and\n  <code>x</code> models into <code>o</code> models as you wish, as long as the\n  above rules are not violated.\n</p><p>\n  Your task is to find a legal way of placing and/or upgrading models that\n  earns the maximum possible number of style points.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each test case begins with one line with two\n  integers <b>N</b> and <b>M</b>, as described above. Then, <b>M</b> more lines\n  follow; the i-th of these lines has a <code>+</code>, <code>x</code>, or\n  <code>o</code> character (the type of the model) and two integers\n  <b>R<sub>i</sub></b> and <b>C<sub>i</sub></b> (the position of the model).\n  The rows of the grid are numbered 1 through <b>N</b>, from top to bottom.\n  The columns of the grid are numbered 1 through <b>N</b>, from left to\n  right.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, first output one line containing\n  <code>Case #x: y z</code>, where <code>x</code> is the test case number\n  (starting from 1), <code>y</code> is the number of style points earned in\n  your arrangement, and <code>z</code> is the total number of models you have\n  added and/or substituted in. Then, for each model that you have added or\n  substituted in, output exactly one line in exactly the same format described\n  in the Input section, where the character is the type of the model that you\n  have added or substituted in. These <code>z</code> lines can be in any order.\n</p><p>\n  If there are multiple valid answers, you may output any one of them.\n</p>\n\n<h3>Limits</h3>\n<p>\n  Time limit: 20 seconds per test set.<br/>\n  Memory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  1 &le; <b>N</b> &le; 100.<br/>\n  1 &le; <b>C<sub>i</sub></b> &le; <b>N</b>, for all i.<br/>\n  0 &le; <b>M</b> &le; <b>N</b><sup>2</sup>.<br/>\n  No two pre-placed models appear in the same cell.<br/>\n  It is guaranteed that the set of pre-placed models follows the rules.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  <b>R<sub>i</sub></b> = 1, for all i. (Any models that are pre-placed are in\n  the top row. Note that you may add/replace models in that row and/or add\n  models in other rows.)<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>R<sub>i</sub></b> &le; <b>N</b>, for all i.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 0\n1 1\no 1 1\n3 4\n+ 2 3\n+ 2 1\nx 3 1\n+ 2 2\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 4 3\no 2 2\n+ 2 1\nx 1 1\nCase #2: 2 0\nCase #3: 6 2\no 2 3\nx 1 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>\n  The sample output displays one set of answers to the sample cases. Other\n  answers may be possible. Note that the last sample case would not appear in\n  the Small dataset.\n</p><p>\n  In sample case #1, the grid is 2-by-2 and is initially blank. The output\n  corresponds to the following grid. (In these explanations, we will use\n  <code>.</code> to denote a blank cell.)\n</p>\n<code>\n  x.<br>\n  +o<br>\n</code>\n<p>\n  In sample case #2, the only cell is already occupied by an <code>o</code>\n  model, and it is impossible to add a new model or replace the\n  <code>o</code> model.\n</p><p>\n  In sample case #3, the grid looks like this before you place any models:\n</p>\n<code>\n  ...<br>\n  +++<br>\n  x..<br>\n</code>\n<p>\n  The output corresponds to this grid:\n</p>\n<code>\n  .x.<br>\n  ++o<br>\n  x..<br>\n</code>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Fashion Show","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Oversized Pancake Flipper: Analysis</h2>\n\n<p>\n  Let's start with two simple but key observations. First, the flips are\n  commutative. That is, the order in which you make the flips doesn't matter:\n  flipping at the same positions in any order always yields the same result.\n  Second, you never need to flip at the same position more than once: since\n  flips are commutative, you may rearrange the flips so that two flips at the\n  same position happen consecutively, and then it is clear that they cancel\n  each other out and you might as well not do either.\n</p>\n\n<h3>Small dataset</h3>\n<p>\n  Applying the observations above to the Small dataset leaves only a really\n  small number of combinations to try. Since there are <b>N</b>-<b>K</b>+1\n  possible flips, the number of flip subsets is\n  2<sup><b>N</b>-<b>K</b>+1</sup>, which is at most 2<sup>9</sup> = 512 for\n  this dataset. We can just try all of these combinations, discard the ones\n  that leave at least one pancake blank side up, and get the minimum number of\n  flips or determine that it is impossible.\n</p><p>\n  Even if you don't have the observations above, a\n  <a href=\"https://en.wikipedia.org/wiki/Breadth-first_search\">breadth-first search</a>\n  of all possible pancake states, using all possible flips as transitions, is\n  also easily fast enough.\n</p>\n\n<h3>Large dataset</h3>\n<p>\n  Of course, the approach above will take way too long for the Large dataset,\n  which can have up to 1000 pancakes. There is a simple greedy strategy that is\n  not too hard to find. Notice that the left-most pancake <i>p<sub>1</sub></i>\n  is only affected by the left-most flip <i>f<sub>1</sub></i>. That means that\n  the initial status of <i>p<sub>1</sub></i> completely determines what do we\n  need to do with <i>f<sub>1</sub></i> if we want to have any chance of leaving\n  all pancakes happy side up: use <i>f<sub>1</sub></i> if and only if\n  <i>p<sub>1</sub></i> is initially blank side up. After deciding on\n  <i>f<sub>1</sub></i>, we can notice that there is only one remaining flip\n  <i>f<sub>2</sub></i> that affects the second to the left pancake\n  <i>p<sub>2</sub></i>. So, after we have used <i>f<sub>1</sub></i> (or not),\n  the current state of <i>p<sub>2</sub></i> completely determines whether to\n  use <i>f<sub>2</sub></i>.\n</p><p>\n  Continuing with this reasoning, we can use the leftmost <b>N</b>-<b>K</b>+1\n  pancakes to determine all flips. After doing that, we only need to check\n  whether the last <b>K</b>-1 pancakes are happy side up or not. If they all\n  are, then the answer is the number of flips we used. Otherwise, the answer is\n  IMPOSSIBLE. Notice that this reasoning also implies that at most one of the\n  subsets of flips from our Small-only solution above would have worked.\n</p><p>\n  If we carry out the above strategy literally and actually flip all of the\n  pancakes in memory each time, the complexity is O(<b>N</b><sup>2</sup>). We\n  can reduce this to O(<b>N</b>) by only flipping one pancake at a time, and\n  keeping a running count of the number of flips that we \"owe\" the current\n  pancake. For instance, suppose that <b>N</b> = 10 and <b>K</b> = 5, and the\n  first pancake is blank side up. We start with the first pancake, and because\n  we must flip it, we know we must flip the first five pancakes. We increase\n  our flip count to 1, and also make a memo to decrease the flip count by 1\n  once we reach the sixth pancake. We continue from left to right, and whenever\n  a pancake is blank side up and the flip count is even, or a pancake is happy\n  side up and the flip count is odd, we increase the flip count and make\n  another memo. These memos can be easily stored in another array of length\n  <b>N</b> that is checked before handling each pancake. This optimization is\n  not necessary to solve the Large dataset, but it is a useful trick in\n  programming contest problems (and at least one of your Code Jam engineers\n  has used it in day-to-day software engineering work!)\n</p>\n","id":"0000000000201847","statement":"<h3>Problem</h3>\n<p>\n  Last year,\n  the Infinite House of Pancakes introduced a new kind of pancake.\n  It has a happy face made of chocolate chips on one side (the \"happy side\"),\n  and nothing on the other side (the \"blank side\").\n</p>\n<p>\n  You are the head cook on duty. The pancakes are cooked in a single row over a\n  hot surface. As part of its infinite efforts to maximize efficiency, the\n  House has recently given you an oversized pancake flipper that flips exactly\n  <b>K</b> consecutive pancakes. That is, in that range of <b>K</b> pancakes,\n  it changes every happy-side pancake to a blank-side pancake, and vice versa;\n  it does <i>not</i> change the left-to-right order of those pancakes.\n</p><p>\n  You cannot flip fewer than <b>K</b> pancakes at a time with the flipper,\n  even at the ends of the row (since there are raised borders on both sides of\n  the cooking surface). For example, you can flip the first <b>K</b> pancakes,\n  but not the first <b>K</b> - 1 pancakes.\n</p><p>\n  Your apprentice cook, who is still learning the job, just used the\n  old-fashioned single-pancake flipper to flip some individual pancakes and\n  then ran to the restroom with it, right before the time when customers come\n  to visit the kitchen. You only have the oversized pancake flipper left, and\n  you need to use it quickly to leave all the cooking pancakes happy side up,\n  so that the customers leave feeling happy with their visit.\n</p><p>\n  Given the current state of the pancakes, calculate the minimum number of uses\n  of the oversized pancake flipper needed to leave all pancakes happy side up,\n  or state that there is no way to do it.\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> test cases follow. Each consists of one line with a string <b>S</b>\n  and an integer <b>K</b>. <b>S</b> represents the row of pancakes: each of its\n  characters is either <code>+</code> (which represents a pancake that is\n  initially happy side up) or <code>-</code> (which represents a pancake that\n  is initially blank side up).\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>, where\n  <code>x</code> is the test case number (starting from 1) and <code>y</code>\n  is either <code>IMPOSSIBLE</code> if there is no way to get all the pancakes\n  happy side up, or an integer representing the the minimum number of times you\n  will need to use the oversized pancake flipper to do it.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n  Every character in <b>S</b> is either <code>+</code> or <code>-</code>.<br/>\n  2 &le; <b>K</b> &le; length of <b>S</b>.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  2 &le; length of <b>S</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n  2 &le; length of <b>S</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n---+-++- 3\n+++++ 4\n-+-+- 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 3\nCase #2: 0\nCase #3: IMPOSSIBLE\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Case #1, you can get all the pancakes happy side up by first flipping the\n  leftmost 3 pancakes, getting to <code>++++-++-</code>, then the rightmost 3,\n  getting to <code>++++---+</code>, and finally the 3 pancakes that remain\n  blank side up. There are other ways to do it with 3 flips or more, but none\n  with fewer than 3 flips.\n</p><p>\n  In Case #2, all of the pancakes are already happy side up, so there is no\n  need to flip any of them.\n</p><p>\n  In Case #3, there is no way to make the second and third pancakes from the\n  left have the same side up, because any flip flips them both. Therefore,\n  there is no way to make all of the pancakes happy side up.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":10}],"title":"Oversized Pancake Flipper","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Tidy Numbers: Analysis</h2>\n<h3>Small dataset</h3>\n<p>\n  The Small dataset can be solved by a simulation, going backwards through the\n  numbers that Tatiana counted. We start with <b>N</b> and check whether it is\n  tidy. If it is, we are done; if not, we check <b>N</b>-1, and then\n  <b>N</b>-2 if <b>N</b>-1 is not tidy, and so on.\n</p><p>\n  Checking a number for tidiness takes a single pass over its digits. We\n  can bound the number of digits of numbers no greater than <b>N</b> by\n  log<sub>10</sub><b>N</b>. Since we iterate through at most O(<b>N</b>)\n  numbers, the overall time complexity of this approach is O(<b>N</b> log\n  <b>N</b>). This is easily fast enough to solve the Small dataset, in which\n  <b>N</b> &le; 1000, but it will not hold up for the Large dataset, which can\n  have <b>N</b> as large as 10<sup>18</sup>. If you start at the non-tidy\n  number 111111111111111110, you have a <i>very</i> long way down to count\n  before reaching the answer, 99999999999999999!\n</p><p>\n  To iterate through the digits of an integer, you can use a language-provided\n  utility to convert it to a string, or repeatedly take the value modulo 10 to\n  obtain the last digit and divide by 10 to remove the last digit.\n</p>\n<h3>Large dataset: A greedy approach</h3>\n<p>\n  There is an efficient greedy approach for the Large, but it has some tricky\n  cases.\n</p><p>\n  Let us name the digits of <b>N</b> N<sub>1</sub>, N<sub>2</sub>, ...,\n  N<sub>L</sub> from most to least significant (i.e., left to right, the way in\n  which we usually write digits). Let A be our desired answer: the most\n  recently counted tidy number. We want A to have as many digits from the left\n  as possible in common with <b>N</b>, because that minimizes the value\n  <b>N</b> - A.\n</p><p>\n  Find the first \"inversion\" in <b>N</b> &mdash; that is, the minimum i such\n  that N<sub>i</sub> &gt; N<sub>i+1</sub>. If there is no such i, then\n  <b>N</b> is already tidy and A = <b>N</b>. Otherwise: no number starting\n  with the sequence N<sub>1</sub>, N<sub>2</sub>, ..., N<sub>i</sub> can be\n  both smaller than <b>N</b> and tidy. So, we can try making our answer start\n  with A<sub>1</sub> = N<sub>1</sub>, A<sub>2</sub> = N<sub>2</sub>, ...,\n  A<sub>i-1</sub> = N<sub>i-1</sub>. The next digit A<sub>i</sub> has to be\n  less than N<sub>i</sub>, so we can try using A<sub>i</sub> =\n  N<sub>i</sub>-1. If A<sub>i</sub> is greater than or equal to\n  A<sub>i-1</sub>, we can make the remaining digits from A<sub>i+1</sub>\n  onward into 9s; this makes A as large as possible while ensuring that it\n  remains tidy. However, if A<sub>i</sub> is less than A<sub>i-1</sub>, we\n  would just be creating another inversion, and so we should instead try\n  starting A with the digits up to N<sub>i-2</sub>. If that doesn't work, we\n  can try the digits up to N<sub>i-3</sub>, and so on. We may even start with\n  zero digits of <b>N</b>; for <b>N</b> = 211, we get A = 199. Even starting\n  with zero digits might not work: for <b>N</b> = 100, for example, the answer\n  is 99.\n</p><p>\n  Let's condense these observations into a final algorithm. If there is no\n  inversion, we are done. Otherwise, if the first digit of the inversion is\n  i, find the maximum j &lt; i such that N<sub>j</sub> &lt; N<sub>j+1</sub>.\n  If there is no such j, set j = 0. Then A starts with N<sub>1</sub>,\n  N<sub>2</sub>, ..., N<sub>j</sub>, N<sub>j+1</sub>-1, and then ends with\n  enough 9s to make it length L. The only exception is if j = 0 and\n  N<sub>1</sub> is 1, in which case the answer is L-1 9s.\n</p><p>\n  Since this strategy requires only one pass\n  forward through the digits of <b>N</b> and then another pass backward, it\n  is O(the number of digits in <b>N</b>), which, as we argued above, is\n  O(log <b>N</b>). In this case, we can even get away with not converting the\n  input data strings into integers!\n</p><p>\n  To bypass some of the complexity above, we could have simply tried all\n  combinations of the form SD999...99, where S is each prefix of <b>N</b>\n  (including the empty prefix), D is each possible digit from 0 to 9, and the\n  number of 9s is such that the total length is L. L-1 9s must also be included\n  as a special case. Then the answer must be among those options, and it is the\n  largest tidy number among them that does not exceed <b>N</b>. This is a\n  common trick to simplify the code of greedy solutions: try more options than\n  are needed, as long as the number of options is still tractable. It is often\n  easier to implement finding the best solution among several options than to\n  implement the checks necessary to avoid options we know we do not need.\n</p>\n<h3>Large dataset: A combinatoric approach</h3>\n<p>\n  Another way to solve this with a little bit more math is to notice that there\n  are few tidy numbers. For a fixed length L, the number of tidy numbers is the\n  number of ways to put 8 balls in L+1 bins. Each bin represents a position at\n  the start or end or in between two digits, and each ball represents \"increase\n  the number by 1\". So, for instance, tidy number 2455 is represented by 1 ball\n  in the first bin (skipping 1), 2 balls in the second bin (moving from 2 to 4),\n  1 ball in the third (4 to 5), no ball in the fourth (5 is repeated), and the rest\n  of the balls in the last bin (moving from 5 up to 9, but there are no digits left\n  to write). 8 balls in L+1 bins is equal to (L+8 choose 8) which, for the maximum\n  L=18, is less than 2 million. So, we can enumerate all of the tidy numbers,\n  skipping the rest and just return the largest we find which is no greater than\n  <b>N</b>. To enumerate tidy numbers, we can use recursion like in this pseudocode:\n</p><pre>\nbest = 1\nenum(current_string, current_digit, digits_left):\n  if digits_left &gt; 0\n    enum(current_string + current_digit, current_digit, digits_left - 1)\n    enum(current_string + (current_digit + 1), current_digit + 1, digits_left - 1)\n  else\n    if best &le; string_to_int(current_string) &le; N\n      best = string_to_int(current_string)\n</pre><p>\n  We can also define a function that finds the next tidy number greedily and use it. We present\n  such a function in the next subsection.\n</p>\n<h3>Large dataset: A binary search approach</h3>\n<p>\n  Our original problem is: given an integer <b>N</b>, find the largest Y &le;\n  <b>N</b> such that Y is a tidy number. Let's consider a related problem:\n  given an integer X, find the smallest integer Y &ge; X such that Y is a tidy\n  number. That problem turns out to have a significantly simpler solution.\n  Suppose that X is a sequence of digits X<sub>1</sub>, X<sub>2</sub>, ...,\n  X<sub>L</sub>, enumerated from most to least significant, as above. Then Y\n  can be formed by finding the first inversion in the sequence (i.e., the\n  minimum i such that X<sub>i</sub> &gt; X<sub>i+1</sub>) and creating a\n  new number that is X<sub>1</sub>, X<sub>2</sub>, ..., X<sub>i</sub> plus\n  enough additional copies of X<sub>i</sub> to make Y as long as X. For\n  example, if we start with the number 13254, then the first inversion is at\n  32, and we replace everything after the 3 with more 3s, forming 13333. If\n  there are no inversions, then X is already tidy and Y = X. This algorithm is\n  O(L) for an X of L digits.\n</p><p>\n  With this related problem solved, we can solve the original problem by\n  <a href=\"http://en.wikipedia.org/wiki/Binary_search_algorithm\">binary searching</a>\n  for the smallest range [X, <b>N</b>] such that the Y (as defined above) that\n  corresponds to X is not larger than <b>N</b>. This approach takes\n  O(log<sup>2</sup> <b>N</b>) time, because the binary search takes log\n  <b>N</b> steps, and each step requires running the O(L) greedy algorithm\n  above. As argued above, L can be bounded by log <b>N</b>. This approach is\n  less efficient than the greedy approach above, but it is still easily fast\n  enough to pass the Large dataset.\n</p>\n","id":"0000000000201878","statement":"<h3>Problem</h3>\n<p>\n  Tatiana likes to keep things tidy. Her toys are sorted from smallest to\n  largest, her pencils are sorted from shortest to longest and her computers\n  from oldest to newest. One day, when practicing her counting skills, she\n  noticed that some integers, when written in base 10 with no leading zeroes,\n  have their digits sorted in non-decreasing order. Some examples of this are 8,\n  123, 555, and 224488. She decided to call these numbers <i>tidy</i>. Numbers\n  that do not have this property, like 20, 321, 495 and 999990, are not tidy.\n</p><p>\n  She just finished counting <i>all</i> positive integers in ascending order from 1 to\n  <b>N</b>. What was the last tidy number she counted?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>. <b>T</b>\n  lines follow. Each line describes a test case with a single integer <b>N</b>,\n  the last number counted by Tatiana.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y</code>,\n  where <code>x</code> is the test case number (starting from 1)\n  and <code>y</code> is the last tidy number counted by Tatiana.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 20 seconds per test set.<br/>\nMemory limit: 1 GB.<br/>\n  1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test Set 1 - Visible)</h4>\n<p>\n  1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n<h4>Large dataset (Test Set 2 - Hidden)</h4>\n<p>\n  1 &le; <b>N</b> &le; 10<sup>18</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n132\n1000\n7\n111111111111111110\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 129\nCase #2: 999\nCase #3: 7\nCase #4: 99999999999999999\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  Note that the last sample case would not appear in the Small dataset.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Tidy Numbers","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Test set 1</h3>\n\n<p>\n  For test set 1, the limits are small enough that you can just simulate\n  the rules outlined in the statement. Most implementations of a simulation\n  will run in O(<b>N</b><b>K</b>) time and thus finish immediately, but even a\n  slow O(<b>N</b><sup>2</sup><b>K</b>) implementation like \"try every possible\n  stall for the next person, and for each empty stall run a loop for each side\n  to check for the closest neighbors\" will most likely finish in time.\n</p><p>\n  For test sets 2 and 3, however, something quadratic in the number of stalls\n  won't cut it, so we have to do better.\n</p>\n\n<h3>Test set 2</h3>\n\n<p>\n  The critical observation to jump from test set 1 to test set 2 is\n  that only the number of consecutive runs of empty stalls matters at any given\n  time. The next person always chooses the middle stall or the left of the two\n  middle stalls of a longest subsequence of consecutive empty stalls. Moreover,\n  the output format already hints at this: even if you were to choose the\n  rightmost of a set of two middle stalls, or a longest run of stalls other\n  than the leftmost one, the answer would not change. Thus, we can rewrite the\n  algorithm in this equivalent (for the required output) form:\n</p><ol>\n  <li>Find any longest subsequence of consecutive empty stalls.</li>\n  <li>Choose the middle or one of the two middle stalls.</li>\n</ol><p>\n  Notice that even though there are still ties to be broken, the output is\n  equivalent for all of them. Since the output is equivalent, so is the\n  multiset of lengths of consecutive runs of empty stalls left behind, so the\n  whole process only depends on that multiset. (As a reminder, a multiset is a\n  set in which the same element can appear more than once.) We can write an\n  optimized simulation that solves test set 2 following this pseudocode:\n</p><pre>\n  S = {<b>N</b>}  - This is a multiset!\n  repeat <b>K</b> times:\n    X = max(S)\n    X0 = ceil((X - 1) / 2)\n    X1 = floor((X - 1) / 2)\n    if this is the last step:\n      we are done; answer is X0 and X1\n    else:\n      remove one instance of X from S\n      insert X0 and X1 into S\n</pre><p>\n  If the operations over <code>S</code> are efficient, this will run in\n  quasilinear time. There are many data structures that support insertion,\n  finding the maximum, and removal of the maximum in logarithmic time,\n  including AVL trees, red-black trees, and heaps. Many languages have one such\n  structure in their standard libraries (e.g., the <code>multiset</code> or\n  <code>priority_queue</code> in C++, <code>TreeSet</code> in Java, and\n  <code>heapq</code> module in Python). Since we take O(log <b>K</b>) time for\n  each of K steps, the algorithm takes only O(<b>K</b> log <b>K</b>) time,\n  which is fast enough to solve test set 2. However, for test set 3, even\n  quasilinear time on K is not enough.\n</p>\n\n<h3>Test set 3</h3>\n\n<p>\n  The observation required to solve test set 3 is that we are simulating\n  similar steps over and over again. The first time a bathroom user arrives, we\n  partition <b>N</b> into ceil((<b>N</b> - 1) / 2) and\n  floor((<b>N</b> - 1) / 2), which means that numbers between\n  ceil((<b>N</b> - 1) / 2) and <b>N</b> will never appear in S. This hints at a\n  logarithmic number of simulation steps.\n</p><p>\n  Let's divide the work in stages. The first stage processes only <b>N</b>.\n  Then, stage <i>i</i>+1 processes all of the values spawned by stage <i>i</i>.\n  So, stage 2 processes up to 2 values: ceil((<i>i</i> - 1) / 2) and\n  floor((<i>i</i> - 1) / 2). What about the other stages? It is not hard to\n  prove by induction that they also process at most two consecutive values:\n  since stage i processes two consecutive values, they are either 2x and 2x+1 or\n  2x and 2x-1, for some x (that is, one even and one odd number). Thus, the spawned\n  values for stage i+1 can only be x and/or x-1.\n  Since the largest value in each stage is at most half the largest\n  value of the previous stage, there are a logarithmic number of stages. This all\n  means that there are at most O(log <b>N</b>) different values\n  that go into S at any point. Of course, some of them appear in S many, many\n  times. So, the optimization to get the running time low enough for test\n  set 3 is to process all repetitions of a given value at the same time,\n  since all of them yield the same X0 and X1 values. We can do that by using a\n  regular set with a separate count for the number of repetitions.\n</p><pre>\n  S = {<b>N</b>}  - This is a set, not a multiset!\n  C(N) = 1\n  P = 0\n  repeat:\n    X = max(S)\n    X0 = ceil((X - 1) / 2)\n    X1 = floor((X - 1) / 2)\n    P = P + C(X)\n    if P &ge; <b>K</b>:\n      we are done; the answer is X0 and X1.\n    else:\n      remove X from S\n      insert X0 and X1 into S\n      add C(X) to the counts of X0 and X1 in C\n</pre><p>\n  Once again, we have structures that implement all the required operations in\n  logarithmic time, yielding an O(log<sup>2</sup> <b>N</b>) running time\n  overall. In general, adding any good dictionary implementation to the\n  structure of choice from the test set 2 solution would work, either by\n  plugging the dictionary functionality into the structure (like\n  <code>map</code> in C++ or <code>TreeMap</code> in Java) or having a separate\n  hash-table for the dictionary (which is the easiest implementation in Python).\n</p><p>\n  Moreover, since we proved the population of S is at most 4 at any given time\n  (only values from two consecutive stages can coexist in S), any implementation\n  of set and dictionary will provide all operations in constant time, because the\n  size of the whole structure is bounded by a constant! This makes the overall\n  time complexity just O(log <b>N</b>).\n</p><p>\n  This was a nice problem to put experimentation to work if your intuition was not\n  enough. After solving test set 1, if you print the succession of values for a\n  fixed <b>N</b>, you may spot the pattern of few values occurring\n  in the set S, and from there, you can find the mathematical arguments to support\n  the needed generalization. In harder problems in later rounds, this can become an\n  even more important asset to tackle problems. As you can see in many parts of last\n  year's finals <a href=\"https://www.youtube.com/watch?v=4diQ6JXY4cI\">live stream</a>,\n  finalists use experimentation a lot to inspire themselves and/or validate their ideas\n  before committing to them.\n</p>\n","id":"0000000000201905","statement":"<h3>Problem</h3>\n<p>\n  A certain bathroom has <b>N</b> + 2 stalls in a single row; the stalls on the\n  left and right ends are permanently occupied by the bathroom guards. The\n  other <b>N</b> stalls are for users.\n</p><p>\n  Whenever someone enters the bathroom, they try to choose a stall that is as far\n  from other people as possible. To avoid confusion, they follow deterministic\n  rules: For each empty stall S, they compute two\n  values L<sub>S</sub> and R<sub>S</sub>, each of which is the number of empty\n  stalls between S and the closest occupied stall to the left or right,\n  respectively. Then they consider the set of stalls with the farthest closest\n  neighbor, that is, those S for which min(L<sub>S</sub>, R<sub>S</sub>) is\n  maximal. If there is only one such stall, they choose it; otherwise, they choose\n  the one among those where max(L<sub>S</sub>, R<sub>S</sub>) is maximal. If there\n  are still multiple tied stalls, they choose the leftmost stall among those.\n</p><p>\n  <b>K</b> people are about to enter the bathroom; each one will choose their\n  stall before the next arrives. Nobody will ever leave.\n</p><p>\n  When the last person chooses their stall S, what will the values of\n  max(L<sub>S</sub>, R<sub>S</sub>) and min(L<sub>S</sub>, R<sub>S</sub>)\n  be?\n</p>\n\n<h3>Input</h3>\n<p>\n  The first line of the input gives the number of test cases, <b>T</b>.\n  <b>T</b> lines follow. Each line describes a test case with two integers\n  <b>N</b> and <b>K</b>, as described above.\n</p>\n\n<h3>Output</h3>\n<p>\n  For each test case, output one line containing <code>Case #x: y z</code>,\n  where <code>x</code> is the test case number (starting from 1),\n  <code>y</code> is max(L<sub>S</sub>, R<sub>S</sub>), and <code>z</code>\n  is min(L<sub>S</sub>, R<sub>S</sub>) as calculated by the last person to\n  enter the bathroom for their chosen stall S.\n</p>\n\n<h3>Limits</h3>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>K</b> &le; <b>N</b>.<br/>\nTime limit: 60 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n</p>\n\n<h4>Small Dataset 1 (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 1000.<br/>\n</p>\n\n<h4>Small Dataset 2 (Test set 2 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 10<sup>6</sup>.<br/>\n</p>\n\n<h4>Large Dataset (Test set 3 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 10<sup>18</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">5\n4 2\n5 2\n6 2\n1000 1000\n1000 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1 0\nCase #2: 1 0\nCase #3: 1 1\nCase #4: 0 0\nCase #5: 500 499\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\n  In Sample Case #1, the first person occupies the leftmost of the middle two\n  stalls, leaving the following configuration (<code>O</code> stands for an\n  occupied stall and <code>.</code> for an empty one): <code>O.O..O</code>.\n  Then, the second and last person occupies the stall immediately to the right,\n  leaving 1 empty stall on one side and none on the other.\n</p><p>\n  In Sample Case #2, the first person occupies the middle stall, getting to\n  <code>O..O..O</code>. Then, the second and last person occupies the leftmost\n  stall.\n</p><p>\n  In Sample Case #3, the first person occupies the leftmost of the two middle\n  stalls, leaving <code>O..O...O</code>. The second person then occupies the\n  middle of the three consecutive empty stalls.\n</p><p>\n  In Sample Case #4, every stall is occupied at the end, no matter what the\n  stall choices are.\n</p><p>\n  In Sample Case #5, the first and only person chooses the leftmost middle\n  stall.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":5},{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Bathroom Stalls","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"00000000002017f7","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2017"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
