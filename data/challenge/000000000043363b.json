{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1408145700000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"000000000043363b","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\n<b>Gennady Korotkevich</b> is the 2014 Code Jam champion!\n</p>\n\n<p>\nThe <a href=\"https://www.youtube.com/watch?v=Y0YxYV6-9Bw\" target=\"_blank\">2014 Google Code Jam World Final</a> was hosted in Los Angeles, and our finalists this year came from all over the world: Belarus, Brazil, Bulgaria, China, Czech Republic, Poland, South Korea, Taiwan, Ukraine, and Russia. We had 26 finalists, including our defending champion Ivan Miatselski (<b>mystic</b>).\n</p>\n\n<p>\nThere were six problems, and it was extremely challenging to solve them all in the four hours the finalists had. To win the prestigious grand prize, the contestants had to be strategic in deciding which problems they were going to try.\n</p>\n\n<p>\nThere was a broad range of difficulty in this year’s problems. The small input of Problem B was the easiest, and 25 finalists solved it. Besides that, most finalists managed to solve Problem A and B, as well as the small inputs of Problems C, D, and E. The large inputs of Problems C and D were harder, but were still solved by more than 10 finalists. The large inputs of Problem E and F proved to be the hardest: only our champion solved E, and nobody solved F (though our runner-up came close).\n</p>\n\n<p>\nAt the end of the round, if we only counted the guaranteed points from small inputs, <b>hos.lyric</b>, <b>eatmore</b>, and <b>mystic</b> would make up the top 3. However, most of the points in a contest like this one come from submissions on large inputs, and <b>eatmore</b>, <b>mystic</b>, and <b>Gennady.Korotkevich</b> had the highest potential number of points. But as we discovered when we <a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ#t=21128\" target=\"_blank\">unveiled the results</a> of our testing in an increasingly tense room, not all of them got all the points they might have.\n</p>\n\n<p>\nThe final result: Third place went to China's Yuzhou Gu (<b>sevenkplus</b>), who beautifully solved all problems except for the large input of E, and Problem F. In second place was Russia's Evgeny Kapun (<b>eatmore</b>) whose final attack on the large input of F was not quite correct, but who solved F-small. The winner, with an almost perfect performance on all problems except F was Belarus’s Gennady Korotkevich (<b>Gennady.Korotkevich</b>). This was Gennady's first Code Jam final, but only because he was too young in previous years: he first would have qualified in 2010, at the age of 14. Gennady has earned the title of Code Jam Champion, receiving a prize of $15,000 and a guaranteed ticket to the finals to defend his title next year!\n</p>\n\n<p>\nYou can see who solved what, when, and how the other contestants fared on the full scoreboard.\n</p>\n\n<p>\nThis year, we did a <a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ#t=445\" target=\"_blank\">live broadcast</a> of the whole contest on YouTube, which you can watch if you have an unusually high level of passion for the subject. It also contains <a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ#t=18681\" target=\"_blank\">brief explanations of how to solve the problems</a> at the end, in case you're interested in hearing the solutions explained in a different way.\n</p>\n\n<p>\nThat's it for Google Code Jam 2014!  With a record-breaking number of participants and an exciting final, we look forward to seeing you all again soon!\n</p>\n\n\n<hr>\n\nCast\n\n<p>\nProblem A. Checkerboard Matrix written by David Arthur. Prepared by John Dethridge and Jonathan Paulson.\n</p>\n\n<p>\nProblem B. Power Swapper written by David Arthur. Prepared by Ahmed Aly and Mohammad Kotb.\n</p>\n\n<p>\nProblem C. Symmetric Trees written by Steve Thomas. Prepared by John Dethridge and Steve Thomas.\n</p>\n\n<p>\nProblem D. Paradox Sort written by David Arthur. Prepared by John Dethridge.\n</p>\n\n<p>\nProblem E. Allergy Testing written by Bartholomew Furrow. Prepared by Jonathan Paulson.\n</p>\n\n<p>\nProblem F. ARAM written and prepared by Bartholomew Furrow.\n</p>\n\n<p>\nContest analysis presented by Bartholomew Furrow, David Arthur, Denis Savenkov, Felix Halim, Igor Naverniouk, John Dethridge, Jonathan Paulson, Steve Thomas, Steven Zhang, Sumudu Fernando, Topraj Gurung, and Tsung-Hsien Lee.\n</p>\n\n<p>\nSolutions and other problem preparation by Ahmed Aly, Alex Fetisov, Bartholomew Furrow, David Arthur, Igor Naverniouk, John Dethridge, Jonathan Paulson, Mohammad Kotb, Petr Mitrichev, Steve Thomas, Sumudu Fernando, and Timothy Loh.\n</p>\n","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1408131300000,"tasks":[{"analysis":"<p>\n<a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ&t=319m50s\" target=\"_blank\">Video of Igor Naverniouk’s explanation.</a>\n</p>\n\n<p>\nGiven a vertex-colored tree, we want to know whether it is possible to draw the tree in a 2D plane with a line of symmetry (as defined in the problem statement).\n</p>\n\n<p>\nAn important question to ask is: how many vertices in the tree are located on the symmetry line? We can categorize the answer into two cases. The first is where there is no vertex on the symmetry line, and the second is where there are one or more vertices on the symmetry line. We will discuss each category in the following sections.\n</p>\n\n<h3>\nNo vertex on the symmetry line\n</h3>\n\n<p>\nThis is the easier case. Since the tree has at least one vertex, there must be a vertex <b>A</b> on the left of the symmetry line connected to another vertex <b>A’</b> on the right of the symmetry line. The rest of the vertices must belong to the subtree of A or to the subtree of A’. The only edge that crosses the line of symmetry is the edge connecting vertex A and A’. There cannot be any other edges that cross the line of symmetry (otherwise there would be a cycle). The last requirement is that subtree A and subtree A’ are isomorphic. We will elaborate later on how to check whether two subtrees are <a href=\"http://en.wikipedia.org/wiki/Graph_isomorphism\" target=\"_blank\">isomorphic</a>. The following figure illustrates this case:\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1LQTM4ypfdBmU6y-IUKKOxfJ7VT0AljSs5AVGoPM2MGJdRpxan62kZmc9TNODvglCjNViqZbkh/no_vertex.png\">\n\n<h3>\nOne or more vertices on the symmetry line\n</h3>\n\n<p>\nIn this case, we can pick a vertex <b>A</b> and put it on the symmetry line. Next, we look at the children of A. Each child represents a subtree. For each child (or subtree) of A we find another (different) child of A that is isomorphic to it. If found, we can put one child on the left side of the symmetry line and the other on the right side of the symmetry line. The root nodes of the subtrees that cannot be paired must be put on the symmetry line. Since there are only two available positions on the line (one is above A and the other is below A), the number of children that <b>cannot</b> be paired must be at most two. These (at most) two children are put on the symmetry line using the same technique described above, except that they can only have one unpaired child (since they have only one available position on the symmetry line). See the following illustration:\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1ELpUBE_bJl0FUxofmXJWa9iCOHWImy65y1KadYaV4zCydN_O-aPL08YYNIZk2GUwdBeZS2WV81TRW6QPBJuIqYyI/one_or_more_vertices.png\">\n\n<p>\nWe pair up all children of A that are isomorphic to each other (e.g., B and B’, C and C’ and so on) and put one of them on the left and the other on the right of the symmetry line. There can only be at most two remaining unpaired children (subtree X and subtree Y). We can recursively put X and Y on the symmetry line just above and below vertex A respectively. The subtree of X can only have at most one unpaired child since there is only one available position to put the unpaired child on the symmetry line (i.e., above X). Similarly with the subtree of Y.\n</p>\n\n<h3>\nHow to check whether two subtrees are isomorphic?\n</h3>\n\n<p>\nThe above placing strategies require a quick way of checking whether two subtrees are isomorphic. One way to do this is by encoding each subtree into a unique string representation and then checking whether the strings are equal. One way to encode a subtree into a string is by using a nested-parentheses encoding: starting from the root node of the subtree, construct a string that begins with “(“ followed by the color of the node, then a comma, followed by a sorted, comma-separated list of the encodings of its children (which are computed recursively in the same way), and finally followed by a “)”. For example if node X is the parent of node Y and node Y is the parent of node Z, then the encoding of the subtree X is “(X,(Y,(Z)))”. If node X is the parent of node Z and node Y, then the encoding of the subtree X is “(X,(Y),(Z))”. Note that the children encodings are sorted because we want two subtrees with identical children to produce the same string.\n</p>\n\n<p>\nHere is a sample implementation in Python 3:\n</p>\n<pre>\nimport sys\n\ndef encode_subtree(a, parent):\n  children = []\n  for b in con[a]:\n    if b != parent:\n      if con[a][b] == -1:\n        con[a][b] = encode_subtree(b, a)\n      children.append(con[a][b])\n\n  m = '(' + colors[a]\n  for c in sorted(children):\n    m += ',' + c\n  return m + ')'\n\n\ndef rec_symmetric(a, parent):\n  first_pair = {}\n  for b in con[a]:\n    if b != parent:\n      if con[a][b] in first_pair:\n        del first_pair[con[a][b]]\n      else:\n        first_pair[con[a][b]] = b\n\n  keys = list(first_pair.values())\n  if len(keys) == 0: return True\n\n  ok = rec_symmetric(keys[0], a)\n  if len(keys) == 1 or not ok: return ok\n\n  # Non-root is only allowed one unpaired branch.\n  if len(keys) &gt; 2 or parent != -1: return False\n\n  return rec_symmetric(keys[1], a)\n\n\ndef symmetric():\n  # No vertex in the middle line.\n  for a in range(N):\n    for b in con[a]:\n      if con[a][b] == con[b][a]:\n        return True\n\n  # Pick a vertex in the middle line.\n  for a in range(N):\n    if rec_symmetric(a, -1):\n      return True\n\n  return False\n\n\nsys.setrecursionlimit(100000)\nfor tc in range(int(input())):\n  colors = []\n  con = []\n\n  N = int(input())\n  for i in range(N):\n    colors.append(input())\n    con.append({})\n\n  for i in range(N - 1):\n    e = input().split()\n    a = int(e[0]) - 1\n    b = int(e[1]) - 1\n    con[a][b] = -1\n    con[b][a] = -1\n\n  for a in range(N):\n    encode_subtree(a, -1)\n\n  if symmetric():\n    print(\"Case #%d: SYMMETRIC\" % (tc + 1))\n  else:\n    print(\"Case #%d: NOT SYMMETRIC\" % (tc + 1))\n</pre>\n","id":"00000000004334f8","statement":"<h3>Problem</h3>\n<p>\nGiven a vertex-colored tree with N nodes, can it be drawn in a 2D plane with a line of symmetry?\n</p>\n<p>\nFormally, a tree is <i>line-symmetric</i> if each vertex can be assigned a location in the 2D plane such that:\n</p>\n<ul>\n<li>All locations are distinct.</li>\n<li>If vertex <b>v<sub>i</sub></b> has color <b>C</b> and coordinates (<b>x<sub>i</sub></b>, <b>y<sub>i</sub></b>), there must also be a vertex <b>v<sub>i</sub>'</b> of color <b>C</b> located at (-<b>x<sub>i</sub></b>, <b>y<sub>i</sub></b>) -- Note if <b>x<sub>i</sub></b> is 0, <b>v<sub>i</sub></b> and <b>v<sub>i</sub>'</b> are the same vertex.</li>\n<li>For each edge (<b>v<sub>i</sub></b>, <b>v<sub>j</sub></b>), there must also exist an edge (<b>v<sub>i</sub>'</b>, <b>v<sub>j</sub>'</b>).</li>\n<li>If edges were represented by straight lines between their end vertices, no two edges would share any points except where adjacent edges touch at their endpoints.</li>\n</ul>\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.\n<p>Each test case starts with a line containing a single integer <b>N</b>, the number of vertices in the tree.\n</p>\n<p>\n<b>N</b> lines then follow, each containing a single uppercase letter. The i-th line represents the color of the i-th node.\n</p> \n<p>\n<b>N</b>-1 lines then follow, each line containing two integers <b>i</b> and <b>j</b> (1 &le; <b>i</b> &lt; <b>j</b> &le; <b>N</b>). This denotes that the tree has an edge from the <b>i</b>-th vertex to the <b>j</b>-th vertex. The edges will describe a connected tree.\n</p>\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is \"SYMMETRIC\" if the tree is line-symmetric by the definition above or \"NOT SYMMETRIC\" if it isn't.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n2 &le; <b>N</b> &le; 12.\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n2 &le; <b>N</b> &le; 10000.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4\nR\nG\nB\nB\n1 2\n2 3\n2 4\n4\nR\nG\nB\nY\n1 2\n2 3\n2 4\n12\nY\nB\nY\nG\nR\nG\nY\nY\nB\nB\nB\nR\n1 3\n1 9\n1 10\n2 3\n3 7\n3 8\n3 11\n4 8\n5 7\n6 7\n8 12\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: SYMMETRIC\nCase #2: NOT SYMMETRIC\nCase #3: SYMMETRIC\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n<p>The first case can be drawn as follows:</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1Gi3WKQF6K4IQWATFxFvsXVqidFolO5TY3GSBPXqFcpZcbRiCl7L-cNY8VZh0gW3JsQHg/tree1.png\">\n<p>No arrangement of the second case has a line of symmetry:</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U2ComXz-2XxJZzTo254kImtqZNeglbAsPOE70C-2aTE7JtkqcC0vFUtdXJyLJffoSdZOwk/tree2.png\">\n<p>One way of drawing the third case with a symmetry line is as follows:</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0h94Wh13lkP9lzHeRBFAT9j46-vUVcGD_SZ5_rDJwP31g0a2OYFpvLh50eU3Ngql5ZsgM/tree3.png\">","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":18}],"title":"Symmetric Trees","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n<a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ&t=311m20s\" target=\"_blank\">Video of Igor Naverniouk’s explanation.</a>\n</p>\n\n<p>\nLet’s start by making some observations about a checkerboard matrix:\n<ul>\n<li>\nSince a matrix is of dimension 2*N by 2*N, each row and each column have the same number of 0s and 1s.\n</li>\n<li>\nCorners of a checkerboard matrix always have two 0s and two 1s, and if we take any submatrix with at least 2 rows and 2 columns (not necessarily square) there will be an even number of 0s and 1s in the corners.\n</li>\n</ul>\nHere is an example of a checkerboard matrix and two sample submatrices (shown with red borders), there are four 1s and no 0s in the corners of one of them and two 1s, two 0s in the other’s. It is easy to see that it is impossible to find any submatrix with at least 2 rows and 2 columns where the above property is false.\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1vcP8CbRZHiOc4QVjdoluenD0D9Ur2WQlAd8-G3cyoyZkpfWzaMBpqCWADpkMMRUNlVgKNqA/checker.png\">\n<p>\nNow, let’s analyze what happens when we swap 2 rows or 2 columns. Such an operation doesn’t change the number of 0s and 1s in a row or column, but more importantly corners of any submatrix will still have even number of 0s and 1s. Indeed, by swapping rows or columns we transform any submatrix with corners located on both of the swapped rows or columns and it will not change the numbers in the corners. This means that any matrix for which the above properties doesn’t hold cannot be transformed into a checkerboard matrix.\n</p>\n<p>\nLet’s take a matrix for which the above properties hold and consider a pair of rows (the same arguments hold for columns). We can show that all rows that start with 1 will actually be equal to each other and so will be all rows that start with 0 (let’s call these sets of rows A and B). Additionally, corresponding (same column) numbers of a type A and type B row will be different. Thus A rows will be the inverse of B rows. Let’s prove this by considering two rows of the same type. Let’s choose a submatrix with 2 corners fixed in the first column and the others in some other column. By definition of row types, we have 2 corners in the first column equal to each other, but then by the property of a checkerboard matrix we cannot have two different numbers in the other corners as we would get an odd number of 0s or 1s. Therefore, all numbers of same type rows (i.e. A or B) are the same. Analogously we can show that A rows and B rows are the inverse of each other. Since in a checkerboard matrix each row and column has the same number of 0s and 1s, the number of rows of each type is the same. The same arguments hold for columns.\n</p>\n<p>\nHere is an example of a matrix obtained by permutation of rows and columns of a checkerboard matrix, which demonstrates the facts we just proved:\n</p>\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3kKknaESAweosAtp6NNBFrswex7k6QDxlDylwRiDwlKyWaNFJDnadu20OZOAQK0uzqpwBqDdo/checker2.png\">\n<p>\nIn a checkerboard matrix, type A and type B rows (and columns) alternate. We note that transformations of rows and columns are independent and we can first find the optimal number of row swaps, then the optimal number of column swaps, and then sum these numbers. Let us denote a type A row (or column) as ‘A’, and a type B row (or column) as ‘B’. Therefore the problem generalizes to the following problem: Given a sequence of 'A' and 'B' characters where the number of ‘A’s is the same as the number of ‘B’s, swap pairs of elements to make the ‘A’s and ‘B’s alternate. We have 2 choices on which letter goes first, either ‘A’ or ‘B’. We can try both. Given the desired order is fixed we can take a pair of ‘A’ and ‘B’ that are in the wrong place and swap them and record the number of swaps.\n</p>\n\n<p>\nTo conclude, here is the algorithm for the whole problem:\n<ol>\n<li>\nStart by assigning the first row to type A\n</li>\n<li>\nGo over all rows and compare them element by element with the first row\n<ul>\n<li>\nif rows equal each other, they are of the same type\n</li>\n<li>\nif they are the inverse of each other, they are of type B\n</li>\n<li>\notherwise the given matrix cannot be transformed into a checkerboard matrix and we can output “IMPOSSIBLE”\n</li>\n</ul>\n</li>\n<li>\nCheck that the sets A and B have the same number of rows, otherwise output “IMPOSSIBLE”\n</li>\n<li>\nThe minimum number of row (similarly for column) swaps is equal to min(nswaps_A, nswaps_B) where nswaps_X is the number of wrong positions for type X if we assume that the first row is of type X. The number of wrong positions for type X is equal to the number of rows of type X that reside at even positions. Remember that type A and B must alternate.\n</li>\n<li>\nRepeat 1-4 for columns.\n</li>\n<li>\nOutput the sum of the answers for rows and columns.\n</li>\n</ol>\n</p>\n\n<p>\nSample implementation in Python 3:\n</p>\n\n<pre>\ndef count_swaps(pos):\n  nswaps = 0\n  for i in pos:\n    if i % 2 == 0:\n      nswaps = nswaps + 1\n  return nswaps\n\n\ndef inverse(A):\n  return [chr(ord('0') + ord('1') - ord(c)) for c in A]\n\n# min_swaps returns minimum swaps required to \n# form alternating rows. If B is an invalid matrix, \n# returns -1 to denote an impossible case.\ndef min_swaps(M, N):\n  # Step 1.\n  typeA = M[0]\n  typeB = inverse(typeA)\n\n  pos_A = []\n  pos_B = []\n  for i in range(2 * N):\n    # Step 2 a.\n    if M[i] == typeA:\n      pos_A.append(i)\n    # Step 2 b.\n    elif M[i] == typeB:\n      pos_B.append(i)\n    # Step 2 c.\n    else:\n      return -1\n  # Step 3.\n  if len(pos_A) != len(pos_B):\n    return -1\n\n  # Step 4.\n  return min(count_swaps(pos_A), count_swaps(pos_B))\n\n\ndef solve(M, N):\n  # Step 1-4.\n  row_swaps = min_swaps(M, N)\n  if row_swaps == -1:\n    return \"IMPOSSIBLE\"\n\n  Mt = [list(i) for i in zip(*M)]  # Transpose matrix M\n\n  # Step 5.\n  col_swaps = min_swaps(Mt, N)\n  if col_swaps == -1:\n    return \"IMPOSSIBLE\"\n\n  return row_swaps + col_swaps\n\n\nfor tc in range(int(input())):\n  N = int(input())\n  M = []\n  for i in range(2 * N):\n    M.append(list(input()))\n  print(\"Case #%d: %s\" % (tc + 1, solve(M, N)))\n</pre>","id":"0000000000433537","statement":"<h3>Problem</h3>\n<p>\nWhen she is bored, Mija sometimes likes to play a game with matrices. She tries to transform one matrix into another with the fewest moves. For Mija, one move is swapping any two rows of the matrix or any two columns of the matrix.\n\n<p>\nToday, Mija has a very special matrix <b>M</b>. <b>M</b> is a 2<b>N</b> by 2<b>N</b> matrix where every entry is either a 0 or a 1. Mija decides to try and transform <b>M</b> into a <i>checkerboard matrix</i> where the entries alternate between 0 and 1 along each row and column. Can you help Mija find the minimum number of moves to transform <b>M</b> into a <i>checkerboard matrix</i>?\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case starts with a line containing a single integer: <b>N</b>. The next 2<b>N</b> lines each contain 2<b>N</b> characters which are the rows of <b>M</b>; each character is a 0 or 1.\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the minimum number of row swaps and column swaps required to turn <b>M</b> into a <i>checkerboard matrix</i>. If it is impossible to turn <b>M</b> into a checkerboard matrix, y should be \"IMPOSSIBLE\".\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 10<sup>3</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1\n01\n10\n2\n1001\n0110\n0110\n1001\n1\n00\n00\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0\nCase #2: 2\nCase #3: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nIn the first sample case, <b>M</b> is already a <i>checkerboard matrix</i>.\n\n<p>\nIn the second sample case, Mija can turn <b>M</b> into a <i>checkerboard matrix</i> by swapping columns 1 and 2 and then swapping rows 1 and 2.\n\n<p>\nIn the third sample case, Mija can never turn <b>M</b> into a <i>checkerboard matrix</i>; it doesn't have enough 1s.","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":9}],"title":"Checkerboard Matrix","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n<a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ&t=324m22s\" target=\"_blank\">Video of Igor Naverniouk’s explanation.</a>\n</p>\n\n<p>\nWe can view the set of preferences as a directed graph.  We have a node in the graph for each candy, and if we prefer candy X over candy Y, then there is a directed edge from the node for X to the node for Y.\n</p>\n\n<p>\nWe first describe a procedure to determine if we can find any valid permutation, then we describe a process to find the lexicographically smallest permutation.\n</p>\n\n<h3>\nIs a permutation possible?\n</h3>\n\n<p>\nTo answer this question, we will use a depth-first search in the graph described above. We use A, the target candy, as the root of the search. A valid permutation exists if and only if we can visit <b>all</b> other candies from the root.  Otherwise, there is no valid permutation. Why is that?\n</p>\n<p>\nIf all the candies are reached in the DFS, then we have a directed tree rooted at A containing all the nodes.  Then we can generate a valid permutation by printing the nodes using a <a href=\"http://en.wikipedia.org/wiki/Tree_traversal#Post-order\" target=\"_blank\">post-order traversal</a> of the tree (i.e. each node is placed in post-order in the permutation order).\n</p>\n<p>\nIn that permutation, A is the last candy that Vlad will be offered, and Vlad will keep it. To see why this is true, consider the tree implied by the depth-first search. Let X be the candy Vlad is holding before receiving candy A. X must have been preferred to every candy between X and A in the post-order traversal. If X was not a child of A, then one of those candies must be X's parent in the tree, which Vlad would prefer over X. So X must be a child of candy A in the depth-first search, so he will prefer to keep A when offered it.\n</p>\n<p>\nWe demonstrate this with an example for the following test case:\n</p>\n\n<pre>\n4 1\n-YNY\nN-YN\nYN-N\nNYY-\n</pre>\n\n<p>\nThere are 4 candies, and the target candy is candy 1. The candy preferences are shown by directed edges in the figure below. The solid lines represent the tree the DFS found, while the dashed lines represent the edges that were not taken during the DFS.\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0gctuqlTARMlSKh6-_cNqrUdDS9hnaO4djEB_CJpImfxCn6txU4pVQBIy1NmcHkk02Y2RUut0/paradox1.png\"><br>\n\n\n<p>\nIn the post-order traversal, we get the permutation (ordering) 3, 2, 4, 1, which is a valid permutation that leads to our target candy 1 being chosen in the end.\n</p>\n\n<p>\nNow we show that if there is a candy that we do not visit in the DFS, then there is no valid permutation. Let X be a candy that is not reached. Let Y be the candy that Vlad keeps after receiving candy X. Y is either X, or another candy which Vlad prefers to X, in which case there is a directed edge in the graph from Y to X. Y is not A, because there cannot be an edge from A to X, or X would have been visited in the depth-first traversal. Consider the list of unique candies that Vlad chooses to keep, in order of time. Assume that Vlad will end up with candy A. The list of kept candies must then end in A, and contain Y earlier in the list. In the sublist of candies between Y and A, Vlad prefers each candy to the one before it.  But this means there must be a directed path in the graph from A to X, which is impossible because X was not visited in the DFS. So Vlad cannot end up with candy A.\n</p>\n<p>\nThus by using the depth-first traversal procedure, we can answer if the given input can form a valid permutation.\n</p>\n\n<p>\nIn the following sections, we describe the procedure to generate the lexicographically-smallest permutation.\n</p>\n\n<h3>\nChecking for valid partial solutions\n</h3>\n\n<p>\nWe will use a greedy strategy to find the lexicographically-smallest permutation. To help us with the greedy strategy, we discuss the case of a partial solution. We want to answer if we can generate a valid permutation from this partial list. In the partial list, the first few numbers (candies) of the lexicographically-smallest permutation have been selected, and one of those candies is the current “best” (preferred) candy B (which might be equal to A). We modify our graph by removing all the numbers (except B) that are already selected in the permutation.\n</p>\n\n<p>\nThe goal is to answer if we can end up with A from the current partial solution. Trivially, if A is part of the set of removed numbers then it is impossible to generate a valid permutation (we can never end up with A from this state). But if A is not part of the removed set then there are two cases to consider: (i) B is <b>equal</b> to A, or (ii) B is <b>not equal</b> to A. If it is case (i), then A <b>must</b> be preferred over all remaining candies for us to end up with A, otherwise we can report that we cannot generate a valid permutation from this partial solution. Now, let us deal with the more complicated case (ii).\n</p>\n\n<p>\nFirst note that we cannot just use the idea proposed in the section “Is a permutation possible?”, i.e. pick A as the root, then do post-order depth-first traversal on the remaining nodes. The depth-first search might contain a path as follows: A-&gt;..-&gt;B-&gt;Y-&gt;Z (see figure below).  Then we can't use the post-order traversal, because B is already being held by Vlad, so Y and Z can't occur before it.\n</p>\n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U21dmgEX4gxC984yL__gpsx4pjPsPcY8NUh0lAytypA3R0ATYDg16LiQIjTQRDkDrFQy6F4954/paradox2.png\"><br>\n\n<p>\nInstead, we follow the following procedure:\n<ol>\n<li>\nDo the same depth-first search, but when visiting B, do not follow any edges out of B.\n</li>\n<li>\nThen, for each node X which was not visited by the DFS, and for which there is an edge from B to X, add X as a child of B.\n</li>\n</ol>\n</p>\n\n<p>\nIf this succeeds in adding every node to the tree, then it is possible to complete the permutation, otherwise it is not.\n</p>\n\n<p>\nTo construct the remainder of a permutation from this tree, we first append to the partial solution all the children of B that were added in step 2.  Vlad prefers B to each of these.  Then we remove B and its children from the tree, and append a post-order traversal of the remaining tree.  This results in A winning, for the same reasons as for the algorithm in the previous section for determining feasibility of the whole permutation.\n</p>\n\n</p>\nAlso similarly to the previous section, we can show that if there is a node X which is not added to the tree by the above procedure, then Vlad cannot be left with A, or else there would be a path from A to X that would have allowed X to be added to the tree.\n</p>\n\n<h3>\nFinding the lexicographically-smallest permutation\n</h3>\n\n<p>\nWe described above a method to determine if we can generate a valid permutation from a given partial solution.\nUsing this idea, we give an algorithm that provides us with the lexicographically-smallest permutation.\n</p>\n\n<p>\nWe start with an empty prefix of the permutation, then iteratively add the lexicographically smallest candy that leads to a valid prefix.\nIt reports a partial solution as impossible if no candy can be added to the partial solution leading to a valid solution. This algorithm is outlined in the pseudocode below:\n</p>\n\n<pre>\nLet P = []  // The partial solution\n\nIf !IsValidPartialSolution(P)\n  return IMPOSSIBLE\n\nRepeat N times\n  For i = 1 to N\n    // Test if appending i to P gives a valid partial solution\n    If P.contains(i) is false\n      If IsValidPartialSolution(P + [i]) is true\n        P = P + [i]\n        Break\n\nReturn P\n</pre>\n\n<p>\nSample implementation in Python 3:\n</p>\n\n<pre>\ndef dfs(i, removed, visited):\n  visited.add(i)\n  for j in range(len(prefer[i])):\n    if prefer[i][j] == 'Y':\n      if j not in visited and j not in removed:\n        dfs(j, removed, visited)\n\n\ndef valid(partial):\n  B = partial[0]\n  for i in partial:\n    if prefer[i][B] == 'Y':\n      B = i\n\n  removed = set(partial)\n  removed.remove(B)\n\n  # Trivial case.\n  if A in removed: return False\n\n  # Case (i)\n  if A == B:\n    for i in range(N):\n      if i != A and i not in removed:\n        if prefer[A][i] != 'Y':\n          return False\n    return True\n\n  # Case (ii)\n  visited = set([B])\n  dfs(A, removed, visited)\n  for i in range(len(prefer[B])):\n    if prefer[B][i] == 'Y':\n      visited.add(i)\n  return len(visited.union(removed)) == N\n\n\ndef solve():\n  visited = set()\n  dfs(A, set(), visited)\n  if len(visited) != N: return \"IMPOSSIBLE\"\n\n  partial = []\n  for i in range(N):\n    for j in range(N):\n      if j not in partial and valid(partial + [j]):\n        partial = partial + [j]\n        break\n  return ' '.join(map(str, partial))\n\n\nfor tc in range(int(input())):\n  [N, A] = map(int, input().split())\n  prefer = []\n  for i in range(N):\n    prefer.append(input())\n  print(\"Case #%d: %s\" % (tc + 1, solve()))\n</pre>\n","id":"0000000000433720","statement":"<h3>Problem</h3>\n\n<p>\nVlad likes candies.  You have a bag of different candies, and you're going to let Vlad keep one of them.  You choose an order for the candies, then give them to Vlad one at a time.  For each candy Vlad receives (after the first one), he compares the candy he had to the one he was just given, keeps the one he likes more, and throws the other one away.\n</p>\n\n<p>\nYou would expect that for any order you choose, Vlad will always end up with his favorite candy.  But this is not the case!  He does not necessarily have a favorite candy.  We know for any pair of candies which one he will prefer, but his choices do not necessarily correspond to a simple ranking.  He may choose Orange when offered Orange and Lemon, Banana when offered Orange and Banana, and Lemon when offered Lemon and Banana!\n</p>\n\n<p>\nThere is a particular candy you want Vlad to end up with.  Given Vlad's preferences for each pair of candies, determine if there is an ordering such that Vlad will end up with the right candy.  If there is, find the lexicographically-smallest such ordering.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case will start with a line containing the integers <b>N</b> and <b>A</b>, separated by a space.  <b>N</b> is the number of candies, and <b>A</b> is the number of the candy we want Vlad to finish with.  The candies are numbered from 0 to <b>N</b>-1. The next <b>N</b> lines each contains <b>N</b> characters.  Character j of line i will be 'Y' if Vlad prefers candy i to candy j, 'N' if Vlad prefers candy j to candy i, and '-' if i = j. Note that if i &ne; j, the jth character of the ith row must be different from the ith character of the jth row.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case output \"Case #x: \", where x is the case number, followed by either \"IMPOSSIBLE\" or a space-separated list of the lexicographically-smallest ordering of candies that leaves Vlad with <b>A</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 10.\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 100.\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 0\n-Y\nN-\n2 0\n-N\nY-\n4 3\n-YNN\nN-YY\nYN-Y\nYNN-\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 1\nCase #2: IMPOSSIBLE\nCase #3: 1 2 0 3\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":28}],"title":"Paradox Sort","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ&t=330m0s\" target=\"_blank\">Video of Bartholomew Furrow’s explanation.</a>\n\n<p>We describe two solution strategies. First a dynamic programming solution, then a more direct combinatorial solution.\n\n<h2>Dynamic programming on the number of foods</h2>\n\n<p>At a glance, this sounds like a standard dynamic programming problem where we compute the minimum number of days needed to identify the bad food among the N foods. We can split the N foods into two groups, perform an experiment on one of the groups (i.e., eat all the foods in the first group) and wait for the outcome. If Kelly gets an allergic reaction, then the bad food is in the first group, otherwise it’s in the second group. The number of days needed then depends on the number of days it takes to solve each of the smaller sets.\n\n<p>We can try all possible split sizes for the first group, which gives an O(N^2) solution. We can improve this to O(N) by noticing that the optimal split size for N is always at least as large as the optimal split size for N-1.  So we only need to consider split sizes starting at the previous split size, and in total only O(N) split positions are considered. Looking at the constraints for the small input, where N can be as large as 10^15, it is obvious that this is not the way to go. However, this approach may give some insight on how to improve the solution (as we shall see in the next section).\n\n<p>You may wonder why splitting the N foods equally and performing experiments on one of the groups does not give an optimal answer. Consider an example where A = 1, B = 100, and N = 4. In this case, the cost of having an allergic reaction is very high. It is better to perform an experiment one food at a time because as soon as Kelly eats the bad food, she will know about it the next day and thus the whole process only takes at most 3 days. But if she splits into two groups of size 2 and performs an experiment on one of the groups, she risks getting an allergic reaction and still being unable to identify the bad food and will have to wait 100 days for the next experiment. Therefore splitting the N foods equally may not lead to an optimal solution.\n\n\n<h2>Dynamic programming on the number of days</h2>\n\n<p>After playing around with some small cases where A and B are at most 100, you will discover that the minimum number of days needed is only in the range of thousands, even for large N. This gives a hint that using the number of days as the DP state could be much more efficient. We can use DP to compute max_foods(D), the maximum number of foods for which Kelly can identify the bad food using at most D days. If we can compute max_foods(D) quickly, we can compute the final answer by finding the smallest X where max_foods(X) &gt;= N.\n\n<p>To compute max_foods(D), we are going to construct a full binary tree that represents a strategy that handles the largest possible number of foods in at most D time.\nEach node in the tree corresponds to a set of foods.\nKelly starts at the root node, and performs a series of tests.\nEach test narrows down the set of foods, and she moves to the node corresponding to that set.\nTo do this, she eats all the foods in the right child of the current node.  If she does not get a reaction, she moves to the left child.  If she does get a reaction, she moves to the right child.\nLeaf nodes of the tree correspond to single foods.  When Kelly reaches a leaf node, she has figured out the food to which she is allergic, and can stop.\n\n<p>Define the \"height\" of a node to be the number of days remaining at that node.\nThe root node has height D, and each other node must have height at least 0.\nIf a node has height X, then its left child has height X-A, since it takes A days until Kelly knows she has not had a reaction.  Its right child has height X-A if it is a leaf, and X-B otherwise.  This is because Kelly only has to wait B days if she needs to perform another test when the reaction has worn off.\n\n<p>Define the \"value\" of a node to be the size of the set of foods to which that node corresponds.\n\n<p>Let’s look at an example of a node with height = D and value = max_foods(D) = max_foods(D-A) + max_foods(D-B):\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3kjke3UIJc30ARxNUU0w-1EY2eAy2nOPVxWx-Ato1yeK2-k9eNWCqi8JDKW3nVRHZtO6zx/branch.png\">\n\n<p>The height of the left child is D - A days, and it has value max_foods(D - A). The height of the right child is D - B days, and it has value max_foods(D - B). This means that if Kelly has a budget of D days and max_foods(D - A) + max_foods(D - B) foods to be processed, she can divide the foods into two groups: the first group is of size max_foods(D - A) foods and the second group is of size max_foods(D - B) foods.\n\n<p>If the tree corresponds to a strategy for handling max_foods(D) foods, then each subtree must contain as many nodes as possible given the time constraints, otherwise we could produce a better strategy by changing that subtree.\n\n<p>So if more than one food can be handled at a node A, then its value must be max_foods(height(A)).\n\n<p>The situation for leaf nodes, where only one food can be handled, is more complex.  If the node is the left child of its parent, then its height must be less than A, otherwise we could handle at least two foods there instead.  If the node is the right child of its parent, then its height must only be less than B.  This is because if another food is added, then Kelly must wait B days after the previous test instead of A days.\n\n<p>Let’s see an example where we want to compute max_foods(8) where A = 2 and B = 3. We can construct the following full binary tree:\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U3SlRdsq3pYyVDjEUPfbpZLuH1OKvvRpaDhbU4gPSxO1qyWGw9j4cdRHTA-8BU9eZal7Q/tree.png\">\n\n<p>The root node has height = 8 days. Using the rules described above, we can continue traversing the children until we reach the leaf nodes. Going up from the leaf nodes all the way to the root, we can compute the value of the intermediate nodes by summing the value of their two children. From the figure above, we can figure out that max_foods(8) = 9, and similarly max_foods(6) = 5, max_foods(5) = 4, etc.\n\n<p>Nodes with the same height always have the same value (except for the case of leaves which are right children.)\n\n<p>Thus, we can use memoization to do the computation in O(days needed). Here is a sample implementation in Python 3:\n\n<pre>from functools import lru_cache\n\n@lru_cache(maxsize = None)  # Memoization.\ndef max_foods(D, A, B):\n  if D &lt; A: return 1  # Leaf node.\n  return max_foods(D - A, A, B) + max_foods(D - B, A, B)\n\n# We can also use binary search here.\ndef min_days(N, A, B):\n  days = 0\n  while max_foods(days, A, B) &lt; N:\n    days = days + 1\n  return days\n\nfor tc in range(int(input())):\n  print(\"Case #%d: %d\" % (tc+1, \\\n    min_days(*map(int, input().split()))))</pre>\n\n<p>The above solution assumes that the answer (i.e., the number of days) is limited to a few thousand days, which is true for the small input cases where A and B is at most 100. For the large input cases, A and B can be up to 10^12 which makes the above solution infeasible.\n\n\n<h2>Dynamic programming on the number of edges of each type</h2>\n\n<p>Observe that for large A and B, the set of days D where max_foods(D) is larger than max_foods(D-1) is sparse.\nEach edge reduces the remaining time by either A or B.  Call these A-edges and B-edges.\nSince the height of a node depends only on the number of A-edges and B-edges on its path to the root, we can use a more “compact” DP state to compute max_foods(D) by using the number of A-edges and B-edges instead of using the height as shown in the sample implementation in Python 3 below:\n\n<pre>INF = 1e16\n\ndef max_foods(D, A, B):\n  ans = 0\n  mem = [0] * 60  # zero-array of 60 elements.\n  mem[0] = 1\n  for i in range(int(D / A + 1)):  # A-edges.\n    for j in range(int(D / B + 1)):  # B-edges.\n      H = i * A + j * B  # Height of this node.\n\n      # Skip this node if it uses more than D days.\n      if H &gt; D: break\n\n      # Aggregate the child’s value.\n      if j &gt; 0 and H + A &lt;= D: mem[j] += mem[j-1]\n\n      # if we are too close to D to add a B-edge,\n      # the right child is a leaf,\n      # so add this node to the answer.\n      if H + B + A &gt; D: ans += mem[j]\n\n      # Avoid overflows.\n      ans = min(ans, INF)\n      mem[j] = min(mem[j], INF)\n\n  return ans</pre>\n\n<p>Notice that the above code reuses the DP array as it iterates through the A-edges, and the number of B-edges is limited to &lt; 60, so the memory footprint is very small. However, this approach does not work when the number of A-edges is very large. This number can be as large as 50 * B / A, so whether this solution works depends closely on the ratio B / A. In the next two sections we provide two solutions to address this issue.\n\n\n<h3>Solution 1: Use a closed-form solution for #B-edges &lt;= 2.</h3>\n\n<p>Observe that as the ratio B / A gets large, the number of B-edges in the solution ends up being very small and the number of A-edges ends up being very large (which makes the dynamic programming solution above run very slow). In fact, if B / A &gt; N, then the solution will involve no B-edges at all. This corresponds to a strategy of trying the foods one at a time until you find the correct one. It is possible to derive closed forms to compute max_foods(D) if there are at most 0, 1 and 2 B-edges in the solution, corresponding to tree heights &lt;B+A, &lt;2B+A and &lt;3B+A respectively. For a ratio B / A greater than 200,000, the maximum tree height is less than 3B+A and so we can get the solution from one of these closed forms. If the ratio is less than 200,000, we can fall back to our dynamic programming solution.\n\n<p>Below is the sample implementation in Python 3 of the closed form solutions for computing max_foods(D) where there are at most 0 (linear), 1 (quadratic), or 2 (cubic) B-edges:\n\n<pre>def linear(D, A, B):\n  return int(D / A + 1)\n\ndef quadratic(D, A, B):\n  R = int((D - B) / A)\n  if INF / R &lt; R: return INF\n  return int(linear(D, A, B) + (R * (R + 1)) / 2)\n\ndef cubic(D, A, B):\n  ans = quadratic(D, A, B)\n  a = int((D - 2 * B) / A)\n  for i in range(a):\n    R = a - i\n    if INF / R &lt; R: return INF\n    ans += int((R * (R + 1)) / 2)\n    if ans &gt; INF: return INF\n  return ans</pre>\n\n<p>To put it all together, we can determine which closed form solution to use, or use the compact dynamic programming as the fallback and then use binary search to find the minimum days needed. Here is the rest of the code:\n\n<pre>def binary_search(N, A, B, low, high, func):\n  while high - low &gt; 1:\n    D = int((high + low) / 2)\n    if func(D, A, B) &gt;= N:\n      high = D\n    else:\n      low = D\n  return high\n\ndef min_days(N, A, B):\n  if quadratic(B + A, A, B) &gt;= N:\n    return binary_search(N, A, B, -1, B + A, linear)\n  if cubic(2 * B + A, A, B) &gt;= N:\n    return binary_search(N, A, B, B + A, 2 * B + A, quadratic)\n  if cubic(3 * B + A, A, B) + 1 &gt;= N:\n    return binary_search(N, A, B, 2 * B + A, 3 * B + A, cubic)\n  return binary_search(N, A, B, 3 * B + A, 51 * B, max_foods)\n\nfor tc in range(int(input())):\n  print(\"Case #%d: %d\" % (tc+1, \\\n    min_days(*map(int, input().split()))))</pre>\n\n\n<h3>Solution 2: Speed up the dynamic programming solution through fast matrix exponentiation</h3>\n\n<p>There is another way to handle very large number of A-edges without using closed form formulae. Observe that in the dynamic programming solution code, the mem vector at stage i+1 is a linear sum of itself at stage i, so we can represent the transition as a matrix-vector multiplication, implementing the answer as an accumulator parameter in the vector. We can therefore accelerate the process using fast matrix exponentiation.\n\n<p>There is a slight complication in that the matrix is not the same for all i. If p_j is the smallest index j for which H + A &gt; D, then the matrix describing the state transition remains constant as long as p_j doesn't change. However, we can see from the structure that p_j is monotonically decreasing with increasing i and it can therefore only take 50 different values at most. We can therefore break up the computation into at most 50 ranges of continuous p_j and perform our matrix exponentiation to get the answer to each of them.\n\n<p>The complexity of this method could be as high as log^6 N, from factors log N for the binary search, log N ranges of p_j, matrix multiplications of log^3 N and log N for the fast exponentiation. However, not all of these parameters can be large simultaneously and it's likely that the actual time bound is somewhat tighter than this coarse estimate.\n\n\n<h2>Combinatorial solution</h2>\n\n<p>We can compute max_foods(T) more directly, and then do a binary search to find the minimum T such that max_foods(T) &gt;= N.\n\n<p>For each leaf, we write down a string of 'x' and 'y' characters that indicates the path taken from the root to the leaf.  'x' indicates a left branch, and 'y' indicates a right branch.  For paths that end with a right branch, and have height &lt; B-A, remove the final 'y'.\n\n<p>Each leaf's string now consists of some unique arrangement of K 'x' characters and L 'y' characters, where T-B &lt; KA + LB &lt;= T. Also, each possible string of 'x' and 'y' characters satisfying the above constraint corresponds to a leaf in the tree. We can determine the number of leaves by counting the number of these strings. There are (K+L) choose L strings that contain 'x' K times and 'y' L times.  So, we have:\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1660xY7oKiYKiYpSiww9VdvZ-CdfGN4CKE8IVBnVZ8SpvMOYgLsv0cqif3VJLJzyUsMw/sum1.png\">\n\n<p>where T-B &lt; KA + LB &lt;= T\n\n<p>We can easily compute the minimum and maximum K such that T-B&lt; KA+LB &lt;= T for a given L.  So we can rewrite the sum above as:\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1zEvySxn-z8xb6PVul3h8ce9zvnjY0ovGIKD_LYHV0R-03KIItTXfqj-0Eb2yJUnmt1A/sum2.png\">\n\n<p>Which equals:\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U24YB_Xkmccc7eZ8Hl2DXwi4Mm6bJbLH1K5pH7rfmNxBf4WyTzKHOTWAnf8ye-mWcxuwA/sum3.png\">\n\n<p>Since the number of strings grows exponentially with L, the maximum L is O(log N), so we can compute this sum efficiently.\n\n<p>Below is a sample implementation in Python 3. Note that Python has a built in big integer, thus we don’t need to worry so much about overflow.\n\n<pre>def nCk(n, k):\n  if k &gt; n: return 0\n  res = 1\n  for i in range(1, min(n - k, k) + 1):\n    res = res * (n - i + 1) // i\n  return res\n\ndef max_foods(D, A, B):\n  cnt = 0\n  for L in range(min(51, D // B + 1)):\n    K_min = (D - L * B - B) // A + 1\n    K_max = (D - L * B) // A\n    cnt += nCk(K_max + L + 1, L + 1) - nCk(K_min + L, L + 1)\n  return cnt\n\ndef min_days(N, A, B):\n  lo = 0\n  hi = int(1e15)\n  while lo &lt; hi:\n    D = (lo + hi) // 2\n    if max_foods(D, A, B) &gt;= N:\n      hi = D\n    else:\n      lo = D + 1\n  return lo\n\nfor tc in range(int(input())):\n  print(\"Case #%d: %d\" % (tc+1, \\\n    min_days(*map(int, input().split()))))</pre>","id":"000000000043380f","statement":"<h3>Problem</h3>\n<p>\nKelly is allergic to exactly one of <b>N</b> foods, but she isn't sure which one.\nSo she decides to undergo some experiments to find out.\n\n<p>\nIn each experiment, Kelly picks several foods and eats them all.\nShe waits <b>A</b> days to see if she gets any allergic reactions.\nIf she doesn't, she knows she isn't allergic to any of the foods she ate.\nIf she does get a reaction, she has to wait for it to go away:\nthis takes a total of <b>B</b> days (measured from the moment when she ate the foods).\n\n<p>\nTo simplify her experimentation, Kelly decides to wait until each experiment is finished (after <b>A</b> or <b>B</b> days) before starting the next one.\nAt the start of each experiment, she can choose the set of foods she wants to eat based on the results of previous experiments.\n\n<p>\nKelly chooses what foods to eat for each experiment\nto minimize the worst-case number of days before she knows\nwhich of the <b>N</b> foods she is allergic to.\nHow long does it take her in the worst case?\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. Each test case on a single line, containing three space-separated integers: <b>N</b>, <b>A</b> and <b>B</b>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and <b>y</b> is the number of days it will take for Kelly to find out which food she is allergic to, in the worst case.\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 200.<br/>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 10<sup>15</sup>.<br/>\n1 &le; <b>A</b> &le; <b>B</b> &le; 100.\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 10<sup>15</sup>.<br/>\n1 &le; <b>A</b> &le; <b>B</b> &le; 10<sup>12</sup>.\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n4 5 7\n8 1 1\n1 23 32\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 12\nCase #2: 3\nCase #3: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\nIn the first sample case:\n<ul>\n<li>First, Kelly eats foods #1 and #2.\n<li>If she gets no reaction after 5 days, she eats food #3.\n5 days after <i>that</i>, she will know whether she is allergic to food #3 or food #4.\n<li>If she does get a reaction to the first experiment, then 7 days after the first experiment, she eats food #1.  5 days after that, she will know whether she is allergic to food #1 or food #2.\n</ul>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":15},{"type":2,"type__str":"HIDDEN","value":35}],"title":"Allergy Testing","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\n<a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ&t=315m15s\" target=\"_blank\">Video of Bartholomew Furrow’s explanation.</a>\n</p>\n<p>\nObserve that a swap operation of size 2^x can be performed independently from a swap operation of size 2^y. Thus, we can simplify the sorting process by performing the swaps from the smallest size to the largest size and assume that when performing a swap of size 2^z, the adjacent numbers inside it are <b>fully</b> sorted (by the previous, smaller sized swaps). <b>Fully</b> sorted here means the adjacent numbers are increasing consecutively (i.e., each number is bigger than the previous by 1).\n</p>\n\n<p>\nLet’s look at the possible swappings for the smallest 2^k size element where k = 0 (i.e., swapping two sets of size 1). There are 2^N valid sets of size 1. However, we are only interested in swapping two valid sets such that all 2^(k+1) sized valid sets are fully sorted. This is important because when swapping larger sizes, we assume the smaller sized valid sets are all already fully sorted. Let’s look at some examples:\n<ul>\n<li>\nPermutation: 2 4 1 3. The only way is to swap 2 with 3, yielding 3 4 1 2 where all 2^1 sized valid sets are fully sorted.\n</li>\n<li>\nPermutation: 1 4 3 2. There are two ways to perform a swap so that all 2^1 sized valid sets are fully sorted. The first is by swapping 1 with 3 and the other is by swapping 4 with 2.\n</li>\n<li>\nPermutation: 1 4 3 2 6 5. In this case, there are 3 valid sets of size 2^1. It needs at least two swaps to make all 2^1 sized valid sets fully sorted. Thus, it is impossible to sort this permutation.\n</li>\n</ul>\n</p>\n<p>\nLearning from the examples above, it is sufficient to only consider swapping at most two valid sets of size 2^k for k = 0. We can generalize this for larger k, assuming all valid sets of smaller size are already fully sorted.\n</p>\n<p>\nTo count the number of ways to sort, we can use recursion (backtracking) to simulate all possible swaps. The recursion state contains the underlying array, the value k, and the number of swaps performed so far. The recursion starts from the smallest sized swaps (k = 0) with the original input array, then it decides which valid sets to swap (if any) and recurses to the larger (k + 1) swaps, and so on until it reaches the largest sized swaps (k = N). The depth of the recursion is at most N and there are at most two branches per recursion state (since there are at most two possible swaps for each size) and each state needs O(2^N) to gather at most two valid candidate sets to be swapped. Thus, the algorithm runs in O(2^(N*2)). When the recursion reaches depth N, it has the number of swaps that have been done so far. Since the ordering of the swaps matters, the number of ways is equal to the factorial of the number of swaps. We propagate the number of ways back up to the root to get the final value. Below is a sample implementation in Python 3:\n</p>\n<pre>\nimport math\n\ndef swap(arr, i, j, sz):  # Swap two sets.\n  for k in range(sz):\n    t = arr[i + k]\n    arr[i + k] = arr[j + k]\n    arr[j + k] = t\n\ndef count(arr, N, k, nswapped):\n  if k == N:\n    return math.factorial(nswapped)\n\n  i = 0\n  idx = []  # Candidates’ index for swappings.\n  sz = 2**k\n  while i &lt; 2**N:\n    if arr[i] + sz != arr[i + sz]:\n      idx.append(i)\n    i = i + sz * 2\n\n  ret = 0\n  if len(idx) == 0:  # No swap needed.\n    ret = count(arr, N, k + 1, nswapped)\n\n  elif len(idx) == 1:  # Only one choice to swap.\n    swap(arr, idx[0], idx[0] + sz, sz)\n    if arr[idx[0]] + sz == arr[idx[0] + sz]:\n      ret = count(arr, N, k + 1, nswapped + 1)\n    swap(arr, idx[0], idx[0] + sz, sz)\n\n  elif len(idx) == 2:  # At most 2 choices.\n    for i in [idx[0], idx[0] + sz]:\n      for j in [idx[1], idx[1] + sz]:\n        swap(arr, i, j, sz)\n        if arr[idx[0]] + sz == arr[idx[0] + sz]:\n          if arr[idx[1]] + sz == arr[idx[1] + sz]:\n            ret = ret + count(arr, N, k + 1, nswapped + 1)\n        swap(arr, i, j, sz)\n\n  return ret\n\n\nfor tc in range(int(input())):\n  N = int(input())\n  arr = list(map(int, input().split()))\n  print(\"Case #%d: %d\" % (tc+1, count(arr, N, 0, 0)))\n</pre>","id":"00000000004339f3","statement":"<h3>Problem</h3>\n<p>\nIn a parallel universe, people are crazy about using numbers that are powers of two, and they have defined an exciting sorting strategy for permutations of the numbers from 1 to 2<sup><b>N</b></sup>. They have defined a swapping operation in the following way:\n<ul>\n<li>A range of numbers to be swapped is valid if and only if it is a range of adjacent numbers of size 2<sup>k</sup>, and its starting position (position of the first element in the range) is a multiple of 2<sup>k</sup> (where positions are 0-indexed).</li>\n<li>A valid swap operation of <i>size-k</i> is defined by swapping two distinct, valid ranges of numbers, each of size 2<sup>k</sup>.</li>\n</ul>\n</p>\n\n<p>\nTo sort the given permutation, you are allowed to use at most one swap operation of each size k, for k in [0, <b>N</b>). Also, note that swapping a range with itself is not allowed.\n</p>\n\n<p>\nFor example, given the permutation [3, 6, 1, 2, 7, 8, 5, 4] (a permutation of the numbers from 1 to 2<sup>3</sup>), the permutation can be sorted as follows:\n<ul>\n<li>[3, 6, 1, 2, 7, 8, 5, 4]: make a <i>size-2</i> swap of the ranges [3, 6, 1, 2] and [7, 8, 5, 4].</li>\n<li>[7, 8, 5, 4, 3, 6, 1, 2]: make a <i>size-0</i> swap of [5] and [3].</li>\n<li>[7, 8, 3, 4, 5, 6, 1, 2]: make a <i>size-1</i> swap of [7, 8] and [1, 2].</li>\n<li>[1, 2, 3, 4, 5, 6, 7, 8]: done.</li>\n</ul>\nThe previous steps used every swap size (0, 1, and 2) at most once. Also, notice that all the swaps were valid because both ranges for each size k started at indices that were multiples of 2<sup>k</sup>.\n</p>\n\n<p>\nCount how many ways there are to sort the given permutation by using the rules above. A way is an ordered sequence of swaps, and two ways are the same only if the sequences are identical.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow. The first line of each test case contains a single integer <b>N</b>. The following line contains <b>2<sup>N</sup></b> space-separated integers: a permutation of the numbers 1, 2, ..., 2<sup><b>N</b></sup>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the number of ways to sort the given permutation using the rules above.\n</p>\n\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 200.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 4.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 12.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n1\n2 1\n2\n1 4 3 2\n3\n7 8 5 6 1 2 4 3\n2\n4 3 2 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 3\nCase #3: 6\nCase #4: 0\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":4},{"type":2,"type__str":"HIDDEN","value":12}],"title":"Power Swapper","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<a href=\"https://www.youtube.com/watch?v=GYX3sn3Q_DQ&t=341m45s\" target=\"_blank\">Video of Bartholomew Furrow’s explanation.</a>\n\n<p>We are going to do a binary search to find the answer.  At each iteration of the binary search, we have some estimate of the answer Q, and we need to decide if that estimate is too high or too low.  We do this by trying to find a strategy that can achieve a fraction Q of wins in the long run.\n\n<p>We need to describe what a valid strategy is.  In a straightforward dynamic programming formulation of the problem, the current state would be the champion we have been assigned, the amount of money we have, and the number of games that remain; the decision we would need to make at each state is whether to reroll.\n\n<p>Obviously we cannot compute the decision for each of these states individually; there are O(10^100 * N * R * G) of them!  But since the number of games that will be played is immense, we can assume that the number of games remaining is unimportant, and just optimize assuming there are \"infinite\" games remaining.  It can be proved that the amount of error this will induce in the answer is far less than 10^-10, the required precision.  Also note that if we reroll when assigned a certain champion for a particular amount of money, then it also makes sense to reroll when assigned a champion with a lower winning probability, with the same amount of money.  So to compute a strategy, we we only need to decide for each amount of money, which hero we would reroll that has the highest winning probability.\n\n<p>But how do we evaluate how good a strategy is, when we're going to play infinite games?  When we are low on money, we need to be more conservative about when we reroll.  If we reroll too aggressively when we have very little money left and our amount of money drops below 1 dollar, we will not be able to reroll for a while and our expected number of wins will drop.  Intuitively what we need to determine is, if our money gets low, to say M dollars, how much will we fall behind our expected number of won games before our amount of money improves to M+1/G?\n\n<p>We define the \"surplus\" for a set of games as the number of games won in the set minus Q multiplied by the number of games played in the set.  We choose our strategy at M money to maximize the expected surplus of the set of games that occur until we reach M+1/G money.  (If M is equal to R, then our amount of money will not increase, so we use the set of games that lasts until we have M money again.)  Let this value be A[M].\n\n<p>If M&lt;1 then we cannot reroll, so\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U0SItEdAgVbt7G6nIcxZehSglIfidOsY9FrircokDdqxaXb53hsC8UA-Mw3qJL_hdF_BJ8/aram1.png\">\n\n<p>since the set will consist of exactly one game, and we get a random champion.\n\n<p>For 1 &lt;= M &lt; R, suppose that our strategy requires that we will reroll the worst K_M heroes.  Sort the values Pi.  Then:\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U03Jf7nVeW00m7iIzjXnlPgrDWQiDk-cLRujR9dX8bcyzl9ca066SFt3Ad5w4FEhXqe_xk/aram2.png\">\n\n<p>Similarly, for M=R:\n\n<p><img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1d1uzjt8JftTcqZVu_A0ms3MifG5UpFD_Z7-DsKpbi45S0sTKnDma_QL9PTvWT_Q3OZtw/aram3.png\">\n\n<p>We can compute the optimal values for A by optimizing for K_M separately for each M from 0 to R.  Note that A[M]&gt;=-1 for all M, since the strategy of never rerolling has a surplus no worse than -1, so the optimal strategy must be at least as good as that.\n\n<p>If A[R]&gt;=0, we decide that Q is too high.  If A[R]&lt;0, we decide that Q is too low.  We now show that this works.\n\n<p>We start with R money.  We will return to R money multiple times, with expected surplus A[R] each time, until finally we reach 10^100 games and stop.  Consider instead the scenario where once we reach 10^100 games, we keep playing until we reach R money again.  The expected surplus in this scenario is T*A[R], where T&gt;=1 is the expected number of times we return to R money.  Now, let X be the expected surplus of the games after the 10^100th.  From the definition of A, X=A[M] + A[M+1/G] + ... + A[R-1/G], where M is the amount of money we have after game 10^100.\n\n<p>Assume that A[M]&lt;0 for M&lt;R (if not, we can play as if R was equal to the lowest M such that A[M] &gt;= 0 and the proof will work).  Then -RG &lt;= X &lt; 0.\n\n<p>Now the surplus for the first 10^100 games is Y=T*A[R] - X.  Therefore T*A[R] &lt; Y &lt;= T*A[R] + RG.  \n\n<p>RG is insignificant over 10^100 games.  So the fraction of expected wins for this strategy is Q + T*A[R] * 10^-100.  So we assert that if A[R] &gt;= 0, then we can achieve a strategy which wins a fraction of at least Q, and otherwise we cannot.  This will allow our binary search to converge to a sufficiently accurate answer.\n\n<p>Below is a sample implementation in Python 3. To avoid fractional dollars, we introduce a smaller unit (e.g., a coin) C for the money where G coins is equal to one dollar.\n\n<pre># Can you win at least X fraction of the time?\ndef CanWin(X):\n  A = []\n  last_G_values = 0\n\n  # C &lt; G, not enough coins for a reroll.\n  for C in range(0, G):\n    A.append(avg_win_prob_top[N] - X)\n    last_G_values += A[C]\n\n  # C &gt;= G, enough coins for a reroll.\n  for C in range(G, R * G + 1):\n    A.append(-1e100)\n    for K in range(1, N + 1):\n      p = (N - K) / N  # Probability of rerolling.\n      p_reroll = p / (1 - p) * last_G_values\n      p_not_reroll = avg_win_prob_top[K] - X\n      A[C] = max(A[C], p_reroll + p_not_reroll)\n\n    if A[C] &gt;= 0: return True\n    last_G_values += A[C] - A[C - G]\n\n  return False\n\n\nfor tc in range(int(input())):\n  [N, R, G] = map(int, input().split())\n  win_prob = map(float, input().split())\n  win_prob = sorted(win_prob, reverse=True)\n\n  avg_win_prob_top = [0]\n  for topK in range(1, N + 1):\n    avg_win_prob_top.append(sum(win_prob[0:topK]) / topK)\n\n  lo = 0\n  hi = 1\n  for i in range(60):\n    mid = (lo + hi) / 2\n    if CanWin(mid):\n      lo = mid\n    else:\n      hi = mid\n\n  print(\"Case #%d: %.15f\" % (tc + 1, lo))</pre>\n\n\n<p>An alternative solution is to evaluate strategies by modelling the game as a Markov chain and computing its stationary distribution, then iteratively improving the strategy.  It is quite difficult to do this with sufficient accuracy.","id":"0000000000433a40","statement":"<h3>Problem</h3>\n<p>\nIn the game League of Legends&trade;, you can play a type of game called \"ARAM\", which is short for \"All Random, All Mid\". This problem uses a similar idea, but doesn't require you to have played League of Legends to understand it.\n</p>\n<p>\nEvery time you start playing an ARAM game, you're assigned one of <b>N</b> \"champions\", uniformly at random. You're more likely to win with some champions than with others, so if you get unlucky then you might wish you'd been given a different champion. Luckily for you, the game includes a \"Reroll\" function. \n</p>\n<p>\nRerolling randomly reassigns you a champion in a way that will be described below; but you can't reroll whenever you want to. \nThe ability to reroll works like a kind of money. Before you play your first ARAM game, you begin with <b>R</b> RD (\"reroll dollars\"). You can only reroll if you have at least 1 RD, and you must spend 1 RD to reroll. After every game, you gain 1/<b>G</b> RD (where <b>G</b> is an integer), but you can never have more than <b>R</b> RD: if you have <b>R</b> RD and then play a game, you'll still have <b>R</b> RD after that game.\n</p>\n<p>\nIf you have at least 1RD, and you choose to reroll, you will spend 1RD and be re-assigned one of the <b>N</b> champions, uniformly at random. There's some chance you might get the same champion you had at first. If you don't like the champion you rerolled, and you still have at least 1RD left, you can reroll again. As long as you have at least 1RD left, you can keep rerolling.\n</p>\n<p>\nFor example, if <b>R</b>=2 and <b>G</b>=2, and you use a reroll in your first game, then after your first game you will have 1.5 RD. If you play another game, this time without using a reroll, you will have 2.0 RD. If you play another game without using a reroll, you will still have 2.0 RD (because you can never have more than <b>R</b>=2). If you use two rerolls in your next game, then after that game you will have 0.5 RD.\n</p>\n<p>\nYou will be given the list of champions, and how likely you are to win a game if you play each of them. If you play 10<sup>100</sup> games and choose your strategy optimally, what fraction of the games do you expect to win?\n</p>\n\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each starts with a line containing three space-separated integers: <b>N</b>, <b>R</b> and <b>G</b>. The next line contains <b>N</b> space-separated, real-valued numbers <b>P</b><sub>i</sub>, indicating the probability that you will win if you play champion <code>i</code>.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the test case number (starting from 1) and y is the proportion of games you will win if you play 10<sup>100</sup> games.\n</p>\n<p>\ny will be considered correct if it is within an absolute or relative error of 10<sup>-10</sup> of the correct answer.  See the <a href=\"https://codingcompetitions.withgoogle.com/codejam/faq\" target=\"_blank\">FAQ</a> for an explanation of what that means, and what formats of real numbers we accept.\n</p>\n\n<h3>Limits</h3>\n<p>\nMemory limit: 1 GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0.0 &le; <b>P</b><sub>i</sub> &le; 1.0.<br/>\n<b>P</b><sub>i</sub> will be expressed as a single digit, followed by a decimal point, followed by 4 digits.<br/>\n</p>\n\n<h4>Small dataset</h4>\n<p>\nTime limit: 60 seconds.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>R</b> &le; 2.<br/>\n1 &le; <b>G</b> &le; 3.<br/>\n</p>\n\n<h4>Large dataset</h4>\n<p>\nTime limit: 120 seconds.<br/>\n1 &le; <b>N</b> &le; 1000.<br/>\n1 &le; <b>R</b> &le; 20.<br/>\n1 &le; <b>G</b> &le; 20.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tbody><tr>\n  <td>\n  <br>\n  <span class=\"io-table-header\">Input</span>\n  <br>&nbsp;\n  </td>\n  <td>\n  </td></tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n2 1 1\n1.0000 0.0000\n3 1 1\n1.0000 0.0000 0.5000\n6 2 3\n0.9000 0.6000 0.5000 0.1000 0.2000 0.8000\n\n  </pre>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <br><hr><br>\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <span class=\"io-table-header\">Output</span>\n  <br>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">Case #1: 0.750000000000\nCase #2: 0.666666666667\nCase #3: 0.618728522337\n\n  </pre>\n  </td></tr>\n  </tbody></table>\n  </div>\n  \n\n<h3>Note</h3>\n<p>\nLeague of Legends is a trademark of Riot Games. Riot Games does not endorse and has no involvement with Google Code Jam. \n</p>","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":22},{"type":2,"type__str":"HIDDEN","value":42}],"title":"ARAM","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"000000000043363b","type":1,"type__str":"SPECTATOR"},"title":"World Finals 2014"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
