{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1370104200000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432cd3","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nIn this round, rng..58 took an early lead by solving problem B while most other contestants were working on A. Soon after, fellow Japanese contestants hos.lyric and komaki jumped to the top with problems B and C solved, also skipping problem A.\n</p>\n\n<p>\nOne hour into the contest, over 100 contestants had correctly solved problem A or B, with very few solutions for C, and no attempts on D. At that point, it looked as if solving both A and B might be enough to guarantee a ticket to round 3. In another half an hour, there were just over 20 correct solutions for problem C, but still no correct attempts for problem D, not even for D-small.\n</p>\n\n<p>\nThe top 3 spots remained unchanged for over an hour -- hos.lyric, Gennady.Korotkevich, and fanhqme -- each with problems A, B and C. This remained the case until the very last minute, when bmerry came in with an impressive solution for both parts of problem D, earning him the top spot on the scoreboard. He submitted his D-large solution with only 6 seconds left on the clock!\n</p>\n\n<hr/>\n<p>Cast</p>\n<p>Problem A. <i>Ticket Swapping</i> written by Onufry Wojtaszczyk. Prepared by Tomek Czajka.</p>\n\n<p>Problem B. <i>Many Prizes</i> written by Bartholomew Furrow. Prepared by Tomek Czajka.</p>\n\n<p>Problem C. <i>Erdős–Szekeres</i> written and prepared by David Arthur.</p>\n\n<p>Problem D. <i>Multiplayer Pong</i> written and prepared by Onufry Wojtaszczyk.</p>\n\n<p>Contest analysis presented by Onufry Wojtaszczyk. Solutions and other problem preparation by Ahmed Aly, Igor Naverniouk, Tomek Kulczynski, John Dethridge, Tiancheng Lou, Steve Thomas, Jan Kuipers, and Tomek Czajka.</p>","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1370095200000,"tasks":[{"analysis":"<h2>Get the information</h2>\n<p>\nThe real trick to this problem is squeezing as much information as possible from the sequences A[i] and B[i]. We will get information out in the form of inequalities between various elements of the sequence X.\n</p>\n\n<p>\nFirst notice that if we have two indices i &lt; j, and A[i] &ge; A[j], then X[i] &gt; X[j]. Indeed, if it were otherwise, then the increasing sequence of length A[i] with X[i] as its largest element could be extended by adding X[j] at the end to obtain an increasing sequence with X[j] at the end, and we would have A[j] &ge; A[i] + 1. This allows us to add some inequalities X has to satisfy. We can add symmetric ones for B &mdash; if i &lt; j and B[i] &le; B[j], then X[i] &lt; X[j].\n</p>\n\n<p>\nThese inequalities are not enough, however, to reconstruct X. Indeed, if we take A[i] = i + 1 and B[i] = <b>N</b> - i, we get no inequalities to consider, but at the same time not all permutations X are going to work. The problem is that while we know what we need to do with X so that no longer subsequences exist, we still need to guarantee that long enough sequences exist.\n</p>\n\n<p>\nThis is relatively simple to accomplish, though. If A[i] &gt; 1, then the increasing subsequence ending at X[i] is formed by the extension of some sequence of length A[i] - 1. This means that X[i] has to be larger than X[j] for some j &lt; i with A[j] = A[i] - 1. The previous set of inequalities guarantees that of the set of all such j (that is, j which are smaller than i and have A[j] = A[i] - 1) the one with the smallest X[j] is the largest j. Thus, it is enough to find the largest j with j &lt; i and A[j] = A[i]-1 and add X[j] &lt; X[i] to our set of inequalities. We again do the symmetric thing for B.\n</p>\n\n<h2>Use the information</h2>\n<p>\nNotice that the inequalities we have are indeed enough to guarantee that any sequence X satisfying them will lead to the A and B we want. It's relatively easy to check the first set of inequalities guarantees the numbers A and B will not be larger than we want, while the second set of inequalities guarantee they will be large enough.\n</p>\n\n<p>\nWe now reduced the problem to finding the lexicographically smaller permutation satisfying a given set of inequalities. To find the lexicographically smallest result we are foremost interested in minimizing the first value in X. To this end, we will simply traverse all the inequalities that the first value in X has to satisfy (that is, iterate over all the elements we know to be smaller, then all elements we know to be smaller than these elements, etc.). We can do this, e.g., through a DFS. After learning how many elements of X have to be smaller than X[1], we can assign the smallest possible value (this number + 1) to X[1]. Now we need to assign numbers smaller than X[1] to all these elements, in the lexicographically smallest way.\n</p>\n\n<p>\nNote that how we do this assignment will not affect the other elements (since they are all going to be larger than X[1], and so also larger than everything we assign right now). Thus, we can assign this set of elements so that it is lexicographically smallest. This means taking the earliest of these elements, and repeating the same procedure recursively (find all elements smaller than it, assign the appropriate value, recurse). Note that once some values have been assigned, we need to take that into account when assigning new values (so, if we already assigned 1, 3 and 10; and now we know that an element we're looking at is larger than 4 others, the smallest value we can assign to it is 7).\n</p> \n\n<p>\nSuch a recursive procedure will allow us to solve the problem. For each element, we are going to traverse the graph of inequalities to find all the elements smaller than it is (O(<b>M</b> time if we do a DFS, where <b>M</b> is the number of inequalities we have), then see what's the smallest value we can assign (O(<b>N</b>) with a linear search, we can also go down to O(log<b>N</b>), but don't need to), and recurse. This gives us, pessimistically, O(<b>N</b><sup>3</sup>) time &mdash; easily good enough for the small testcase, but risky for the large.\n</p>\n\n<h2>Compress the information</h2>\n<p>\nFollowing the exact procedure above we can end up with O(<b>N</b><sup>2</sup>) inequalities. This will be too much for us (at least for the large dataset), so we will compress a bit.\n</p>\n\n<p>\nThe problem is with inequalities of the first type &mdash; for indices smaller than a given i there can be many with A larger or equal to A[i]. A trick we can use, though, is to take only one inequality &mdash; find the largest j &lt; i with A[j] = A[i], and insert only the inequality X[j] &amp;gt X[i].\n</p>\n\n<p>\nAny other k &lt; j with A[k] = A[i] will follow from transitivity &mdash; there will be a sequence of indices with A equal to A[i] connecting k to i. Any k with A[k] &gt; A[i] will also follow, since X[k] will have to be greater than some X[l] for A[l] = A[i] and l &lt; k (and thus &lt; i). This means we can reduce our set of inequalities down to a set of O(<b>N</b>), which means that each DFS traversal step will take only O(<b>N</b>) time, and the solution to the whole problem will run in O(<b>N</b><sup>2</sup>).\n</p>\n\n<p>\nInteresting fact: It is also possible to solve this problem in O(<b>N</b> log<b>N</b>). Can you figure it out?\n</p>","id":"0000000000432a8c","statement":"<h3>Problem</h3>\n\n<p>\nGiven a list <b>X</b>, consisting of the numbers (1, 2, ..., <b>N</b>), an <i>increasing subsequence</i> is a subset of these numbers which appears in increasing order, and a <i>decreasing subsequence</i> is a subset of those numbers which appears in decreasing order. For example, (5, 7, 8) is an increasing subsequence of (4, 5, 3, 7, 6, 2, 8, 1).\n</p>\n\n<p>\nNearly 80 years ago, two mathematicians, Paul Erdős and George Szekeres proved a famous result: <b>X</b> is guaranteed to have either an increasing subsequence of length at least sqrt(<b>N</b>) or a decreasing subsequence of length of at least sqrt(<b>N</b>). For example, (4, 5, 3, 7, 6, 2, 8, 1) has a decreasing subsequence of length 4: (5, 3, 2, 1).\n</p>\n\n<p>\nI am teaching a combinatorics class, and I want to \"prove\" this theorem to my class by example. For every number X[i] in the sequence, I will calculate two values:\n<ul>\n<li> A[i]: The length of the longest increasing subsequence of <b>X</b> that includes X[i] as its largest number.\n<li> B[i]: The length of the longest decreasing subsequence of <b>X</b> that includes X[i] as its largest number.\n</ul>\nThe key part of my proof will be that the pair (A[i], B[i]) is different for every i, and this implies that either A[i] or B[i] must be at least sqrt(<b>N</b>) for some i. For the sequence listed above, here are all the values of A[i] and B[i]:\n<pre>\n  i  |  X[i]  |  A[i]  |  B[i] \n-----+--------+--------+--------\n  0  |   4    |   1    |   4\n  1  |   5    |   2    |   4\n  2  |   3    |   1    |   3\n  3  |   7    |   3    |   4\n  4  |   6    |   3    |   3\n  5  |   2    |   1    |   2\n  6  |   8    |   4    |   2\n  7  |   1    |   1    |   1\n</pre>\n\n<p>\nI came up with a really interesting sequence to demonstrate this fact with, and I calculated A[i] and B[i] for every i, but then I forgot what my original sequence was. Given A[i] and B[i], can you help me reconstruct <b>X</b>?\n</p>\n\n<p>\n<b>X</b> should consist of the numbers (1, 2, ..., <b>N</b>) in some order, and if there are multiple sequences possible, you should choose the one that is lexicographically smallest. This means that X[0] should be as small as possible, and if there are still multiple solutions, then X[1] should be as small as possible, and so on.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>. <b>T</b> test cases follow, each consisting of three lines.\n</p>\n\n<p>\nThe first line of each test case contains a single integer <b>N</b>. The second line contains <b>N</b> positive integers separated by spaces, representing A[0], A[1], ..., A[<b>N</b>-1]. The third line also contains <b>N</b> positive integers separated by spaces, representing B[0], B[1], ..., B[<b>N</b>-1].\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: \", followed by X[0], X[1], ... X[<b>N</b>-1] in order, and separated by spaces.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 30.<br/>\nIt is guaranteed that there is at least one possible solution for <b>X</b>.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 20.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 2000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">2\n1\n1\n1\n8\n1 2 1 3 3 1 4 1\n4 4 3 4 3 2 2 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 1\nCase #2: 4 5 3 7 6 2 8 1\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":9},{"type":2,"type__str":"HIDDEN","value":15}],"title":"Erdős–Szekeres","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>Preliminaries</h2>\n<p>\nWe hope you took our Fair Warning, which we fairly repeated in Fair and Square this year &mdash; we consider Big Integers to be fair game, so if your language doesn't natively support them, you'd better have a library to handle them ready.</p>\n\n<p>\nThis problem seems to be about fractions initially, since the ball can hit the walls at fractional positions. There's a way to move it to integers (man, Big Fractions would be too much). The way to go about it is to scale things. Let's scale the time, so now there are <b>V<sub>X</sub></b> units to a second, and scale vertical distances, so that there are <b>V<sub>X</sub></b> units to the old unit. This means the vertical speeds stay the same, horizontal speeds get <b>V<sub>X</sub></b> times smaller, horizontal distances stay the same, and vertical distances grow <b>V<sub>X</sub></b> times larger. In implementation terms, this means we shrink <b>V<sub>X</sub></b> to 1 and grow <b>A</b> times <b>V<sub>X</sub></b> &mdash; and now suddenly the ball moves a integral number of units upwards and one unit to the side in each unit of time (and so will hit the vertical walls in integral moments of time).\n</p>\n\n<p>\nThe above assumes <b>V<sub>X</sub></b> is positive. If it's zero, then the ball will never hit the walls, and so the game ends in a draw. If it's negative, we can flip the whole board across the <b>Y</b> axis and swap the teams to make <b>V<sub>X</sub></b> change signs. Similarly, we can assume <b>V<sub>Y</sub></b> positive &mdash; if it's zero, putting all paddles in the single impact point will guarantee a draw, and if it's negative, we can flip the board vertically.\n</p>\n\n<p>\nSo now the ball will hit a given vertical wall every 2<b>B</b> units of time. It's also relatively easy to figure out what is the position of the impact. If there were no vertical walls, the ball would hit at the initial hit position (<b>Y</b> + (<b>B</b> - <b>X</b>) <b>V<sub>Y</sub></b>), and then at 2<b>B</b><b>V<sub>Y</sub></b> intervals from there. To calculate the positions in real life, notice that every 2<b>A</b> upwards the ball is in the same position again (so we can take impact points module 2<b>A</b>), and if that number is larger than <b>A</b>, the ball goes in the other direction, and the impact position is 2<b>A</b> minus whatever we calculated.\n</p>\n\n<h2>Many bounces</h2>\n<p>\nSo now we know how to calculate hit positions, so we can just simulate and see who loses first, right? Well, wrong, because the ball can bounce very many times. Even in the small dataset, the number of bounces can go up to 10<sup>11</sup>, too much for simulation.\n</p>\n\n<p>\nNotice that the positions of the paddles are pretty much predetermined. The paddle of a given player has to be exactly at the point of impact when it is the player's turn to bounce it, and then the only question is whether the player will have enough time to reach the next point of impact before the ball. With <b>N</b> paddles on a team, and <b>V</b> being the speed of the paddle, the player can move the paddle by 2<b>B</b><b>V</b><b>N</b> before the next impact. The ball, in the same time, will move by 2<b>B</b><b>V<sub>Y</sub></b><b>N</b>, but while the paddle moves in absolute numbers, the ball moves \"modulo 2<b>A</b> with wrapping\", as described above.\n</p>\n\n<p>\nIf the distance the ball moves (modulo <b>A</b>) is smaller or equal to the distance the paddle moves, the paddle will always be there in time. The interesting case is when it is not so. In this case, there is still a chance for the paddle to be in the right place on time due to the \"wrapping effect\". For instance, if the ball moves by <b>A</b>+1 with each bounce, and the first bounce happens at <b>A</b> / 2, the next one will happen at <b>A</b> / 2 - 1, the next one at <b>A</b> / 2 + 2, and so on &mdash; so the initial bounces will be pretty close by. We can calculate exactly the set of positions where the ball hitting the wall will allow the paddle to catch up, and it turns out that it is two intervals modulo 2<b>A</b>.\n</p>\n\n<p>\nSo now the question becomes \"how long can the ball bounce without hitting a prohibited set of two intervals\", which is easy to reduce to \"without hitting the given interval\". This is a pure number-theoretic question: we have an arithmetic sequence <b>I</b> + K<b>S</b>, modulo 2<b>A</b>, and we are interested in the first element of this sequence to fall into a given interval.\n</p>\n\n<h2>Euclid strikes again</h2>\n<p>\nThere is a number of approaches one can take to solving this problem. We will take an approach similar to the Euclidean algorithm. First, we can shift everything modulo 2<b>A</b> so that <b>I</b> is zero, and we are dealing with the sequence K<b>S</b>. Also, we can shift the problem so that <b>S</b> &le; <b>A</b> &mdash; if not, we can (once again) flip the problem vertically. Thus, the ball will bounce at least twice before wrapping around the edge of 2<b>A</b>.\n</p>\n\n<p>\nWe can calculate when is the first time the ball will pass the beginning of the forbidden interval (by integral division). If at this point the ball hits the forbidden interval, we are done. Otherwise, the ball will travel all the way to 2<b>A</b>, and then wrap around and hit the wall again at some position <b>P</b> smaller than <b>S</b>. Notice that in this case the interval obviously is shorter than <b>S</b>.\n</p>\n\n<p>\nNow, the crucial question is what <b>P</b> is. It's relatively easy to calculate for what values of <b>P</b> will the next iteration land in the interval (if the interval is [k<b>S</b> + a, k<b>S</b> + b] for some k, a, b, then the interesting set of values of <b>P</b> is [a, b]). If <b>P</b> happens to be in this interval, we can again calculate the answer fast. If not, however, we will do another cycle, and then hit the wall (after cycling) at the point 2<b>P</b>, mod <b>S</b>. Notice that this is very similar to the original problem! We operate modulo <b>S</b>, we increment by <b>P</b> with each iteration, and we are interested in when we enter the interval [a,b].\n</p>\n\n<p>\nThus, we can apply recursion to learn after how many cycles will we finally be in a position to fall into the original interval we were interested in. So we make that many full cycles, and then we finish with a part of the last cycle to finally hit the interval.\n</p>\n\n<h2>Complexity analysis</h2>\n<p>\nAll the numbers we will be operating on will have at most <b>D</b> = 200 digits in the large dataset, so operations on them will take at most O(<b>D</b><sup>2</sup> log<b>D</b>) time (assuming a quadratic multiplication implementation and a binary-search implementation of division). Each recursion step involves a constant number of arithmetic operations plus a recursive call, for which the number <b>A</b> (the modulo) decreases at least twice. This means we make at most O(<b>D</b>) recursion steps &mdash; so the whole algorithm will run in O(<b>D</b><sup>3</sup> log<b>D</b>) time, fast enough allowing even some room for inefficiency.\n</p>\n","id":"0000000000432adb","statement":"<h3>Problem</h3>\n<p>\nTwo teams of players play pong. Pong is a simple computer game, where each player controls a paddle (which we assume to be a point), and a little ball bounces back and forth. The players in one team are required to bounce the ball in a fixed cyclic order (so in a three-player team, the first one to touch the ball would be P1, then P2, then P3 and only then P1 again), until one of the players doesn't manage to bounce it, at which point the ball leaves the playing field and this player's team loses.\n</p>\n\n<p>\nTo be more precise: the playing field is a rectangle of size <b>A</b>x<b>B</b>. On each vertical wall (of length <b>A</b>) there are a number of paddles, one for each player of the team guarding this wall. Each paddle is a point. All the paddles of the players on one team move vertically at the same speed (in units per second), and can pass each other freely. There is also a ball, for which we are given its initial position (horizontal and vertical, counted from the lower-left corner) and initial speed (horizontal and vertical, again in units per second). The players are allowed to choose the initial positioning of their paddles on their vertical walls knowing the initial position of the ball. Whenever the ball reaches a horizontal wall, it bounces off (with the angle of incidence equal to the angle of reflection). Whenever it reaches a vertical end of the field, if the paddle of the player who is supposed to touch the ball now is there, it bounces off, while if there isn't, the team of the player whose paddle was supposed to be there loses.\n</p>\n\n<p>\nThe game can take quite a long time, with the players bouncing the ball back and forth. Your goal is to determine the final result (assuming all players play optimally).\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of four lines.\nThe first line contains two integers, <b>A</b> and <b>B</b>, describing the height and width of the playing field.\nThe second line contains two integers, <b>N</b> and <b>M</b>, describing the sizes of the two teams: <b>N</b> is the number of players on the team with paddles on the <b>X</b> = 0 wall, and <b>M</b> is the number of players on the team with paddles on <b>X</b> = <b>B</b> wall.\nThe third line contains two integers, <b>V</b> and <b>W</b>, describing the speed of the paddles of players in the first and second team, respectively.\nThe fourth line contains four integers: <b>Y</b>, <b>X</b>, <b>V<sub>Y</sub></b> and <b>V<sub>X</sub></b>, describing the initial position (vertical and horizontal) and initial speed of the ball (the ball moves by <b>V<sub>Y</sub></b> units up and <b>V<sub>X</sub></b> to the right each second, until it bounces).\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is one of the three possible outputs: \"DRAW\" (if the game can proceed forever), \"LEFT z\", if the team with paddles on <b>x</b> = 0 wins, and the opposing team can bounce the ball at most z times, or \"RIGHT z\" if the team with paddles on <b>X</b> = <b>B</b> wins and the opposing team can bounce the ball at most z times.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n0 &lt; <b>X</b> &lt; <b>B</b><br/>\n0 &lt; <b>Y</b> &lt; <b>A</b><br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b>, <b>M</b> &le; 10<sup>6</sup><br/>\n1 &le; <b>V</b>, <b>W</b> &le; 10<sup>12</sup><br/>\n-10<sup>12</sup> &le; <b>V<sub>Y</sub></b> &le; 10<sup>12</sup><br/>\n-10<sup>6</sup> &le; <b>V<sub>X</sub></b> &le; 10<sup>6</sup><br/>\n2 &le; <b>A</b>, <b>B</b> &le; 10<sup>6</sup><br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b>, <b>M</b> &le; 10<sup>100</sup><br/>\n1 &le; <b>V</b>, <b>W</b> &le; 10<sup>100</sup><br/>\n-10<sup>100</sup> &le; <b>V<sub>Y</sub></b>, <b>V<sub>X</sub></b> &le; 10<sup>100</sup><br/>\n2 &le; <b>A</b>, <b>B</b> &le; 10<sup>100</sup><br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">4\n6 4\n1 2\n3 1\n5 1 4 8\n12 3\n3 1\n2 3\n1 1 2 4\n12 3\n1 3\n3 1\n1 1 2 4\n12 2\n1 2\n10 2\n3 1 13 4\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: LEFT 2\nCase #2: DRAW\nCase #3: LEFT 3\nCase #4: RIGHT 11\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<img src=\"https://codejam.googleapis.com/dashboard/get_file/AQj_6U1MVhgPKcMfhYDJ_U5dxpkLhCOtHoQS3HFMmv2Q_-OowygxCEyZ1IbZv1wwv9-1ZA2tRg/pong.png\">\n<p>\nThe picture depicts the gameplay in the first sample case. The ball bounces off the right wall at time 0.375 (the first RIGHT player intercepts it, for instance by beginning with her paddle there and not moving it), then off the left wall at 0.875 (the LEFT player bounces it), again on the right at time 1.375 (the second RIGHT player can position his paddle at the bounce point), again on the left (where the LEFT player gets just in time to catch it &mdash; she covers the three units of distance exactly in one second in which she needs to get there) and then hits the right wall too far for the first RIGHT player to get there. Note the second RIGHT player could catch the ball, but is not allowed by the rules to do so. Also note that if RIGHT team had one player more, she could bounce the ball, and then LEFT would lose &mdash; the ball would come too far up for the single LEFT player to get there in time.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":12},{"type":2,"type__str":"HIDDEN","value":25}],"title":"Multiplayer Pong","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nLet's begin by an observation that will make our life a bit easier: if we reverse all the team numbers (that is, team 0 becomes team 2<sup><b>N</b></sup>-1, team 1 becomes team 2<sup><b>N</b></sup>-2, etc.), without changing the tournament list. This will result in the final ranks of the teams also being reversed, since it's relatively easy to see that all the records will be reversed (wins becoming losses and vice versa). This means that the problem of having a team rank as low as possible to get into the first <b>P</b> is equivalent to the problem of a team ranked as high as possible to get into the bottom <b>P</b> (or, in other words, not get into the top 2<sup><b>N</b></sup> - <b>P</b>). Thus, if we are able to answer the question what is the lowest rank that can possibly get into the top <b>P</b>, we can run the same code to see what's the lowest rank that can possibly be in the top 2<sup><b>N</b></sup> - <b>P</b>, subtract one, and reverse, and this will be the lowest rank that will always get a prize. This means we only have to solve one problem &mdash; lowest ranked team guaranteed to be in the top <b>P</b>\n</p>\n\n<p>\nFor the small dataset we have at most 1024 teams, which means we can try to figure out the tournament tree that will give a given team the best position, do this for all teams, and see which team was the lowest-ranked one to get a prize. Let's skip this, however, and jump straight to the solution for the large dataset, where 2<sup>50</sup> teams clearly disallow any direct approaches.\n</p>\n\n<p>\nThe key observation we can make here is that if we have a team we want to be as high as possible, we can do it with a record that includes a string of wins followed by a string of losses, and nothing else. This sounds surprising, but is actually true. Imagine, to the contrary, that the team (let's call them <b>A</b>) has a loss (against some team <b>B</b>) followed by a win against <b>C</b>, who played <b>D</b> in the previous round. Note that up to the round where <b>A</b> plays <b>B</b> the records of the four teams were identical. Also note that all the tournament trees of the four teams so far are disjoint, and so we can swap them around. In particular, we can swap team <b>C</b> and all its tree with team <b>B</b> and all its tree. Since we swap whole trees, the records of teams don't change, so now team <b>A</b> will play <b>C</b> in the first match and win &mdash; and so its record is going to be strictly better than it was, no matter what happens next. Thus, any ordering in which team <b>A</b> has a loss followed by a win is suboptimal.\n</p>\n\n<p>\nThis allows us to solve the problem of getting the highest possible rank for a given team. We simply need to greedily win as much as we can. If we're the worst team, we can't win anything. If we're not, we can certainly win the first match. The second match will be played against the winner of some match, so in order to win it we need to be better than three teams. To win two matches, we need to be better than seven teams, and so on.\n</p>\n\n<p>\nWe can also reverse the reasoning to get the lowest-ranked team that can win the prize. First, let's ask how many matches does one need to win in order to win a prize. If you win no matches, you are in the top 2<sup><b>N</b></sup> (not a huge achievement!). If you win one, you are in the top 2<sup><b>N</b> - 1</sup>. And so on. Once we know how many matches you need to win, you directly know how many teams you need to be better than. Simple python code follows:\n</p>\n<pre>\n<code>\ndef LowRankCanWin(N, P):\n  if P == 0:\n    return -1\n  matches_won = 0\n  size_of_group = 2 ** N\n  while size_of_group &gt; P:\n    matches_won += 1\n    size_of_group /= 2\n  return 2 ** N - 2 ** matches_won\n\ndef ManyPrizes(N, P):\n  print 2 ** N - LowRankCanWin(N, 2 ** N - P) - 2, LowRankCanWin(N, P)\n</code>\n</pre>","id":"0000000000432be8","statement":"<h3>Problem</h3>\n<p>\nWe're going to run a tournament with <code>2<sup><b>N</b></sup></code> teams, and give out <b>P</b> identical prizes to the teams with ranks <code>0..<b>P</b>-1</code>.\n<p>\nThe teams are numbered 0 through 2<sup><b>N</b></sup>-1.  When team i and team j play against each other in a game, team i will win iff <code>i&lt;j</code>.\n</p>\n<p>\nThe teams for a tournament are organized in some order, called the tournament's <i>tournament list</i>, which contains all <code>2<sup><b>N</b></sup></code> teams in the tournament.  The tournament list will affect which teams play each other, and in what order.\n</p>\n<p>\nYour job will be to find the largest-numbered team that is <i>guaranteed</i> to win a prize, independent of how the tournament list is ordered; and to find the largest-numbered team that <i>could</i> win a prize, depending on how the tournament list is ordered.\n</p>\n\n<h3>Tournament Resolution</h3>\n\n<p>\nThe tournament is conducted in <b>N</b> <i>rounds</i>.\n</p>\n<p>\nEach team has a <i>record</i>: the list of the results of the games it has played so far.  For example, if a team has played three games, and won the first, lost the second and won the third, its record is <code>[W, L, W]</code>.  If a team has played zero games, its record is <code>[]</code>.\n</p>\n<p>\nIn each round, every team plays a game against a team with the same record.  The first team in the tournament list with a particular record will play against the second team with that record; the third team with the same record will play against the fourth; and so on.\n</p>\n<p>\nAfter <b>N</b> rounds, each team has a different record.  The teams are ranked in reverse lexicographical order of their records; so <code>[W, W, W] &gt; [W, W, L] &gt; [W, L, W] ... &gt; [L, L, L]</code>.</p>\n\n<p>\nHere is an example of a tournament with <b>N</b>=3, and the tournament list <code>[2, 4, 5, 3, 6, 7, 1, 0]</code>, where the columns represent different rounds, and the teams are grouped by their records.  The winner of each game in the example has been marked with a <code>*</code>.\n</p>\n\n<pre>\nRound 1    Round 2    Round 3    Final Result\n                                 (best rank at top)\n<b>[]         [W]        [W,W]</b>\n2  *       2  *       2          0  [W,W,W]\n4          3          0  *       2  [W,W,L]\n<b>                      [W,L]</b>\n5          6          3  *       3  [W,L,W]\n3  *       0  *       6          6  [W,L,L]\n<b>           [L]        [L,W]</b>\n6  *       4  *       4          1  [L,W,W]\n7          5          1  *       4  [L,W,L]\n<b>                      [L,L]</b>\n1          7          5  *       5  [L,L,W]\n0  *       1  *       7          7  [L,L,L]\n</pre>\n\n<p>\nIf we give out 4 prizes (<b>N</b>=3, <b>P</b>=4), the prizes will go to teams 0, 2, 3 and 6.\n</p>\n<p>\nThe largest-numbered team that was guaranteed to win a prize with <b>N</b>=3, <b>P</b>=4, independent of the order of the tournament list, was team <code>0</code>: this tournament list demonstrated that it's possible for team <code>1</code> <i>not</i> to win a prize, and it turns out that team <code>0</code> will always win one, regardless of the order of the tournament list.\n</p>\n<p>\nThe largest-numbered team that could win a prize with <b>N</b>=3, <b>P</b>=4, depending on how the tournament list was ordered, was team <code>6</code>: this tournament list demonstrated that it's possible for team <code>6</code> to win a prize, and it turns out that team <code>7</code> will never win one, regardless of the order of the tournament list.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of two space-separated integers: <b>N</b>, which indicates the tournament has <code>2<sup><b>N</b></sup></code> teams, and <b>P</b>, the number of prizes.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y z\", where x is the case number (starting from 1), y is the largest-numbered team that is <i>guaranteed</i> to win a prize, independent of how the tournament list is ordered; and z is the largest-numbered team that <i>could</i> win a prize, depending on how the tournament list is ordered.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>P</b> &le; 2<sup><b>N</b></sup>.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 50.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3 4\n3 5\n3 3\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 0 6\nCase #2: 2 6\nCase #3: 0 4\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":7},{"type":2,"type__str":"HIDDEN","value":13}],"title":"Many Prizes","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h2>The small dataset</h2>\n<p>\nNote that in this problem we treat the passengers as one \"player\" in a game, and assume they all cooperate to pay as little as possible in total to the city. This means it doesn't matter who actually pays for a given entry card. In particular, when the train leaves a station, the charge on each entry card in the train increases (by <b>N - i</b>, where <b>i</b> is the number of stations this card traveled so far). Since all passengers want to exit the subway eventually, all entry cards will have to be paid &mdash; so we might just as well immediately subtract this cash from the passenger \"total\" and move on.\n</p>\n\n<p>\nAs long as nobody exists the train, there's no need to exchange entry cards. Only once someone needs to exits, the passengers (along with the ones who just entered) need to gather and figure out which entry cards do the passengers who are just leaving take with them. They should choose the entry cards that have been on the train for the shortest amount of time so far, since on each subsequent stop the price for such an entry card will be larger than the price for any card that has been on the train longer (as the price is <b>N - i</b>, where <b>i</b> is the number of stations the card traveled so far). This means that at every station, the passengers should pool all the cards together, and then whoever wants to exit takes the entry cards with the smallest distance.\n</p>\n\n<p>\nFor the small dataset, a naive implementation of this algorithm will work. We can process station by station, holding a priority queue (or even just any collection) of the entry cards present. When anyone wants to exit, we iterate over the collection to find the card that has been on the train for the shortest amount, add its cost to the total passengers cost and remove it from the set. We also need to figure out how much the passengers <i>should</i> pay, but fortunately that's easy.\n</p>\n\n<h2>The large dataset</h2>\n<p>\nThe large data set needs a bit more subtlety. With the insane amounts of passengers and stations we will need to avoid processing unnecessary events. First of all, we should process only the stations at which someone wants to enter or exit. This will make us process only O(<b>M</b>) stations, much less than the <b>N</b> we would process otherwise. Moreover, we should avoid processing passengers one by one.</p>\n\n<p>\nTo this end, notice that the order in which we want to give exit cards to passengers is actually a LIFO stack &mdash; whichever card came in last will go out first. So, we can keep the information about entry cards present in the train in a <a href=\"http://en.wikipedia.org/wiki/Stack_(abstract_data_type)\" target=\"_blank\">stack</a>. Whenever a new group of passengers comes in, we take their entry cards and put them onto the stack (as one entry, storing the number of cards and the entry station). Whenever any group wants to leave, we go through the stack. If the topmost group of cards is big enough, we simply decrease its size, pay for what we took, and continue. If not, we take the whole group of cards, pay for it, decrease the amount of cards we need by the size of the group, and proceed through the stack.\n</p>\n\n<p>\nThis algorithm will take only O(<b>M</b>) time in total to process all the passengers &mdash; we will put on the stack at most <b>M</b> times, so we will take a whole group from the stack at most <b>M</b> times, and each group of passengers will decrease a group size (not take the whole group of cards) at most once, so in total &mdash; at most <b>M</b> such operations in the whole algorithm. Additionally, we need to sort all the events (a group of passengers entering or leaving) up front, so we are able to solve the whole problem in O(<b>M</b> log<b>M</b>).\n</p>\n\n<p>\nFinally, when implementing, one needs to be careful. Due to the large amounts of stations and passengers involved, we have to use modular arithmetic carefully, because &mdash; as always with modular arithmetic &mdash; we risk overflow. In particular, whenever we multiply three numbers (which we do when calculating how much to pay for a group of tickets), we need to take care to apply the modulo after multiplying the first two.\n</p>","id":"000000000043315f","statement":"<h3>Problem</h3>\n<p>\nThe city has built its first subway line, with a grand total of <b>N</b> stations, and introduced a new way of paying for travel. Instead of just paying for one ticket and making an arbitrary journey, the price you pay is now based on <i>entry cards</i>.\n</p>\n\n<p>\nWhen entering the subway, each passenger collects an <i>entry card</i>, which specifies the station the passenger entered at. When leaving the subway, the passenger has to give up the entry card, and is charged depending on the distance (in stations traveled) between the entry station specified on the entry card, and the exit station on which the entry card is surrendered.\nThe payment depends on the distance between these stations as follows: <ul>\n<li> if they are the same station, you don't pay;</li>\n<li> if they are adjacent stations, you pay <b>N</b> pounds;</li>\n<li> if the distance is two stations, you pay <b>2N - 1</b>: a charge <b>N</b> for the first stop and <b>N - 1</b> for the second;</li>\n<li> the third station costs <b>N-2</b> (so you pay <b>3N - 3</b> for a three-station-long trip), the fourth stop <b>N-3</b>, and the <i>i</i>th stop <b>N + 1-<i>i</i></b>;</li>\n<li>thus, if you travel from one end of the subway to the other (a distance of <b>N</b>-1 stations), you pay 2 pounds for the last station traveled, and a grand total of (<b>N</b><sup>2</sup> + <b>N</b> - 2) / 2 in total. </li>\n</ul>\n</p>\n\n<p>\nAfter introducing this system the city noticed their gains are not as big as they expected. They figured out this might be due to people swapping their entry cards &mdash; so, for instance, if one person enters at station <b>A</b>, travels two stations to <b>B</b> and exits, while another person enters at <b>B</b>, travels three stations to <b>C</b> and exits, they would normally pay (in total) <b>2N - 1 + 3N - 3 = 5N - 4</b>. But if the two people swapped their entry cards at station <b>B</b>, then the first one would travel for free (as he would surrender an entry card specifying the station <b>B</b> while exiting a station <b>B</b>, and so register a distance of zero); while the second person will exit at station <b>C</b> and surrender an entry card specifying station <b>A</b>, which is 5 stations away, and pays <b>5N - 10</b>, at a net loss of six pounds to the city!\n</p>\n\n<p>\nThe city now wants to learn how much they can possibly lose if this practice becomes widespread. We will consider only one direction (from station 1 to station <b>N</b>, passing through all the stations in order) of the subway, and only one train on this line. We assume a passenger travelling from <b>o</b> to <b>e</b> obtains an entry card at <b>o</b>, can swap her entry card any number of times with any other passengers anywhere between <b>o</b> and <b>e</b>, including swapping with people who leave at <b>o</b> or those who enter at <b>e</b>, and then exit the train at <b>e</b> with some entry card (it is necessary to surrender some entry card to exit the subway). We also assume the passenger will not exit the train in the meantime (that is, will not surrender the currently held card and obtain a new one).\n</p>\n\n<p>\nYou are given a map of traffic (specifying how many passengers travel this train from which station to which), and you should calculate the city's financial loss, assuming passengers swap their cards to maximize this loss.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case contains the number <b>N</b> of stops (the stops are numbered 1 to <b>N</b>), and the number <b>M</b> of origin-endpoint pairs given. The next <b>M</b> lines contain three numbers each: the origin stop <b>o<sub>i</sub></b>, the end stop <b>e<sub>i</sub></b> and <b>p<sub>i</sub></b>: the number of passengers that make this journey.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the total loss the city can observe due to ticket swapping, modulo 1000002013.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 20.<br/>\n1 &le; <b>o<sub>i</sub></b> &lt; <b>e<sub>i</sub></b> &le; <b>N</b><br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n2 &le; <b>N</b> &le; 100.<br/>\n1 &le; <b>M</b> &le; 100.<br/>\n1 &le; <b>p<sub>i</sub></b> &le; 100.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n2 &le; <b>N</b> &le; 10<sup>9</sup>.<br/>\n1 &le; <b>M</b> &le; 1000.<br/>\n1 &le; <b>p<sub>i</sub></b> &le; 10<sup>9</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n6 2\n1 3 1\n3 6 1\n6 2\n1 3 2\n4 6 1\n10 2\n1 7 2\n6 9 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 6\nCase #2: 0\nCase #3: 10\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<p>\nThe first test case is the case described in the problem statement - two passengers meet at station 3 and swap tickets. In the second test case the two passengers don't meet at all, so they can't swap tickets (and so the city incurs no loss). In the third case, only one of the early passengers can swap tickets with the later passenger.\n</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":8},{"type":2,"type__str":"HIDDEN","value":11}],"title":"Ticket Swapping","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432cd3","type":1,"type__str":"SPECTATOR"},"title":"Round 2 2013"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
