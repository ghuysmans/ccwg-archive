{"challenge":{"announcements":[],"are_results_final":true,"end_ms":1365897600000,"hide_scoreboard":false,"hide_scoreboard_config":{},"id":"0000000000432dfc","is_practice_available":true,"my_user_type":1,"my_user_type__str":"SPECTATOR","recap":"<p>\nGoogle Code Jam 2013 is off and running! We have 17059 advancers out of 21962 people who correctly solved at least one input, and 45754 registrants. All those numbers are records for us!\n</p>\n\n<p>\nWe started with Tomek's variation on a game for children (who is this Tomek anyway?!), and then quickly delved into the riddles of lawnmowers, palindromes, and pirates. Overall, it was a pretty tough set this year, with problem D in particular being something that could have been a Finals problem. A huge congratulations to the 63 people who managed to solve everything!\n</p>\n\n<p>\nThere are three more rounds to go before the Finals, and we're just getting started. We hope to see all the advancers in the First Rounds!\n</p>\n\n<hr>\n\n<p>Cast</p>\n\n<p>Problem A. <i>Tic-Tac-Toe-Tomek</i> Written by Tomek Kulczyński and Bartholomew Furrow. Prepared by Onufry Wojtaszczyk and Bartholomew Furrow.</p>\n\n<p>Problem B. <i>Lawnmower</i> Written by Onufry Wojtaszczyk. Prepared by Jan Kuipers and Onufry Wojtaszczyk.</p>\n\n<p>Problem C. <i>Fair and Square</i> Written by Onufry Wojtaszczyk. Prepared by Nikolay Kurtov and Onufry Wojtaszczyk.</p>\n\n<p>Problem D. <i>Treasure</i> Written by David Arthur. Prepared by Tomek Kulczyński and David Arthur.</p>\n\nContest analysis presented by Onufry Wojtaszczyk and David Arthur.\n\nSolutions and other problem preparation by Igor Naverniouk, Tomek Czajka, Karim Nosseir, Hao Pan, and Petr Mitrichev.","registration_gives_participant":false,"result_status":30,"result_status__str":"FINALIZED","start_ms":1365807600000,"tasks":[{"analysis":"<h3>The Small Input</h3>\n\n<p>\nFor a problem like this, it can be helpful to think through a few cases. Let's look at the first two examples from the problem statement:\n\n<pre>\n   2 2 2 2 2\n   2 1 1 1 2    2 1 2\n   2 1 2 1 2    1 1 1\n   2 1 1 1 2    2 1 2\n   2 2 2 2 2\n</pre>\n\n<p>\nAll the grass needs to be cut to either height 1 or 2. Thus, we can begin by cutting the whole lawn to height 2. The question that remains is which rows and which columns to cut to height 1. Note that if we cut a row (or column) to height 1, all the squares in this row or column will be height 1 in the final pattern since we can't grow grass back.\n</p>\n\n<p>\nIn the left example, we must at some point do a cut with the lawnmower at height 1. Otherwise, we would never get any grass that low. However, there is nowhere that it is safe to make a cut like that. Every row and every column has at least one square where we want the final grass height to be 2, so we can never run the lawnmower through that row or column while at height 1. This pattern is impossible.\n</p>\n\n<p>\nIn the second example, we also must do some cuts with the lawnmower at height 1. However, in this case, there are two places where we can safely make that cut: the middle row and the middle column. If we do both, we get the desired pattern.\n</p>\n\n<p>\nMore generally, there are some rows and columns we cannot cut to height 1. By avoiding those rows and columns, we ensure nothing will be made too low. What remains is to check if it is still possible to get all the grass low <i>enough</i>. Well, if our only goal is to get the grass low, we should do all the cuts we can!\n</p>\n\n<p>\nThis suggests the following approach:\n<ul>\n<li> Determine which rows and columns it is safe to cut at height 1 (meaning the pattern has no square with height &gt; 1 in that row or column).\n<li> Do a cut on each of these rows and columns at height 1.\n<li> Check if we got every square low enough. If so, the pattern is possible. Otherwise, it is not.\n</ul>\n</p>\n\n<h3>The Large Input</h3>\n\n<p>\nFor the large input, we can use almost the exact same strategy. You just have to think through what that means!\n</p>\n\n<p>\nWe can cut any row or column at a height that is equal to the maximum height appearing in this row (or column). As long as we follow this rule, we will never cut a square too low, and then as above, we just need to try to get everything low enough. For that purpose, we want to use all the cuts we can. The full algorithm is then:\n</p>\n\n<ul>\n<li> Iterate over every row and find the largest height that the pattern has in this row. Cut the row at this height.\n<li> Do the same thing for every column.\n<li> Output \"YES\" if this achieved the desired pattern, and \"NO\" if not.\n</ul>\n","id":"0000000000432b85","statement":"<h3>Problem</h3>\n<p>\nAlice and Bob have a lawn in front of their house, shaped like an <b>N</b> metre by <b>M</b> metre rectangle. Each year, they try to cut the lawn in some interesting pattern. They used to do their cutting with shears, which was very time-consuming; but now they have a new automatic lawnmower with multiple settings, and they want to try it out.\n</p>\n\n<p>\nThe new lawnmower has a height setting - you can set it to any height <b>h</b> between 1 and 100 millimetres, and it will cut all the grass higher than <b>h</b> it encounters to height <b>h</b>. You run it by entering the lawn at any part of the edge of the lawn; then the lawnmower goes in a straight line, perpendicular to the edge of the lawn it entered, cutting grass in a swath 1m wide, until it exits the lawn on the other side.  The lawnmower's height can be set only when it is not on the lawn.\n</p>\n\n<p>\nAlice and Bob have a number of various patterns of grass that they could have on their lawn. For each of those, they want to know whether it's possible to cut the grass into this pattern with their new lawnmower. Each pattern is described by specifying the height of the grass on each 1m x 1m square of the lawn.\n</p>\n\n<p>\nThe grass is initially 100mm high on the whole lawn.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case begins with a line containing two integers: <b>N</b> and <b>M</b>. Next follow <b>N</b> lines, with the <i>i</i>th line containing <b>M</b> integers <b>a<sub>i,j</sub></b> each, the number <b>a<sub>i,j</sub></b> describing the desired height of the grass in the <i>j</i>th square of the <i>i</i>th row.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is either the word \"YES\" if it's possible to get the x-th pattern using the lawnmower, or \"NO\", if it's impossible (quotes for clarity only).\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 100.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b>, <b>M</b> &le; 10.<br/>\n1 &le; <b>a<sub>i,j</sub></b> &le; 2.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b>, <b>M</b> &le; 100.<br/>\n1 &le; <b>a<sub>i,j</sub></b> &le; 100.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n3 3\n2 1 2\n1 1 1\n2 1 2\n5 5\n2 2 2 2 2\n2 1 1 1 2\n2 1 2 1 2\n2 1 1 1 2\n2 2 2 2 2\n1 3\n1 2 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: YES\nCase #2: NO\nCase #3: YES\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":30}],"title":"Lawnmower","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nIn this problem, you had to classify the state of a Tic-Tac-Toe game with a twist. The board is 4x4, and an extra symbol can appear on the board - a \"T\", which either player can use for victory.\n</p>\n\n<p>\nNote that you are guaranteed by the problem description the input will always describe a board that was obtained by a correct sequence of moves. As the game ends when one player wins, this guarantees that only one player can have four symbols (or 3 symbols and a T) in a completed line.\n</p>\n\n<p>\nThus, the simplest way to check whether a player, say \"X\", won is to check all rows, columns and diagonals whether they contain only \"T\"s and \"X\"s. Do not forget to check both diagonals! If there is a row, column or diagonal containing no \".\"s or \"O\"s, we know that X won. Similarly, if there is a row, column or diagonal contianing no \"X\"s or \".\"s, O won.\n</p>\n\n<p>\nIf none of the players won, we only have to distinguish between a draw and a game not completed. This is relatively simple - if the board contains even a single \".\", the game has not completed yet; otherwise it's a draw.\n</p>\n\n<p>\nNote that your solutions are checked automatically, by a program. This means that your output has to be exactly matching the specification. A number of contestants had problems due to returning \"O Won\" instead of \"O won\" or \"The game has not been completed\" instead of \"Game has not completed\". In a programming competition it is important to follow the specification of the output as exactly as possible.\n</p>\n\n<p>\nHere is a complete solution in Python for reference:\n</p>\n\n<pre>\nimport sys\n\ndef solve(b):\n  for c in ['X', 'O']:\n    wind1 = True\n    wind2 = True\n    for x in range(4):\n      winh = True\n      winv = True\n      for y in range(4):\n        if b[y][x]!=c and b[y][x]!='T': winv = False\n        if b[x][y]!=c and b[x][y]!='T': winh = False\n      if winh or winv: return c + ' won'\n      if b[x][x]!=c and b[x][x]!='T': wind1 = False\n      if b[3-x][x]!=c and b[3-x][x]!='T': wind2 = False\n    if wind1 or wind2: return c + ' won'\n\n  for x in range(4):\n    for y in range(4):\n      if b[y][x]=='.': return 'Game has not completed'\n\n  return 'Draw'\n\n\nnumcases = int(sys.stdin.readline())\nfor casenum in range(1,numcases+1):\n  board = []\n  for i in range(0,5):\n    board.append(sys.stdin.readline().strip())\n  print 'Case #' + repr(casenum) + ': ' + solve(board)\n</pre>\n","id":"0000000000432fe5","statement":"<h3>Problem</h3>\n<p>\nTic-Tac-Toe-Tomek is a game played on a 4 x 4 square board.  The board starts empty, except that a single 'T' symbol may appear in one of the 16 squares.  There are two players: X and O.  They take turns to make moves, with X starting. In each move a player puts her symbol in one of the empty squares.  Player X's symbol is 'X', and player O's symbol is 'O'.\n</p>\n<p>\nAfter a player's move, if there is a row, column or a diagonal containing 4 of that player's symbols, or containing 3 of her symbols and the 'T' symbol, she wins and the game ends.  Otherwise the game continues with the other player's move. If all of the fields are filled with symbols and nobody won, the game ends in a draw.  See the sample input for examples of various winning positions.\n</p>\n<p>\nGiven a 4 x 4 board description containing 'X', 'O', 'T' and '.' characters (where '.' represents an empty square), describing the current state of a game, determine the status of the Tic-Tac-Toe-Tomek game going on. The statuses to choose from are:\n</p>\n<ul>\n<li> \"X won\" (the game is over, and X won) </li>\n<li> \"O won\" (the game is over, and O won) </li>\n<li> \"Draw\" (the game is over, and it ended in a draw) </li>\n<li> \"Game has not completed\" (the game is not over yet) </li>\n</ul>\n<p>\nIf there are empty cells, and the game is not over, you should output \"Game has not completed\", even if the outcome of the game is inevitable.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case consists of 4 lines with 4 characters each, with each character being 'X', 'O', '.' or 'T' (quotes for clarity only). Each test case is followed by an empty line.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is one of the statuses given above.  Make sure to get the statuses exactly right.  When you run your code on the sample input, it should create the sample output exactly, including the \"Case #1: \", the capital letter \"O\" rather than the number \"0\", and so on.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\nThe game board provided will represent a valid state that was reached through play of the game Tic-Tac-Toe-Tomek as described above.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 10.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 1000.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">6\nXXXT\n....\nOO..\n....\n\nXOXT\nXXOO\nOXOX\nXXOO\n\nXOX.\nOX..\n....\n....\n\nOOXX\nOXXX\nOX.T\nO..O\n\nXXXO\n..O.\n.O..\nT...\n\nOXXX\nXO..\n..O.\n...O\n\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: X won\nCase #2: Draw\nCase #3: Game has not completed\nCase #4: O won\nCase #5: O won\nCase #6: O won\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n\n<h3>Note</h3>\n<p>Although your browser might not render an empty line after the last test case in the sample input, in a real input file there would be one.</p>\n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":20}],"title":"Tic-Tac-Toe-Tomek","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<h3>Lexicographically Smallest?</h3>\n\n<p>\nThis problem asks you to open the chests in the lexicographically smallest order. As if it's not hard enough to find just any old way to open the chests, we make you find a particular way! If you have not tried similar problems before, this part might seem especially daunting.\n</p>\n\n<p>\nHowever, it's a red herring. Suppose you can answer the following simpler question: \"Is it possible at all to open all the chests?\". Then you can use that as a black box to find the lexicographically smallest way of opening them. Check whether you have the key to open chest #1 first, and whether the black box says it is possible to open all the remaining chests after doing so. If the answer to both questions is yes, then you should definitely start by opening chest #1. Otherwise, you have no choice but to try a different chest. Repeating this logic for every chest at every time, you can get the lexicographically smallest solution.\n</p>\n\n<p>\nThis is not very fast, but there aren't too many chests to worry about here, so that's okay. And that means, from now on, we can focus on the slightly simpler question: \"Is it possible to open all the chests?\".\n</p>\n\n<br/>\n<h3>Eulerian Path</h3>\n\n<p>\nUnfortunately, even this question is still pretty hard!\n</p>\n\n<p>\nWhen dealing with a really tricky problem, it can sometimes be helpful to look at special cases to build up your intuition. Towards that end, let's suppose that you begin with exactly one key, that one chest is empty, and that all remaining chests also contain exactly one key. Why look at this case in particular? You'll see!\n</p>\n\n<p>\nIn this version of the problem, you will always have exactly one key at any given time. When you open a chest of type A containing a key of type B, you are switching from a key of type A to a key of type B. This suggests that we can represent the problem as a graph. We will have one vertex for each chest/key type, and for every chest, we will add a directed edge from the chest type to the contained key type.\n</p>\n\n<p>\nYou begin with a single key, and then you must choose a chest of the matching type, giving you a key of perhaps a different type. From there, you must choose a chest of the new type, and so on, eventually choosing every chest exactly once. In the graph formulation, you can think of this as beginning at the vertex corresponding to your starting key, and then repeatedly following edges, using each edge exactly once. In other words, you are looking for an <a href=\"https://www.google.com/search?q=eulerian+path\" target=\"_blank\">Eulerian Path</a> on the graph!\n</p>\n\n<p>\nThe good news here is that Eulerian Path is a famous problem and you can look up on the internet how to tell if one exists:\n</p>\n\n<ul>\n<li> At most one vertex (namely the start vertex) has OutDegree - InDegree = 1.\n<li> At most one vertex has InDegree - OutDegree = 1.\n<li> All other vertices have InDegree = OutDegree.\n<li> There is a path from the start vertex to every other vertex in the graph.\n</ul>\n\n<p>\nThe bad news is that if this special case is already as hard as Eulerian Path, the full problem is going to be even harder!\n</p>\n\n<br/>\n<h3>Generalizing the Eulerian Path</h3>\n\n<p>\nIf you come up with the previous observation, the first thing you might try is to reduce the full problem directly to Eulerian paths. Unfortunately, this is probably doomed to fail. Once you have multiple keys in a single chest, there is no graph structure to use. (Nothing we have found anyway!)\n</p>\n\n<p>\nThe better plan is to generalize only the conditions required for an Eulerian path to exist. In fact, those conditions can be described very naturally in terms of chests and keys:\n</p>\n\n<ul>\n<li> For each type, there must be at least as many keys of that type as there are chests of that type.\n<li> It must be possible to get at least one key of any single type.\n</ul>\n\n<p>\nLet's say a chest/key configuration is <i>connected</i> if it satisfies the second condition, and <i>good</i> if it satisfies both conditions. It turns out that it is possible to open all the chests if and only if the configuration is good!\n</p>\n\n<p>\nAnd it is not too hard to check if a configuration is good - the first condition is just a count, and the second can be checked with a <a href=\"https://www.google.com/search?q=breadth+first+search\" target=\"_blank\">Breadth First Search</a> or a <a href=\"https://www.google.com/search?q=depth+first+search\" target=\"_blank\">Depth First Search</a>. So all that remains for a complete solution is convincing ourselves that checking goodness is indeed equivalent to the original problem:\n</p>\n\n<p>\n<br/>\n<b>Claim:</b> It is possible to open all the chests if and only if the configuration is good.\n</p>\n\n<p>\n<b>Proof:</b> One direction is easy. If the configuration is not good, then we will never be able to open enough chests of one type, either because there are not enough keys, or because we can never reach even one of those keys.\n</p>\n\n<p>\nFor the other direction, let's suppose we have a good configuration. Nothing we do from this point on will change whether there are enough keys of each type. We will show there is always at least one chest we can open that also maintains the connectivity property. The resulting configuration would then also be good, so there would also be a chest we could open there that would maintain connectivity, and so on. Repeating, we can keep opening chests until there is nothing left.\n</p>\n\n<p>\nSo all we need to do is prove that there is at least one chest that can be opened without breaking connectivity. We know the configuration is connected initially. For each type T, there is a sequence of chests we can open to get a key of type T. To be precise, here exists a sequence of types T<sub>1</sub>, T<sub>2</sub>, ..., T<sub>n</sub>, with the following properties:\n<ul>\n<li> You already have at least one key of type T<sub>1</sub>.\n<li> T<sub>n</sub> = T.\n<li> For each i, there is a chest of type T<sub>i</sub> which you would be able to open to get a key of type T<sub>i+1</sub>.\n</ul>\n</p>\n\n<p>\nSuppose you have a key of some arbitrary type A. If you already have <i>all</i> keys of type A, then you can open all the chests of type A, and doing so will certainly not break connectivity. So that case is easy.\n</p>\n\n<p>\nOtherwise, there must exist some chest of type B containing a key of type A. Let T<sub>1</sub>, T<sub>2</sub>, ..., T<sub>n-1</sub>=B, T<sub>n</sub>=A denote a sequence of key types that you can go through to get a key of type B and then use that to get another key of type A. As mentioned above, we know such a sequence must exist. We can also assume that T<sub>i</sub> != A for 1 &lt; i &lt; n. Otherwise, we could just chop off part of the sequence to get a faster method! Now we consider two cases:\n\n<ul>\n<li> Suppose that T<sub>1</sub> != A. Then you can use your key of type A to open anything you want, and we claim the resulting configuration will still be connected.\n<br/>\n<br/>\nTo prove this, pick an arbitrary key type C (possibly equal to A). Before opening any chests, we know there is some sequence of key types S<sub>1</sub>, S<sub>2</sub>, ..., S<sub>m</sub>=C that will give you a key of type C. If A is not part of this list, then opening a chest of type A does not interfere with getting a key of type C. Otherwise, the S list and T list intersect somewhere, so we can let j be the largest integer such that S<sub>j</sub> equals some T<sub>i</sub>. Then after using our A key, we can still get a key of type C in the following way: T<sub>1</sub>, T<sub>2</sub>, ..., T<sub>i</sub>=S<sub>j</sub>, S<sub>j+1</sub>, ... S<sub>m</sub>=C.\n<br/>\n<br/>\nSince this is true for every C, we know the configuration is still connected!\n<br/>\n<br/>\n\n<li> Suppose that T<sub>1</sub> = A. In this case, you should use your key to open a chest of type T<sub>2</sub>. You can now still obtain a key of type B, and so the rest of the argument follows exactly as before.\n</ul>\n\n<p>\nTherefore, no matter what happens, you can always open a chest without breaking connectivity, and the claim is proven!\n</p>","id":"0000000000433101","statement":"<h3>Problem</h3>\n<p>\nFollowing an old map, you have stumbled upon the Dread Pirate Larry's secret treasure trove!</p>\n\n<p>\nThe treasure trove consists of <b>N</b> locked chests, each of which can only be opened by a key of a specific type. Furthermore, once a key is used to open a chest, it can never be used again. Inside every chest, you will of course find lots of treasure, and you might also find one or more keys that you can use to open other chests. A chest may contain multiple keys of the same type, and you may hold any number of keys.\n</p>\n\n<p>You already have at least one key and your map says what other keys can be found inside the various chests. With all this information, can you figure out how to unlock all the chests?\n</p>\n\n<p>\nFor example, suppose the treasure trove consists of four chests as described below, and you began with exactly one key of type 1:\n\n<pre>\nChest Number  |  Key Type To Open Chest  |  Key Types Inside\n--------------+--------------------------+------------------\n1             |  1                       |  None\n2             |  1                       |  1, 3\n3             |  2                       |  None\n4             |  3                       |  2\n</pre>\n\nYou can open all the chests in this example if you do them in the order 2, 1, 4, 3. If you start by opening chest #1 first, then you will have used up your only key, and you will be stuck.\n</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> test cases follow.  Each test case begins with a single line containing two positive integers <b>K</b> and <b>N</b>, representing the number of keys you start with and the number of chests you need to open.\n</p>\n\n<p>\nThis is followed by a line containing <b>K</b> integers, representing the types of the keys that you start with.\n</p>\n\n<p>\nAfter that, there will be <b>N</b> lines, each representing a single chest. Each line will begin with integers <b>T<sub>i</sub></b> and <b>K<sub>i</sub></b>, indicating the key type needed to open the chest and the number of keys inside the chest. These two integers will be followed by <b>K<sub>i</sub></b> more integers, indicating the types of the keys contained within the chest.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: C<sub>1</sub> C<sub>2</sub> ... C<sub><b>N</b></sub>\", where x is the case number (starting from 1), and where  C<sub>i</sub> represents the index (starting from 1) of the i<sup>th</sup> chest that you should open.\n</p>\n\n<p>\nIf there are multiple ways of opening all the chests, choose the \"lexicographically smallest\" way. In other words, you should choose to make C<sub>1</sub> as small as possible, and if there are multiple ways of making C<sub>1</sub> as small as possible, choose the one that makes C<sub>2</sub> as small as possible, and so on.\n</p>\n\n<p>\nIf there is no way to open all the chests, you should instead output one line containing \"Case #x: IMPOSSIBLE\".\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n1 &le; <b>T</b> &le; 25.<br/>\n1 &le; <b>K</b>.<br/>\nAll key types will be integers between 1 and 200 inclusive.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>N</b> &le; 20.<br/>\nIn each test case, there will be at most 40 keys altogether.<br/>\n</p>\n\n<h4>Large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>N</b> &le; 200.<br/>\nIn each test case, there will be at most 400 keys altogether.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1 4\n1\n1 0\n1 2 1 3\n2 0\n3 1 2\n3 3\n1 1 1\n1 0\n1 0\n1 0\n1 1\n2\n1 1 1\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2 1 4 3\nCase #2: 1 2 3\nCase #3: IMPOSSIBLE\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":20},{"type":2,"type__str":"HIDDEN","value":60}],"title":"Treasure","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"},{"analysis":"<p>\nThe first thing to do in this problem (as in many other problems) is to make sure you read it carefully. Many contestants thought that 676 should be a fair and square number - after all, it is a square <b>and</b> a palindrome. It is <i>not</i>, however, a square <b>of</b> a palindrome, and this example is actually mentioned specifically in the problem statement!\n</p>\n\n<h3>The small input</h3>\n<p>\nOnce you realize this, you can approach the small testcase by iterating over all the numbers Little John considers, and checking each one of them. You have to check for each number <b>X</b> whether it is a palindrome, and whether it is the square of a palindrome.\n</p>\n<p>\nTo check whether <b>X</b> is a palindrome, you can simply convert it to string format (the details here depend on the programming language you are using) and compare the first character to the last, the second to the second last, and so on.\n</p>\n<p>\nTo check whether <b>X</b> is the square of a palindrome, there are multiple options. One is to calculate the square root, and if the square root is an integer, check if it is a palindrome as described above. Another is simply to iterate over all numbers up to <b>X</b>, and for each palindrome, square it and see if the square is <b>X</b>. That's a perfectly good solution for the small input, but it will be too slow for the larger ones.\n</p>\n\n<h3>The first large input</h3>\n<p>\nFor the first large input, we need to deal with numbers up to 10<sup>14</sup>, and also with 10,000 test cases. A linear search of all numbers up to 10<sup>14</sup> is not going to be fast enough, so we have to be smarter - we can't afford to check each number in the interval individually.\n</p>\n<p>\nWe don't really need to go all the way up to 10<sup>14</sup> though! We are interested in numbers whose <i>squares</i> are Fair and Square and between <b>A</b> and <b>B</b> - and that means we have to check up to the <i>square root</i> of <b>B</b> only. That's only 10<sup>7</sup> numbers to check in the worst case.\n</p>\n<p>\nWe are not done though. While 10<sup>7</sup> numbers can be processed within the time limit, processing 10,000 cases like this is somewhat risky. There are two tricks you can notice to make your solution faster.\n</p>\n<p>\nOne trick is that we are interested not in all the numbers up to 10<sup>7</sup>, but only in palindromes. We can generate all the palindromes much faster. Start by taking all the numbers up to 10<sup>4</sup>, and then taking their mirror reflections (either duplicating the last number or not) to generate all palindromes of length up to 8 (and then square each and check whether it is a Fair and Square number in the interesting interval). This will cause us to evaluate only around 10,000 numbers for each test case, which is small enough  that even a slow machine can deal with all the test cases in four minutes. You would need to use a reasonably efficient language however.\n</p>\n<p>\nAn alternative is to simply generate all the fair and square numbers up to 10<sup>14</sup> <i>before</i> processing the test cases. There are relatively few of them &mdash; it turns out only 39. Thus, if you find all of them (in any fashion) before downloading the input file, you can easily give the correct answers to all the input cases.</p>\n<p>\nNote that if you do this, you have to include the code you used to generate Fair and Square numbers - not just the code that includes the full list!\n</p>\n<h3>The second large data set</h3>\n<p>\nNow we come to the largest data set. Even combining both the tricks above is not enough - we need to go over 10<sup>25</sup> palindromes to precompute everything. This will take a very long time in any language on any computer! A good idea here is to generate the first few Fair and Square numbers (and their square roots) to try and get an idea of what they look like. There are two things you can notice:\n</p>\n<ul>\n<li> All the Fair and Square numbers have an odd number of digits</li>\n<li> All the digits are rather small. In particular, with one exception, every square root of a Fair and Square number consists only of digits 0, 1 and 2. </li>\n</ul>\n<p>\nLet's try to understand why these things would be true.\n</p>\n\n<p>\nLet's begin with the \"odd number of digits\". A square of a number with <b>N</b> digits will have either 2<b>N</b> - 1 or 2<b>N</b> digits, depending on whether there is a carry on the last position. Let's try to prove a carry never happens. \nLet <b>X</b> be Fair and Square, and let its square root be <b>Y</b>. Let the first digit of <b>Y</b> be <b>c</b> - then the first two digits of <b>X</b> are between <b>c</b><sup>2</sup> and (<b>c</b>+1)<sup>2</sup>. In particular:\n</p>\n<ul>\n<li>If the first digit of <b>Y</b> is 1, the first digit of <b>X</b> is between 1 and 4 - and thus no carry.</li>\n<li>If the first digit of <b>Y</b> is 2, the first digit of <b>X</b> is between 4 and 9 - and thus no carry.</li>\n<li>If the first digit of <b>Y</b> is 3, the first digits of <b>X</b> are between 9 and 16, so the first digit is 9 or 1. As <b>Y</b> is a palindrome, the last digit of <b>Y</b> is 3 as well, and thus the last digit of <b>X</b> is 9 - meaning the first digit of <b>X</b> is 9 as well, meaning no carry.</li>\n<li>If the first and last digit of <b>Y</b> is 4, the last digit of <b>X</b> is 6, while the first is either 1 or 2 - so <b>X</b> can't be Fair and Square.</li>\n<li>Similarly, if the first and last digit of <b>Y</b> is 5 (last digit of <b>X</b> is 5, first is 2 or 3), 6 (last digit of <b>X</b> is 6, first is 3 or 4), 7 (last digit of <b>X</b> is 9, first is 4, 5 or 6), 8 (last digit of <b>X</b> is 4, first is 6, 7 or 8) and 9 (last digit of <b>X</b> is 1, first is 8 or 9), then <b>X</b> also can't be Fair and Square.</li>\n</ul>\n<p>\nThis means there is no carry in the first digit.\n</p>\n\n<p>\nNow since all the digits seem so small, maybe this means there is no carry at all? Note that if you take a palindrome and square it, and there's no carry, the result is a palindrome as well - so that would give us a nice characterization of Fair and Square numbers. Indeed, it turns out to be the case, and the proof follows.\n</p>\n\n<p>\nLet <b>Y</b> have digits (a<sub>d</sub>)(a<sub>d-1</sub>)...(a<sub>0</sub>). Let b<sub>k</sub> = a<sub>0</sub> * a<sub>k</sub> + a<sub>1</sub> * a<sub>k-1</sub> + ... + a<sub>k</sub> * a<sub>0</sub>. Note that b<sub>i</sub> is exactly the i<i>th</i> digit of <b>X</b> = <b>Y</b><sup>2</sup> when performing long multiplication, before carries are performed. Since a<sub>j</sub> = a<sub>d-j</sub>, we also have b<sub>i</sub> = b<sub>2d-i</sub>.<br/>\nNow suppose there's a carry in the long multiplication (meaning some b<sub>j</sub> is greater than 9), and that we take a carry into digit i but no larger digits. We know digits i and 2d-i in <b>X</b> are equal, and are equal to b<sub>i</sub> plus whatever we carried into digit <i>i</i>. Since we carry nothing to digit i+1, b<sub>i</sub> is no larger than 9.<br/>\nNow we will see that digit 2d-i of <b>X</b> has to equal b<sub>2d-i</sub> (which is equal to b<sub>i</sub>, and thus no larger than 9). For it to be different, we would have to carry something into digit 2d-i - but this would mean that b<sub>j</sub> is larger than 9 for some j &lt; 2d-i, and hence b<sub>2d-j</sub> is also greater than 9 and we would have a carry after digit i.<br/>\nSince <b>X</b> is a palindrome, this tells us that digit i of <b>X</b> is equal to b<sub>i</sub>, which means that no carry entered digit i, and we have a contradiction.<br/>\nWe conclude that no carries were performed in the long multiplication at all.\n</p>\n\n<p>\nThus, the Fair and Square numbers are exactly the palindromes with no carries inside. In particular, the middle digit of <b>X</b> is the sum of squares of all the digits of <b>Y</b>, so this sum has to be no larger than nine. We conclude that only 0, 1, 2, and 3 can appear in <b>Y</b>.</p>\n\n<p>\nTo find all Fair and Square numbers, it therefore suffices to consider only palindromes consisting of these four digits, with the sum of squares of digits \nat most 9. It turns out this is a small enough set that it can be directly searched, allowing us to generate the full list of all Fair and Square numbers up to 10<sup>100</sup> in a few seconds - and thus allowing us to solve the largest dataset.\n</p>\n\n<h3>Lessons learned</h3>\n<p>\nThere are a few things we want to remind you of in the context of this problem:\n</p>\n<ul>\n<li>It is really important to read the problem statement carefully.</li>\n<li>We can sometimes have problems in which we don't have the standard combination of one small and one large input. The rules for dealing with small and large inputs are still the same (unless explicitly stated otherwise in the problem statement).</li>\n<li>We can also sometimes give problems that require very large integers. We did give Fair Warning about this some time ago, but it's always worth reminding.</li>\n<li>Finally, if you use precomputation in your solution, remember that you are required to provide us not only with the code that you actually used to solve the problem (containing the precomputed values), but also the code that you used for precomputation.</li>\n</ul>\n","id":"0000000000433335","statement":"<h3>Problem</h3>\n<p>\nLittle John likes palindromes, and thinks them to be fair (which is a fancy word for nice). A <i>palindrome</i> is just an integer that reads the same backwards and forwards - so 6, 11 and 121 are all palindromes, while 10, 12, 223 and 2244 are not (even though 010=10, we don't consider leading zeroes when determining whether a number is a palindrome).\n</p>\n\n<p>\nHe recently became interested in squares as well, and formed the definition of a <i>fair and square</i> number - it is a number that is a palindrome <b>and</b> the <i>square of a palindrome</i> at the same time. For instance, 1, 9 and 121 are fair and square (being palindromes and squares, respectively, of 1, 3 and 11), while 16, 22 and 676 are <b>not</b> fair and square: 16 is not a palindrome, 22 is not a square, and while 676 is a palindrome and a square number, it is the square of 26, which is not a palindrome.\n</p>\n\n<p>\nNow he wants to search for bigger fair and square numbers. Your task is, given an interval Little John is searching through, to tell him how many fair and square numbers are there in the interval, so he knows when he has found them all.\n</p>\n\n<h3>Solving this problem</h3>\n<p>Usually, Google Code Jam problems have 1 Small input and 1 Large input. This problem has 1 Small input and 2 Large inputs. Once you have solved the Small input, you will be able to download any of the two Large inputs. As usual, you will be able to retry the Small input (with a time penalty), while you will get only one chance at each of the Large inputs.</p>\n\n<h3>Input</h3>\n<p>\nThe first line of the input gives the number of test cases, <b>T</b>.  <b>T</b> lines follow.  Each line contains two integers, <b>A</b> and <b>B</b> - the endpoints of the interval Little John is looking at.\n</p>\n\n<h3>Output</h3>\n<p>\nFor each test case, output one line containing \"Case #x: y\", where x is the case number (starting from 1) and y is the number of fair and square numbers greater than or equal to <b>A</b> and smaller than or equal to <b>B</b>.\n</p>\n\n<h3>Limits</h3>\n<p>\nTime limit: 30 seconds per test set.<br/>\nMemory limit: 1GB.<br/>\n</p>\n\n<h4>Small dataset (Test set 1 - Visible)</h4>\n<p>\n1 &le; <b>T</b> &le; 100.<br/>\n1 &le; <b>A</b> &le; <b>B</b> &le; 1000.<br/>\n</p>\n\n<h4>First large dataset (Test set 2 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 10000.<br/>\n1 &le; <b>A</b> &le; <b>B</b> &le; 10<sup>14</sup>.<br/>\n</p>\n\n<h4>Second large dataset (Test set 3 - Hidden)</h4>\n<p>\n1 &le; <b>T</b> &le; 1000.<br/>\n1 &le; <b>A</b> &le; <b>B</b> &le; 10<sup>100</sup>.<br/>\n</p>\n\n\n  <h3>Sample</h3>\n  <div class=\"problem-io-wrapper\">\n  <table>\n  <tr>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Input</span>\n  <br/>&nbsp;\n  </td>\n  <td>\n  <br/>\n  <span class=\"io-table-header\">Output</span>\n  <br/>&nbsp;\n  </td>\n  </tr>\n  <tr>\n  <td>\n  <pre class=\"io-content\">3\n1 4\n10 120\n100 1000\n\n  </pre>\n  </td>\n  <td>\n  <pre class=\"io-content\">Case #1: 2\nCase #2: 0\nCase #3: 2\n\n  </pre>\n  </td></tr></table>\n  </div>\n  \n","task_type":1,"task_type__str":"CODE_JAM","tests":[{"type":1,"type__str":"VISIBLE","value":10},{"type":2,"type__str":"HIDDEN","value":35},{"type":2,"type__str":"HIDDEN","value":55}],"title":"Fair and Square","trial_input_type":1,"trial_input_type__str":"TEXT_FILE"}],"ticket":{"challenge_id":"0000000000432dfc","type":1,"type__str":"SPECTATOR"},"title":"Qualification Round 2013"},"languages":[{"id":1,"id__str":"BASH","name":"Bash"},{"id":2,"id__str":"C","name":"C (GCC)"},{"id":11,"id__str":"CSHARP","name":"C# (Mono)"},{"id":3,"id__str":"CPP","name":"C++17 (G++)"},{"id":19,"id__str":"CLOJURE","name":"Clojure"},{"id":24,"id__str":"D","name":"D (GDC)"},{"id":32,"id__str":"DART","name":"Dart"},{"id":28,"id__str":"FSHARP","name":"F# (Mono)"},{"id":6,"id__str":"GO","name":"Go 1.11.6"},{"id":20,"id__str":"GROOVY","name":"Groovy"},{"id":12,"id__str":"HASKELL","name":"Haskell (GHC)"},{"helper_text":"Please name your main class \"Solution\" (uppercase S) and do not declare a package.","id":4,"id__str":"JAVA","name":"Java 11 (OpenJDK)"},{"id":10,"id__str":"JAVASCRIPT","name":"JavaScript (Node.js)"},{"id":29,"id__str":"JULIA","name":"Julia"},{"id":22,"id__str":"KOTLIN","name":"Kotlin"},{"id":23,"id__str":"LISP","name":"Lisp (SBCL)"},{"id":30,"id__str":"LUA","name":"Lua"},{"id":18,"id__str":"OCAML","name":"OCaml"},{"id":31,"id__str":"OBJECTIVEC","name":"Objective-C (GNU)"},{"id":15,"id__str":"OCTAVE","name":"Octave"},{"id":9,"id__str":"PHP","name":"PHP"},{"id":21,"id__str":"PASCAL","name":"Pascal (FPC)"},{"id":14,"id__str":"PERL","name":"Perl"},{"id":34,"id__str":"PYPY3","name":"PyPy 3"},{"id":7,"id__str":"PYTHON3","name":"Python 3.7"},{"id":25,"id__str":"R","name":"R"},{"id":8,"id__str":"RUBY","name":"Ruby"},{"id":17,"id__str":"RUST","name":"Rust"},{"helper_text":"Please name your main class \"Solution\" (uppercase S).","id":13,"id__str":"SCALA","name":"Scala"},{"id":16,"id__str":"SWIFT","name":"Swift"},{"id":33,"id__str":"TYPESCRIPT","name":"TypeScript (Node.js)"},{"id":27,"id__str":"VISUALBASIC","name":"Visual Basic (Mono)"}]}
